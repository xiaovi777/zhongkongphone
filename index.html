<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>koko小手机</title>
<script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.6/StreamSaver.min.js"></script>
    <meta name="apple-mobile-web-app-capable" content="yes">

<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="apple-mobile-web-app-title" content="koko">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="manifest" href="manifest.json">
<meta name="theme-color"
      content="#ffffff"
      media="(prefers-color-scheme: light)">

<meta name="theme-color"
      content="#000000"
      media="(prefers-color-scheme: dark)">
    <style>
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap');

        :root {
            --theme-primary: #81c784;
            --theme-primary-hover: #66bb6a;
            --theme-secondary: #aed581;
            --sent-message-bg: #e6f5c9;
            --background-start: #f1f8e9;
            --background-end: #ffffff;
            --text-on-primary: #ffffff;
            --text-dark: #424242;
            --text-gray: #757575;
            --soft-red: #ff8a80;
            --border-color: #e8e8e8;
            --shadow-color: rgba(129, 199, 132, 0.12);
            --soft-radius: 16px;
            --card-background: rgba(255, 255, 255, 0.7);
        }
        
       /* --- 您新增的叙事模式美化样式 --- */
.narrative-speech {
    background-color: #e6f5c9; /* 清新的青苹果色背景 (来自您已有的 --sent-message-bg 变量) */
    padding: 2px 8px;
    border-radius: 8px;
    display: inline-block;
    margin: 1px 0;
}

.narrative-psychology {
    text-decoration: none; /* 去掉下划线 */
    background-color: #e6f5c9; /* 浅绿色背景 (复用已有变量 --sent-message-bg) */
    color: #66bb6a; /* 青苹果绿字体 (复用已有变量 --theme-primary-hover) */
    padding: 2px 6px; /* 增加一点内边距，让背景更好看 */
    border-radius: 6px; /* 增加圆角 */
    font-style: normal; /* 也可以加一点斜体来区分 */
}

.narrative-action {
    font-style: normal;
    color: #517655; /* 深一点的青苹果色 (来自您已有的 --theme-primary-hover 变量) */
} 
        
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    /* ↓↓↓ 就是修改这一行 ↓↓↓ */
    font-family: var(--main-font, 'Nunito', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif);
}
        
        body {
            background-image: linear-gradient(to bottom, var(--background-start), var(--background-end));
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #app-container, #screen {
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        
        #screen {
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 5px 25px var(--shadow-color);
        }
        
        .chat-header {
    background-color: rgba(129, 199, 132, 0.75);
    backdrop-filter: blur(12px);
    color: var(--text-on-primary);
    padding: 8px 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    display: grid; /* <--- 核心改动1：使用网格布局 */
    grid-template-columns: 1fr auto 1fr; /* <--- 核心改动2：三列布局 */
    align-items: center;
    z-index: 10;
    flex-shrink: 0;
}
/* 新增：修复顶栏右侧按钮的对齐问题 */
.chat-header > div:last-child {
    text-align: right;
}
        .app-header, .world-book-header, .api-header, .moments-header, .discover-header, .contact-settings-header {
            background-color: rgba(220, 237, 200, 0.7);
            backdrop-filter: blur(12px);
            color: var(--text-dark);
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: none;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            z-index: 10;
            flex-shrink: 0;
            position: relative;
        }
        
        .chat-input-area {
            background-color: #f8f9fa;
            padding: 6px 8px;
            display: flex;
            align-items: center;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative;
        }
        
        #message-input {
            flex-grow: 1;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 8px 15px;
            font-size: 15px;
            outline: none;
            resize: none;
            max-height: 100px;
            overflow-y: auto;
            align-self: flex-end;
            min-height: 34px;
        }

        .input-action-btn {
            border: none;
            border-radius: 50%;
            width: 34px;
            height: 34px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 8px;
            cursor: pointer;
            font-size: 16px;
            flex-shrink: 0;
            transition: transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            align-self: flex-end;
        }
        .input-action-btn:hover {
            transform: scale(1.1);
        }

        #send-btn {
            background-color: var(--theme-primary);
            color: var(--text-on-primary);
            width: auto;
            padding: 0 18px;
            border-radius: 22px;
        }
        #send-btn .fa-paper-plane {
            font-size: 18px;
        }

        #request-reply-btn {
            background-color: var(--theme-secondary);
            color: var(--text-on-primary);
        }
        
        #chat-screen {
            background-image: url('https://i.postimg.cc/SQ3DH79X/MEITU-20250811-151831796.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            transform: translate3d(0, 0, 0); 
            -webkit-transform: translate3d(0, 0, 0);
            will-change: transform, background-image;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            background-attachment: fixed;
    
        }
        
        #main-screen { height: 100%; display: flex; flex-direction: column; }
        .app-title { font-size: 20px; font-weight: 700; }
        .contacts-container { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .section-title { padding: 10px 15px; font-size: 14px; color: var(--text-gray); background-color: transparent; font-weight: 600; }
        .contact-item { display: flex; align-items: center; padding: 12px 15px; background-color: transparent; border-bottom: 1px solid var(--border-color); border-radius: var(--soft-radius); margin: 0 8px 4px; cursor: pointer; transition: background-color 0.2s; }
        .contact-item:hover { background-color: rgba(255, 255, 255, 0.7); }
        .contact-avatar { width: 50px; height: 50px; border-radius: 50%; background-color: #ddd; margin-right: 15px; display: flex; align-items: center; justify-content: center; font-size: 20px; color: var(--text-gray); overflow: hidden; flex-shrink: 0; }
        .contact-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .contact-info { flex-grow: 1; min-width: 0; }
        .contact-name { font-weight: 600; margin-bottom: 3px; color: var(--text-dark); }
        .contact-last-message { font-size: 14px; color: var(--text-gray); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
        .contact-time { font-size: 12px; color: #999; margin-top: 5px; }
        .unread-count { background-color: var(--theme-primary); color: var(--text-on-primary); font-size: 12px; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-left: 10px; }
        .bottom-nav { display: flex; background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(10px); border-top: 1px solid var(--border-color); padding: 10px 0; flex-shrink: 0; }
        .nav-item { flex: 1; text-align: center; color: var(--text-gray); font-size: 14px; cursor: pointer; transition: color 0.2s, transform 0.2s; }
        .nav-item-content { position: relative; display: inline-block; }
        .nav-item.active { color: var(--theme-primary); transform: scale(1.1); }
        .nav-icon { font-size: 20px; margin-bottom: 5px; }
        .notification-dot { position: absolute; top: -2px; right: -8px; width: 8px; height: 8px; background-color: var(--soft-red); border-radius: 50%; border: 1px solid white; display: none; }
        .back-btn { font-size: 24px; cursor: pointer; margin-right: 15px; }
        .chat-info { flex-grow: 1; text-align: center; }
        .chat-name { font-weight: 700; font-size: 18px; }
        .chat-status { font-size: 13px; opacity: 0.8; }
        .chat-messages { flex-grow: 1; padding: 8px; overflow-y: auto; display: flex; flex-direction: column; }
        #load-more-messages { background-color: #e0e0e0; color: #555; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; margin: 0 auto 15px; font-size: 13px; display: none; }
        #load-more-messages:hover { background-color: #d1d1d1; }
        /* ▼▼▼ 在你的 .message-wrapper 样式里，加上 animation 这一行 ▼▼▼ */
.message-wrapper { 
    display: flex; 
    max-width: 90%; 
    margin-bottom: 1px; 
    position: relative; 
    /* 就是加上下面这一行！ */
    animation: bubble-fade-in 0.35s ease-out; 
}
        .message-wrapper.received { align-self: flex-start; flex-direction: row; }
        .message-wrapper.sent { align-self: flex-end; flex-direction: row-reverse; }
        .message-avatar { width: 40px; height: 40px; border-radius: 6px; flex-shrink: 0; visibility: hidden; }
        .is-first-in-sequence .message-avatar { visibility: visible; margin-top: 10px; }
        .message-avatar img { width: 100%; height: 100%; border-radius: 6px; object-fit: cover; }
        .message-body { display: flex; flex-direction: column; margin: 0 10px; }
        .message-wrapper.sent .message-body { align-items: flex-end; }
        .message-wrapper.received .message-body { align-items: flex-start; }
        .message-author-name { font-size: 13px; color: #888; margin-bottom: 4px; display: none; }
        .is-first-in-sequence .message-author-name { display: block; margin-top: 10px;}
        .message { padding: 6px 10px; border-radius: 22px; position: relative; word-wrap: break-word; min-width: 50px; box-shadow: 0 2px 4px var(--shadow-color); font-size: 14px; white-space: pre-wrap;}
        .message-timestamp { font-size: 11px; color: #aaa; margin-top: 4px; padding: 0 5px; }
        .message-wrapper.selected .message, .message-wrapper.selected .message.red-packet, .message-wrapper.selected .message.voice, .message-wrapper.selected .message.picture-description { background-color: #bde0fe !important; }
/* ▼▼▼ 用这个新的动画效果，替换掉你原来的 @keyframes fadeIn ▼▼▼ */
@keyframes bubble-fade-in {
    from {
        opacity: 0;
        transform: translateY(15px); /* 从下方 15px 的位置开始 */
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
        .message.received { background-color: white; border-top-left-radius: 4px; }
        .message.sent { background-color: var(--sent-message-bg); border-top-right-radius: 4px; }
        .message-image-container { padding: 5px; background-color: inherit; border-radius: inherit; }
        .message-image { max-width: 150px; max-height: 150px; border-radius: 12px; display: block; cursor: default; }
        .message-image-container.sent { border-top-right-radius: 4px; }
        .message-image-container.received { border-top-left-radius: 4px; }
        /* ▼▼▼ 修复图片气泡的空格问题 ▼▼▼ */
.message.image-message { 
    padding: 0; 
    background-color: transparent; 
    box-shadow: none; 
    
    /* 核心修复：强制不保留空白符 */
    white-space: normal !important; 
    
    /* 消除图片底部的微小缝隙 */
    font-size: 0 !important; 
    line-height: 0 !important;
    
    /* 确保容器大小适应图片 */
    display: inline-block;
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 新的、统一风格的左侧按钮 ▼▼▼ */
        .emoji-btn, .attachment-btn {
            /* 1. 复制 .input-action-btn 的核心样式 */
            border: none;
            border-radius: 50%; /* 变成圆圈 */
            width: 34px;       /* 统一宽度 */
            height: 34px;      /* 统一高度 */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            align-self: flex-end; /* 保持垂直对齐 */
            
            /* 2. 赋予它们新的样式 */
            font-size: 16px; /* 统一下图标大小 */
            background-color: #f0f2f5; /* 一个中性的灰色背景 */
            color: var(--text-gray); /* 灰色图标 */
        }
        
        /* 3. 单独调整间距 */
        .emoji-btn {
            margin-right: 8px; /* 表情按钮和附件按钮之间的间距 */
            /* 注意：我们不设置 margin-left，让它贴着左边 */
        }
        
        .attachment-btn {
            margin-right: 10px; /* 附件按钮和输入框之间的间距 */
        }
        
        /* 4. (可选) 悬浮效果 */
        .emoji-btn:hover, .attachment-btn:hover {
            transform: scale(1.1);
            background-color: #e0e0e0; /* 悬浮时变深一点 */
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        #edit-mode-bar, #moments-edit-mode-bar, #diary-edit-mode-bar { display: none; padding: 10px 15px; background-color: #f0f0f0; border-top: 1px solid #ddd; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .edit-action-btn { padding: 8px 16px; border-radius: 20px; border: none; font-size: 14px; cursor: pointer; }
        #delete-selected-btn, #delete-selected-moments-btn { background-color: var(--soft-red); color: white; }
        #cancel-edit-btn, #cancel-moments-edit-btn { background-color: #bdc3c7; color: #333; }
        #profile-screen, #char-profile-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; display: none; flex-direction: column; }
        
        .profile-header {
            background-image: linear-gradient(135deg, var(--sent-message-bg), #dcedc8);
            padding: 30px 20px 15px;
            text-align: center;
            color: var(--text-dark);
            position: relative;
            flex-shrink: 0;
        }
        .avatar-container {
            position: relative;
            margin: 0 auto 15px;
            width: 100px;
            height: 100px;
        }
        .profile-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .change-avatar-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: rgba(255, 255, 255, 0.7);
            color: var(--text-dark);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .profile-name { font-size: 22px; font-weight: 700; margin-bottom: 5px; }
        .profile-status { font-size: 16px; opacity: 0.9; }
        .profile-actions { display: flex; justify-content: center; gap: 20px; padding: 10px 0; background-color: white; border-bottom: 1px solid #eee; flex-shrink: 0; }
        .action-item { text-align: center; cursor: pointer; }
        .action-icon { width: 50px; height: 50px; border-radius: 50%; background-color: #f0f2f5; display: flex; align-items: center; justify-content: center; font-size: 24px; color: var(--theme-primary); margin: 0 auto 10px; transition: all 0.3s; }
        .action-icon:hover { background-color: #e0f2f1; transform: scale(1.05); }
        .action-label { font-size: 14px; color: var(--text-gray); }
        .profile-details { flex-grow: 1; overflow-y: auto; padding: 10px; background-color: #f0f2f5; }
        .detail-item { padding: 15px; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; cursor: pointer; background-color: white; }
        .detail-item:last-child { border-bottom: none; }
        .discover-section .detail-item { border-radius: 0; margin-bottom: 0; }
        .discover-section .detail-item:first-child { border-top-left-radius: var(--soft-radius); border-top-right-radius: var(--soft-radius); }
        .discover-section .detail-item:last-child { border-bottom-left-radius: var(--soft-radius); border-bottom-right-radius: var(--soft-radius); border-bottom: none; }
        .detail-label { font-size: 16px; color: #333; font-weight: 600; }
        .detail-value { font-size: 16px; color: var(--text-gray); max-width: 60%; text-align: right; overflow: hidden; text-overflow: ellipsis; }
        .edit-btn { color: var(--theme-primary); font-size: 18px; cursor: pointer; padding: 5px; }
        #discover-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; display: none; flex-direction: column; }
        .discover-title { font-size: 20px; font-weight: 700; flex-grow: 1; text-align: center; margin-left: 0; }
        .discover-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .discover-section { background-color: var(--card-background); border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px;}
        .discover-item { padding: 15px; display: flex; align-items: center; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s; background-color: transparent; }
        .discover-item:last-child { border-bottom: none; }
        .discover-item:hover { background-color: rgba(255,255,255,0.5); }
        .discover-icon { width: 40px; height: 40px; border-radius: 8px; background-color: #f0f2f5; display: flex; align-items: center; justify-content: center; font-size: 20px; color: var(--theme-primary); margin-right: 15px; }
        .discover-info { flex-grow: 1; }
        .discover-name { font-weight: 600; margin-bottom: 3px; }
        .discover-desc { font-size: 14px; color: var(--text-gray); }
        .discover-arrow { color: #999; font-size: 18px; }
/* ▼▼▼ 使用这个【包含 #investment-center-screen 的完整版】替换旧规则 ▼▼▼ */
#automation-modal, #automation-screen, #world-book-screen, #api-settings-screen, #contact-settings-screen, #moments-screen, #diary-screen, #emoticon-library-screen, .preset-management-screen, #post-detail-screen, #trending-topic-screen, #square-api-settings-screen, 
#snoop-api-settings-screen,
#memory-album-screen, #music-library-screen, #shopping-screen, #product-detail-screen, 
#schedule-screen, #events-screen,
#relationship-network-screen,
#sms-chat-screen,
#favorites-screen,
#investment-center-screen, /* <--- 修正：加上游戏中心 */
#stock-market-screen      /* <--- 修正：加上交易所 */
{
    position: absolute;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: transparent; /* 背景色由各自页面的内联样式或更具体的规则覆盖 */
    display: none; /* 默认隐藏 */
    flex-direction: column; /* 垂直布局 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
        .world-book-content, .api-content, .contact-settings-content, .emoticon-library-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .world-book-list { display: flex; flex-direction: column; gap: 15px; }
        .world-book-item { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;}
        .world-book-item:hover { transform: translateY(-3px); box-shadow: 0 6px 12px var(--shadow-color); }
        .book-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
        .book-name { font-weight: 600; font-size: 18px; }
        .book-content { color: var(--text-gray); line-height: 1.5; white-space: pre-wrap; word-break: break-all; }
        .api-title { font-size: 20px; font-weight: 600; margin-left: 15px; }
        .form-group { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .form-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .form-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; }
        .form-input:focus { outline: none; border-color: var(--theme-primary); }
        .form-button { width: 100%; padding: 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-group-inline { display: flex; align-items: center; gap: 10px; }
        .form-group-inline .form-input { flex-grow: 1; }
        #fetch-models-btn, #fetch-square-models-btn, #fetch-snoop-models-btn { padding: 10px 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; flex-shrink: 0; }
        #add-world-book-modal, #post-moment-modal, #user-persona-preset-modal, #thought-preset-modal, #add-emoticon-modal, #automation-modal, #send-red-packet-modal, #send-transfer-modal, #send-voice-modal, #send-picture-modal, #add-music-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 100; }
.modal-content {
    background-color: white;
    width: 90%;
    max-width: 400px;
    border-radius: var(--soft-radius);
    /* overflow: hidden; */ /* <--- 1. 我们把这行的 overflow: hidden 注释掉 */
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    animation: modalIn 0.3s ease;

    /* ▼▼▼ 2. 加上这三行 ▼▼▼ */
    display: flex;
    flex-direction: column;
    max-height: 85vh; /* 关键：弹窗最大高度不超过屏幕的85% */
}
        @keyframes modalIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { background-color: var(--theme-primary); color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 18px; font-weight: 600; }
        .close-btn { font-size: 24px; cursor: pointer; }
        .modal-body {
    padding: 20px;

    /* ▼▼▼ 3. 加上这两行 ▼▼▼ */
    overflow-y: auto; /* 关键：允许内容区垂直滚动 */
    flex-shrink: 1;   /* 允许内容区在需要时收缩 */
}
        .form-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .form-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .form-button:hover { background-color: var(--theme-primary-hover); }
        #add-contact-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 100; }
        .contact-form-group { margin-bottom: 20px; }
        .contact-form-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .contact-form-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; }
        .contact-form-input:focus { outline: none; border-color: var(--theme-primary); }
        .contact-form-textarea { width: 100%; height: 100px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .contact-form-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .contact-form-select { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; background-color: white; }
        .contact-form-select:focus { outline: none; border-color: var(--theme-primary); }
        .mask-editor, .world-book-selector { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .mask-editor-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .mask-editor-group { margin-bottom: 15px; }
        .mask-editor-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .mask-editor-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .mask-editor-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .world-book-selector-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .world-book-selector .world-book-list { max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; }
        #world-book-selector-list .world-book-item { padding: 10px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; }
        .world-book-checkbox { margin-right: 10px; }
        .world-book-name { font-weight: 500; }
        .save-settings-btn { width: 100%; padding: 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; }
        .user-mask-editor { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .user-mask-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .user-mask-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .user-mask-textarea:focus { outline: none; border-color: var(--theme-primary); }
        
        /* --- V7.0 新增: 一起听歌卡片样式 --- */
.message.music-share-card {
    background-color: #f3f4f6;
    color: #333;
    width: 260px;
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: default;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.message.sent.music-share-card { background-color: var(--sent-message-bg); }
.music-card-cover {
    width: 60px;
    height: 60px;
    background-color: #555;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 28px;
    flex-shrink: 0;
    position: relative;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    animation: spin 8s linear infinite;
    animation-play-state: paused; /* 默认暂停 */
}
.music-card-cover.playing {
    animation-play-state: running; /* 播放时旋转 */
}
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.music-card-play-btn {
    position: absolute;
    color: rgba(255, 255, 255, 0.8);
    font-size: 20px;
    cursor: pointer;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}
.music-card-info {
    flex-grow: 1;
    min-width: 0;
}
.music-card-title {
    font-weight: 600;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.music-card-artist {
    font-size: 13px;
    color: var(--text-gray);
    margin-top: 2px;
}
.music-card-progress-bar {
    width: 100%;
    height: 3px;
    background-color: #ddd;
    border-radius: 3px;
    margin-top: 8px;
    overflow: hidden;
}
.music-card-progress {
    width: 0%;
    height: 100%;
    background-color: var(--theme-primary);
}
.music-card-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #999;
    margin-top: 5px;
}
.music-card-loop-btn {
    cursor: pointer;
    font-size: 14px;
}
/* --- V7.0 新增: 小窝相册新样式 --- */
.album-section {
    background-color: white;
    border-radius: 12px;
    padding: 15px 20px;
    margin-bottom: 20px;
    box-shadow: 0 4px 12px var(--shadow-color);
}
.album-section-title {
    font-size: 18px;
    font-weight: bold;
    color: var(--theme-primary);
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #f0f0f0;
}
.album-milestone-item, .album-stat-item {
    display: flex;
    align-items: center;
    padding: 10px 0;
    font-size: 16px;
}
.album-item-icon {
    width: 30px;
    text-align: center;
    margin-right: 15px;
    color: var(--text-gray);
}
.album-item-label { color: #333; }
.album-item-value {
    margin-left: auto;
    font-weight: 600;
    color: var(--text-dark);
}
.album-memory-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
}
.album-memory-item {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 10px;
    font-size: 14px;
    line-height: 1.5;
    border: 1px solid #eee;
    cursor: pointer;
}
.album-memory-item .fas {
    margin-right: 5px;
    color: var(--theme-secondary);
}
        
        /* ---论坛/微博 样式--- */
        .moments-header .back-btn { font-size: 24px; cursor: pointer; position: relative; z-index: 1; }
        .moments-header .action-btn { font-size: 20px; }
        .header-actions { display: flex; gap: 20px; position: relative; z-index: 1; }
        .moments-content { flex-grow: 1; overflow-y: auto; background-color: #f0f2f5; }
        .mention {
    color: var(--theme-primary);
    font-weight: 600;
    cursor: pointer;
}
.mention:hover {
    text-decoration: underline;
}
/* --- 新代码：模仿Koko论坛(1)的主导航栏样式 --- */
.feed-tabs {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;          /* 增加上下内边距 */
    background-color: #ffffff; /* 背景改为白色 */
    border-bottom: 1px solid #e0e0e0; /* 添加底部边框线 */
    flex-shrink: 0;
}

.feed-tab-btn {
    text-decoration: none;
    color: #888;              /* 默认文字颜色改为灰色 */
    font-size: 16px;
    font-weight: 500;         /* 字体粗细调整 */
    padding: 10px 15px;       /* 修改内边距，为胶囊形状做准备 */
    border-radius: 20px;      /* 添加圆角 */
    border: none;
    background: none;
    cursor: pointer;
    /* 为背景和颜色变化添加过渡效果 */
    transition: background-color 0.3s, color 0.3s;
}

/* 新增：为图标和文字之间添加一点间距 */
.feed-tab-btn .fas {
    margin-right: 5px;
}

.feed-tab-btn.active {
    color: #000;              /* 激活时文字改为黑色 */
    font-weight: bold;         /* 激活时文字加粗 */
    background-color: #e9ecef; /* 激活时背景改为淡灰色，形成胶囊效果 */
}

/* 关键：删除或确保没有 .feed-tab-btn.active::after 规则，去掉下划线 */
.feed-tab-btn.active::after {
    display: none;
}

.feed-sub-tabs {
    display: flex;
    /* 核心修复1：改为从左侧开始排列，这样滚动条才能正常从左开始 */
    justify-content: flex-start; 
    gap: 15px;
    padding: 8px 10px;
    background-color: #fafafa;
    flex-shrink: 0;
    border-bottom: 1px solid #eee;
    
    /* 核心修复2：允许 X 轴（横向）在内容溢出时自动显示滚动条 */
    overflow-x: auto;

    /* (可选) 隐藏滚动条本身，但保留滚动功能（在移动端更美观） */
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
}

/* (可选) 隐藏滚动条 - Webkit (Chrome, Safari) */
.feed-sub-tabs::-webkit-scrollbar {
    display: none;
}
/* --- 新代码：模仿Koko论坛(1)的黑白胶囊按钮风格 --- */
.feed-sub-tab-btn {
    padding: 8px 16px;      /* 稍微增大一点内边距，让按钮更大方 */
    font-size: 14px;
    font-weight: 500;
    color: #555;            /* 默认文字颜色改为深灰色 */
    border: 1px solid #ddd; /* 保留一个细边框 */
    background-color: #fff; /* 默认背景为白色 */
    border-radius: 20px;    /* 圆角更圆润 */
    cursor: pointer;
    transition: all 0.3s;
    white-space: nowrap;    /* 防止文字换行 */
}

.feed-sub-tab-btn.active {
    color: #fff;            /* 激活时文字为白色 */
    background-color: #000;  /* 激活时背景为黑色 */
    border-color: #000;      /* 激活时边框也为黑色 */
    font-weight: bold;       /* 激活时文字加粗 */
}

        .posts-list { padding: 10px; display: flex; flex-direction: column; gap: 10px; }
/* --- 新代码：模仿Koko论坛(1)的精致卡片和悬浮效果 --- */
.post-item {
    position: relative;
    display: flex;
    padding: 20px;          /* 增大内边距，让内容更舒展 */
    gap: 15px;              /* 稍微增大头像和内容的间距 */
    background-color: white;
    border-radius: 12px;    /* 调整圆角大小 */
    border: 1px solid #e0e0e0; /* 增加一个非常淡的边框，提升质感 */
    box-shadow: 0 2px 8px rgba(0,0,0,0.06); /* 调整一个更柔和的阴影 */
    cursor: pointer;
    /* 核心动效：为阴影和位移添加过渡效果 */
    transition: box-shadow 0.3s, transform 0.2s;
}

/* 核心动效：添加鼠标悬浮时的样式 */
.post-item:hover {
    transform: translateY(-3px); /* 向上移动3像素，产生上浮感 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* 阴影变得更深更明显 */
}
        .post-delete-btn { position: absolute; top: 10px; right: 10px; width: 28px; height: 28px; background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(5px); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--text-gray); font-size: 14px; cursor: pointer; z-index: 2; transition: all 0.2s; }
        .post-delete-btn:hover { background-color: var(--soft-red); color: white; }

        .post-item-avatar img { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; }
        .post-content-area { flex-grow: 1; display: flex; flex-direction: column; gap: 8px; min-width: 0; }
        .post-author-name { font-weight: 700; color: var(--text-dark); }
        .post-author-handle { font-size: 14px; color: var(--text-gray); margin-left: 8px; }
        .post-text { line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; font-size: 15px; }
        .post-meta { color: #999; font-size: 13px; }
        .post-actions { display: flex; justify-content: space-between; align-items: center; color: var(--text-gray); font-size: 14px; margin-top: 12px; padding-top: 8px; border-top: 1px solid #f0f0f0; }
        .post-action-btn { cursor: pointer; display: flex; align-items: center; gap: 6px; transition: color 0.2s; }
/* --- 新代码：将交互颜色改为更中性的深灰色或黑色 --- */
.post-action-btn {
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    color: #888; /* 将默认图标颜色改为灰色 */
    transition: color 0.2s;
}
.post-action-btn:hover, .post-action-btn.liked {
    color: #000; /* 悬浮和点赞后的颜色改为黑色 */
}
        .post-action-btn.liked .fa-heart { font-weight: 900; }
        .post-action-btn i { font-size: 16px; }

        .post-comments { background-color: #f7f9f9; border-radius: 10px; padding: 10px; font-size: 14px; display: flex; flex-direction: column; gap: 8px; margin-top: 5px; }
        .post-comments:empty { display: none; }
        
        .comment-delete-btn { color: var(--text-gray); font-size: 12px; cursor: pointer; opacity: 0; transition: all 0.2s; }
        .comment-delete-btn:hover { color: var(--soft-red); }
        .post-comment-item:hover .comment-delete-btn { opacity: 1; }

        .post-comment-item { line-height: 1.5; padding: 8px 0; border-bottom: 1px solid #eee; }
        .post-comment-item:last-child { border-bottom: none; }
        .comment-author { font-weight: 600; color: var(--theme-primary); margin-right: 5px; cursor: pointer; }
        .comment-content { color: var(--text-dark); }
        .comment-meta { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--text-gray); margin-top: 4px; }
        .comment-reply-to { background-color: #e9e9e9; padding: 4px 8px; border-radius: 8px; font-size: 13px; margin-left: 5px; }
        /* --- 新增：用于在帖子中显示作者签名 --- */
.post-author-signature {
    font-size: 13px;
    color: var(--text-gray);
    margin-top: 4px; /* 与昵称拉开一点距离 */
    padding-bottom: 8px; /* 与帖子正文拉开一点距离 */
    white-space: pre-wrap; /* 允许签名中的换行 */
    word-break: break-word;
}


        /* 热搜榜样式 */
        .trending-list { list-style: none; padding: 10px; background-color: white;}
        .trending-item { display: flex; align-items: center; padding: 15px; border-bottom: 1px solid #f0f0f0; cursor: pointer; }
        .trending-item:hover { background-color: #f9f9f9; }
        .trending-item:last-child { border-bottom: none; }
        .trending-rank { font-size: 18px; font-weight: bold; color: var(--text-gray); width: 40px; text-align: center; }
        .trending-rank.top-3 { color: var(--soft-red); }
        .trending-info { flex-grow: 1; }
        .trending-title { font-size: 16px; font-weight: 600; color: var(--text-dark); margin-bottom: 4px; }
        .trending-meta { font-size: 13px; color: var(--text-gray); }
        .trending-tag { background-color: #ffcdd2; color: #c62828; font-size: 11px; padding: 2px 6px; border-radius: 5px; margin-left: 8px; font-weight: bold; }
        
        #post-detail-screen { background-color: #f0f2f5; }
        .post-detail-content { flex-grow: 1; overflow-y: auto; }
        #post-detail-container { padding: 0; }
        #post-detail-container .post-item { cursor: default; }
        .comments-section { padding: 15px; background-color: #f0f2f5; }
        .comments-title { font-size: 16px; font-weight: 700; color: var(--text-dark); padding-bottom: 10px; border-bottom: 1px solid #ddd; margin-bottom: 10px; }
        .comment-input-area { display: flex; padding: 10px 15px; background-color: white; border-top: 1px solid #ddd; flex-shrink: 0; }
        #comment-input { flex-grow: 1; border: 1px solid #ddd; border-radius: 18px; padding: 8px 15px; font-size: 15px; resize: none; }
        #submit-comment-btn { background-color: var(--theme-primary); color: white; border: none; border-radius: 18px; padding: 8px 20px; margin-left: 10px; font-weight: 600; cursor: pointer; }
        
        .diary-entry {
            position: relative;
            background-color: white;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        
        .diary-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .diary-entry-meta { font-size: 12px; color: #999; margin-bottom: 10px; }
        .diary-entry-content { font-size: 16px; line-height: 1.6; color: #333; }
        .diary-delete-btn { position: absolute; top: 15px; right: 15px; font-size: 18px; color: #aaa; cursor: pointer; transition: color 0.2s ease; }
        .diary-delete-btn:hover { color: var(--soft-red); }
        .preset-list { display: flex; flex-direction: column; gap: 10px; padding: 15px 20px; }
        .preset-item { background-color: white; border-radius: 12px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); display: flex; justify-content: space-between; align-items: center; }
        .preset-info { flex-grow: 1; cursor: pointer; min-width: 0; margin-right: 10px; }
        .preset-name { font-weight: 500; font-size: 16px; color: #333; margin-bottom: 5px; }
        .preset-desc { font-size: 13px; color: var(--text-gray); overflow: hidden; text-overflow: ellipsis; white-space: pre-wrap; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; }
        .preset-actions { display: flex; gap: 10px; flex-shrink: 0; }
        .preset-action-btn { font-size: 18px; color: #999; cursor: pointer; padding: 5px; }
        .preset-action-btn:hover { color: var(--theme-primary); }
        .preset-action-btn.delete:hover { color: var(--soft-red); }
        /* ▼▼▼ 把这段新代码粘贴进去 ▼▼▼ */
.preset-action-btn.active {
    color: var(--theme-primary); /* 使用主题绿色作为激活颜色 */
}
        .emoticon-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .emoticon-item { background-color: #fff; border-radius: 8px; padding: 8px; box-shadow: 0 1px 3px var(--shadow-color); position: relative; display: flex; flex-direction: column; align-items: center; justify-content: space-between; }
        .emoticon-item img { max-width: 100%; height: 60px; object-fit: contain; margin-bottom: 5px; }
        .emoticon-name { font-size: 12px; color: #333; text-align: center; word-break: break-all; }
        .emoticon-delete-btn { position: absolute; top: -5px; right: -5px; background-color: var(--soft-red); color: white; width: 20px; height: 20px; border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; line-height: 20px; box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        /* ▼▼▼ 替换旧的 #emoticon-picker 样式 ▼▼▼ */
#emoticon-picker {
    position: absolute;
    bottom: 65px;
    left: 10px;
    right: 10px;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 10px;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
    max-height: 250px;
    z-index: 50;
    padding: 10px;

    /* 核心修改：默认隐藏，布局改为垂直弹性盒子 */
    display: none;
    flex-direction: column; 
}

/* 激活时显示为 flex，而不是 grid */
#emoticon-picker.active {
    display: flex !important; 
}

/* 让标签栏固定在顶部，不被压缩 */
#emoticon-picker .feed-sub-tabs {
    flex-shrink: 0; 
}

/* 让下面的表情网格自动填满剩余空间，并负责滚动 */
#emoticon-picker .emoticon-grid {
    flex-grow: 1;
    overflow-y: auto; /* 滚动条加在这里 */
    
    /* 内部维持网格布局 */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 10px;
    padding-top: 5px;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
        #emoticon-picker .emoticon-item { cursor: pointer; transition: transform 0.2s; }
        #emoticon-picker .emoticon-item:hover { transform: scale(1.1); }
        #emoticon-picker .emoticon-delete-btn { display: none; }
        
        /* --- 音乐库新增样式 --- */
        #music-library-list { display: flex; flex-direction: column; gap: 10px; }
        .music-item { background-color: white; border-radius: 8px; padding: 12px 15px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 1px 3px var(--shadow-color); }
        .music-info { flex-grow: 1; }
        .music-title { font-weight: 600; color: #333; }
        .music-artist { font-size: 14px; color: var(--text-gray); margin-top: 3px; }
        .music-delete-btn { background: none; border: none; font-size: 16px; color: #aaa; cursor: pointer; padding: 5px; }
        .music-delete-btn:hover { color: var(--soft-red); }
        #music-library-picker .picker-title { font-weight: 600; color: var(--text-gray); margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 8px; }
        #music-library-picker .picker-list { max-height: 120px; overflow-y: auto; }
        #music-library-picker .picker-item { padding: 8px 5px; cursor: pointer; border-radius: 4px; }
        #music-library-picker .picker-item:hover { background-color: #f0f0f0; }

/* ▼▼▼ 用这个新规则，替换掉旧的 #feed-status-indicator 规则 ▼▼▼ */

#feed-status-indicator {
    position: absolute; /* 1. 让它“浮”起来，不占空间 */
    
    /* 2. 把它精确定位到原来“论坛”标题的位置 */
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 60%; /* 限制一个宽度，防止文字太长和按钮打架 */
    
    /* 3. 让它看起来就像标题一样 */
    font-size: 18px; /* 字体可以比原标题小一点点，以示区别 */
    font-weight: 600; /* 字体粗细 */
    color: var(--text-gray); /* 加载时用灰色文字 */
    
    /* 4. 移除所有旧的边框、背景等 */
    padding: 0;
    text-align: center;
    background-color: transparent;
    border: none;
    
    display: none; /* 默认还是隐藏的 */
    z-index: 11; /* 确保它能盖住原来的标题 */
    
    /* 5. (可选) 加一个微妙的呼吸灯动画，让它更像在“加载” */
    animation: pulse-fade 1.5s infinite ease-in-out;

    /* 6. 移除旧的flex布局属性 */
    flex-shrink: unset; 
    order: unset; 
}

/* 7. (新) 呼吸灯动画 */
@keyframes pulse-fade {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

/* 8. (新) 这就是魔法！ */
/* 当顶栏(header)处于“is-loading”状态时... */
.moments-header.is-loading .moments-title {
    /* ...就隐藏掉原来的“论坛”二字 */
    visibility: hidden; /* 用 visibility 而不是 display:none 来保持布局稳定 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: var(--theme-primary); }
        input:focus + .slider { box-shadow: 0 0 1px var(--theme-primary); }
        input:checked + .slider:before { transform: translateX(22px); }
        .slider.round { border-radius: 28px; }
        .slider.round:before { border-radius: 50%; }
        #attachment-menu { position: absolute; bottom: 65px; left: 10px; right: 10px; background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 12px; box-shadow: 0 -4px 15px rgba(0,0,0,0.1); padding: 15px; display: none; grid-template-columns: repeat(4, 1fr); gap: 15px; z-index: 50; transition: opacity 0.2s ease, transform 0.2s ease; transform: translateY(10px); opacity: 0; }
        #attachment-menu.active { display: grid; transform: translateY(0); opacity: 1; }
        .attachment-menu-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; text-align: center; }
        .attachment-menu-item .icon-wrapper { width: 60px; height: 60px; background-color: white; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 28px; color: #555; margin-bottom: 8px; border: 1px solid #eee; }
        .attachment-menu-item .label { font-size: 13px; color: var(--text-gray); }
        .attachment-menu-item:hover .icon-wrapper { background-color: #f0f0f0; }
        .system-notification { align-self: center; background-color: #e1e1e1; color: var(--text-gray); font-size: 12px; padding: 5px 12px; border-radius: 15px; margin: 10px 0; text-align: center; }
        /* --- [V-MOD] AI假图片样式 (替换旧的 .message.picture-description) --- */

/* --- [V-MOD 2.0] AI "翻转"图片卡片样式 --- */

/* 1. 气泡本身 (透明容器) */
.message.picture-description {
    padding: 0;
    background-color: transparent;
    box-shadow: none;
    cursor: pointer;
    border-radius: 12px;
    overflow: hidden; 
}

/* 2. 内部的 "卡片"，这是我们的关键 */
.picture-description .message-image-container {
    position: relative; /* 关键：让文字可以浮动在图片之上 */
    padding: 5px;
    display: inline-block;
    
    /* == 你的要求：固定大小 == */
    /* (150px 图片 + 左右各 5px 内边距) */
    width: 160px;  
    height: 160px; 
    
    /* 确保大小计算正确 */
    box-sizing: border-box; 
    
    /* 圆角和过渡（用于切换背景色） */
    border-radius: 12px; 
    transition: background-color 0.3s ease;
}

/* 3. 卡片背景色 (保持原样) */
.message.sent.picture-description .message-image-container {
     background-color: var(--sent-message-bg);
}
.message.received.picture-description .message-image-container {
     background-color: white;
}

/* 4. 图片样式 (负责淡出) */
.picture-description .message-image {
    width: 150px;  /* 固定 150px */
    height: 150px; /* 固定 150px */
    border-radius: 12px;
    display: block;
    object-fit: cover; /* 确保图片不变形 */
    
    /* == 你的要求：淡出效果 == */
    opacity: 1;
    transition: opacity 0.3s ease-in-out;
    
    /* 定位，为文字腾出空间 */
    position: absolute;
    top: 5px;
    left: 5px;
}

/* 5. 【全新】描述文字的样式 (负责淡入) */
.picture-description-text {
    /* 浮动在图片之上 */
    position: absolute;
    top: 5px;
    left: 5px;
    width: 150px;  /* 尺寸与图片完全一致 */
    height: 150px; /* 尺寸与图片完全一致 */
    
    /* == 你的要求：文字可滑动 == */
    overflow-y: auto;
    padding: 10px; 
    box-sizing: border-box;

    /* == 你的要求：淡入效果 == */
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
    pointer-events: none; /* 隐藏时不可点击或滑动 */
    
    /* 文字排版 */
    font-size: 13px;
    color: var(--text-dark, #424242);
    line-height: 1.5;
    word-wrap: break-word;
    
    /* 适配深色气泡 (可选) */
    .message.sent & {
        color: var(--text-dark, #424242);
    }
}

/* 6. 【关键】切换状态的CSS */

/* 当卡片被点击，添加 .description-visible 类时... */
.picture-description.description-visible .message-image {
    /* == 你的要求：图片淡出 == */
    opacity: 0;
}

.picture-description.description-visible .picture-description-text {
    /* == 你的要求：文字淡入 == */
    opacity: 1;
    pointer-events: auto; /* 允许滑动和点击 */
}
/* --- [V-MOD 2.0] CSS 结束 --- */
        .message.sent.picture-description { background-color: var(--sent-message-bg); }
        .message.received.picture-description { background-color: #fff; }
        .message.picture-description i { font-size: 20px; color: var(--text-gray); margin-right: 10px; }
        .message.picture-description span { color: #333; }
        .message.voice { display: flex; align-items: center; justify-content: space-between; cursor: pointer; }
        .message.voice .fa-wifi { font-size: 20px; transform: rotate(90deg); color: var(--text-gray); }
        .message.sent.voice { background-color: var(--sent-message-bg); }
        .message.received.voice { background-color: #fff; }
        .message.sent.voice .fa-wifi { order: 2; margin-left: 15px; }
        .message.received.voice .fa-wifi { margin-right: 15px; }
        .voice-duration { color: var(--text-gray); }
/* ▼▼▼ 粘贴这个【最终修复版】▼▼▼ */
        .transcribed-text { 
            background-color: #fff; 
            border: 0px solid #eee; /* 修复1：默认边框改为0 */
            padding: 0 10px; /* 修复2：默认的 上下内边距 改为0 */
            border-radius: 8px; 
            margin-top: 0; 
            font-size: 14px; 
            color: #333; 
            max-height: 0; 
            opacity: 0; 
            overflow: hidden; 
            /* 修复3：把padding和border也加入过渡动画 */
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out, padding 0.3s ease-out, border-width 0.3s ease-out; 
        }
        .transcribed-text.visible { 
            max-height: 200px; 
            opacity: 1; 
            margin-top: 5px; 
            padding: 10px; /* 修复4：仅在可见时恢复内边距 */
            border-width: 1px; /* 修复5：仅在可见时恢复边框 */
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        .message.red-packet { background-color: #FFCC80; color: #5D4037; width: 240px; padding: 0; overflow: hidden; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s; box-shadow: 0 2px 5px rgba(255, 152, 0, 0.2); }
        .message.red-packet.opened { background-color: #FFF3E0; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); }
        .message.red-packet .red-packet-header { padding: 10px 15px; display: flex; align-items: center; }
        .message.red-packet .red-packet-icon { font-size: 24px; margin-right: 10px; color: #FFA726; }
        .message.red-packet .red-packet-blessing { font-size: 15px; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; }
        .message.red-packet .red-packet-status { font-size: 13px; opacity: 0.9; }
        .message.red-packet.opened .red-packet-icon, .message.red-packet.opened .red-packet-blessing, .message.red-packet.opened .red-packet-status { color: #BCAAA4; }
        .message.red-packet .red-packet-footer { background-color: transparent; color: #A1887F; font-size: 12px; padding: 5px 15px; border-top: 1px solid rgba(161, 136, 127, 0.2); }
        .message.red-packet.opened .red-packet-footer { color: #cebeba; border-top: 1px solid rgba(161, 136, 127, 0.1); }
        .message.sent.red-packet { border-top-right-radius: 0; }
        .message.received.red-packet { border-top-left-radius: 0; }
        .message.transfer { background-color: var(--theme-primary); color: white; width: 240px; padding: 0; overflow: hidden; position: relative; box-shadow: 0 2px 5px var(--shadow-color); }
        .message.transfer.completed { background-color: #C8E6C9; }
        .message.transfer.completed .transfer-info .transfer-text, .message.transfer.completed .transfer-info .transfer-amount { color: #388E3C; }
        .message.transfer.completed .transfer-icon i { color: var(--theme-primary-hover); }
        .message.transfer.completed::after { content: '\f00c'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; right: 15px; top: 50%; transform: translateY(-50%); font-size: 18px; color: var(--theme-primary-hover); }
        .message.transfer .transfer-header { padding: 10px 15px; display: flex; align-items: center; }
        .message.transfer .transfer-icon { font-size: 24px; margin-right: 10px; }
        .message.transfer .transfer-info .transfer-text { font-size: 15px; font-weight: 500; }
        .message.transfer .transfer-info .transfer-amount { font-size: 18px; font-weight: bold; }
        .message.transfer .transfer-footer { background-color: transparent; color: white; font-size: 12px; padding: 5px 15px; border-top: 1px solid rgba(255,255,255,0.3); opacity: 0.9; }
        .message.transfer.completed .transfer-footer { color: var(--theme-primary-hover); border-top: 1px solid rgba(102, 187, 106, 0.2); }
        .message.sent.transfer { border-top-right-radius: 0; }
        .message.received.transfer { border-top-left-radius: 0; }

        /* --- Pet Game Styles --- */
        #pet-container {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }
        .pet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        #pet-name {
            color: var(--text-dark);
        }
        #pet-gold-display {
            font-size: 16px;
            color: #E6A23C;
        }
        .pet-visual-area {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            margin-bottom: 15px;
        }
        .pet-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        .stat-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .stat-bar-label {
            width: 60px;
            text-align: right;
        }
        .stat-bar {
            flex-grow: 1;
            height: 10px;
            background-color: #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        .stat-bar-inner {
            height: 100%;
            width: 100%;
            border-radius: 5px;
            background-color: var(--theme-primary);
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        .pet-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .pet-action-btn {
            padding: 10px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #f0f2f5;
            color: var(--text-dark);
        }
        .pet-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .pet-action-btn:disabled {
            background-color: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #work-pet-btn {
            background-color: var(--theme-secondary);
            color: white;
        }
        
        .slime {
    width: 55px; /* 宽度设为55px */
    height: 40px; /* 高度设为40px，这样基础形状更稳定 */
    /* 背景色和半透明效果保持不变 */
    background-color: rgba(209, 233, 206, 0.8); 
    
    /* 核心修改：只设置左上角和右上角的圆角，让底部保持平坦 */
    /* 这四个值分别对应：左上、右上、右下、左下 */
    border-radius: 60px 60px 30px 30px; 

    position: relative;
    animation: slime-bob 2s infinite ease-in-out;
    transition: all 0.5s ease;
    
    /* 边框效果保持不变 */
    border: 2px solid rgba(76, 175, 80, 0.5);
    /* 新增：移除底部边框线，让它完美地“贴”在地面上 */
    border-bottom: none; 
    
    /* 内阴影果冻质感保持不变 */
    box-shadow: inset 0 -4px 8px rgba(0, 0, 0, 0.15), 
                inset 0 4px 6px rgba(255, 255, 255, 0.4);
}
        .slime.hungry { background-color: #ffb74d; }
        .slime.dirty { background-color: #bdbdbd; }
        .slime::before {
            content: '';
            position: absolute;
            width: 7px;
            height: 7px;
            background-color: #212121;
            border-radius: 50%;
            top: 15px;
            left: 12px;
            transition: all 0.5s ease;
        }
        .slime::after {
            content: '';
            position: absolute;
            width: 7px;
            height: 7px;
            background-color: #212121;
            border-radius: 50%;
            top: 15px;
            right: 12px;
            transition: all 0.5s ease;
        }
        .slime-shadow {
            width: 50px;
            height: 8px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 50%;
            margin-top: 5px;
            animation: slime-shadow-squish 2s infinite ease-in-out;
            transition: all 0.5s ease;
        }
        @keyframes slime-bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes slime-shadow-squish {
             0%, 100% { transform: scaleX(1); }
            50% { transform: scaleX(0.8); }
        }

        /* --- V6.0 新增：宠物进化形态 --- */
        /* 初始宝宝期形态 */
        .slime.baby-form { }

        /* 幼年期 */
        .slime.toddler-form {
            transform: scale(1.15); /* 长大一点 */
            background-color: #a5d6a7; /* 颜色变嫩一点 */
        }
        .slime.toddler-form::before, 
        .slime.toddler-form::after {
            width: 7px; /* 眼睛变大一点 */
            height: 7px;
            box-shadow: 0 0 2px rgba(255, 255, 255, 0.6); /* 眼睛里有光 */
        }

        /* 少年期，眼睛变成 > < 的样子*/
        .slime.teenager-form {
            transform: scale(1.25);
            animation-duration: 1.5s; /* 变得更活泼，跳得快一点 */
        }
        .slime.teenager-form::before { /* 左眼 */
            content: '>';
            font-weight: bold;
            color: white;
            background: none;
            font-size: 12px;
            line-height: 1;
            transform: rotate(-15deg);
            top: 18px;
            left: 18px;
        }
        .slime.teenager-form::after { /* 右眼 */
            content: '<';
            font-weight: bold;
            color: white;
            background: none;
            font-size: 12px;
            line-height: 1;
            transform: rotate(15deg);
            top: 18px;
            right: 18px;
        }
        /* --- 新增：史莱姆互动动画 --- */
        .slime.happy-jiggle {
            animation: happy-jiggle 0.5s ease-in-out;
        }
        @keyframes happy-jiggle {
            0%, 100% { transform: scale(1, 1); }
            25% { transform: scale(0.95, 1.05); }
            50% { transform: scale(1.05, 0.95); }
            75% { transform: scale(0.98, 1.02); }
        }

        .slime .blush {
            position: absolute;
            width: 15px;
            height: 6px;
            background-color: rgba(255, 105, 180, 0); /* 默认透明 */
            border-radius: 50%;
            top: 22px;
            transition: background-color 0.3s ease;
        }
        .slime .blush.left { left: 5px; transform: rotate(-15deg); }
        .slime .blush.right { right: 5px; transform: rotate(15deg); }
        .slime.is-blushing .blush {
            background-color: rgba(255, 105, 180, 0.6); /* 脸红 */
        }
/* --- 新增：用于隐藏思维预设的编辑功能 --- */
/*

/ * 1. 隐藏“思维预设管理”页面右上角的“+”添加按钮 * /
#add-thought-preset-btn {
    display: none;
}

/ * 2. 隐藏每个思维预设项目右侧包含“编辑”和“删除”图标的整个操作区 * /
#thought-presets-list .preset-actions {
    display: none;
}

*/
/* --- 钱包收支明细样式 --- */
        #transaction-list {
            padding: 10px 0;
        }
        .transaction-item {
            background-color: white;
            padding: 15px;
            margin: 0 15px 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .transaction-info .desc {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 4px;
            font-size: 16px;
        }
        .transaction-info .time {
            font-size: 13px;
            color: var(--text-gray);
        }
        .transaction-amount {
            font-size: 16px;
            font-weight: bold;
            flex-shrink: 0;
            margin-left: 15px;
        }
        .transaction-amount.income {
            color: var(--theme-primary-hover);
        }
        .transaction-amount.expense {
            color: var(--soft-red);
        }

/* --- 转账退还样式 --- */
        .message.transfer.returned {
            background-color: #bdc3c7; /* 中性灰色背景 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .message.transfer.returned .transfer-info .transfer-text,
        .message.transfer.returned .transfer-info .transfer-amount,
        .message.transfer.returned .transfer-footer {
            color: #6c757d;
            text-decoration: line-through; /* 添加删除线表示作废 */
        }
        .message.transfer.returned .transfer-icon i {
            color: #6c757d;
        }
        /* 将退还后的图标从对勾变为退还箭头 */
        .message.transfer.returned::after {
            content: '\f0e2'; /* Font Awesome "reply/undo" icon */
            font-family: 'Font Awesome 6 Free';
            font-weight: 900; 
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 18px;
            color: #6c757d;
        }
        /* 转账弹窗里的退还按钮样式 */
        #return-transfer-btn {
            margin-top: 10px;
            background-color: #e67e22; /* 胡萝卜橙色 */
        }
        /* --- 全新美化的转账弹窗样式 --- */
        #transfer-modal .modal-header { /* 优化头部 */
            background-color: #f7f9f9;
            color: var(--text-dark);
            border-bottom: 1px solid #eee;
        }
        #transfer-modal .close-btn { color: #999; }
        #transfer-modal .modal-body {
            padding: 20px 25px 30px;
            text-align: center;
        }
        .transfer-sender-profile { /* 发起人信息 */
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 25px;
        }
        .transfer-sender-avatar {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            margin-right: 12px;
        }
        .transfer-sender-info { text-align: left; }
        .transfer-sender-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-dark);
        }
        .transfer-recipient-name {
            font-size: 14px;
            color: var(--text-gray);
        }
        .transfer-amount-display { /* 金额显示 */
            padding-bottom: 25px;
            margin-bottom: 25px;
            border-bottom: 1px dashed #ddd;
        }
        .transfer-amount-display span:first-child { /* '¥' 符号 */
            font-size: 32px;
            font-weight: 500;
            margin-right: 4px;
        }
        .transfer-amount-display span:last-child { /* 金额数字 */
            font-size: 48px;
            font-weight: 700;
            color: var(--text-dark);
        }
        .transfer-action-area .form-button { /* 按钮区域 */
            margin-top: 10px;
        }
        #confirm-transfer-btn { background-color: var(--theme-primary); }
        #return-transfer-btn { background-color: #e67e22; }

        /* --- 已收款/已退还状态视图 --- */
        .transfer-status-info {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-dark);
        }
        .transfer-status-info i {
            font-size: 24px;
            margin-right: 10px;
        }
        .transfer-status-info i.fa-check-circle { color: var(--theme-primary-hover); }
        .transfer-status-info i.fa-undo-alt { color: #e67e22; }
        .transfer-status-subtext {
            margin-top: 8px;
            font-size: 14px;
            color: var(--text-gray);
        }
        /* --- 修正系统消息包裹层，使其居中 --- */
        .message-wrapper.system-wrapper {
            align-self: center;
            /* 解除最大宽度限制，让内部的灰色消息自己决定宽度 */
            max-width: none;
            justify-content: center;
        }
        /* --- 论坛帖子内的红包卡片样式 --- */
        .forum-red-packet-card {
            background-color: #FFCC80;
            color: #5D4037;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .forum-red-packet-card:hover {
            transform: scale(1.02);
        }
        .forum-red-packet-card .red-packet-icon {
            font-size: 24px;
            margin-right: 10px;
            color: #FFA726;
        }
        .forum-red-packet-card .red-packet-blessing {
            font-weight: 500;
        }

        /* --- 帖子分享到私聊里的卡片样式 --- */
        .message.post-share-card {
            background-color: #fff;
            border: 1px solid #eee;
            width: 250px;
            padding: 12px;
            border-radius: 12px;
            cursor: pointer;
        }
        .post-share-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        .post-share-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .post-share-name {
            font-weight: 600;
            font-size: 14px;
        }
        .post-share-content {
            font-size: 14px;
            color: var(--text-gray);
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.5;
        }
        .post-share-footer {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
            text-align: right;
        }
        
        /* --- 发布动态时添加红包的按钮样式 --- */
        .moment-extra-actions {
            display: flex;
            justify-content: flex-start;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0;
        }
        .moment-action-btn {
            font-size: 20px;
            color: var(--text-gray);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
        }
        .moment-action-btn:hover {
            background-color: #f0f0f0;
        }
        .moment-action-btn.active {
            color: var(--soft-red);
        }
        
        /* --- 转发时选择联系人的弹窗样式 --- */
        .contact-picker-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 15px;
        }
        .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 6px;
        }
        .contact-picker-item:hover {
            background-color: #f9f9f9;
        }
        .contact-picker-item input {
            margin-right: 15px;
        }
        .contact-picker-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        #custom-confirm-confirm-btn.danger {
    background-color: var(--soft-red) !important;
}
/* ========================================================== */
/* V9.0 新增：悬浮音乐播放器样式 */
/* ========================================================== */
:root {
    --apple-green: #8DB600; /* 新增苹果绿 */
}
#music-player-card {
    display: none; /* 默认隐藏，由JS控制 */
    flex-direction: column;
    position: absolute; /* 使用absolute定位在#screen内 */
    width: 320px;
    height: 500px;
    background-color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(20px);
    border-radius: 16px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
    overflow: hidden;
    top: 50px; 
    left: 50px;
    z-index: 1000;
    transition: all 0.4s ease-in-out;
}
.player-header {
    padding: 0 15px;
    height: 45px;
    font-weight: 600;
    color: var(--text-dark);
    background-color: rgba(0,0,0,0.05);
    cursor: move;
    position: relative;
    user-select: none;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0;
}
.player-collapse-btn {
    position: absolute;
    top: 50%;
    left: 15px;
    transform: translateY(-50%);
    cursor: pointer;
    color: var(--text-light);
    padding: 5px;
}
/* --- ▼▼▼ 新增的关闭按钮样式 ▼▼▼ --- */
#player-close-btn {
    position: absolute;
    top: 50%;
    right: 15px;
    transform: translateY(-50%);
    cursor: pointer;
    color: var(--text-gray);
    padding: 5px;
    font-size: 18px;
    transition: transform 0.2s ease;
}
#player-close-btn:hover {
    transform: translateY(-50%) scale(1.15);
}
.header-collapsed-content {
    display: none;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding-left: 35px;
}
.header-avatar-stack { display: flex; align-items: center; }
.header-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px solid white;
    object-fit: cover;
}
.header-avatar:last-child { margin-left: -10px; }
.header-lyric {
    flex-grow: 1;
    font-size: 14px;
    font-weight: 600;
    color: var(--apple-green);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.player-main-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    transition: opacity 0.3s;
}
.player-avatar-stack { display: flex; justify-content: center; align-items: center; padding: 20px 0 15px; }
.player-avatar { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid white; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }
.player-avatar:last-child { margin-left: -25px; }
.player-song-info { text-align: center; }
.player-title { font-size: 18px; font-weight: 700; color: var(--text-dark); }
.player-artist { font-size: 14px; color: var(--text-light); margin-top: 5px; }
.lyrics-container { flex-grow: 1; overflow: hidden; position: relative; mask-image: linear-gradient(transparent 0%, black 20%, black 80%, transparent 100%); margin-top: 15px; }
.lyrics-wrapper { position: absolute; width: 100%; transition: transform 0.5s ease-out; }
.lyric-line { padding: 8px 20px; text-align: center; font-size: 16px; color: var(--text-light); transition: color 0.5s, transform 0.5s; }
.lyric-line.active {
    color: var(--apple-green);
    font-weight: 600; 
    transform: scale(1.1); 
}
.player-controls-wrapper { padding: 15px 20px; border-top: 1px solid rgba(0,0,0,0.05); }
.player-progress-bar-wrapper { display: flex; align-items: center; gap: 10px; font-size: 12px; color: var(--text-light); }
.player-progress-bar { flex-grow: 1; height: 4px; background-color: rgba(0,0,0,0.1); border-radius: 2px; cursor: pointer; padding: 4px 0; background-clip: content-box; }
.player-progress { width: 0%; height: 100%; background-color: var(--theme-primary); border-radius: 2px; }
.player-controls { display: flex; justify-content: space-around; align-items: center; font-size: 20px; margin-top: 10px; color: var(--text-dark); }
.player-control-btn { cursor: pointer; transition: transform 0.2s; width: 30px; text-align: center;}
.player-control-btn:hover { transform: scale(1.15); }
.player-play-btn { font-size: 40px; color: var(--theme-primary); }

#music-player-card.collapsed {
    height: 45px;
    background-color: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(25px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.25);
}
#music-player-card.collapsed .header-collapsed-content,
#music-player-card.collapsed .player-collapse-btn {
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
#music-player-card.collapsed .player-header-title { display: none; }
#music-player-card.collapsed .header-collapsed-content { display: flex; }
#music-player-card.collapsed .player-main-content { visibility: hidden; opacity: 0; }

.player-playlist-view {
    position: absolute;
    top: 45px;
    left: 0; right: 0; bottom: 95px; 
    background-color: rgba(255, 255, 255, 0.92); 
    backdrop-filter: blur(20px); 
    transform: translateY(100%);
    transition: transform 0.4s ease-in-out, opacity 0.4s ease-in-out; /* 建议给opacity也加上过渡效果 */
    opacity: 0;
    padding: 10px 0;
    overflow-y: auto;
    border-top: 1px solid rgba(0,0,0,0.05);
    pointer-events: none; /* <-- 核心新增：隐藏时忽略点击事件 */
    z-index: 3;
}
.player-playlist-view.active { 
    transform: translateY(0); 
    opacity: 1; 
    pointer-events: auto; /* <-- 核心新增：显示时恢复点击事件 */
}
.playlist-item { padding: 12px 20px; cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05); }
.playlist-item:hover { background-color: rgba(0,0,0,0.05); }
.playlist-item.playing .playlist-title { color: var(--theme-primary); }
.playlist-title { font-weight: 600; color: var(--text-dark); font-size: 14px; }
.playlist-artist { font-size: 12px; color: var(--text-light); }
/* ========================================================== */
/* V16.0 最终完美版：无缝、平滑的呼吸光晕 */
/* ========================================================== */

/* 1. 【防重叠魔法】(此部分无变化) */
.player-avatar {
    position: relative;
}
.player-avatar:first-child {
    z-index: 2;
}
.player-avatar:last-child {
    z-index: 1;
}

/* 2. 【重新定义动画】创建一个完整的“吸气-呼气”循环 */
@keyframes pulse-glow-left {
    /* 动画的开始和结束点都是同一个状态：最小、最明显的光晕 */
    0%, 100% {
        box-shadow: -2px 0 5px 0px rgba(129, 199, 132, 0.7);
    }
    /* 动画的中点是另一个状态：最大、最微弱的光晕 */
    50% {
        /* 关键：这里的透明度不是0，而是0.1，保留了一丝微光，确保动画永不中断！ */
        box-shadow: -8px 0 20px 12px rgba(129, 199, 132, 0.1);
    }
}

@keyframes pulse-glow-right {
    0%, 100% {
        box-shadow: 2px 0 5px 0px rgba(129, 199, 132, 0.7);
    }
    50% {
        box-shadow: 8px 0 20px 12px rgba(129, 199, 132, 0.1);
    }
}

/* 3. 【应用新动画】移除 alternate，并使用更平滑的 ease-in-out */
#player-avatar-stack.is-playing .player-avatar:first-child {
    /* 动画时长3秒，无限循环，缓入缓出效果，不再需要 alternate */
    animation: pulse-glow-left 3s infinite ease-in-out;
}
#player-avatar-stack.is-playing .player-avatar:last-child {
    animation: pulse-glow-right 3s infinite ease-in-out;
}
/* --- 红包领取详情弹窗样式 --- */
.claimer-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.claimer-item:last-child {
    border-bottom: none;
}
.claimer-avatar {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    margin-right: 12px;
}
.claimer-info {
    flex-grow: 1;
}
.claimer-name {
    font-weight: 500;
    color: var(--text-dark);
}
.claim-time {
    font-size: 12px;
    color: var(--text-gray);
    margin-top: 2px;
}
.claim-amount {
    font-size: 15px;
    font-weight: 600;
    color: var(--text-dark);
}
.best-luck-badge {
    background-color: #FFD700;
    color: #A67C00;
    font-size: 11px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 5px;
    margin-left: 8px;
}
/* --- V-Final 新增: 游戏转盘样式 --- */
.wheel-option-item {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}
.wheel-option-item input[type="text"] {
    flex-grow: 1;
}
.wheel-option-item input[type="number"] {
    width: 60px;
    text-align: center;
}
.wheel-option-item .delete-option-btn {
    background: none;
    border: none;
    color: var(--soft-red);
    cursor: pointer;
    font-size: 18px;
}
.message.game-wheel-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 250px;
    padding: 12px;
    border-radius: 12px;
}
.wheel-card-title {
    font-weight: bold;
    text-align: center;
    padding-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
    margin-bottom: 12px;
}
.wheel-card-result-area {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.wheel-result-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.wheel-player-name {
    font-size: 14px;
    color: #555;
}
.wheel-player-result {
    font-size: 14px;
    font-weight: 600;
    background-color: #f0f2f5;
    padding: 4px 10px;
    border-radius: 12px;
}
.spin-btn {
    background-color: var(--theme-primary);
    color: white;
    border: none;
    padding: 4px 12px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 14px;
}
.spin-btn:hover {
    background-color: var(--theme-primary-hover);
}
/* --- 引用回复功能样式 --- */
.message-wrapper {
    position: relative; /* 确保回复按钮可以正确定位 */
}

.reply-btn {
    position: absolute;
    top: 50%;
    background-color: rgba(240, 240, 240, 0.8);
    backdrop-filter: blur(2px);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #555;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    opacity: 0; /* 默认完全透明，隐藏 */
    transform: translateY(-50%) scale(0.8); /* 默认缩小一点 */
    transition: opacity 0.2s ease, transform 0.2s ease; /* 添加平滑过渡动画 */
    pointer-events: none; /* 隐藏时不可点击 */
}

/* 当父级 message-wrapper 拥有 .show-reply-btn 类时，让按钮显示出来 */
.message-wrapper.show-reply-btn .reply-btn {
    opacity: 1;
    transform: translateY(-50%) scale(1);
    pointer-events: auto; /* 显示时恢复点击 */
}

/* ▼▼▼ 用这个替换你原来的 ▼▼▼ */
.message-wrapper.sent .reply-btn,
.message-wrapper.sent .recall-btn { /* <-- 关键：把 .recall-btn 加到这里 */
    left: -35px; /* 两个按钮都固定在左边 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
.message-wrapper.received .reply-btn {
    right: -35px; /* 收到的消息，按钮在右边 */
}
.reply-btn:hover {
    transform: translateY(-50%) scale(1.1) !important;
}

/* 聊天输入框上方的引用预览条 */
#reply-preview-bar {
    padding: 8px 15px;
    background-color: #f0f0f0;
    font-size: 13px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e0e0e0;
}
#reply-preview-content {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #666;
}
#reply-preview-content .sender {
    font-weight: 600;
    color: #333;
}
#cancel-reply-btn {
    cursor: pointer;
    font-size: 16px;
    margin-left: 10px;
    color: #888;
}

/* 聊天气泡中的引用消息框 */
.message-quote {
    background-color: rgba(0, 0, 0, 0.05);
    padding: 6px 12px;
    border-left: 3px solid var(--theme-primary);
    border-radius: 6px;
    margin-bottom: 8px;
    font-size: 13px;
    cursor: pointer; /* 添加手型光标，提示可以点击 */
}
.message-quote .sender {
    font-weight: 600;
    color: var(--theme-primary);
}
.message-quote .content {
    color: #555;
    white-space: normal; /* Allows the text to wrap naturally */
    word-wrap: break-word; /* Ensures long words don't overflow */
    display: block;
    /* The overflow and text-overflow properties are no longer needed */
}

/* 点击引用框跳转后，目标消息的高亮效果 */
.message-wrapper.highlighted .message {
    animation: highlight-anim 1.5s ease;
}
@keyframes highlight-anim {
    0% { background-color: #fff3cd; }
    100% { background-color: inherit; }
}
.message-wrapper.sent.highlighted .message.sent {
     animation: highlight-anim-sent 1.5s ease;
}
@keyframes highlight-anim-sent {
    0% { background-color: #bde0fe; }
    100% { background-color: var(--sent-message-bg); }
}
/* --- V-Final 新增: 叙事模式气泡加宽 --- */
#chat-messages.narrative-mode-active .message-wrapper {
    max-width: 90%; /* 从默认的 85% 增加到 95% */
}
/* --- V-Final 新增: 在聊天中隐藏角色头像 --- */
.message-wrapper.contact-avatar-hidden .message-avatar {
    display: none;
}
.message-wrapper.received.contact-avatar-hidden .message-body {
    margin-left: 0;
}
/* ========================================================== */
/* V17.0 新增：视频通话样式 (简化版) */
/* ========================================================== */
.video-call-card-content {
    width: 90%;
    max-width: 400px;
    height: 75%;
    max-height: 650px;
    background-color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(18px);
    border-radius: 24px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.5);
    display: flex;
    flex-direction: column;
    color: var(--text-dark);
    overflow: hidden;
}
.video-call-header { padding: 15px; text-align: center; flex-shrink: 0; border-bottom: 1px solid rgba(0,0,0,0.07); }
#call-contact-name { font-size: 18px; font-weight: 700; }
#call-status { display: block; font-size: 13px; color: var(--theme-primary); margin-top: 4px; font-weight: 600; }
.video-call-main { flex-grow: 1; padding: 15px; overflow: hidden; }
.narrative-feed { height: 100%; overflow-y: auto; padding-right: 10px; display: flex; flex-direction: column; }
.char-bubble { align-self: flex-start; max-width: 90%; background-color: #fff; border: 1px solid var(--border-color); box-shadow: 0 1px 2px rgba(0,0,0,0.04); padding: 10px 15px; border-radius: 18px; border-top-left-radius: 4px; margin-bottom: 12px; font-size: 15px; line-height: 1.6; }
.char-bubble p { margin: 0 0 8px 0; }
.char-bubble p:last-child { margin-bottom: 0; }
.char-bubble .narrative-speech { color: var(--text-dark); font-weight: 500; }
.char-bubble .narrative-action { color: var(--text-gray); font-style: italic; }
.char-bubble .narrative-psychology { color: var(--theme-primary-hover); font-style: italic; }
.narrative-feed > .narrative-action { color: var(--text-gray); font-style: italic; align-self: center; text-align: center; font-size: 13px; margin: 5px 0 15px 0; }
.user-message { align-self: flex-end; background-color: var(--sent-message-bg); padding: 10px 15px; border-radius: 18px; border-bottom-right-radius: 4px; color: var(--text-dark); font-weight: 500; margin-bottom: 12px; max-width: 90%; font-size: 15px; line-height: 1.6; }
.video-call-input-area { padding: 8px 15px; display: flex; align-items: center; border-top: 1px solid rgba(0,0,0,0.07); background-color: rgba(0,0,0,0.03); flex-shrink: 0; }
#video-call-input { flex-grow: 1; background-color: white; border: 1px solid var(--border-color); border-radius: 20px; padding: 8px 15px; font-size: 15px; outline: none; resize: none; max-height: 100px; overflow-y: auto; font-family: inherit; }
#video-call-send-btn { background-color: var(--theme-primary); color: var(--text-on-primary); border: none; border-radius: 50%; width: 38px; height: 38px; display: flex; justify-content: center; align-items: center; margin-left: 8px; cursor: pointer; font-size: 16px; flex-shrink: 0; transition: background-color 0.2s; }
.video-call-controls { display: flex; justify-content: space-around; align-items: center; padding: 15px 20px; background-color: rgba(0,0,0,0.03); flex-shrink: 0; }
.control-btn { display: flex; flex-direction: column; align-items: center; cursor: pointer; width: 80px; text-align: center; }
.control-btn i { width: 60px; height: 60px; border-radius: 50%; background-color: #e9ecef; color: var(--text-dark); display: flex; justify-content: center; align-items: center; font-size: 26px; margin-bottom: 6px; transition: all 0.2s ease; }
.control-btn span { font-size: 12px; font-weight: 500; color: var(--text-gray); }
.control-btn.hang-up i { background-color: var(--soft-red); color: white; }

/* 来电界面样式 */
#incoming-call-screen {
    display: none; 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    z-index: 1002; 
    background-color: rgba(0,0,0,0.7); 
    backdrop-filter: blur(10px); 
    color: white; 
    text-align: center; 
    flex-direction: column; 
    justify-content: space-around; 
    align-items: center;
}

/* 实际通话界面样式 */
#video-call-screen {
    display: none; 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    justify-content: center; 
    align-items: center; 
    z-index: 1001; 
    background-color: rgba(0,0,0,0.4);
}
/* --- 新增：响应式手机屏幕模拟 --- */
#app-container {
    /* 默认情况下（手机访问时），占满整个屏幕 */
    width: 100%;
    height: 100%;
    background-color: #f0f2f5; /* 给电脑屏幕背景一个颜色，突出手机区域 */
}

/* 当屏幕宽度大于等于 600px 时（可以理解为平板或电脑）*/
@media (min-width: 600px) {
    #app-container {
        /* 将其最大宽度限制为手机尺寸 */
        max-width: 414px;

        /* 高度也限制为手机尺寸 */
        height: 896px;

        /* 保留圆角来模拟屏幕形状 */
        border-radius: 40px; 
        
        /* 加一点阴影，让它在电脑上有悬浮感，如果完全不想要也可以删除这行 */
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);

        /* 确保内部内容不会溢出圆角 */
        overflow: hidden; 
        
        /* 确保内部的 #screen 元素能正确继承尺寸 */
        position: relative; 
    }
}
/* --- V-Final 新增: 购物中心样式 V3 (修正版) --- */
.product-list {
    display: grid;
    grid-template-columns: 1fr 1fr;
    align-items: start;
    gap: 6px;
    padding: 10px;
}
.product-item {
    background-color: white;
    border-radius: var(--soft-radius);
    box-shadow: 0 1px 4px rgba(0,0,0,0.07);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid #f0f0f0;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    cursor: pointer;
}
.product-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
}
/* V3核心修正：瀑布流错位效果 */
.product-item:nth-child(even) {
    margin-top: 10px;
}
.product-details {
    padding: 12px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-title {
    font-size: 15px;
    font-weight: 600;
    line-height: 1.4;
    color: var(--text-dark);
    margin-bottom: 8px;
}
.product-description {
    font-size: 13px;
    color: #555;
    background-color: #f7f9fa;
    padding: 8px 10px;
    border-radius: 8px;
    margin-bottom: 10px;
    line-height: 1.5;
}
.product-shop {
    font-size: 12px;
    color: var(--text-gray);
    margin-top: auto;
    padding-top: 5px;
}
.product-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
}
.product-price {
    font-size: 16px;
    font-weight: bold;
    color: #ff7043;
}
.product-price span {
    font-size: 12px;
    font-weight: normal;
}
.product-share-btn {
    background: none;
    border: none;
    font-size: 18px;
    color: var(--text-gray);
    cursor: pointer;
    padding: 5px;
}
.product-share-btn:hover {
    color: var(--theme-primary);
}
.message.product-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 240px;
    padding: 10px;
    border-radius: 12px;
}
.product-share-intent {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-gray);
    padding-bottom: 8px;
    margin-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
.product-share-body {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.product-share-info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-share-info .product-title {
    -webkit-line-clamp: 3;
    font-weight: 600;
}
.product-share-info .product-price {
    margin-top: 5px;
    text-align: right;
}
.product-share-accompanying-msg {
    margin-top: 10px;
    padding: 8px;
    background-color: #f7f9fa;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    white-space: pre-wrap;
    word-break: break-all;
}
.product-share-accompanying-msg:empty {
    display: none;
}
#product-detail-content #product-main-info {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--soft-radius);
    box-shadow: var(--shadow-color);
}
#detail-action-bar {
    border-top: 1px solid var(--border-color);
    padding: 10px 15px;
}

/* --- V3 新增: 商品详情页样式 --- */
#product-detail-content #product-main-info {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--soft-radius);
    box-shadow: var(--shadow-color);
}
#detail-action-bar {
    border-top: 1px solid var(--border-color);
    padding: 10px 15px;
}
/* --- V-Final 新增: 聊天内分享的商品卡片样式 V2 --- */
.message.product-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 240px;
    padding: 10px;
    border-radius: 12px;
}
.product-share-intent {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-gray);
    padding-bottom: 8px;
    margin-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
/* V2改动：卡片内不再有图片，改为显示文字描述 */
.product-share-body {
    display: flex;
    flex-direction: column; /* 改为垂直布局 */
    gap: 8px;
}
.product-share-info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-share-info .product-title {
    -webkit-line-clamp: 3;
    font-weight: 600;
}
.product-share-info .product-price {
    margin-top: 5px;
    text-align: right;
}
.product-share-accompanying-msg {
    margin-top: 10px;
    padding: 8px;
    background-color: #f7f9f9;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    white-space: pre-wrap;
    word-break: break-all;
}
.product-share-accompanying-msg:empty {
    display: none;
}
/* --- 聊天顶栏“更多操作”菜单样式 (小竖条版) --- */
#chat-options-menu {
    position: absolute;
    top: 55px; /* 从顶栏下方弹出 */
    right: 10px; /* 对齐右侧的按钮 */
    width: 160px; /* 核心改动：固定宽度，让它成为一个“竖条” */
    background-color: rgba(248, 249, 250, 0.92); /* 使用一个更明亮的背景色 */
    backdrop-filter: blur(12px);
    border-radius: 12px; /* 圆角可以稍微小一点，更显精致 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* 一个更柔和的阴影 */
    z-index: 100;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.08);
}

.chat-option-item {
    display: flex;
    align-items: center;
    padding: 10px 15px; /* 减少一点垂直内边距，让菜单更紧凑 */
    cursor: pointer;
    font-size: 14px; /* 字体也可以稍微小一点 */
    color: var(--text-gray);
    transition: background-color 0.2s; /* 添加一个过渡效果 */
}

.chat-option-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

.chat-option-item i {
    margin-right: 12px;
    color: var(--text-gray);
    width: 20px; /* 固定图标宽度，让文字对齐 */
    text-align: center;
}

.chat-option-divider {
    height: 1px;
    background-color: var(--border-color);
    margin: 4px 10px; /* 分割线也调整一下边距 */
}
/* --- ▼▼▼ 把这段新代码粘贴到 <style> 标签里 --- */
.collapsible-title {
    cursor: pointer; /* 鼠标悬浮时显示为小手形状 */
    display: flex; /* 使用flex布局，让标题和箭头能在一行显示 */
    justify-content: space-between; /* 让标题在左，箭头在右 */
    align-items: center;
}

.collapsible-title .collapse-icon {
    transition: transform 0.2s ease-in-out; /* 让箭头旋转有动画效果 */
    font-size: 14px;
}

.collapsible-title.collapsed .collapse-icon {
    transform: rotate(-90deg); /* 折叠时，箭头旋转-90度 */
}
/* --- ▲▲▲ 粘贴到这里结束 --- */
/* --- 新增：史莱姆随机表情 --- */
/* 移除默认眼睛，为新表情做准备 */
.slime.expression-happy::before, .slime.expression-happy::after,
.slime.expression-sad::before, .slime.expression-sad::after,
.slime.expression-annoyed::before, .slime.expression-annoyed::after,
.slime.expression-shocked::before, .slime.expression-shocked::after {
    background: none; /* 隐藏原来的黑点背景 */
    font-weight: bold;
    font-size: 12px;
    line-height: 1;
    color: #212121; /* 统一设为深灰色 */
}

/* 1. 开心表情 ^_^ */
.slime.expression-happy::before,
.slime.expression-happy::after {
    content: '^';
    top: 18px;
}

/* 2. 难过表情 T_T */
.slime.expression-sad::before,
.slime.expression-sad::after {
    content: 'T';
    top: 18px;
    color: #4285F4; /* 来点蓝色眼泪 */
}

/* 3. 生气/不爽表情 >_< */
.slime.expression-annoyed::before {
    content: '>';
    transform: rotate(-15deg);
    top: 18px;
    left: 18px;
}
.slime.expression-annoyed::after {
    content: '<';
    transform: rotate(15deg);
    top: 18px;
    right: 18px;
}

/* 4. 震惊表情 o_o */
.slime.expression-shocked::before,
.slime.expression-shocked::after {
    content: ''; /* 恢复为空，我们用边框画圆 */
    width: 8px;
    height: 8px;
    border: 2px solid #212121; /* 用边框画一个空心圆 */
    background: white; /* 中间是白色的 */
}
/* --- 新增：更多可爱表情 --- */

/* 1. 开心满足 (u u) */
.slime.expression-pleased::before,
.slime.expression-pleased::after {
    content: 'u';
    font-size: 13px; /* 字体尺寸可以微调 */
    top: 18px;
    font-weight: 600; /* 加粗一点更明显 */
    color: #333;
    background: none;
}

/* 2. 晕乎乎 (x x) */
.slime.expression-dizzy::before,
.slime.expression-dizzy::after {
    content: '×'; /* 使用乘号 × 比字母 x 更好看 */
    font-size: 14px;
    top: 17px;
    font-weight: 600;
    color: #555;
    background: none;
}

/* 3. 无语/怀疑 (- .) */
.slime.expression-doubtful::before {
    content: '';
    width: 10px; /* 横线宽度 */
    height: 3px;  /* 横线厚度 */
    background: #212121;
    border-radius: 2px; /* 让横线两端圆润 */
    top: 20px;
    left: 10px;
}
.slime.expression-doubtful::after {
    /* 右眼还是一个点 */
    content: '';
    width: 7px;
    height: 7px;
    background-color: #212121;
    border-radius: 50%;
    top: 15px;
    right: 12px;
}
/* --- 新增：嘴巴的基础样式和“猫猫嘴”表情 --- */

/* 1. 嘴巴的基础样式 (定位和默认隐藏) */
.slime .mouth {
    position: absolute;
    bottom: 8px; /* 嘴巴在底部偏上一点的位置 */
    left: 50%;
    transform: translateX(-50%); /* 水平居中 */
    width: 0;
    height: 0;
    transition: all 0.3s ease; /* 让表情变化更平滑 */
}

/* 2. 可爱的猫猫嘴 (owo) 表情 */
.slime.expression-cat-face::before,
.slime.expression-cat-face::after {
    /* 眼睛是两个空心圆圈 'o' */
    content: '';
    width: 9px;
    height: 9px;
    border: 2px solid #212121;
    background: white;
    border-radius: 50%;
    top: 14px;
}
/* 用边框“画”一个 'w' 形的嘴巴 */
.slime.expression-cat-face .mouth {
    width: 14px;
    height: 7px;
    border-radius: 0 0 10px 10px / 0 0 6px 6px;
    border: 3px solid #212121;
    border-top: none;
    border-left: 2px solid transparent; /* 用透明边框切出豁口 */
    border-right: 2px solid transparent;
    box-sizing: border-box;
}
/* --- 新增：联系人列表的删除按钮样式 --- */
.contact-delete-btn {
    color: #b0b0b0; /* 默认灰色，不显眼 */
    margin-bottom: 6px; /* 在按钮和下方的时间/未读数之间创建一些间距 */
    cursor: pointer;
    font-size: 10px; /* 图标大小 */
    padding: 5px 8px; /* 增加可点击区域，防止误触 */
    transition: color 0.2s ease;
    display: block; /* 确保按钮在时间的上方 */
    text-align: right; /* 确保图标在容器内是右对齐的 */
}

.contact-delete-btn:hover {
    color: var(--soft-red); /* 鼠标悬浮时变为醒目的红色 */
}
/* --- 新增：用于隐藏AI发送的HTML消息的气泡和头像 --- */
.message-wrapper.ai-html-message .message-avatar,
.message-wrapper.ai-html-message .message-author-name,
.message-wrapper.ai-html-message .message-timestamp {
    display: none !important; /* 彻底隐藏头像、名字和时间戳 */
}
/* --- 新增：热搜话题描述框样式 --- */
#trending-topic-description-container {
    background-color: #e8f5e9; /* 一个淡淡的背景色 */
    padding: 15px;
    margin: 10px; /* 与列表和边缘保持距离 */
    border-radius: var(--soft-radius); /* 使用已有的圆角变量 */
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-dark);
    border: 1px solid var(--border-color);
}
/* --- 新增：地图功能样式 --- */
#map-grid-container {
    position: relative; /* 这个很重要，让后面的图标能相对于它定位 */
    width: 1000px;      /* <--- 新增：给地图一个固定的宽度 */
    height: 1000px;     /* <--- 新增：给地图一个固定的高度 */
    background-color: #e8f5e9; /* 新增：给个底色，防止意外透明 */
    overflow: hidden;   /* 新增：防止图标被拖到地图外面 */
    cursor: crosshair;  /* 新增：鼠标放上去时变成十字准星，更像编辑器 */
    background-image:
        linear-gradient(rgba(129, 199, 132, 0.3) 1px, transparent 1px),
        linear-gradient(90deg, rgba(129, 199, 132, 0.3) 1px, transparent 1px);
    background-size: 20px 20px;
}

.map-icon {
    position: absolute;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    cursor: pointer;
    font-size: 16px;
    transition: transform 0.2s, background-color 0.2s;
    border: 2px solid white;
}
.map-icon:hover {
    transform: scale(1.2);
    background-color: white;
}
.map-icon-label {
    position: absolute;
    bottom: -20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0,0,0,0.7);
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    pointer-events: none; /* 让标签不影响点击图标 */
    opacity: 0;
    transition: opacity 0.2s;
}
.map-icon:hover .map-icon-label {
    opacity: 1;
}
/* --- 新增：地图编辑器中轴线 --- */
#map-grid-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%; /* 水平居中 */
    width: 1px; /* 线的宽度 */
    height: 100%; /* 线的高度 */
    background-color: rgba(255, 0, 0, 0.4); /* 半透明红色，很醒目 */
    z-index: 1; /* 确保它在网格之上，但在图标之下 */
    pointer-events: none; /* 让这条线不会影响你点击图标 */
}

#map-grid-container::after {
    content: '';
    position: absolute;
    left: 0;
    top: 50%; /* 垂直居中 */
    width: 100%; /* 线的宽度 */
    height: 1px; /* 线的高度 */
    background-color: rgba(255, 0, 0, 0.4); /* 半透明红色 */
    z-index: 1; /* 确保它在网格之上，但在图标之下 */
    pointer-events: none; /* 让这条线不会影响你点击图标 */
}
/* --- 新增：分级地点样式 --- */
.map-icon.tier-1 {
    width: 40px;
    height: 40px;
    font-size: 20px;
    border-width: 3px;
    z-index: 10; /* 让一级地点永远在最上层 */
}

/* 修改后的通用图标大小 */
.map-icon.tier-2 {
    width: 36px;
    height: 36px;
    font-size: 18px;
    z-index: 5;
    border-radius: 50%; /* 确保是圆的 */
    background-color: white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15); /* 加点阴影更有质感 */
}

.map-icon.tier-3 {
    width: 22px;
    height: 22px;
    font-size: 12px;
    z-index: 2; /* 让三级地点在最下层 */
}

/* 鼠标悬浮时，统一放大，体验更好 */
.map-icon.tier-1:hover { transform: scale(1.2); }
.map-icon.tier-2:hover { transform: scale(1.3); }
.map-icon.tier-3:hover { transform: scale(1.4); }
.message.location-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 250px;
    padding: 12px;
    border-radius: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
}
.location-card-icon {
    font-size: 24px;
    color: var(--theme-primary);
    flex-shrink: 0;
}
.location-card-info .name {
    font-weight: 600;
    font-size: 15px;
}
.location-card-info .footer {
    font-size: 12px;
    color: #999;
    margin-top: 4px;
}
/* --- 新增：联系人列表的操作按钮和菜单样式 --- */
.contact-options-btn {
    color: #b0b0b0;
    cursor: pointer;
    padding: 5px 10px;
    font-size: 16px;
    margin-right: -5px;
    margin-bottom: 4px;
    display: block;
}
.contact-options-btn:hover {
    color: var(--theme-primary);
}
#contact-item-menu {
    background-color: rgba(248, 249, 250, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.08);
    overflow: hidden;
    width: 200px;
}
#contact-item-menu .menu-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    font-size: 14px;
    color: var(--text-dark);
}
#contact-item-menu .menu-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
#contact-item-menu .menu-item i {
    margin-right: 12px;
    color: var(--text-gray);
    width: 20px;
    text-align: center;
}
/* ========================================================== */
/* V-Final 新增: 锁屏界面 (V3.0 最终样式版) */
/* ========================================================== */
#lock-screen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* 顶部和底部分离，中间留白 */
    color: white;
    font-family: var(--main-font, 'Nunito', sans-serif);
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease, visibility 0.5s;
    padding: 20px; /* 给整个屏幕一个内边距 */
}

#lock-screen.hidden {
    opacity: 0;
    visibility: hidden;
}

.lock-screen-background {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    /* 背景图被移除了，会由JS动态添加 */
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
    filter: blur(8px);
    transform: scale(1.1);
    z-index: -1;
}

#lock-screen::before {
    content: '';
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.35);
    z-index: -1;
}

.lock-screen-body {
    display: flex;
    flex-direction: column;
    gap: 15px; /* 行与行之间的间距 */
}

.widget-row {
    display: flex;
    gap: 15px;
}

.lock-block {
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px S15px rgba(0,0,0,0.1);
    padding: 15px;
}

.photo-block {
    flex: 1.3;
    min-height: 250px;
    /* ▼▼▼ 在这里添加下面三行 ▼▼▼ */
    background-size: contain;     /* 核心：保证图片完整显示 */
    background-position: center;  /* 图片在区块内居中 */
    background-repeat: no-repeat; /* 防止图片平铺重复 */
}
.right-column {
    flex: 1; /* 窄一点 */
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.right-column .widget {
    flex: 1; /* 均分高度 */
}

/* 第二行布局 */
#lock-screen-time-widget { flex: 1; }
#lock-screen-music-widget { flex: 1.3; }

/* 第三行布局 */
#lock-screen-notification-widget {
    width: 100%;
    flex-direction: row;
    align-items: center;
    gap: 12px;
    font-size: 15px; /* 稍微增大字体 */
    opacity: 0.9;
    min-height: 50px; /* 新增：增加最小高度 */
    padding: 0 15px;  /* 新增：增加左右内边距 */
    overflow: hidden; /* 新增：隐藏滚出边界的文字 */
}

.lock-screen-footer {
    text-align: center;
    font-size: 14px;
    opacity: 0.8;
    padding: 10px 0;
}

/* 组件内部样式 */
.widget { display: flex; flex-direction: column; }
.widget-header { font-size: 14px; font-weight: 600; color: rgba(255, 255, 255, 0.8); margin-bottom: 8px; padding-bottom: 5px; border-bottom: 1px solid rgba(255, 255, 255, 0.2); }
.widget-header i { margin-right: 6px; }
.widget-content { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; }
.memo-content { font-size: 15px; line-height: 1.6; cursor: pointer; justify-content: flex-start; overflow-y: auto; }
.countdown-content { text-align: center; }
.countdown-days { font-size: 36px; font-weight: 700; }
.countdown-label { font-size: 13px; color: rgba(255, 255, 255, 0.8); margin-top: 4px; }
.placeholder-text { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; color: rgba(255, 255, 255, 0.7); }
#lock-screen-time-widget { font-weight: 600; text-align: center; font-size: 42px; line-height: 1.2; }
#lock-screen-date { font-size: 14px; opacity: 0.8; font-weight: normal; }
.music-content { text-align: center; }
#lock-screen-song-info { font-size: 14px; opacity: 0.9; }
.music-controls { margin-top: 10px; display: flex; justify-content: center; align-items: center; gap: 25px; font-size: 20px;}
.music-controls i { cursor: pointer; }
/* --- 新增：为置顶按钮添加激活样式 --- */
.pin-event-btn.active {
    color: var(--theme-primary); /* 使用主题绿色作为激活颜色 */
}
/* ========================================================== */
/* V-Final 新增: 锁屏消息滚动条动画 (V3-图标分离版) */
/* ========================================================== */
#lock-screen-notification-widget {
    width: 100%;
    min-height: 50px;
    padding: 0 15px;
    display: flex; /* 使用flex布局让图标和文字容器并排 */
    align-items: center; /* 垂直居中 */
    gap: 12px;
    font-size: 15px;
    opacity: 0.9;
}

#lock-screen-notification-widget > i {
    opacity: 0.8; /* 图标稍微淡一点 */
}

/* 这是新的滚动“轨道”，负责隐藏超出部分的文字 */
.notification-scroll-wrapper {
    flex-grow: 1; /* 占据剩余的所有宽度 */
    height: 1.5em; /* 限定滚动区域的高度为大约一行文字的高度 */
    overflow: hidden; /* 隐藏超出这个区域的文字 */
    position: relative;
}

/* 这是真正滚动的文字容器 */
#lock-screen-notification-text {
    position: absolute;
    width: 100%;
    animation-name: vertical-scroll;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    transform: translateY(100%); /* 默认位置在轨道下方 */
}

#lock-screen-notification-text div {
    padding-bottom: 20px;
    white-space: nowrap;
}

@keyframes vertical-scroll {
    from {
        transform: translateY(100%);
    }
    to {
        transform: translateY(-100%);
    }
}
/* --- 新的心声面板样式 (猫咪主题 - 硬编码颜色版) --- */
#heart-voice-panel {
    position: absolute;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 280px;
    background-color: #FFFBF5; /* 直接使用颜色 */
    border-radius: 16px;
    border: 2px solid #EAD9D5; /* 直接使用颜色 */
    box-shadow: 4px 4px 0px #EAD9D5; /* 直接使用颜色 */
    display: none;
    flex-direction: column;
    gap: 14px;
    padding: 18px 20px;
    z-index: 100;
}

.hv-item {
    display: flex;
    align-items: flex-start;
    font-size: 14px;
    padding-bottom: 12px;
    border-bottom: 1px dashed #EAD9D5; /* 直接使用颜色 */
}

.hv-item:last-child {
    border-bottom: none;
    padding-bottom: 0;
}

.hv-icon {
    font-size: 18px;
    margin-right: 12px;
    width: 20px;
    text-align: center;
    margin-top: -2px;
}

.hv-label {
    font-weight: 600;
    color: #7D6C65; /* 直接使用颜色 */
    flex-shrink: 0;
}

.hv-value {
    color: #A28F88; /* 直接使用颜色 */
    margin-left: 8px;
    line-height: 1.5;
}

#hv-jealousy {
    color: #FFB347; /* 直接使用颜色 */
    font-size: 16px;
    font-weight: bold;
    letter-spacing: 2px;
}
/* --- 新样式结束 --- */
/* --- 新增：为自动提取的标题和摘要添加样式 --- */
.post-item h3 {
    margin-top: 0;
    margin-bottom: 10px; /* 标题和摘要之间的间距 */
    font-size: 18px;     /* 标题字号 */
    font-weight: 600;    /* 标题加粗 */
    line-height: 1.4;
}

.post-summary {
    font-size: 15px;
    color: #666;        /* 摘要文字颜色 */
    margin: 0;
    /* 以下三行用于摘要文字过多时，显示省略号 */
    display: -webkit-box;
    -webkit-line-clamp: 2; /* 最多显示2行 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
/* --- 新增/修改：作者与时间戳同行并两端对齐的样式 --- */

/* 这是新的容器样式 */
.post-card-meta-line {
    display: flex;                /* 启用 Flex 布局 */
    justify-content: space-between; /* 核心：让内部元素两端对齐 */
    align-items: center;          /* 垂直居中，防止高低不平 */
    margin: 12px 0;               /* 保持和上下元素的间距 */
}

/* 这是修改后的作者信息样式 */
.post-author-info {
    font-size: 14px;
    color: #888;
    margin: 0; /* 移除它自己的上下边距，交给父容器管理 */
}

/* 确保时间戳本身也没有多余的边距 */
.post-item .post-meta {
    margin: 0;
}
/* 新增的代码 */
.diary-entry.selected {
    background-color: #bde0fe; /* 选中后变成淡蓝色 */
}
.diary-select-checkbox {
    margin-right: 15px; /* 复选框和文字之间留点空隙 */
    transform: scale(1.3); /* 把复选框放大一点，方便点击 */
}
/* --- 新增：被窥探App内容的独立页面样式 --- */
#snooped-app-content-screen {
    position: absolute; /* 使其能覆盖整个屏幕 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f0f2f5; /* 背景色可以根据喜好调整 */
    display: none; /* 默认隐藏 */
    flex-direction: column; /* 垂直布局：顶部栏 + 内容区 */
}

/* 内容区域样式调整 (可以复用或微调 .api-content) */
#snooped-app-content-body {
    flex-grow: 1; /* 占据剩余所有空间 */
    overflow-y: auto; /* 内容过多时可滚动 */
    padding: 10px; /* 内边距 */
}
/* --- 修改后：模仿微信聊天气泡的【微信专属】样式 --- */

.snoop-wechat-chat-container { /* <--- 类名已修改 */
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
    background-color: #ebebeb; /* 聊天背景色 */
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    margin-bottom: 20px;
}

.snoop-wechat-header { /* <--- 类名已修改 */
    padding: 8px 12px;
    background-color: #f7f7f7;
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;
    text-align: center;
}
.snoop-wechat-header .contact-name { /* <--- 类名已修改 */
    font-size: 14px;
    font-weight: 600;
    color: #111;
}

.snoop-wechat-area { /* <--- 类名已修改 */
    flex-grow: 1;
    overflow-y: auto;
    padding: 8px;
    max-height: 50vh;
}
.snoop-wechat-area::-webkit-scrollbar { /* <--- 类名已修改 */
    width: 3px;
}
.snoop-wechat-area::-webkit-scrollbar-thumb { /* <--- 类名已修改 */
    background: #dcdcdc;
    border-radius: 2px;
}

.snoop-wechat-timestamp { /* <--- 类名已修改 */
    text-align: center;
    margin: 8px 0;
}
.snoop-wechat-timestamp span { /* <--- 类名已修改 */
    background-color: #dcdcdc;
    color: #fff;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 4px;
}

.snoop-wechat-row { /* <--- 类名已修改 */
    display: flex;
    margin-bottom: 10px;
    max-width: 85%;
}
.snoop-wechat-row.sent { /* <--- 类名已修改 */
    justify-content: flex-end;
    margin-left: auto;
}
.snoop-wechat-row.received { /* <--- 类名已修改 */
    justify-content: flex-start;
    margin-right: auto;
}

.snoop-wechat-bubble { /* <--- 类名已修改 */
    padding: 6px 9px;
    border-radius: 6px;
    font-size: 13px;
    line-height: 1.5;
    word-wrap: break-word;
    word-break: break-all;
}

.snoop-wechat-bubble.received { /* <--- 类名已修改 */
    background-color: #fff;
    color: #111;
}
.snoop-wechat-bubble.sent { /* <--- 类名已修改 */
    background-color: #95ec69; /* 微信绿色气泡 */
    color: #111;
}
/* --- 微信专属样式结束 --- */
/* --- 扩大顶栏右上角按钮的触摸范围 --- */
.app-header .action-btn,
.chat-header .action-btn,
.world-book-header .action-btn,
.api-header .action-btn, /* 假设API header右侧按钮也用了action-btn */
.moments-header .action-btn,
.preset-management-screen .api-header .action-btn { /* 包括预设管理页面的+按钮 */
    /* 增加内边距，上下左右各加 10px */
    padding: 10px;

    /* 为了抵消padding增加的空间，防止布局错乱，
       同时使用等值的负外边距把它“拉回来” */
    margin: -10px;

    /* 如果按钮之间原本有左右margin，可能需要微调这里的负margin值
       或者在下面的规则里稍微调整按钮间的间距 */
}

/* （可选）如果上面的修改导致按钮挤在一起，可以微调按钮之间的间距 */
.header-actions .action-btn,
.app-header > div:last-child .action-btn {
    /* 稍微增加一点左边距，让按钮之间分开点 */
    margin-left: 5px;
    /* 抵消上面设置的水平方向负外边距 */
     margin-right: -10px;
     margin-top: -10px;
     margin-bottom: -10px;
}

/* 确保按钮的容器有足够空间 */
.app-header > div:last-child,
.chat-header > div:last-child,
.world-book-header > div,
.api-header > div:last-child,
.moments-header .header-actions {
     /* 可能需要给容器加一点右内边距，防止按钮被挤出屏幕 */
     /* padding-right: 5px; */
}
/* --- 新增：模仿 iOS/Android 原生短信气泡样式 --- */

/* 1. 聊天区域背景改为白色 */
.snoop-sms-area {
    background-color: #ffffff; /* 白色背景 */
    padding: 10px; /* 稍微增加内边距 */
}

/* 2. 气泡基础样式：更大的圆角 */
.snoop-sms-bubble {
    padding: 8px 12px; /* 调整内边距 */
    border-radius: 18px; /* 更圆的圆角，形成胶囊状 */
    max-width: 80%; /* 限制最大宽度，防止气泡过长 */
    line-height: 1.4; /* 调整行高，让文字更舒适 */
    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05); /* 添加非常细微的阴影增加质感 */
}

/* 3. 收到的消息气泡 (左侧，灰色) */
.snoop-sms-bubble.received {
    background-color: #E5E5EA; /* iOS 系统灰色 */
    color: #000000; /* 黑色文字 */
}

/* 4. 发送的消息气泡 (右侧，蓝色) */
.snoop-sms-bubble.sent {
    background-color: #0B81FF; /* iOS 系统蓝色 (比默认#007AFF稍亮一点) */
    color: #ffffff; /* 白色文字 */
}

/* 5. 时间戳样式：居中，灰色小字，无背景 */
.snoop-sms-timestamp span {
    background-color: transparent; /* 去掉背景 */
    color: #8A8A8E; /* iOS 时间戳灰色 */
    font-size: 11px; /* 调小字号 */
    padding: 0; /* 去掉内边距 */
    border-radius: 0; /* 去掉圆角 */
}
.snoop-sms-timestamp {
    text-align: center;
    margin: 15px 0 10px; /* 调整时间戳的上下间距 */
}

/* 6. (可选) 简化顶部标题栏，更接近原生风格 */
.snoop-sms-header {
    background-color: #f8f8f8; /* 非常浅的灰色背景 */
    border-bottom: 1px solid #dcdcdc; /* 稍浅的边框线 */
    padding: 10px 15px; /* 调整内边距 */
}
.snoop-sms-header .contact-name {
     font-size: 16px; /* 稍微增大字号 */
     font-weight: 600; /* 加粗 */
     color: #000; /* 黑色标题 */
}

/* 7. (可选) 调整消息行间距 */
.snoop-sms-row {
    margin-bottom: 8px; /* 稍微减小消息之间的垂直间距 */
}

/* --- iOS/Android 原生短信样式结束 --- */
/* --- 确保这段短信【行布局】样式存在且正确 --- */

.snoop-sms-row { /* 检查这个类名是否正确 */
    display: flex;       /* 必须是 flex 才能让气泡正确排列 */
    margin-bottom: 10px; /* 控制行间距 */
    max-width: 85%;      /* 限制整行的最大宽度 */
}
.snoop-sms-row.sent { /* 检查这个类名是否正确 */
    justify-content: flex-end; /* 让发送的气泡内容靠右 */
    margin-left: auto;         /* 整行靠右 */
}
.snoop-sms-row.received { /* 检查这个类名是否正确 */
    justify-content: flex-start; /* 让接收的气泡内容靠左 */
    margin-right: auto;        /* 整行靠左 */
}
/* --- 短信行布局样式结束 --- */
/* --- 新增：窥探模式照片图标样式 V5 (两列，文字悬浮) --- */

.snoop-photo-grid {
    display: grid;
    /* 每行显示 2 个图标 */
    grid-template-columns: repeat(2, 1fr);
    gap: 5px; /* 图标之间的间距 */
    column-gap: 5px;
    padding: 5px; /* 网格区域的内边距 */
}

.snoop-photo-item-container {
    position: relative; /* 让详情文字能相对于它定位 */
    display: flex;
    justify-content: center; /* 图标水平居中 */
}

.snoop-photo-item {
    width: 150px; /* 图标背景宽度 (增大) */
    height: 200px; /* 图标背景高度 (增大) */
    background-color: rgba(255, 255, 255, 0.8); /* 半透明白色背景 */
    backdrop-filter: blur(5px); /* 背景模糊效果 */
    border-radius: 18px; /* 更大的圆角 */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
    box-shadow: 0 3px 8px rgba(0,0,0,0.1); /* 添加一点阴影 */
    overflow: hidden; /* 防止内部元素溢出 */
}

.snoop-photo-item:hover {
    transform: scale(1.05) translateY(-3px); /* 悬浮时放大上移 */
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.snoop-photo-item i {
    font-size: 48px; /* 图标大小 (增大) */
    color: #55758a; /* 图标颜色 (更柔和) */
    opacity: 0.8;
}

.snoop-photo-details {
    display: none;
    position: absolute;
    bottom: 10px; /* 仍然定位在容器底部偏上 */
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 10px); /* 宽度仍然比容器窄一点 */
    max-width: 140px;        /* 最大宽度也稍微小于图标 (图标是120px) */
    /* --- 核心修改在这里 --- */
    height: 190px;           /* 设置一个固定的高度 (比图标120px略小) */
    overflow-y: auto;        /* 当内容超出高度时，允许垂直滚动 */
    /* --- 修改结束 --- */
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(8px);
    color: #ffffff;
    border-radius: 10px;
    padding: 8px 10px; /* 稍微减小一点内边距，给滚动条留空间 */
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    font-size: 13px;
    line-height: 1.5;
    word-wrap: break-word;
    word-break: break-all;
    z-index: 10;
    pointer-events: auto; /* 改回 auto，允许用户滚动 */
}

.snoop-photo-details p {
    margin: 0 0 6px 0;
}
.snoop-photo-details p:last-child {
    margin-bottom: 0;
}

/* 当details可见时应用的样式 */
.snoop-photo-details.visible {
    display: block;
    /* 动画：从下方轻微弹出并淡入 */
    animation: popUpDetails 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes popUpDetails {
    from { opacity: 0; transform: translateX(-50%) translateY(10px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* 之前为想法添加的样式 (thoughtStyle)，现在也应用到详情框内部 */
.snoop-photo-details .thought-style-div { /* 使用一个新类名 */
    font-size: 12px; /* 想法文字小一点 */
    color: #dcdcdc; /* 浅灰色文字 */
    background: rgba(255, 255, 255, 0.1); /* 更浅的背景 */
    padding: 6px 10px;
    border-radius: 6px;
    margin-top: 8px;
    border-left: 3px solid rgba(255, 255, 255, 0.3);
}
.snoop-photo-details .thought-style-div.reason-private { /* 私密原因用不同颜色 */
    background: rgba(255, 128, 171, 0.15);
    border-left-color: rgba(255, 128, 171, 0.5);
    color: #ffdde8;
}
/* --- 照片图标样式 V5 结束 --- */
/* --- 新增：窥探模式音乐歌单样式 V5 (模仿截图 + 右侧信息) --- */

.snoop-music-list {
    padding: 0;
}

.snoop-music-item {
    display: flex;
    align-items: center;
    padding: 8px 15px;
    border-bottom: 1px solid #f0f0f0;
    transition: background-color 0.2s;
}

.snoop-music-item:last-child {
    border-bottom: none;
}

.snoop-music-item:hover {
    background-color: rgba(0, 0, 0, 0.04);
}

.snoop-music-index {
    font-size: 14px;
    color: #999;
    width: 30px;
    text-align: center;
    flex-shrink: 0;
    margin-right: 10px;
}

.snoop-music-cover {
    width: 45px;
    height: 45px;
    background-color: #eee;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 12px;
    flex-shrink: 0;
    overflow: hidden;
}
.snoop-music-cover i {
    color: #bbb;
    font-size: 20px;
}

.snoop-music-info {
    flex-grow: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.snoop-music-title {
    font-size: 15px;
    font-weight: 500; /* 可以改为 600 让标题加粗，更容易区分 */
    color: #333;
    /* --- 核心修改：允许换行 --- */
    white-space: normal; /* 允许正常换行 */
    overflow: visible;   /* 内容超出时不隐藏 */
    text-overflow: clip; /* 内容超出时不显示省略号 */
    /* --- 修改结束 --- */
    line-height: 1.4; /* 可以适当增加行高，让多行文字不挤 */
    margin-bottom: 2px; /* 稍微增加和艺术家名字的间距 */
    /* (可选) 限制最多显示两行，超出部分隐藏，防止极端情况 */
    display: -webkit-box;
    -webkit-line-clamp: 2; /* 最多显示 2 行 */
    -webkit-box-orient: vertical;
    overflow: hidden; /* 配合上面三行，隐藏超出部分 */
    text-overflow: ellipsis; /* 超出两行时仍然显示省略号 */
    word-break: break-all; /* 允许在任意字符处换行，防止长英文单词溢出 */
}

.snoop-music-artist {
    font-size: 12px;
    color: #888;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.2;
}

/* --- 新增/修改：右侧元信息样式 --- */
.snoop-music-meta-right {
    margin-left: auto; /* 推到最右侧 */
    padding-left: 10px; /* 和文字之间留空隙 */
    font-size: 11px;    /* 小字号 */
    color: #aaa;       /* 浅灰色 */
    flex-shrink: 0;   /* 防止被压缩 */
    text-align: right;  /* 右对齐 */
    display: flex;      /* 允许内部元素排列 */
    flex-direction: column; /* 垂直排列 */
    align-items: flex-end; /* 右对齐 */
}

.snoop-music-meta-right span {
    white-space: nowrap; /* 防止换行 */
}

/* 如果有时长，平台信息需要换行显示 */
.snoop-music-meta-right .snoop-music-platform.new-line {
    margin-top: 2px; /* 增加一点垂直间距 */
}

.snoop-music-platform {
    font-style: italic; /* 平台名斜体 */
}
/* --- 新增：窥探模式音乐想法样式 --- */

.snoop-music-thought {
    font-size: 11px; /* 比艺术家字体更小 */
    color: #a0a0a0; /* 更浅的灰色 */
    margin-top: 4px; /* 和艺术家之间留点距离 */
    /* (可选) 允许换行并最多显示两行 */
    white-space: normal;
    display: -webkit-box;
    -webkit-line-clamp: 5;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.3;
    font-style: italic; /* 斜体 */
}

/* --- 音乐想法样式结束 --- */
/* --- 音乐歌单样式 V5 结束 --- */
/* --- 银行卡样式 (恢复 V4 渐变版) --- */
.snoop-bank-cards-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    margin-bottom: 20px;
}

.snoop-bank-card {
    /* 使用线性渐变背景 */
    background: linear-gradient(135deg, #f5f7fa, #e0e5ec);
    border-radius: 8px;
    padding: 12px 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    border: 1px solid #d1d9e6; /* 保持一个细边框 */
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    min-height: 80px;
}

.snoop-bank-card-name {
    font-size: 13px;
    color: #555;
    font-weight: 500;
    margin-bottom: 8px;
}

.snoop-bank-card-balance {
    font-size: 18px; /* 余额字体比 V5 略小 */
    font-weight: bold;
    color: #333;
    text-align: right;
}
/* --- 银行卡样式结束 --- */

/* --- 新增：窥探模式资产样式 V6 (表格投资 + 银行流水) --- */

/* 投资列表 V6 样式 */
.snoop-investments-list-v6 {
    background-color: #ffffff; /* 白色背景 */
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    overflow: hidden; /* 隐藏内部边框溢出 */
    margin-bottom: 25px;
}

/* 投资表头 */
.snoop-investment-header-row {
    display: grid;
    /* 定义四列的宽度比例，名称列最宽 */
    grid-template-columns: 2fr 1fr 1fr 1fr;
    background-color: #f7f9fa; /* 浅灰色表头背景 */
    padding: 8px 15px;
    font-size: 11px; /* 表头字号 */
    color: #8899a6; /* 表头颜色 */
    font-weight: 500;
    border-bottom: 1px solid #e1e8ed; /* 表头下边框 */
}
/* 列标题右对齐 */
.snoop-investment-header-row > div:not(:first-child) {
    text-align: right;
}

/* 单个投资项 V6 */
.snoop-investment-item-v6 {
    display: grid;
    grid-template-columns: 2fr 1fr 1fr 1fr; /* 与表头一致的列宽 */
    padding: 10px 15px;
    border-bottom: 1px solid #f0f0f0; /* 项之间的分隔线 */
    font-size: 13px; /* 统一基础字号 */
    align-items: center; /* 垂直居中 */
}
.snoop-investment-item-v6:last-child {
    border-bottom: none; /* 最后一项无分隔线 */
}

/* 投资项 - 名称/金额列 */
.inv-col-name {
    display: flex;
    flex-direction: column; /* 垂直排列 */
}
.inv-name {
    font-weight: 600; /* 名称加粗 */
    color: #222;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.3;
}
.inv-type {
    font-size: 10px;
    color: #667;
    margin-left: 4px; /* 类型和名称间距 */
}
.inv-value {
    font-size: 11px;
    color: #778;
    margin-top: 1px;
}
.inv-percentage {
    font-size: 10px;
    color: #99a;
    margin-top: 1px;
}

/* 投资项 - 收益列 (统一右对齐) */
.inv-col-daily,
.inv-col-holding,
.inv-col-cumulative {
    text-align: right;
    font-weight: 600; /* 收益数字加粗 */
    font-size: 13px; /* 统一字号 */
}
/* 盈亏颜色 */
.profit { color: #f44336; } /* 红涨 */
.loss { color: #4caf50; } /* 绿跌 */
.neutral { color: #757575; } /* 灰色 */

/* 交易流水列表 V6 样式 */
.snoop-transactions-list-v6 {
    display: flex;
    flex-direction: column;
    /* 移除 gap，边框作为分隔 */
    background-color: #ffffff; /* 背景 */
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    overflow: hidden; /* 隐藏内部边框溢出 */
}

/* 单条交易流水 V6 */
.snoop-transaction-item-v6 {
    display: flex; /* 横向布局 */
    justify-content: space-between; /* 两端对齐 */
    align-items: center; /* 垂直居中 */
    padding: 12px 15px; /* 内边距 */
    border-bottom: 1px solid #f0f0f0; /* 分隔线 */
}
.snoop-transaction-item-v6:last-child {
    border-bottom: none;
}

/* 流水左侧信息区 */
.tx-left {
    display: flex;
    flex-direction: column; /* 上下排列 */
    min-width: 0; /* 防止内容溢出 */
    margin-right: 15px; /* 和右侧金额留空隙 */
}
.tx-desc {
    font-size: 14px; /* 主要描述字号 */
    color: #222; /* 主要颜色 */
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 单行省略 */
    margin-bottom: 3px;
}
.tx-subdesc {
    font-size: 11px; /* 次要信息字号 */
    color: #999; /* 灰色 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 单行省略 */
}

/* 流水右侧金额区 */
.tx-amount {
    font-size: 16px; /* 金额字号 */
    font-weight: bold; /* 加粗 */
    flex-shrink: 0; /* 防止被压缩 */
    white-space: nowrap; /* 防止金额换行 */
}
.tx-amount.income { color: #f44336; } /* 收入红色 */
.tx-amount.expense { color: #4caf50; } /* 支出绿色 */
.tx-amount.expense::before { content: "-"; } /* 支出自动加负号 */
.tx-amount.income::before { content: "+"; } /* 收入自动加正号 */

/* --- 资产样式 V6 结束 --- */
/* ========================================================== */
/* ▼▼▼ 新增：短信聊天界面专属样式 (模仿窥探模式) ▼▼▼ */
/* ========================================================== */

/* 1. 短信聊天区域背景 (已在HTML的style中设置，这里留空备用) */
#sms-chat-messages {
    /* background-color: #ffffff; */
    padding: 10px; /* 稍微增加内边距 */
}

/* 2. 短信时间戳样式 (复用窥探模式) */
.sms-timestamp { /* 新类名 */
    text-align: center;
    margin: 15px 0 10px;
}
.sms-timestamp span {
    background-color: transparent;
    color: #8A8A8E; /* iOS 时间戳灰色 */
    font-size: 11px;
    padding: 0;
    border-radius: 0;
}

/* 3. 短信消息行布局 (复用窥探模式，注意类名修改) */
.sms-row { /* 新类名 */
    display: flex;
    margin-bottom: 8px;
    max-width: 85%;
}
.sms-row.sent {
    justify-content: flex-end;
    margin-left: auto;
}
.sms-row.received {
    justify-content: flex-start;
    margin-right: auto;
}

/* 4. 短信气泡样式 (复用窥探模式，注意类名修改) */
.sms-bubble { /* 新类名 */
    padding: 8px 12px;
    border-radius: 18px; /* 更圆的圆角 */
    max-width: 100%; /* 让气泡自己决定宽度，由 .sms-row 控制最大宽度 */
    line-height: 1.4;
    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
    word-wrap: break-word;
    word-break: break-all;
    font-size: 15px; /* 可以根据喜好调整字号 */
}
.sms-bubble.received {
    background-color: #E5E5EA; /* iOS 系统灰色 */
    color: #000000;
}
.sms-bubble.sent {
    background-color: #0B81FF; /* iOS 系统蓝色 */
    color: #ffffff;
}

/* 5. 短信图片样式 (简化版) */
.sms-bubble.image-message {
    padding: 0;
    background-color: transparent;
    box-shadow: none;
    max-width: 150px; /* 限制图片最大宽度 */
    overflow: hidden; /* 图片超出圆角部分隐藏 */
}
.sms-image {
    display: block; /* 消除图片下方的空隙 */
    max-width: 100%;
    height: auto;
    border-radius: 16px; /* 给图片也加上圆角 */
}

/* (可选) 短信输入区域微调 */
#sms-input-area {
    border-top: 1px solid #dcdcdc; /* 顶部边框线 */
}
#sms-message-input {
    /* ... 你可能已有的样式，比如 background-color, border ... */
    flex-grow: 1; /* 占据尽可能多的空间 */
    border-radius: 20px;
    padding: 8px 15px;
    font-size: 15px; /* 和主聊天输入框一致 */
    outline: none;
    resize: none; /* 禁止用户手动拖动调整大小 */
    overflow-y: auto; /* 内容超出时显示滚动条 */
    max-height: 100px; /* 最大高度，比如 100px */
    min-height: 38px; /* 最小高度，和主聊天输入框一致 */
    align-self: flex-end; /* 垂直方向底部对齐 */
    /* 确保背景色和边框符合短信风格 */
    background-color: white;
    border: 1px solid #dcdcdc;
}
/* --- 新增：模仿 iOS 原生短信顶栏样式 --- */
#sms-chat-screen .app-header {
    background-color: #f7f7f7; /* 非常浅的灰色背景 */
    backdrop-filter: none; /* 移除模糊效果 */
    color: #000000; /* 标题文字改为黑色 */
    border-bottom: 1px solid #dcdcdc; /* 添加底部细线 */
    box-shadow: none; /* 移除阴影 */
}

/* (可选) 让返回按钮也变成黑色 */
#sms-chat-screen .app-header .back-btn i {
    color: #000000;
}
/* --- 新增：短信编辑模式样式 --- */

/* 标记被选中的短信行 */
#sms-chat-messages .sms-row.selected {
    background-color: #e0f2fe; /* 淡蓝色背景 */
    border-radius: 8px; /* 加点圆角 */
}

/* 当进入编辑模式时，隐藏输入框，显示编辑栏 */
#sms-chat-screen.sms-edit-mode #sms-input-area {
    display: none;
}
#sms-chat-screen.sms-edit-mode #sms-edit-mode-bar {
    display: flex !important; /* 改为 flex 以显示 */
}
/* ========================================================== */
/* ▲▲▲ 新增：短信聊天界面专属样式 END ▲▲▲ */
/* ========================================================== */
/* --- 新增：收藏夹页面样式 --- */
#favorites-screen .api-content {
    padding: 10px;
}

.favorite-group-card {
    background-color: #ffffff;
    border-radius: var(--soft-radius);
    box-shadow: 0 2px 8px var(--shadow-color);
    margin-bottom: 15px;
    overflow: hidden; /* 裁剪内部元素的边角 */
}

.favorite-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    background-color: #fcfcfc;
}

.favorite-group-header img {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    margin-right: 10px;
}

.favorite-group-header .name {
    font-weight: 600;
    color: var(--text-dark);
}

/* 收藏的单条消息样式 */
.favorite-item {
    display: flex;
    align-items: flex-start; /* 头像置顶 */
    padding: 15px;
    border-bottom: 1px solid #f0f0f0;
    position: relative;
    transition: background-color 0.2s;
}
.favorite-item:hover {
    background-color: #f9f9f9;
}
.favorite-item:last-child {
    border-bottom: none;
}

.favorite-item-avatar img {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    margin-right: 12px;
}

.favorite-item-content {
    flex-grow: 1;
    padding-right: 30px; /* 为删除按钮留出空间 */
}

.favorite-item-sender {
    font-weight: 500;
    color: var(--theme-primary-hover);
    margin-bottom: 5px;
}

.favorite-item-content .message-content {
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-dark);
    word-wrap: break-word; /* 确保长文本能换行 */
}
/* 收藏内容里的叙事样式 (可选，但推荐) */
.favorite-item-content .message-content .narrative-psychology {
    background-color: #f0f0f0;
    color: #555;
    padding: 1px 4px;
    border-radius: 4px;
}

/* 取消收藏按钮 */
.unfavorite-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 16px;
    color: #aaa;
    cursor: pointer;
    padding: 5px;
}
.unfavorite-btn:hover {
    color: var(--soft-red);
}
/* --- 收藏夹样式 V2 (按次分组版) --- */

.favorite-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    background-color: #fcfcfc;
}

/* 收藏卡片头部的时间戳 */
.favorite-group-header .timestamp {
    font-size: 12px;
    color: var(--text-gray);
    margin-left: auto; /* 推到右边 */
    padding-right: 10px; /* 和删除按钮拉开距离 */
}

/* ✨ 核心修改：删除按钮样式 */
.unfavorite-btn {
    position: static; /* 移除绝对定位 */
    font-size: 18px;  /* 稍微放大 */
    color: #bbb;     /* 默认更灰 */
    cursor: pointer;
    padding: 5px;
    margin-left: 5px; /* V2 新增 */
}
.unfavorite-btn:hover {
    color: var(--soft-red);
}

/* (这个不用动，保持原样) */
.favorite-item-content .message-content {
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-dark);
    word-wrap: break-word; 
}
/* ✨ 核心修改：移除单个消息的删除按钮 */
.favorite-item .unfavorite-btn {
    display: none; /* 隐藏掉消息条目内部的旧按钮 */
}
/* --- 聊天记录搜索界面样式 --- */
#chat-search-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f7f7f7; /* 微信风格浅灰背景 */
    z-index: 1100; /* 确保在最上层 */
    display: flex;
    flex-direction: column;
}

.search-header {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    background-color: #fff;
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;
}

.search-input-wrapper {
    flex-grow: 1;
    background-color: #f0f2f5;
    border-radius: 6px;
    padding: 6px 10px;
    display: flex;
    align-items: center;
    margin-right: 10px;
}

.search-icon {
    color: #999;
    margin-right: 8px;
    font-size: 14px;
}

#chat-search-input {
    flex-grow: 1;
    border: none;
    background: transparent;
    font-size: 15px;
    outline: none;
    padding: 0;
}

.clear-search-btn {
    color: #ccc;
    cursor: pointer;
    padding: 5px; /* 增加一点点击范围 */
}

#close-search-btn {
    background: none;
    border: none;
    color: var(--theme-primary); /* 使用主题色 */
    font-size: 16px;
    cursor: pointer;
    padding: 5px 0;
}

#search-results-container {
    flex-grow: 1;
    overflow-y: auto;
    background-color: #fff;
}

.search-placeholder {
    text-align: center;
    color: #999;
    margin-top: 50px;
    font-size: 14px;
}

.search-result-item {
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: background-color 0.2s;
}

.search-result-item:hover {
    background-color: #f9f9f9;
}

.result-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 6px;
    font-size: 13px;
}

.result-sender {
    font-weight: 600;
    color: #333;
}

.result-time {
    color: #bbb;
    font-size: 12px;
}

.result-content {
    font-size: 15px;
    color: #666;
    line-height: 1.4;
    /* 超出两行显示省略号 */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 高亮关键词样式 */
.highlight-keyword {
    color: var(--theme-primary);
    font-weight: bold;
}
/* --- 步骤 2：在气泡旁边添加“撤回”按钮的样式 --- */
.recall-btn {
    position: absolute;
    top: calc(50% + 14px); /* 把它定位到“回复”按钮的下方 14px */
    transform: translateY(-50%); /* 垂直居中（以它自己的top点为基准）*/
    
    background-color: rgba(240, 240, 240, 0.8);
    backdrop-filter: blur(2px);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: var(--soft-red); /* 撤回按钮用醒目的红色 */
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none; /* 隐藏时不可点击 */
}

/* --- 步骤 3：调整一下原来的“回复”按钮，给新按钮腾地方 --- */
.reply-btn {
    top: calc(50% - 14px); /* 把“回复”按钮向上移动 14px */
}

/* --- 步骤 4：当悬浮时，让两个按钮一起显示出来 --- */
.message-wrapper.sent.show-reply-btn .reply-btn,
.message-wrapper.sent.show-reply-btn .recall-btn {
    opacity: 1;
    transform: translateY(-50%) scale(1); /* 恢复原来的动画效果 */
    pointer-events: auto;
}
/* AI发的消息（received）不需要改，它只显示回复按钮 */
.message-wrapper.received.show-reply-btn .reply-btn {
     opacity: 1;
     transform: translateY(-50%) scale(1);
     pointer-events: auto;
}

/* --- 步骤 5：调整两个按钮的悬浮放大效果 --- */
.message-wrapper.sent.show-reply-btn .reply-btn:hover {
     transform: translateY(-50%) scale(1.1) !important;
}
.message-wrapper.sent.show-reply-btn .recall-btn:hover {
     transform: translateY(-50%) scale(1.1) !important;
}
/* --- AI“表演式”撤回消息的样式 (V3 - 统一居中版) --- */

/* 1. 这是“未点开”的占位符样式 (保持不变) */
.system-notification.recall-ai-placeholder {
    background-color: #e0e0e0; 
    color: #888;
    font-style: italic;
    cursor: pointer; 
    user-select: none;
    transition: background-color 0.2s, color 0.2s;
}
.system-notification.recall-ai-placeholder:hover {
    background-color: #d5d5d5;
    color: #555;
}

/* 2. 这是被“点开后”的样式 (新版：居中、带红条) */
.system-notification.recall-ai-revealed {
    background-color: #f5f5f5;      /* 1. 浅灰背景 */
    color: #444;                   /* 2. 正常文字颜色 */
    font-style: normal;             /* 3. 恢复正常字体 */
    cursor: pointer;                /* 4. 保持可点击（为了能关上） */
    text-shadow: none;              /* 5. 确保没有模糊 */
    //border-top: 2px solid var(--soft-red); /* 6. 顶部加个红条 */
    //border-bottom: 2px solid var(--soft-red); /* 7. 底部也加个红条 */
    text-align: center;               /* 8. 内部文字还是左对齐好看 */
    display: inline-block;          /* 9. 让它根据内容自适应宽度 */
    max-width: 80%;                 /* 10. 防止太长 */
    box-sizing: border-box;         /* 11. 确保padding不会撑爆 */
}

/* 3. “点开后”显示的前缀 (新版：目标是新class) */
.system-notification.recall-ai-revealed .recall-prefix {
    font-weight: bold;
    color: var(--soft-red);
    margin-right: 5px;
    text-align: center;
}
/* --- 新增：为“中国红”刮刮乐添加专属样式 --- */
#scratch-grid-display.game-china-red {
    display: flex; /* 改为 flex 布局 */
    flex-direction: column; /* 垂直排列 */
    gap: 15px;
    background-color: #fff; /* 白色底板 */
    border: 2px solid #f44336; /* 红色边框 */
    border-radius: 8px;
    padding: 15px;
}
.china-red-area h3 {
    font-size: 14px;
    color: #333;
    margin: 0 0 8px 0;
    text-align: left;
    padding-bottom: 5px;
    border-bottom: 1px dashed #f44336;
}
.winning-numbers-grid {
    display: flex;
    justify-content: center;
    gap: 15px;
}
.your-numbers-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 你的号码区，一行4个 */
    gap: 8px;
}
.scratch-cell-winner {
    background: #fffbe6; /* 浅黄色背景 */
    border: 2px solid #fdd835; /* 黄色边框 */
    color: #c62828; /* 红色数字 */
    font-weight: bold;
    font-size: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%; /* 圆形 */
    display: flex;
    align-items: center;
    justify-content: center;
}
.scratch-cell-player {
    background: #fce4e4; /* 浅红色背景 */
    border-radius: 6px;
    padding: 5px;
    text-align: center;
    border: 2px solid transparent; /* 默认无边框 */
}
.scratch-cell-player.scratched.match {
    /* ✨ 匹配成功的号码高亮！ ✨ */
    border-color: #f44336;
    background: #fff;
    box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
    transform: scale(1.05);
}
.player-number {
    font-size: 18px;
    font-weight: bold;
    color: #333;
}
.player-prize {
    font-size: 12px;
    color: #c62828;
    font-weight: 500;
}
/* --- 新增：刮刮乐“覆盖层”样式 --- */
.scratch-cell-player.covered {
    background: #bdbdbd; /* 灰色覆盖层 */
    border-color: #9e9e9e;
    cursor: pointer;
    position: relative;
    /* 强制重置 flex 布局，以便居中图标 */
    display: flex !important; 
    align-items: center !important;
    justify-content: center !important;
    transition: transform 0.2s, background-color 0.2s;
}
.scratch-cell-player.covered:hover {
    transform: scale(1.05);
    background: #b0b0b0;
}
/* 隐藏掉所有“内容”元素 */
.scratch-cell-player.covered .player-number,
.scratch-cell-player.covered .player-prize,
.scratch-cell-player.covered .symbol-content,
.scratch-cell-player.covered .cell-content {
    display: none;
}
/* 显示“刮开”图标 */
.scratch-cell-player.covered .scratch-icon {
    display: block;
    font-size: 24px;
    color: rgba(255, 255, 255, 0.7);
}
/* 刮开后（scratched）的状态 */
.scratch-cell-player.scratched {
    cursor: default;
}
/* 刮开后，隐藏图标 */
.scratch-cell-player.scratched .scratch-icon {
    display: none;
}
/* 刮开后，显示内容 */
.scratch-cell-player.scratched .player-number,
.scratch-cell-player.scratched .player-prize,
.scratch-cell-player.scratched .symbol-content,
.scratch-cell-player.scratched .cell-content {
    display: block; /* 显形！*/
}
/* 这个是内容占位符，默认不显示 */
.scratch-icon {
    display: none;
}
/* --- 样式结束 --- */
/* --- 新增：Koko交易所 - 标签页和新闻大屏样式 --- */
#stock-tabs-container .feed-tab-btn {
    font-size: 14px; /* 标签页字小一点 */
    padding: 8px 10px;
}
#stock-tabs-container .feed-tab-btn i {
    margin-right: 4px;
}

#stock-news-feed {
    /* display: flex !important;  <-- 删掉这行 */
    /* flex-direction: column-reverse !important; <-- 删掉这行 */
    background-color: #f7f9fa;
}
.news-item {
    padding: 6px 8px;
    margin-bottom: 4px;
    border-radius: 4px;
    line-height: 1.5;
    animation: fadeIn 0.5s ease; /* 消息淡入动画 */
}
.news-item.positive { /* 利好消息 (涨) */
    background-color: #fce4e4;
    border-left: 3px solid #f44336;
    color: #c62828;
}
.news-item.negative { /* 利空消息 (跌) */
    background-color: #e8f5e9;
    border-left: 3px solid #4caf50;
    color: #2e7d32;
}
.news-item.neutral { /* 中性消息 */
    background-color: #f5f5f5;
    border-left: 3px solid #90a4ae;
    color: #37474f;
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
/* --- 样式结束 --- */
/* --- 新增：论坛帖子的图片样式 --- */
        .post-image-content {
            max-width: 100%; /* 图片最大宽度不超过帖子宽度 */
            max-height: 400px; /* 限制最大高度，防止图片过长 */
            border-radius: 12px;
            margin-top: 10px;
            object-fit: cover; /* 保持图片比例 */
            cursor: zoom-in; /* 提示可以点击（虽然我们还没做大图） */
        }
        /* --- 新增：评论区的图片样式 --- */
        .comment-image-content {
            max-width: 200px; /* 评论区的图小一点 */
            border-radius: 10px;
            margin-top: 8px;
            cursor: zoom-in;
        }
/* --- 新增：转发聊天记录卡片样式 --- */
.message.chat-history-card {
    background-color: #f7f7f7; /* 浅灰色背景 */
    border: 1px solid #e0e0e0;
    width: 260px; /* 固定宽度 */
    padding: 0; /* 移除默认内边距，让内部自己控制 */
    border-radius: 12px;
    overflow: hidden; /* 隐藏内部溢出的圆角 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    cursor: not-allowed; /* 暂时让它不可点击 */
}
.ch-header {
    padding: 10px 15px;
    font-size: 15px;
    font-weight: 600;
    color: var(--text-dark);
    border-bottom: 1px solid #e0e0e0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.ch-body {
    padding: 10px 15px;
    max-height: 200px; /* 限制最大高度，超出可滚动 */
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 4px; /* 消息间的最小间距 */
}
/* 卡片内部的迷你消息条目 */
.ch-item {
    font-size: 13px;
    line-height: 1.5;
    word-wrap: break-word;
}
.ch-sender {
    font-size: 12px;
    color: #888;
    margin-bottom: 2px;
}
.ch-bubble {
    display: inline-block; /* 让气泡自适应内容宽度 */
    max-width: 95%; /* 最大宽度 */
    padding: 6px 10px;
    border-radius: 10px;
}
/* 迷你-收到的气泡 */
.ch-item.received .ch-bubble {
    background-color: #ffffff;
    border-top-left-radius: 2px;
}
/* 迷你-发送的气泡 */
.ch-item.sent {
    align-self: flex-end; /* 自己发的消息靠右 */
    text-align: right;
}
.ch-item.sent .ch-bubble {
    background-color: var(--sent-message-bg, #e6f5c9);
    border-top-right-radius: 2px;
    text-align: left; /* 气泡内的文字还是左对齐 */
}
.ch-footer {
    padding: 6px 15px;
    font-size: 12px;
    color: #aaa;
    border-top: 1px solid #e8e8e8;
    background-color: #fdfdfd;
}
/* --- V-Final 新增: “我们的日子”精致卡片样式 --- */

/* 1. 让 #events-content-list 成为卡片容器 */
#events-content-list {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 15px; /* 卡片之间的间距 */
}

/* 2. 新的卡片 .event-card 样式 */
.event-card {
    background-color: #ffffff;
    border-radius: 16px; /* 更圆润的圆角 */
    box-shadow: 0 4px 12px var(--shadow-color);
    border: 1px solid white;
    display: flex;
    align-items: stretch; /* 让左右两边一样高 */
    overflow: hidden; /* 隐藏溢出的边框 */
    position: relative; /* 为了定位按钮 */
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.event-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px var(--shadow-color);
}

/* 3. 卡片左侧的“倒计时”区域 */
.event-card-countdown {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px 25px;
    color: white;
    min-width: 100px;
    text-align: center;
}

.event-card-days {
    font-size: 36px;
    font-weight: 700;
    line-height: 1.1;
}

.event-card-label {
    font-size: 13px;
    font-weight: 500;
    opacity: 0.9;
}

/* 4. 卡片右侧的“信息”区域 */
.event-card-info {
    flex-grow: 1;
    padding: 18px 20px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    cursor: pointer; /* 提示可以点击编辑 */
}

.event-card-name {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-dark);
    margin-bottom: 5px;
}

.event-card-date {
    font-size: 14px;
    color: var(--text-gray);
    margin-bottom: 8px;
}

.event-card-notes {
    font-size: 13px;
    color: #555;
    background-color: #f7f9fa;
    padding: 8px 10px;
    border-radius: 8px;
}

.event-card-notes:empty {
    display: none; /* 如果没有备注，就隐藏 */
}

/* 5. 卡片上的操作按钮 (复用 .preset-actions) */
.event-card-actions {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    gap: 5px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(4px);
    border-radius: 20px;
    padding: 2px;
}
.event-card-actions .preset-action-btn {
    font-size: 16px;
}

/* 6. 根据不同类型设置主题色 */

/* 纪念日 (红色) */
.event-card[data-type="anniversary"] .event-card-countdown {
    background-color: #ff8a80;
}
.event-card[data-type="anniversary"] .event-card-name {
    color: #c62828;
}

/* 生理期 (粉色) */
.event-card[data-type="period"] .event-card-countdown {
    background-color: #f06292;
}
.event-card[data-type="period"] .event-card-name {
    color: #ad1457;
}

/* 其他 (黄色) */
.event-card[data-type="custom"] .event-card-countdown {
    background-color: #ffee58;
    color: #555; /* 黄色背景用深色字 */
}
.event-card[data-type="custom"] .event-card-name {
    color: #a08c32;
}

/* --- 样式结束 --- */
/* --- V-Final 修复：“我们的日子”卡片按钮美化 --- */

/* 1. 修改操作区容器 (改为垂直排列) */
.event-card-actions {
    position: absolute;
    top: 10px; /* 稍微挪下来一点 */
    right: 10px; /* 稍微挪进来一点 */
    display: flex;
    
    /* --- 核心修改在这里 --- */
    flex-direction: column; /* 改为垂直排列 */
    /* --- 修改结束 --- */
    
    gap: 8px; /* 两个按钮之间拉开一点距离 */
    
    /* 移除这些旧样式 */
    background-color: transparent;
    backdrop-filter: none;
    border-radius: 0;
    padding: 0;
}

/* 2. 重新定义按钮本身 (变成小圆圈) */
.event-card-actions .preset-action-btn {
    width: 30px; /* 设定宽度 */
    height: 30px; /* 设定高度 */
    border-radius: 50%; /* 变圆 */
    
    background-color: rgba(0, 0, 0, 0.08); /* 默认用一个很淡的灰色底 */
    color: #555; /* 默认图标颜色深一点 */
    font-size: 13px; /* 图标小一点 */
    
    /* 覆盖 .preset-action-btn 的默认 padding */
    padding: 0; 
    
    /* 居中图标 */
    display: flex;
    align-items: center;
    justify-content: center;
    
    transition: all 0.2s ease;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* 3. 悬浮效果 (通用) */
.event-card-actions .preset-action-btn:hover {
    transform: scale(1.1);
    color: white; /* 悬浮时图标都变白 */
}

/* 4. 置顶按钮 (pin-event-btn) 的悬浮和激活样式 */
.event-card-actions .pin-event-btn:hover {
    background-color: var(--theme-primary-hover, #66bb6a);
}
.event-card-actions .pin-event-btn.active {
    background-color: var(--theme-primary, #81c784); /* 激活时用主题绿 */
    color: white; /* 白色图标 */
}

/* 5. 删除按钮 (delete-event-btn) 的悬浮样式 */
.event-card-actions .delete-event-btn:hover {
    background-color: var(--soft-red, #ff8a80); /* 悬浮时用主题红 */
    color: white; /* 白色图标 */
}

/* --- 修复结束 --- */
/* --- 新增：让系统消息在编辑模式下也能变蓝 --- */
.message-wrapper.system-wrapper.selected .system-notification {
    background-color: #bde0fe !important; /* 变成和其他选中项一样的淡蓝色 */
    color: #333 !important; /* 同时把文字变黑，不然看不清 */
}
/* --- 新增：修复输入框被长文本撑爆的问题 --- */
#message-input,
#comment-input,
#video-call-input,
#sms-message-input {
    /*
     * 这是一个经典的Flexbox修复。
     * 默认情况下, flex-grow: 1 的元素不会收缩到小于其内容的“最小宽度”。
     * 当输入一个很长的、不换行的字符串时, 它的“最小宽度”会变得非常大,
     * 导致它撑爆父容器 (display:flex), 把旁边的按钮挤出去。
     *
     * min-width: 0; 告诉浏览器：
     * "允许这个元素收缩到0, 忽略你内容的宽度, 
     * 然后再根据 flex-grow: 1 把它拉伸到所有可用的剩余空间。"
     * 这就保证了它永远不会撑爆容器。
     */
    min-width: 0;
}
/* ========================================================== */
/* ================== 海龟汤 游戏专属CSS ================== */
/* ========================================================== */

/* 游戏界面的根样式 */
#game-chat-screen {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    --color-user: #0b84ff;
    --color-ai: #34c759;     /* iOS 绿色 */
    --color-host: #ff453a;     /* iOS 红色 */
    --color-win: #ffcc00;     /* 胜利黄 */
}

/* 游戏聊天记录 */
#game-chat-log-wrapper.loading #game-puzzle-area-pinned {
    opacity: 0.5;
    text-align: center;
}

/* 游戏气泡样式 */
#game-chat-screen .message-wrapper { 
    display: flex; 
    max-width: 85%; 
    margin-bottom: 12px; 
    flex-direction: column;
    animation: gameFadeIn 0.3s ease-out;
}
@keyframes gameFadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
#game-chat-screen .message-wrapper.user { align-self: flex-end; }
#game-chat-screen .message-wrapper.ai-player { align-self: flex-start; }
#game-chat-screen .message-wrapper.host { align-self: center; max-width: 95%; }

#game-chat-screen .sender-name {
    font-size: 13px;
    font-weight: 600;
    margin: 0 10px 4px 10px;
}
#game-chat-screen .message-wrapper.user .sender-name { color: var(--color-user); text-align: right; }
#game-chat-screen .message-wrapper.ai-player .sender-name { color: var(--color-ai); }
#game-chat-screen .message-wrapper.host .sender-name { color: var(--color-host); text-align: center; }

#game-chat-screen .message {
    padding: 10px 14px;
    border-radius: 18px;
    line-height: 1.5;
    word-wrap: break-word;
    font-size: 15px;
    color: #ffffff;
    width: fit-content;
}
#game-chat-screen .message-wrapper.user .message { 
    background-color: #0b84ff; 
    border-top-right-radius: 4px; 
    margin-left: auto;
}
#game-chat-screen .message-wrapper.ai-player .message { 
    background-color: #2c2c2e; 
    border-top-left-radius: 4px; 
    margin-right: auto;
}
#game-chat-screen .message-wrapper.host .message {
    background-color: #2c2c2e;
    border: 1px solid #3a3a3c;
    text-align: center;
    width: 100%;
    box-sizing: border-box;
}
/* 主持人回答(是/否) 和 最终答案 的样式 */
#game-chat-screen .message-wrapper.host .message.answer {
    background-color: #444;
    font-weight: bold;
}
#game-chat-screen .message-wrapper.host .message.victory {
    background-color: var(--color-win);
    color: #000;
    font-weight: bold;
    font-size: 16px;
    border-color: var(--color-win);
}
#game-chat-screen .message-wrapper.host .message.surrender {
    background-color: var(--color-host);
    color: white;
    font-weight: bold;
}

/* 游戏输入区 */
#game-input-area.game-ended::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(44, 44, 46, 0.7);
    backdrop-filter: blur(2px);
    z-index: 1;
}

/* 游戏输入按钮的统一样式 */
#game-input-area .game-input-btn {
    border: none;
    border-radius: 50%;
    width: 38px; height: 38px;
    margin-left: 8px;
    cursor: pointer;
    font-size: 16px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s;
}
#game-input-area .game-input-btn:hover { transform: scale(1.1); }
#game-input-area .game-input-btn:disabled { background-color: #555 !important; transform: scale(1); cursor: default; }
/* --- 修正：让返回按钮区域支持横向排列 (箭头 + 火花) --- */
#back-from-chat {
    display: flex;           /* 启用 Flex 布局 */
    align-items: center;     /* 垂直居中 */
    gap: 6px;               /* 箭头和火花之间的间距 */
    width: auto;            /* 自适应宽度 */
}

/* --- 火花在顶栏的专属样式 --- */
.spark-icon-header {
    font-size: 15px;        /* 调整大小，比箭头(24px)稍微小一点，显得精致 */
    line-height: 1;
    cursor: help;           /* 鼠标放上去显示问号，提示可查看天数 */
    transition: transform 0.2s;
    margin-left: 12px;
}

.spark-icon-header:hover {
    transform: scale(1.2);  /* 悬浮放大一点点 */
}

/* --- 火花等级样式 (统一图标版) --- */

/* 等级 1: 刚开始 (灰色/银色火花) */
.spark-level-1 { 
    color: #bdbdbd; /* 灰色，表示刚开始，还没烧起来 */
    /* 如果觉得灰色太暗，也可以用浅粉色 #ffcdd2 */
}

/* 等级 2: 升温 (橙色) - 保持不变 */
.spark-level-2 { 
    color: #ff9800; 
    text-shadow: 0 0 2px rgba(255, 152, 0, 0.5);
}

/* Level 3: 红色 (呼吸动画) */
.spark-level-3 { 
    color: #ff8a80; /* 浅红色 */
    text-shadow: 0 0 8px rgba(255, 82, 82, 0.9);
    animation: spark-breathe 2s infinite alternate; /* 2秒慢速呼吸 */
}

/* Level 4: 巨轮 (呼吸动画 + 金色光晕) */
.spark-level-4 { 
    color: #ea80fc; /* 紫粉色 */
    text-shadow: 0 0 10px #fff59d; /* 金色光晕 */
    font-weight: bold;
    font-size: 16px;
    animation: spark-breathe 2s infinite alternate; /* 也是呼吸，不摇摆了 */
}

/* 新的呼吸动画：只缩放，不旋转 */
@keyframes spark-breathe {
    0% { transform: scale(1); opacity: 0.85; }
    100% { transform: scale(1.15); opacity: 1; }
}
/* 地图目录列表样式 */
.directory-item {
    padding: 8px 10px;
    font-size: 13px;
    color: #333;
    cursor: pointer;
    border-radius: 6px;
    display: flex;
    align-items: center;
    transition: background-color 0.2s;
}
.directory-item:hover {
    background-color: #e3f2fd; /* 悬浮变蓝 */
}
.directory-item i {
    margin-right: 8px;
    width: 16px;
    text-align: center;
    color: var(--theme-primary);
}

/* 面包屑样式 */
.breadcrumb-item {
    cursor: pointer;
    color: var(--theme-primary);
}
.breadcrumb-item:hover {
    text-decoration: underline;
}
.breadcrumb-item.active {
    color: #333;
    font-weight: normal;
    cursor: default;
    text-decoration: none;
}
.breadcrumb-separator {
    color: #999;
    font-size: 12px;
}

/* 给选中的地点加个高亮光圈 */
.map-icon.highlighted {
    box-shadow: 0 0 0 4px rgba(255, 87, 34, 0.6), 0 4px 12px rgba(0,0,0,0.3);
    transform: scale(1.3) !important;
    z-index: 100 !important;
    background-color: #fff3e0 !important;
    border-color: #ff5722 !important;
}
/* ========================================= */
/* ▼▼▼ 幸运字符系统 V-Final (CSS) ▼▼▼ */
/* ========================================= */

/* 1. 胶囊核心样式 (精致迷你版) */
.lucky-char-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    
    /* --- 尺寸调整 --- */
    height: 16px;  /* 原来是 22px */
    min-width: 24px; /* 原来是 40px */
    padding: 0 4px; /* 原来是 10px，收紧一点 */
    border-radius: 9px; /* 圆角跟着高度变 */
    margin-left: 4px; /* 离火花近一点 */
    
    /* --- 字体调整 --- */
    font-family: "Georgia", serif; 
    font-weight: bold;
    font-style: italic;
    font-size: 8px; /* 原来是 12px */
    
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15); /* 阴影也稍微收敛一点 */
    transition: all 0.3s ease;
    user-select: none;
    border: 1px solid rgba(255,255,255,0.3);
}

.lucky-char-badge:hover { 
    transform: scale(1.1); 
}

/* 2. 字母状态 */
.char-letter { margin: 0 0.5px; transition: all 0.5s ease; display: inline-block; }

/* 未解锁：统一暗灰色 */
.char-letter.locked {
    color: rgba(255, 255, 255, 0.3) !important; 
    text-shadow: none !important;
}

/* 3. 稀有度配色与光效 */

/* [Epic 史诗] - 粉金背景 + 粉色光 */
.lucky-char-epic { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%); color: #d94f5c; }
.lucky-char-epic .char-letter.unlocked { color: #d94f5c; text-shadow: 0 0 5px rgba(255, 255, 255, 0.9); }
/* 史诗完成态 */
.lucky-char-epic.completed {
    box-shadow: 0 0 15px rgba(255, 154, 158, 0.8); border-color: #fff;
    animation: pulse-pink 2s infinite;
}

/* [Rare 稀有] - 黑蓝背景 + 金色光 */
.lucky-char-rare { background: linear-gradient(135deg, #141e30 0%, #243b55 100%); color: #ffd700; border-color: #ffd700; }
.lucky-char-rare .char-letter.unlocked { color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.8); }
/* 稀有完成态 */
.lucky-char-rare.completed {
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
    animation: pulse-gold 2s infinite;
}

/* [Common 普通] - 蓝紫背景 + 白色光 */
.lucky-char-common { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
.lucky-char-common .char-letter.unlocked { color: #fff; text-shadow: 0 0 4px rgba(255, 255, 255, 0.8); }
/* 普通完成态 */
.lucky-char-common.completed {
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
    animation: pulse-white 2s infinite;
}

/* 呼吸动画 */
@keyframes pulse-pink { 0% { box-shadow: 0 0 10px rgba(255, 154, 158, 0.5); } 50% { box-shadow: 0 0 20px rgba(255, 154, 158, 0.9); } 100% { box-shadow: 0 0 10px rgba(255, 154, 158, 0.5); } }
@keyframes pulse-gold { 0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); } 50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); } 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); } }
@keyframes pulse-white { 0% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.4); } 50% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.8); } 100% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.4); } }

/* --- 字符仓库列表样式 --- */
.lucky-char-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    max-height: 300px;
    overflow-y: auto;
    padding: 5px;
}
.lucky-char-card {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #f9f9f9;
    padding: 10px 15px;
    border-radius: 10px;
    border: 1px solid #eee;
    transition: all 0.2s;
}
.lucky-char-card.equipped {
    background: #e3f2fd;
    border-color: #2196f3;
}
.lucky-char-info { display: flex; flex-direction: column; }
.lucky-char-meaning { font-size: 12px; color: #888; margin-top: 4px; }
.lucky-char-actions button {
    padding: 4px 8px; font-size: 12px; border-radius: 4px; border: none; cursor: pointer;
}
.btn-equip { background: #4caf50; color: white; }
.btn-unequip { background: #9e9e9e; color: white; }
/* --- 拍一拍 头像抖动特效 --- */
@keyframes avatar-shake {
    0% { transform: rotate(0deg); }
    25% { transform: rotate(15deg); }
    50% { transform: rotate(0deg); }
    75% { transform: rotate(-15deg); }
    100% { transform: rotate(0deg); }
}

.avatar-shaking {
    animation: avatar-shake 0.4s ease-in-out;
}
/* --- 漂流瓶 V3 (星之回响主题) --- */
#drift-bottle-screen {
    /* 深邃宇宙渐变 */
    background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
    position: relative;
    overflow: hidden;
    font-family: 'Nunito', "PingFang SC", sans-serif;
    color: white;
}

/* 星空背景动画 */
.stars-container {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 1;
    overflow: hidden;
}
.star {
    position: absolute;
    background: white;
    border-radius: 50%;
    animation: twinkle var(--duration) ease-in-out infinite;
    opacity: 0;
}
@keyframes twinkle {
    0% { opacity: 0; transform: scale(0.5); }
    50% { opacity: var(--opacity); transform: scale(1); }
    100% { opacity: 0; transform: scale(0.5); }
}

/* 中心星球/雷达 */
.cosmos-stage {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 5;
    margin-bottom: 80px;
}

.planet-core {
    width: 140px;
    height: 140px;
    border-radius: 50%;
    /* 梦幻紫蓝渐变 */
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    box-shadow: 
        inset -10px -10px 20px rgba(0,0,0,0.5),
        inset 10px 10px 20px rgba(255,255,255,0.2),
        0 0 30px rgba(118, 75, 162, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    animation: floatPlanet 6s ease-in-out infinite;
}

/* 环绕轨道 */
.orbit-ring {
    position: absolute;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 50%;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
}
.orbit-1 { width: 220px; height: 220px; animation: spinOrbit 20s linear infinite; }
.orbit-2 { width: 320px; height: 320px; animation: spinOrbit 30s linear infinite reverse; border-color: rgba(255,255,255,0.05); }

/* 轨道上的粒子 */
.orbit-dot {
    position: absolute;
    top: 0; left: 50%;
    width: 8px; height: 8px;
    background: #fff;
    border-radius: 50%;
    box-shadow: 0 0 10px #fff;
    transform: translate(-50%, -50%);
}

@keyframes floatPlanet {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-15px); }
}
@keyframes spinOrbit {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* 文字排版 */
.cosmos-title {
    margin-top: 40px;
    font-size: 20px;
    font-weight: 300;
    letter-spacing: 6px;
    text-transform: uppercase;
    background: linear-gradient(to right, #fff, #a1c4fd);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 20px rgba(161, 196, 253, 0.3);
}
.cosmos-subtitle {
    margin-top: 8px;
    font-size: 12px;
    color: rgba(255,255,255,0.5);
    letter-spacing: 2px;
}

/* 底部操作区 (科技感按钮) */
.cosmos-actions {
    position: absolute;
    bottom: 120px;
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 30px;
    z-index: 10;
    padding: 0 30px;
}

.cosmos-btn {
    flex: 1;
    max-width: 150px;
    height: 60px;
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.cosmos-btn:hover {
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
    border-color: rgba(255, 255, 255, 0.3);
}

.cosmos-btn i { font-size: 18px; color: #a1c4fd; }
.cosmos-btn span { font-size: 14px; font-weight: 600; letter-spacing: 1px; color: #fff; }

/* 输入面板样式调整 (适配深色背景) */
#throw-bottle-input-area, #pick-bottle-input-area {
    background: rgba(30, 30, 35, 0.95); /* 深色磨砂 */
    backdrop-filter: blur(20px);
    border-top: 1px solid rgba(255,255,255,0.1);
    color: white;
}
#throw-bottle-input-area h3, #pick-bottle-input-area h3 { color: white !important; }
#throw-bottle-input-area textarea, #throw-bottle-input-area input, 
#pick-bottle-input-area input, #pick-bottle-input-area select {
    background: rgba(255,255,255,0.05) !important;
    border: 1px solid rgba(255,255,255,0.1) !important;
    color: white !important;
}
#throw-bottle-input-area textarea::placeholder, 
#pick-bottle-input-area input::placeholder {
    color: rgba(255,255,255,0.3);
}

/* 弹窗适配 */
.bottle-paper {
    background-color: #2c2c35 !important; /* 深色卡片 */
    background-image: none !important;
    color: #eee !important;
    border: 1px solid rgba(255,255,255,0.1);
}
.bottle-info-section {
    background: rgba(255,255,255,0.05) !important;
    border: none !important;
}
.bottle-text { color: #ddd !important; }
#bottle-name { color: #fff !important; }
/* ▼▼▼ 补上这几行，输入框就能弹出来了 ▼▼▼ */
#throw-bottle-input-area.active, 
#pick-bottle-input-area.active {
    bottom: 0 !important; /* 强制让它浮上来 */
}
/* --- 弹窗 & 结果卡片适配 (星之回响版) --- */

/* 1. 弹窗容器：改为深色磨砂玻璃风格 */
.bottle-paper {
    background-color: rgba(30, 30, 35, 0.95) !important; /* 深色背景 */
    background-image: none !important; /* 去掉原来的信纸横线 */
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    color: #eee !important; /* 文字变白 */
    border-radius: 24px !important; /* 更大的圆角 */
    box-shadow: 0 20px 50px rgba(0,0,0,0.5) !important;
    padding: 25px !important;
    font-family: 'Nunito', "PingFang SC", sans-serif !important; /* 字体统一 */
    max-width: 320px; /* 限制最大宽度，防止撑满屏幕 */
    margin: 0 auto; /* 居中 */
}

/* 2. 头像：调整大小和发光效果 */
.bottle-avatar-large {
    width: 100px !important;
    height: 100px !important;
    border: 3px solid #a1c4fd !important; /* 边框颜色改为主题蓝 */
    box-shadow: 0 0 20px rgba(161, 196, 253, 0.3) !important; /* 发光效果 */
    background-color: #2c2c35 !important;
    margin-bottom: 20px !important;
}

/* 3. 名字和位置：文字颜色适配 */
#bottle-name {
    color: #fff !important;
    font-size: 22px !important;
    font-weight: 700 !important;
    margin-bottom: 5px !important;
}
#bottle-location {
    color: rgba(255, 255, 255, 0.6) !important;
}

/* 4. 信息区域：改为深色块 */
.bottle-info-section {
    background: rgba(255, 255, 255, 0.05) !important;
    border: none !important;
    border-radius: 16px !important;
    padding: 15px !important;
    margin-top: 15px !important;
}

/* 5. 瓶子里的文字：白色 */
.bottle-text {
    color: #ddd !important;
    font-size: 15px !important;
    line-height: 1.6 !important;
    font-style: italic; /* 斜体更有氛围 */
}

/* 6. 底部摘要信息：调淡颜色 */
.bottle-info-section div {
    border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
    color: rgba(255, 255, 255, 0.5) !important;
}
.bottle-info-section strong {
    color: rgba(255, 255, 255, 0.8) !important;
}

/* 7. 按钮适配 */
#reply-bottle-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
    border: none !important;
    color: white !important;
}
#throw-back-btn {
    background: rgba(255, 255, 255, 0.1) !important;
    color: #ccc !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
}
/* ▼▼▼ 【紧急修复】弹窗定位改为全屏悬浮 ▼▼▼ */
#bottle-content-modal {
    position: fixed !important; /* 核心：改为 fixed，无视文档流 */
    top: 0;
    left: 0;
    width: 100vw !important; /* 强制占满视口宽度 */
    height: 100vh !important; /* 强制占满视口高度 */
    z-index: 9999 !important; /* 放在最顶层，盖住底部输入框 */
    
    /* 保持居中逻辑 */
    display: none; /* JS 控制显示时会变成 flex */
    justify-content: center;
    align-items: center;
    
    /* 加深遮罩颜色，更有沉浸感 */
    background-color: rgba(0, 0, 0, 0.7) !important;
    backdrop-filter: blur(8px) !important;
}

/* 优化卡片在深色模式下的显示 */
.bottle-paper {
    margin: auto !important; /* 确保在 flex 容器中居中 */
    flex-shrink: 0 !important; /* 防止被压缩 */
    max-height: 85vh !important; /* 防止太高超出屏幕 */
    overflow-y: auto !important; /* 内容多了可以滚动 */
}

/* 修复加载中的文字颜色 */
#bottle-loading p {
    color: rgba(255, 255, 255, 0.8) !important;
}
#bottle-loading i {
    color: #a1c4fd !important; /* 加载圈圈改成浅蓝色 */
}
/* 表情包选中状态 */
.emoticon-item.is-selecting {
    border: 2px solid transparent; /* 默认透明边框 */
    transition: all 0.2s;
}

.emoticon-item.is-selecting.selected {
    border-color: var(--theme-primary); /* 选中变绿 */
    background-color: #e8f5e9; /* 浅绿背景 */
}

/* 选中时的对勾角标 */
.emoticon-check-mark {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.2);
    color: white;
    display: none; /* 默认隐藏 */
    align-items: center;
    justify-content: center;
    font-size: 12px;
    pointer-events: none; /* 让点击穿透 */
}

/* 进入编辑模式时显示对勾圈圈 */
.emoticon-item.is-selecting .emoticon-check-mark {
    display: flex;
}

/* 选中变实心 */
.emoticon-item.is-selecting.selected .emoticon-check-mark {
    background-color: var(--theme-primary);
}
/* =========== 🚑 紧急修复补丁 V3：全家桶版 =========== */

/* 1. 修复排版：让特殊卡片 和 引用消息 忽略代码缩进 */
.message.red-packet,
.message.transfer,
.message.music-share-card,
.message.location-share-card,
.message.game-wheel-card,
.message.post-share-card,
.message.product-share-card,
.message.chat-history-card,
.message.picture-description,
.message-quote { /* <--- ✨ 把这个加进来了！ */
    white-space: normal !important; 
    word-wrap: break-word !important;
}

/* 2. 恢复身材：强制恢复各类卡片的标准宽度 */
.message.red-packet,
.message.transfer,
.message.product-share-card {
    width: 240px !important;
}

.message.music-share-card,
.message.chat-history-card {
    width: 260px !important;
}

.message.location-share-card,
.message.game-wheel-card,
.message.post-share-card {
    width: 250px !important;
}

/* 3. 确保容器正常 */
.message-image-container {
    white-space: normal !important;
}

/* =========== 修复结束 =========== */
/* --- QQ空间 (Qzone) 专属样式 --- */
.qz-navbar {
    position: absolute; top: 0; left: 0; right: 0;
    height: 50px; padding: 0 15px;
    display: flex; justify-content: space-between; align-items: center;
    z-index: 10; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    transition: background-color 0.3s, color 0.3s;
}
.qz-navbar.scrolled { background: #fff; color: #000; text-shadow: none; border-bottom: 1px solid #eee; }
.qz-navbar i { font-size: 20px; cursor: pointer; }

.qz-header-wrapper { background-color: #fff; position: relative; margin-bottom: 10px; }
.qz-cover {
    width: 100%; height: 240px;
    background-image: url('https://i.postimg.cc/SQ3DH79X/MEITU-20250811-151831796.jpg');
    background-size: cover; background-position: center;
}
.qz-cover-overlay {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 80px;
    background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
}

.qz-profile-container {
    position: absolute; 
    top: 190px; 
    left: 20px;
    right: 20px; /* 👈 改用 right 约束右边界 */
    display: flex; 
    align-items: flex-end; 
    z-index: 5; 
    /* width: 100%;  <-- 这一行一定要删掉！ */
}
/* --- 修复：Koko空间专属滚动条优化 (加强版) --- */
#social-zone-screen {
    overflow-x: hidden; /* 彻底禁止左右滑动 */
    /* Firefox */
    scrollbar-width: none !important; 
    /* IE/Edge */
    -ms-overflow-style: none !important; 
}

/* Chrome/Safari/Webkit 隐藏滚动条 */
#social-zone-screen::-webkit-scrollbar {
    display: none !important; /* 强制不显示 */
    width: 0 !important;      /* 强制宽度为0 */
    height: 0 !important;     /* 强制高度为0 */
    background: transparent !important; /* 强制背景透明 */
    opacity: 0 !important;
}
.qz-avatar-img {
    width: 80px; height: 80px; border-radius: 50%;
    border: 2px solid #fff; object-fit: cover; margin-right: 12px;
}
.qz-nickname-row { display: flex; align-items: center; gap: 5px; margin-bottom: 4px; }
.qz-name-text { font-size: 18px; font-weight: bold; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
.qz-svip-badge {
    background: linear-gradient(90deg, #FFC107, #FF9800); color: white;
    font-size: 10px; padding: 1px 4px; border-radius: 3px;
    font-weight: 800; font-style: italic; border: 1px solid rgba(255,255,255,0.5);
}
.qz-visitors { font-size: 12px; color: rgba(255,255,255,0.8); }

.qz-tab-bar {
    padding: 40px 0 15px 0; display: flex; justify-content: space-around; background: #fff;
}
.qz-tab-item { display: flex; flex-direction: column; align-items: center; gap: 5px; color: #333; font-size: 12px; }
.qz-tab-icon { font-size: 18px; color: #444; }

.qz-quick-post-area { background: #fff; padding: 10px 15px; margin-bottom: 10px; }
.qz-search-bar {
    background-color: #f2f2f7; border-radius: 20px; height: 36px;
    display: flex; align-items: center; padding: 0 15px; color: #999; font-size: 14px; cursor: pointer;
}

/* 动态卡片 */
.qz-card { background: #fff; margin-bottom: 10px; padding: 15px; }
.qz-card-header { display: flex; margin-bottom: 10px; }
.qz-card-avatar { width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; }
.qz-card-name { font-size: 15px; font-weight: 600; color: #333; display: flex; align-items: center; gap: 5px; }
.qz-card-name.vip-red { color: #fb7299; }
.qz-yellow-diamond { color: #FFD700; font-size: 12px; }
.qz-card-time { font-size: 12px; color: #999; margin-top: 2px; }
.qz-card-content { font-size: 16px; line-height: 1.6; color: #000; margin-bottom: 10px; white-space: pre-wrap; }

/* 音乐卡片 */
.qz-music-card {
    background: #f5f5f5; padding: 6px; border-radius: 4px; display: flex; align-items: center; margin-bottom: 10px;
}
.qz-music-cover { width: 50px; height: 50px; border-radius: 4px; margin-right: 10px; }
.qz-music-title { font-size: 14px; font-weight: 600; color: #333; }
.qz-music-artist { font-size: 12px; color: #888; }

/* 图片网格 */
.qz-img-grid { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; }
.qz-img-grid img { width: 100px; height: 100px; object-fit: cover; }
.qz-img-grid.single img { width: auto; max-width: 70%; max-height: 250px; border-radius: 4px; }

/* 操作栏 */
.qz-action-row { display: flex; justify-content: flex-end; gap: 25px; padding: 5px 0; }
.qz-action-btn { color: #666; font-size: 20px; cursor: pointer; }

/* 评论区 */
.qz-comments-section { background: #f8f8f8; padding: 8px; border-radius: 4px; margin-top: 5px; font-size: 13px; }
.qz-like-display i { color: #576b95; margin-right: 5px; }
.qz-user-link { color: #576b95; font-weight: 600; }
.qz-inline-input { margin-top: 8px; background: #ececec; height: 30px; border-radius: 15px; display: flex; align-items: center; padding: 0 10px; color: #999; font-size: 12px; }
/* 1. 去掉那个黑色的渐变遮罩 */
.qz-cover-overlay {
    background: none !important; 
    /* 或者设为透明: background: transparent !important; */
}

/* 2. 给名字和访客数加重一点文字阴影，防止背景太白看不清字 */
.qz-name-text, 
.qz-visitors,
.qz-svip-badge {
    text-shadow: 0 2px 4px rgba(0,0,0,0.6) !important; /* 加深文字背后的阴影 */
}
/* --- QQ空间 蓝色名字链接 --- */
.qz-user-link {
    color: #576b95; /* 经典的腾讯蓝 */
    font-weight: 500;
    cursor: pointer;
    text-decoration: none;
}
.qz-user-link:active {
    background-color: #e5e5e5; /* 点击时的反馈 */
    border-radius: 2px;
}
/* --- QQ空间九宫格样式 --- */

/* 预览区的小图 */
.qz-preview-item {
    width: 100px; height: 100px;
    position: relative;
    border-radius: 4px;
    overflow: hidden;
    background: #eee;
}
.qz-preview-item img { width: 100%; height: 100%; object-fit: cover; }
.qz-preview-item .sim-text {
    width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;
    padding: 5px; font-size: 12px; color: #fff; background: #576b95; text-align: center;
}
.qz-preview-close {
    position: absolute; top: 0; right: 0; background: rgba(0,0,0,0.5); color: white;
    width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer;
}

/* 实际展示区的网格 */
.qz-img-grid {
    display: grid;
    gap: 5px;
    margin-top: 5px;
}

/* 单张图模式 */
.qz-img-grid.cols-1 img, .qz-img-grid.cols-1 .sim-img {
    max-width: 70%; max-height: 240px; width: auto; height: auto;
    border-radius: 6px; object-fit: cover;
}

/* 两列模式 (2, 4 张) */
.qz-img-grid.cols-2 {
    grid-template-columns: repeat(2, 1fr);
    width: 66%; /* 限制宽度，不占满 */
}

/* 三列模式 (3, 5-9 张) */
.qz-img-grid.cols-3 {
    grid-template-columns: repeat(3, 1fr);
}

/* 图片通用样式 */
.qz-img-grid img, .qz-img-grid .sim-img {
    width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 2px;
    background-color: #f0f0f0; cursor: pointer;
}

/* 模拟图片展示样式 */
.qz-img-grid .sim-img {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
    color: white; padding: 10px; text-align: center; font-size: 12px;
    position: relative; overflow: hidden;
}
.qz-img-grid .sim-img i { font-size: 24px; margin-bottom: 5px; opacity: 0.8; }
/* --- 手账列表样式 --- */
.journal-card {
    background: #fff;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    cursor: pointer;
    transition: transform 0.2s;
    border-left: 4px solid #FFD700; /* 左侧金线 */
}
.journal-card:active { transform: scale(0.98); }
.journal-title { font-size: 16px; font-weight: bold; margin-bottom: 5px; color: #333; }
.journal-date { font-size: 12px; color: #999; display: flex; justify-content: space-between; }
.journal-preview { font-size: 13px; color: #666; margin-top: 8px; line-height: 1.5; 
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
}

/* --- 模板选择器样式 --- */
.paper-swatch {
    width: 40px; height: 40px; border-radius: 50%; border: 2px solid #ddd; cursor: pointer; flex-shrink: 0;
}
.paper-swatch.selected { border-color: #576b95; transform: scale(1.1); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }

/* --- 💌 核心：信纸模板 (Templates) 💌 --- */

/* 1. 默认纯白 */
.tmpl-default { background-color: #ffffff; color: #333; }

/* 2. 粉色方格 (少女心) */
.tmpl-grid-pink {
    background-color: #fff0f5;
    background-image: 
        linear-gradient(#eecce0 1px, transparent 1px),
        linear-gradient(90deg, #eecce0 1px, transparent 1px);
    background-size: 20px 20px;
    color: #5a3d4a;
}

/* 3. 复古牛皮纸 (文艺) */
.tmpl-kraft {
    background-color: #f4e4bc;
    background-image: url("https://www.transparenttextures.com/patterns/cardboard-flat.png"); /* 模拟纸纹 */
    color: #5d4037;
    font-family: "Courier New", Courier, monospace; /* 打字机字体 */
}

/* 4. 暗夜星空 (深色模式) */
.tmpl-dark {
    background-color: #2c3e50;
    color: #ecf0f1;
}

/* 5. 点阵纸 (极简) */
.tmpl-dot {
    background-color: #fdfdfd;
    background-image: radial-gradient(#ccc 1px, transparent 1px);
    background-size: 20px 20px;
    color: #333;
}

/* --- 手账编辑器样式 --- */
.journal-toolbar {
    display: flex; gap: 15px; padding: 8px 15px; background: #fff;
    border-bottom: 1px dashed #eee; overflow-x: auto;
}
.tool-btn {
    width: 36px; height: 36px; border-radius: 50%; background: #f5f5f5;
    display: flex; align-items: center; justify-content: center;
    color: #555; cursor: pointer; flex-shrink: 0; font-size: 16px;
}
.tool-btn:active { transform: scale(0.9); background: #e0e0e0; }

/* 编辑区域 */
#journal-content-editor {
    width: 100%; height: 100%; outline: none; padding: 20px;
    font-size: 18px; line-height: 1.8; overflow-y: auto;
}

/* --- 引入中文字体 (加强版) --- */
@import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=ZCOOL+KuaiLe&display=swap');

/* 字体类 (加了 !important 确保生效) */
.font-hand { 
    font-family: 'Ma Shan Zheng', 'KaiTi', '楷体', cursive !important; /* 毛笔/楷体 */
} 
.font-cute { 
    font-family: 'ZCOOL KuaiLe', 'YouYuan', '幼圆', cursive !important; /* 可爱/幼圆 */
} 
.font-normal { 
    font-family: sans-serif !important; /* 默认黑体 */
}

/* 贴纸样式 */
.journal-sticker-img {
    display: inline-block; width: 60px; height: 60px; vertical-align: middle; margin: 2px;
    transition: transform 0.2s; cursor: grab;
}
.journal-sticker-img:hover { transform: scale(1.1); }

/* 胶带/分割线样式 */
.journal-washi-tape {
    display: block; width: 100%; height: 15px; margin: 10px 0;
    background-image: repeating-linear-gradient(45deg, #ffcdd2 0, #ffcdd2 10px, #fff 10px, #fff 20px);
    opacity: 0.8; border-radius: 2px;
}

/* 日期章样式 */
.journal-stamp {
    display: inline-block; border: 2px solid #ef5350; color: #ef5350;
    padding: 2px 8px; border-radius: 8px; font-weight: bold; 
    transform: rotate(-5deg); margin: 5px; font-family: 'Courier New', monospace;
}

/* 新增信纸：蓝天 */
.tmpl-cloud {
    background-color: #e3f2fd;
    background-image: radial-gradient(white 15%, transparent 16%), radial-gradient(white 15%, transparent 16%);
    background-size: 60px 60px;
    background-position: 0 0, 30px 30px;
}

/* 选择贴纸面板的图片 */
.sticker-select-item {
    width: 50px; height: 50px; margin-right: 10px; cursor: pointer; border-radius: 4px; border: 2px solid transparent;
}
.sticker-select-item:hover { border-color: #FFD700; background: #fff3cd; }
/* --- 胶带面板样式 --- */
.tape-select-item {
    display: inline-block; width: 80px; height: 30px; margin-right: 10px; 
    cursor: pointer; border-radius: 2px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: transform 0.1s; position: relative;
}
.tape-select-item:hover { transform: scale(1.05); }
.tape-select-item:active { transform: scale(0.95); }

/* --- 胶带样式库 (CSS Pattern) --- */

/* 基础类 */
.journal-washi-tape {
    display: block; width: 100%; height: 18px; margin: 8px 0; opacity: 0.9; border-radius: 2px;
}

/* 1. 经典粉斜纹 */
.tape-pink-stripe {
    background-image: repeating-linear-gradient(45deg, #ffcdd2 0, #ffcdd2 10px, #fff 10px, #fff 20px);
}

/* 2. 清新蓝条纹 */
.tape-blue-stripe {
    background-image: repeating-linear-gradient(-45deg, #b3e5fc 0, #b3e5fc 10px, #e1f5fe 10px, #e1f5fe 20px);
}

/* 3. 薄荷波点 */
.tape-mint-dot {
    background-color: #b2dfdb;
    background-image: radial-gradient(#fff 20%, transparent 20%);
    background-size: 10px 10px;
}

/* 4. 柠檬格子 */
.tape-lemon-grid {
    background-color: #fff9c4;
    background-image: 
        linear-gradient(#fbc02d 1px, transparent 1px),
        linear-gradient(90deg, #fbc02d 1px, transparent 1px);
    background-size: 15px 15px;
}

/* 5. 梦幻彩虹 (渐变) */
.tape-rainbow {
    background: linear-gradient(to right, #ff9a9e 0%, #fecfef 99%, #a18cd1 100%);
}

/* 6. 复古牛皮纸 */
.tape-kraft {
    background-color: #d7ccc8;
    background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%235d4037' fill-opacity='0.1' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zM6 5v1H5z'/%3E%3C/g%3E%3C/svg%3E");
}

/* 7. 暗夜星空 */
.tape-galaxy {
    background-color: #1a237e;
    background-image: radial-gradient(white 1px, transparent 1px), radial-gradient(white 1px, transparent 1px);
    background-size: 20px 20px;
    background-position: 0 0, 10px 10px;
}
/* --- 便利贴选择面板样式 --- */
.note-select-item {
    display: inline-block; width: 40px; height: 40px; margin-right: 15px; 
    cursor: pointer; box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    transition: transform 0.1s; border: 1px solid #ddd;
}
.note-select-item:hover { transform: scale(1.1) rotate(-5deg); }

/* --- 📝 高颜值便利贴样式 (V2.0) 📝 --- */

/* 基础容器 (负责定位) */
.journal-note-wrapper {
    display: inline-block;
    vertical-align: top; /* 顶部对齐，防止文字错位 */
    margin: 15px 10px;   /* 增加间距，别挤在一起 */
    padding: 0;
    position: relative;  /* 为装饰物定位 */
}

/* 核心便利贴盒子 (通用) */
.journal-note-box {
    width: 180px;             /*稍微宽一点 */
    min-height: 100px;        /* 稍微高一点 */
    padding: 20px 15px 15px;  /* 上边距留给胶带 */
    font-size: 15px;
    line-height: 1.7;
    color: #555;
    font-family: 'Ma Shan Zheng', cursive; /* 默认手写体 */
    word-wrap: break-word;
    outline: none;
    position: relative;
    box-shadow: 3px 4px 12px rgba(0,0,0,0.08); /* 柔和的高级阴影 */
    transition: transform 0.2s;
}
.journal-note-box:hover {
    transform: scale(1.02); /* 鼠标放上去微微放大 */
    z-index: 10;
}

/* --- 款式 1: 柠檬黄 + 半透明胶带 --- */
.note-yellow {
    background-color: #fff9c4; /* 暖黄 */
    background-image: linear-gradient(to bottom right, #fff9c4, #fff176); /* 微渐变 */
    transform: rotate(-2deg);
    border-radius: 2px;
}
/* 顶部胶带装饰 */
.note-yellow::before {
    content: '';
    position: absolute;
    top: -8px; left: 50%; transform: translateX(-50%) rotate(1deg);
    width: 60px; height: 18px;
    background-color: rgba(255, 255, 255, 0.5); /* 半透明白 */
    background-image: repeating-linear-gradient(45deg, rgba(0,0,0,0.05) 0, rgba(0,0,0,0.05) 2px, transparent 2px, transparent 6px); /* 斜纹纹理 */
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    backdrop-filter: blur(2px); /* 磨砂感 */
}

/* --- 款式 2: 少女粉 + 圆点纹理 + 玫红胶带 --- */
.note-pink {
    background-color: #fce4ec;
    /* 可爱的波点背景 */
    background-image: radial-gradient(#f48fb1 15%, transparent 16%);
    background-size: 15px 15px;
    background-position: 0 0;
    color: #880e4f;
    transform: rotate(2deg);
    border-radius: 8px; /* 圆角 */
}
.note-pink::before {
    content: '';
    position: absolute;
    top: -8px; left: 20px;
    width: 50px; height: 15px;
    background-color: rgba(233, 30, 99, 0.3); /* 玫红色半透明 */
    transform: rotate(-3deg);
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* --- 款式 3: 极简蓝格 + 大头针 --- */
.note-blue-grid {
    background-color: #fff;
    /* 蓝色网格纸 */
    background-image: 
        linear-gradient(#e1f5fe 1px, transparent 1px),
        linear-gradient(90deg, #e1f5fe 1px, transparent 1px);
    background-size: 20px 20px;
    color: #0277bd;
    transform: rotate(1deg);
    border: 1px solid #b3e5fc;
}
/* 红色大头针装饰 */
.note-blue-grid::after {
    content: '📍'; 
    position: absolute; 
    top: -12px; left: 50%; transform: translateX(-50%);
    font-size: 24px;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.1);
}

/* --- 款式 4: 复古牛皮 + 拍立得风格 --- */
.note-kraft {
    background-color: #d7ccc8;
    background-image: url("https://www.transparenttextures.com/patterns/cardboard-flat.png"); /* 纸质纹理 */
    color: #3e2723;
    transform: rotate(-1deg);
    border: 4px solid #fff; /* 白边，像照片 */
    border-bottom-width: 15px; /* 底部宽边 */
    box-shadow: 4px 4px 15px rgba(0,0,0,0.2); /* 加重阴影 */
}
/* 黑色小夹子 */
.note-kraft::before {
    content: '';
    position: absolute;
    top: -10px; left: 10px;
    width: 30px; height: 10px;
    background: #333;
    border-radius: 2px;
    transform: rotate(-15deg);
}
/* --- 印章面板样式 --- */
.stamp-select-item {
    display: inline-block; transform: scale(0.8); margin: 0 5px; cursor: pointer; transition: transform 0.1s;
}
.stamp-select-item:hover { transform: scale(1); }
.stamp-select-item:active { opacity: 0.7; }

/* --- 📝 核心：印章样式库 📝 --- */

/* 通用印章基底 */
.journal-stamp-box {
    display: inline-flex; 
    align-items: center; 
    justify-content: center;
    font-weight: bold; 
    opacity: 0.85; /* 模拟墨水半透明 */
    font-family: 'SimKai', 'KaiTi', '楷体', serif; /* 必须用衬线体或楷体才有感觉 */
    user-select: none; 
    vertical-align: middle;
    margin: 5px;
    /* 模拟墨水边缘的微小模糊 */
    text-shadow: 0 0 1px currentColor;
    box-shadow: inset 0 0 2px rgba(255,255,255,0.3);
}

/* 款式 1: 圆形日期章 (红色) */
.stamp-circle-date {
    width: 64px; height: 64px;
    border-radius: 50%;
    border: 3px double #d32f2f; /* 双线边框 */
    color: #d32f2f;
    flex-direction: column;
    font-size: 12px;
    transform: rotate(-15deg); /* 微微倾斜 */
    line-height: 1.2;
    background: radial-gradient(circle, rgba(211, 47, 47, 0.05) 0%, transparent 70%); /* 极淡的红晕 */
}
.stamp-date-day { font-size: 22px; font-weight: 900; border-top: 1px solid #d32f2f; border-bottom: 1px solid #d32f2f; padding: 2px 0; margin: 2px 0; font-family: 'Courier New', monospace; }

/* 款式 2: 方印 (4字专用，如今日无事) */
.stamp-square-mood {
    width: 48px; height: 48px;
    border: 3px solid #c62828; /* 深红 */
    border-radius: 6px; /* 稍微圆润一点 */
    color: #c62828;
    font-size: 18px;
    line-height: 1.1;
    font-weight: 900; /* 极粗 */
    font-family: 'SimSun', 'Songti SC', serif; /* 宋体更有印章感 */
    background-color: rgba(255, 255, 255, 0.2);
    
    /* 核心：强制 flex 居中 + 换行，形成 2x2 布局 */
    display: inline-flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
    padding: 2px;
    text-align: center;
    
    box-shadow: inset 0 0 3px rgba(198, 40, 40, 0.3); /* 模拟印泥晕染 */
    transform: rotate(3deg);
}

/* 款式 2.5: 长条闲章 (3字专用，如宜开心) */
.stamp-vertical-tag {
    width: 24px; min-height: 60px; /* 竖长条 */
    border: 2px solid #c62828;
    border-radius: 12px; /* 椭圆感 */
    color: #c62828;
    font-size: 16px;
    font-weight: bold;
    font-family: 'KaiTi', '楷体', serif;
    
    display: inline-flex;
    flex-direction: column; /* 竖排 */
    align-items: center;
    justify-content: center;
    padding: 5px 2px;
    gap: 2px;
    
    background: rgba(255, 240, 240, 0.2);
    transform: rotate(-5deg);
}

/* 款式 3: 矩形办公章 (蓝色) */
.stamp-rect-status {
    padding: 4px 12px;
    border: 3px solid #1976d2;
    color: #1976d2;
    border-radius: 8px;
    font-size: 16px;
    font-family: sans-serif;
    text-transform: uppercase;
    letter-spacing: 2px;
    transform: rotate(-8deg);
    background: repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(25, 118, 210, 0.05) 2px, rgba(25, 118, 210, 0.05) 4px);
}

/* 款式 4: 极简双线章 (黑色) */
.stamp-simple-black {
    padding: 5px 10px;
    border-top: 2px solid #333;
    border-bottom: 2px solid #333;
    color: #333;
    font-size: 14px;
    font-style: italic;
    font-family: 'Georgia', serif;
    transform: rotate(-2deg);
}
/* --- 📝 核心修复：通用手账纸张样式 (保证编辑和查看一模一样) 📝 --- */
.journal-paper-canvas {
    position: relative; /* 关键！让贴纸不会乱飞 */
    width: 100%;
    min-height: 100%;   /* 撑满高度 */
    padding: 25px 20px; /* 统一内边距 */
    
    /* 统一文字排版 */
    font-size: 18px;
    line-height: 1.8;
    letter-spacing: 0.5px;
    color: #333;
    
    /* 强制换行规则 */
    white-space: pre-wrap; 
    word-wrap: break-word;
    overflow-wrap: break-word;
    
    /* 消除浏览器默认样式的干扰 */
    box-sizing: border-box;
}

/* 消除编辑器里回车产生的 div/p 的额外间距 */
.journal-paper-canvas div,
.journal-paper-canvas p {
    margin: 0;
    padding: 0;
    min-height: 1em; /* 防止空行塌陷 */
}

/* 修复图片/贴纸在查看页的对齐问题 */
.journal-paper-canvas img {
    max-width: 100%;
    vertical-align: middle;
}

/* 修复印章在查看页的错位 */
.journal-stamp {
    display: inline-block !important; /* 强制行内块 */
    vertical-align: middle;
}
.format-btn {
    width: 32px; height: 32px; border-radius: 4px; background: #f5f5f5;
    display: flex; align-items: center; justify-content: center;
    color: #555; cursor: pointer; font-size: 14px; transition: all 0.2s;
}
.format-btn:active, .format-btn.active {
    background: #333; color: #fff; /* 激活状态变黑 */
}

/* 字体切换按钮专用 */
.font-toggle-btn {
    font-weight: bold; font-size: 16px;
}
/* --- 📱 动态流里的“迷你手账”样式 --- */
.qz-journal-preview {
    border-radius: 8px;
    padding: 15px;
    margin: 10px 0;
    max-height: 220px; /* 限制高度，做成缩略版 */
    overflow: hidden;  /* 超出隐藏 */
    position: relative;
    border: 1px solid rgba(0,0,0,0.05);
    box-shadow: inset 0 0 10px rgba(0,0,0,0.02);
    cursor: pointer;
}

/* 底部渐变遮罩，提示“点击阅读全文” */
.qz-journal-preview::after {
    content: '点击查看全文';
    position: absolute;
    bottom: 0; left: 0; width: 100%; height: 60px;
    background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.9) 80%);
    display: flex; align-items: flex-end; justify-content: center;
    padding-bottom: 10px;
    color: #576b95; font-size: 12px; font-weight: bold;
}

/* 标题样式 */
.qz-journal-preview-title {
    font-size: 17px; font-weight: bold; margin-bottom: 8px;
    border-left: 4px solid rgba(0,0,0,0.2); padding-left: 8px;
    color: inherit; /* 跟随信纸颜色 */
}

/* 内容缩放 */
.qz-journal-preview-content {
    font-size: 14px; /* 比原文稍微小一点 */
    line-height: 1.6;
}
/* 让贴纸在预览里变小一点，别占满屏幕 */
.qz-journal-preview-content img {
    max-width: 60px !important; 
    height: auto !important;
}
/* --- 留言板样式 --- */
.gb-card {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    /* 模拟截图中的纸质纹理 */
    background-image: linear-gradient(0deg, transparent 24%, rgba(0, 0, 0, .03) 25%, rgba(0, 0, 0, .03) 26%, transparent 27%, transparent 74%, rgba(0, 0, 0, .03) 75%, rgba(0, 0, 0, .03) 76%, transparent 77%, transparent);
    background-size: 50px 50px;
}

.gb-header {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.gb-avatar {
    width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; object-fit: cover;
}

.gb-info {
    display: flex; flex-direction: column;
}

.gb-name {
    font-size: 15px; font-weight: 600; color: #333;
}

.gb-time {
    font-size: 12px; color: #999; margin-top: 2px;
}

.gb-content {
    font-size: 16px; color: #333; line-height: 1.6; margin-bottom: 10px; padding-left: 50px; /* 对齐头像右侧 */
    white-space: pre-wrap;
}

.gb-reply-box {
    margin-left: 50px;
    background: #f9f9f9;
    padding: 8px 10px;
    border-radius: 4px;
    font-size: 13px;
    color: #666;
}

.gb-reply-user {
    color: #576b95; font-weight: bold; margin-right: 5px;
}
/* --- 修改后的模拟图片样式：支持滚动显示完整文字 --- */
.qz-img-grid .sim-img {
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    /* 核心修改 1：改为从顶部开始排列，防止长文字被遮挡 */
    justify-content: flex-start; 
    
    background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
    color: white; 
    padding: 10px; 
    text-align: center; 
    font-size: 13px; /* 字体稍微大一点点 */
    position: relative; 
    
    /* 核心修改 2：允许垂直滚动，并强制长单词换行 */
    overflow-y: auto;
    word-wrap: break-word;
    white-space: pre-wrap; /* 保留换行符 */
    line-height: 1.4;
}

/* (可选) 美化滚动条，让它在彩色背景上不那么突兀 */
.qz-img-grid .sim-img::-webkit-scrollbar {
    width: 4px;
}
.qz-img-grid .sim-img::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.4);
    border-radius: 4px;
}
/* --- Koko空间装修弹窗样式 --- */
#qz-settings-modal {
    display: none;
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.5); z-index: 3000;
    align-items: flex-end;
}
.qz-settings-panel {
    width: 100%; background: #fff; border-radius: 20px 20px 0 0;
    padding: 20px; max-height: 80%; overflow-y: auto;
    animation: slideUp 0.3s ease;
}
.qz-setting-group { margin-bottom: 20px; border-bottom: 1px solid #f5f5f5; padding-bottom: 15px; }
.qz-setting-title { font-weight: bold; font-size: 15px; margin-bottom: 10px; color: #333; }

/* 颜色选择球 */
.color-swatch-list { display: flex; gap: 15px; overflow-x: auto; padding: 5px; }
.color-swatch { 
    width: 40px; height: 40px; border-radius: 50%; border: 2px solid #eee; 
    cursor: pointer; position: relative; flex-shrink: 0;
}
.color-swatch.active::after {
    content: '✔'; position: absolute; top: 50%; left: 50%; 
    transform: translate(-50%, -50%); color: white; text-shadow: 0 0 2px rgba(0,0,0,0.5);
}

/* 徽章选择网格 */
.badge-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
.badge-option { 
    display: flex; flex-direction: column; align-items: center; 
    padding: 10px; border: 1px solid #eee; border-radius: 8px; cursor: pointer; 
}
.badge-option.selected { border-color: #FF9800; background: #FFF3E0; }
.badge-icon { font-size: 20px; margin-bottom: 5px; }

/* 各种钻的颜色 */
.diamond-yellow { color: #FFD700; } /* 黄钻 */
.diamond-red { color: #FF5252; }    /* 红钻 */
.diamond-green { color: #69F0AE; }  /* 绿钻 */
.diamond-blue { color: #40C4FF; }   /* 蓝钻 */
.diamond-purple { color: #E040FB; } /* 紫钻 */
.icon-star { color: #FFC107; }      /* 星星 */

/* --- 空间主题预设 --- */
/* 1. 少女粉主题 */
.qz-theme-pink .qz-tab-icon { color: #FF80AB !important; }
.qz-theme-pink .qz-tab-item { color: #F06292 !important; }
.qz-theme-pink .qz-action-btn { color: #F48FB1 !important; }
.qz-theme-pink #qz-add-post-btn { color: #EC407A !important; }
/* 2. 暗黑金主题 */
.qz-theme-darkgold #social-zone-screen { background-color: #212121 !important; }
.qz-theme-darkgold .qz-card, .qz-theme-darkgold .qz-header-wrapper, .qz-theme-darkgold .qz-tab-bar, .qz-theme-darkgold .qz-navbar.scrolled { 
    background-color: #333 !important; color: #d4af37 !important; 
}
.qz-theme-darkgold .qz-card-name, .qz-theme-darkgold .qz-content, .qz-theme-darkgold .qz-tab-item { color: #d4af37 !important; }
.qz-theme-darkgold .qz-action-btn { color: #999 !important; }
.qz-theme-darkgold .qz-navbar { color: #d4af37 !important; }
/* 3. 天空蓝主题 */
.qz-theme-blue .qz-navbar.scrolled { background-color: #E3F2FD !important; }
.qz-theme-blue .qz-tab-icon { color: #2196F3 !important; }
.qz-theme-blue .qz-action-btn { color: #64B5F6 !important; }
/* === 强力磨砂玻璃卡片样式 === */
.glass-card {
    /* 30% 不透明度的白色，透出背景更明显 */
    background-color: rgba(255, 255, 255, 0.1) !important; 
    /* 模糊背景，产生磨砂感 */
    backdrop-filter: blur(1px) !important;
    -webkit-backdrop-filter: blur(1px) !important;
    /* 边框也半透明 */
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    /* 文字颜色深一点，防止在浅背景看不清 */
    color: #333 !important; 
}

/* 暗黑金主题下的磨砂效果 */
.qz-theme-darkgold .glass-card {
    background-color: rgba(30, 30, 30, 0.1) !important;
    border: 1px solid rgba(255, 215, 0, 0.1) !important;
    color: #d4af37 !important;
}
/* --- 修复：图标太多不换行的问题 --- */
#qz-badge-container {
    display: flex !important;       /* 强制改为 flex */
    flex-wrap: wrap !important;     /* 强制允许换行 */
    gap: 5px !important;            /* 图标之间的间距 */
    margin-left: 5px;
    max-width: 100%;                /* 防止撑破屏幕 */
    align-items: center;
}

/* --- 新增：SVIP 样式库 --- */

/* 1. 经典黄 (默认) */
.qz-svip-badge.style-yellow {
    background: linear-gradient(90deg, #FFC107, #FF9800);
    color: white;
    border: 1px solid rgba(255,255,255,0.5);
}

/* 2. 黑金尊贵版 (Black & Gold) */
.qz-svip-badge.style-black-gold {
    background: linear-gradient(135deg, #333 0%, #000 100%);
    color: #FFD700; /* 金色文字 */
    border: 1px solid #FFD700;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}
.qz-svip-badge.style-black-gold i {
    color: #FFD700 !important;
    font-style: italic;
    font-weight: 900;
}

/* 3. 黑红霸气版 (Black & Red) */
.qz-svip-badge.style-black-red {
    background: linear-gradient(135deg, #1a0000 0%, #2b0505 100%);
    color: #FF5252; /* 亮红色文字 */
    border: 1px solid #FF5252;
    box-shadow: 0 1px 3px rgba(0,0,0,0.5);
}
.qz-svip-badge.style-black-red i {
    color: #FF1744 !important;
    text-shadow: 0 0 2px #FF1744;
}
/* === 修复：评论区和输入框的透明度 === */

/* 1. 当有自定义背景时，让评论区变成半透明 */
#social-zone-screen.has-custom-bg .qz-comments-section {
    /* 使用 30% 不透明度的白色，既能看清文字，又能透出背景 */
    background-color: rgba(255, 255, 255, 0.2) !important;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/* 2. 顺便把底部的“说点什么吧”输入框也变半透明 */
#social-zone-screen.has-custom-bg .qz-inline-input {
    background-color: rgba(255, 255, 255, 0.2) !important;
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #333 !important;
}

/* 3. 还有音乐卡片，也让它变透明 */
#social-zone-screen.has-custom-bg .qz-music-card {
    background-color: rgba(255, 255, 255, 0.3) !important;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/* --- 如果你用了【暗黑金】主题，评论区要变成半透明黑色 --- */
#social-zone-screen.has-custom-bg.qz-theme-darkgold .qz-comments-section,
#social-zone-screen.has-custom-bg.qz-theme-darkgold .qz-inline-input,
#social-zone-screen.has-custom-bg.qz-theme-darkgold .qz-music-card {
    background-color: rgba(0, 0, 0, 0.2) !important;
    border: 1px solid rgba(255, 215, 0, 0.1);
    color: #d4af37 !important;
}

/* 修复暗黑模式下名字链接看不清的问题 */
#social-zone-screen.has-custom-bg.qz-theme-darkgold .qz-user-link {
    color: #fdd835 !important; /* 亮金色 */
}
#social-zone-screen.has-custom-bg.qz-theme-darkgold .qz-like-display i {
    color: #d4af37 !important;
}
/* ========================================= */
/* ❤️ 情侣默契大挑战 - 完整样式整合版 (V-Final) ❤️ */
/* ========================================= */

/* --- 1. 游戏容器与基础布局 --- */
.cp-game-container {
    padding: 20px;
    height: 100%;
    overflow-y: auto;
    background-color: #fce4ec; /* 默认浅粉背景 */
    display: flex;
    flex-direction: column;
}

/* 步骤容器 (默认隐藏) */
.cp-step-container {
    display: none;
    animation: fadeIn 0.5s;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    margin-bottom: 20px;
}
.cp-step-container.active { display: block; }

/* 题目卡片区域 */
.cp-question-card { text-align: center; margin-top: 20px;}
.cp-question-text {
    font-size: 22px; font-weight: bold; color: #333;
    margin-bottom: 25px; min-height: 60px;
    display: flex; align-items: center; justify-content: center;
    line-height: 1.4;
}

/* 进度条 */
.cp-progress-bar {
    height: 6px; background: #eee; margin-bottom: 10px;
    border-radius: 3px; overflow: hidden;
}
.cp-progress-fill {
    height: 100%; background: var(--theme-primary, #7b1fa2); width: 0%; transition: width 0.3s;
}

/* 选项按钮 (答题时) */
.cp-opt-btn {
    display: block; width: 100%; padding: 12px 15px; margin-bottom: 10px;
    border: 1px solid #ddd; border-radius: 50px; background: white;
    cursor: pointer; text-align: center; transition: all 0.2s;
    font-size: 15px; color: #555;
}
.cp-opt-btn:hover { background: #f5f5f5; }
.cp-opt-btn.selected { 
    background: var(--theme-primary, #7b1fa2); 
    color: white; border-color: var(--theme-primary, #7b1fa2); 
    font-weight: bold;
}

/* 皮肤选择器容器 */
.cp-skin-selector { 
    display: flex; gap: 12px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap; 
    padding: 10px; background: rgba(255,255,255,0.6); border-radius: 30px;
}
.cp-skin-btn { 
    width: 30px; height: 30px; border-radius: 50%; cursor: pointer; 
    border: 2px solid rgba(255,255,255,0.5); box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: transform 0.2s;
}
.cp-skin-btn.active { transform: scale(1.25); border-color: #333; z-index: 1; }

/* 截图区域容器 */
#cp-capture-area { 
    padding: 20px; 
    border-radius: 12px;
    /* 默认背景，会被皮肤样式覆盖 */
    background: white; 
    width: 100%;
    box-sizing: border-box;
}


/* --- 2. 结果卡片通用结构 (Skeleton) --- */
.cp-result-card {
    border-radius: 12px; overflow: hidden;
    /* 默认边框和阴影，皮肤可覆盖 */
    border: 1px solid #e0e0e0; 
    box-shadow: 0 8px 25px rgba(0,0,0,0.08); 
    background: white;
}

.cp-rc-header { padding: 25px 20px; text-align: center; color: white; position: relative; }
.cp-rc-title { font-size: 20px; font-weight: 900; margin-bottom: 5px; letter-spacing: 1px; }
.cp-rc-meta { font-size: 12px; opacity: 0.8; }

.cp-rc-avatars { display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 15px; }
.cp-rc-avatar { 
    width: 64px; height: 64px; border-radius: 50%; border: 3px solid white; 
    background: #ddd; overflow: hidden; box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.cp-rc-avatar img { width: 100%; height: 100%; object-fit: cover; }
.cp-rc-vs { font-size: 20px; font-weight: bold; opacity: 0.6; color: white; }

.cp-rc-body { padding: 20px; background: #f9f9f9; }

/* 每一道题的行 */
.cp-rc-row { 
    background: white; border-radius: 10px; margin-bottom: 15px; padding: 15px; 
    box-shadow: 0 1px 2px rgba(0,0,0,0.03); border: 1px solid #f0f0f0;
}

.cp-rc-q { 
    font-weight: bold; color: #444; margin-bottom: 10px; font-size: 15px;
    line-height: 1.4; border-bottom: 1px dashed #eee; padding-bottom: 8px;
}

/* 填空题：左右对话模式 */
.cp-ans-row {
    display: flex; justify-content: space-between; align-items: stretch;
    font-size: 14px; margin-top: 5px; line-height: 1.5;
}
.cp-ans-user { 
    flex: 1; text-align: left; color: #1976d2; 
    padding-right: 15px; border-right: 1px solid #eee; word-wrap: break-word; 
}
.cp-ans-ai { 
    flex: 1; text-align: right; color: #e91e63; 
    padding-left: 15px; word-wrap: break-word; 
}

/* 选择题：标签模式 */
.cp-opt-tag {
    display: inline-block;
    padding: 4px 10px; border-radius: 12px;
    background: #f5f5f5; color: #999;
    font-size: 12px; margin: 0 6px 6px 0;
    border: 1px solid transparent;
}
/* 用户选的 */
.cp-opt-tag.active-user { background: #e3f2fd; color: #1565c0; border-color: #bbdefb; }
/* AI选的 */
.cp-opt-tag.active-ai { background: #fce4ec; color: #c2185b; border-color: #f8bbd0; }
/* 默契 (都选了) */
.cp-match-tag {
    background: #e1bee7; color: #7b1fa2; font-weight: bold;
    border: 1px solid #ba68c8; padding: 4px 12px;
    position: relative; box-shadow: 0 2px 4px rgba(123, 31, 162, 0.1);
}
.cp-match-tag::after { 
    content: '❤️'; font-size: 10px; position: absolute; top: -5px; right: -5px; 
    filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));
}

/* AI 吐槽气泡 */
.cp-ai-comment { 
    font-size: 12px; color: #777; font-style: italic; margin-top: 8px; 
    background: rgba(0,0,0,0.03); padding: 6px 10px; border-radius: 6px; 
}


/* ========================================= */
/* 🎨 7大皮肤完整样式定义 (Skins) 🎨 */
/* ========================================= */

/* 1. 经典紫 (Default) */
.skin-default #cp-capture-area { background: #f3e5f5; }
.skin-default .cp-rc-header { background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); }

/* 2. 甜蜜粉 (Pink) - 恋爱感 */
.skin-pink #cp-capture-area { background-color: #fff0f5; }
.skin-pink .cp-result-card { border: 2px solid #f8bbd0; border-radius: 24px; box-shadow: none; }
.skin-pink .cp-rc-header { background: #f48fb1; color: #fff; border-bottom: 4px dotted #fff; }
.skin-pink .cp-rc-body { background: #fff0f5; }
.skin-pink .cp-rc-row { border: 1px solid #fce4ec; background: #fff; border-radius: 16px; }
.skin-pink .cp-rc-q { color: #d81b60; border-bottom-color: #f8bbd0; }
.skin-pink .cp-ans-user { color: #d81b60; border-right-color: #f8bbd0; }
.skin-pink .cp-ans-ai { color: #880e4f; }
.skin-pink .cp-match-tag { background: #f8bbd0; color: #c2185b; border-color: #f06292; }

/* 3. 极客黑 (Dark) - 酷炫风 */
.skin-dark #cp-capture-area { background-color: #212121; }
.skin-dark .cp-result-card { border: 1px solid #444; background: #333; }
.skin-dark .cp-rc-header { background: #111; color: #ffd700; border-bottom: 1px solid #333; }
.skin-dark .cp-rc-body { background: #212121; }
.skin-dark .cp-rc-row { background: #2c2c2c; color: #ccc; border: 1px solid #444; }
.skin-dark .cp-rc-q { color: #eee; border-bottom-color: #444; }
.skin-dark .cp-ans-user { color: #64b5f6; border-right-color: #444; }
.skin-dark .cp-ans-ai { color: #f48fb1; }
.skin-dark .cp-ai-comment { background: #333; color: #999; }
.skin-dark .cp-opt-tag { background: #333; color: #777; border-color: #444; }
.skin-dark .cp-match-tag { background: #4a148c; color: #e040fb; border-color: #7b1fa2; }

/* 4. 复古纸 (Paper) - 报纸风 */
.skin-paper #cp-capture-area { background-color: #fdfbf7; }
.skin-paper .cp-result-card { border: 4px double #5d4037; border-radius: 2px; }
.skin-paper .cp-rc-header { background: #d7ccc8; color: #3e2723; border-bottom: 2px solid #5d4037; }
.skin-paper .cp-rc-body { background: #efebe9; }
.skin-paper .cp-rc-row { background: #fff; border: 1px solid #a1887f; border-radius: 0; box-shadow: 2px 2px 0 rgba(93, 64, 55, 0.2); }
.skin-paper .cp-rc-q { color: #3e2723; font-family: "Courier New", serif; font-weight: 900; border-bottom: 1px solid #a1887f; }
.skin-paper .cp-ans-user { color: #3e2723; border-right: 1px dashed #a1887f; font-family: "Courier New", serif; }
.skin-paper .cp-ans-ai { color: #5d4037; font-family: "Courier New", serif; }
.skin-paper .cp-match-tag { background: #efebe9; color: #b71c1c; border: 1px double #b71c1c; }

/* 5. 软萌拟态 (Neumorphism) - 立体感 */
.skin-neumorphism #cp-capture-area { background-color: #e0e5ec; }
.skin-neumorphism .cp-result-card { border: none; background: #e0e5ec; box-shadow: 9px 9px 16px rgb(163,177,198,0.6), -9px -9px 16px rgba(255,255,255, 0.5); border-radius: 20px; }
.skin-neumorphism .cp-rc-header { background: transparent; color: #4d5b6d; padding-bottom: 10px; }
.skin-neumorphism .cp-rc-body { background: #e0e5ec; }
.skin-neumorphism .cp-rc-row { background: #e0e5ec; box-shadow: 5px 5px 10px #b8b9be, -5px -5px 10px #ffffff; border-radius: 15px; color: #555; border: none; }
.skin-neumorphism .cp-rc-q { color: #444; border-bottom: 1px solid rgba(0,0,0,0.05); }
.skin-neumorphism .cp-opt-tag { background: #e0e5ec; box-shadow: 3px 3px 6px #b8b9be, -3px -3px 6px #ffffff; border-radius: 10px; color: #888; }
.skin-neumorphism .cp-match-tag { color: #9C27B0; background: #e0e5ec; border: none; box-shadow: inset 2px 2px 5px #b8b9be, inset -2px -2px 5px #ffffff; }

/* 6. 仲夏夜 (Summer) - 清新撞色 */
.skin-summer #cp-capture-area { background-color: #fff9c4; }
.skin-summer .cp-result-card { border: 3px solid #ffab91; background: #fff; border-radius: 0 20px 0 20px; box-shadow: 6px 6px 0 rgba(255, 171, 145, 0.4); }
.skin-summer .cp-rc-header { background: linear-gradient(to right, #ffab91, #ffcc80); color: #bf360c; }
.skin-summer .cp-rc-body { background: #fffde7; }
.skin-summer .cp-rc-row { background: #ffffff; border: 2px dashed #81d4fa; border-radius: 12px; box-shadow: none; }
.skin-summer .cp-rc-q { color: #f57f17; font-weight: bold; border-bottom-color: #81d4fa; }
.skin-summer .cp-ans-user { color: #0288d1; border-right-color: #b3e5fc; }
.skin-summer .cp-ans-ai { color: #d84315; }
.skin-summer .cp-match-tag { background: #c8e6c9; color: #2e7d32; border: 2px solid #81c784; }

/* 7. 富士山下 (Snow) - 冰蓝透亮 */
.skin-snow #cp-capture-area { background-color: #e3f2fd; }
.skin-snow .cp-result-card { border: 1px solid #bbdefb; background: rgba(255,255,255,0.7); backdrop-filter: blur(10px); border-radius: 12px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1); }
.skin-snow .cp-rc-header { background: linear-gradient(180deg, #bbdefb 0%, #ffffff 100%); color: #546e7a; border-bottom: 1px solid #e3f2fd; }
.skin-snow .cp-rc-body { background: transparent; }
.skin-snow .cp-rc-row { background: rgba(255, 255, 255, 0.8); border: 1px solid #e1f5fe; box-shadow: 0 2px 10px rgba(225, 245, 254, 0.5); }
.skin-snow .cp-rc-q { color: #455a64; letter-spacing: 1px; border-bottom-color: #e1f5fe; }
.skin-snow .cp-ans-user { color: #78909c; border-right-color: #e1f5fe; }
.skin-snow .cp-ans-ai { color: #90a4ae; }
.skin-snow .cp-match-tag { background: linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%); color: #0277bd; box-shadow: 0 0 10px #b3e5fc; border: none; }
/* ========================================= */
/* 🚑 结果卡片“拒绝窄长条”宽屏补丁 🚑 */
/* ========================================= */

/* 1. 针对结果页(Step 3)，去掉外层的白色大框和内边距 */
#cp-step-3.cp-step-container {
    padding: 0 !important;           /* 核心：去掉外层内边距 */
    background: transparent !important; /* 核心：去掉背景，让卡片直接浮在底色上 */
    box-shadow: none !important;     /* 去掉外层阴影 */
    margin-top: 10px;
}

/* 2. 让截图区域(Capture Area) 撑满屏幕宽度 */
#cp-capture-area {
    width: 100% !important;
    box-sizing: border-box !important;
    padding: 10px !important;       /* 截图边缘留白减小，原来是20px */
    margin: 0 auto !important;
    border-radius: 12px;
}

/* 3. 结果卡片本身 (Result Card) 撑满 */
.cp-result-card {
    width: 100% !important;
    margin: 0 !important;
    border-radius: 12px !important;
    /* 稍微减小卡片内部的边距，让文字显示区域更宽 */
}
.cp-rc-header {
    padding: 15px !important; /* 头部缩减 */
}
.cp-rc-body {
    padding: 10px !important; /* 内容区缩减 */
}

/* 4. 调整皮肤选择器和按钮的位置 (因为去掉了外层Padding，要手动加一点距) */
.cp-skin-selector {
    margin: 10px auto 15px auto !important;
    width: 95% !important;
}

/* 5. 按钮组样式微调 */
#cp-step-3 .form-button {
    margin-left: 5px;
    margin-right: 5px;
    width: calc(50% - 10px); /* 按钮各占一半宽度 */
}
/* 按钮容器 */
#cp-step-3 > div:last-child {
    padding: 0 10px 20px 10px; /* 给底部留点空隙 */
}
/* ========================================= */
/* 🚑 问卷卡片排版修复补丁 🚑 */
/* 原因：强制忽略代码缩进产生的空格 */
/* ========================================= */

/* 1. 针对“默契问卷报告”分享卡片 */
.message.cp-share-card,
/* 2. 针对“默契挑战邀请”卡片 */
.message.game-invite-card {
    /* 核心：让文本正常换行，忽略代码里的缩进空格 */
    white-space: normal !important; 
    word-wrap: break-word !important;
    
    /* 修复：移除气泡默认的内边距，改由卡片内部控制，避免双重边距 */
    padding: 0 !important; 
    
    /* 美化：确保背景色圆角不溢出 */
    overflow: hidden;
    
    /* 确保宽度适中 */
    width: 250px !important; 
    max-width: 100% !important;
}

/* 额外优化：让邀请卡片的按钮居中更好看 */
.message.game-invite-card .form-button {
    margin: 0 auto;
}
/* ========================================= */
/* 🚑 截图渲染与布局紧急修复补丁 V2 🚑 */
/* ========================================= */

/* 1. 修复：默契选项 (cp-match-tag) 的布局炸裂问题 */
.cp-match-tag {
    /* 改用 Flex 布局，让爱心和文字自然排列，不要用 absolute */
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    gap: 4px !important; /* 文字和爱心的间距 */
    
    /* 强制限制最大宽度，防止被撑爆 */
    max-width: 100% !important;
    white-space: normal !important; /* 允许换行 */
    height: auto !important;
    
    /* 稍微加粗边框，提升质感 */
    border: 1px solid #ba68c8 !important;
    
    /* 移除可能导致计算错误的旧样式 */
    position: static !important; 
}

/* ★★★ 核心修复：彻底禁用伪元素，防止 html2canvas 算错尺寸 ★★★ */
.cp-match-tag::after {
    content: none !important;
    display: none !important;
}

/* 2. 修复：拟态风格 (Neumorphism) 截图变灰/无光影的问题 */
.skin-neumorphism .cp-result-card,
.skin-neumorphism .cp-rc-row, 
.skin-neumorphism .cp-opt-tag,
.skin-neumorphism .cp-match-tag {
    /* A. 既然阴影渲染不出来，我们就加一个极淡的边框来维持轮廓 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    
    /* B. 使用更“硬”的阴影颜色，放弃 rgba 半透明，改用实色，帮助截图引擎识别 */
    /* 左上白光，右下深灰 */
    box-shadow: 
        -4px -4px 10px #ffffff, 
        4px 4px 10px #a3b1c6 !important; 
}

/* 拟态风格下的背景色微调，避免灰成一团 */
.skin-neumorphism #cp-capture-area {
    background-color: #e0e5ec !important;
}
/* --- 史莱姆快捷面板 --- */
#pet-quick-menu {
    position: absolute;
    bottom: 100%; /* 显示在史莱姆上方 */
    left: 50%;
    transform: translateX(-50%);
    width: 140px;
    background-color: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(5px);
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.15);
    padding: 8px;
    margin-bottom: 10px; /* 离史莱姆有点距离 */
    display: none; /* 默认隐藏 */
    flex-direction: column;
    gap: 5px;
    z-index: 1000;
    border: 1px solid rgba(0,0,0,0.05);
    animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
/* 小箭头指向下面 */
#pet-quick-menu::after {
    content: '';
    position: absolute;
    bottom: -6px;
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px 6px 0;
    border-style: solid;
    border-color: rgba(255, 255, 255, 0.95) transparent transparent transparent;
}

@keyframes popIn {
    from { opacity: 0; transform: translateX(-50%) scale(0.8) translateY(10px); }
    to { opacity: 1; transform: translateX(-50%) scale(1) translateY(0); }
}

.pet-menu-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 13px;
    color: #555;
    padding: 6px 8px;
    background: #f7f9fa;
    border-radius: 8px;
    cursor: pointer;
}

.pet-menu-label {
    font-weight: 600;
}

/* 迷你开关样式 */
.mini-switch {
    position: relative;
    width: 34px;
    height: 18px;
}
.mini-switch input { opacity: 0; width: 0; height: 0; }
.mini-slider {
    position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
    background-color: #ccc; transition: .4s; border-radius: 18px;
}
.mini-slider:before {
    position: absolute; content: ""; height: 14px; width: 14px; left: 2px; bottom: 2px;
    background-color: white; transition: .4s; border-radius: 50%;
}
input:checked + .mini-slider { background-color: var(--theme-primary); }
input:checked + .mini-slider:before { transform: translateX(16px); }
/* --- QQ空间回顶按钮样式 --- */
.qz-back-to-top {
    position: fixed; /* 固定定位，悬浮在屏幕上 */
    bottom: 80px;    /* 距离底部的高度，避开底部导航栏或输入框 */
    right: 20px;     /* 距离右侧的距离 */
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.85); /* 半透明白色背景 */
    backdrop-filter: blur(8px); /* 磨砂玻璃效果 */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
    display: none;   /* 默认隐藏，滑动后才显示 */
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 500;    /* 确保层级够高 */
    color: #555;
    transition: all 0.3s ease;
    border: 1px solid rgba(0,0,0,0.05);
}

.qz-back-to-top:hover {
    transform: translateY(-3px);
    background-color: #fff;
    color: var(--theme-primary); /* 悬浮变色 */
}

/* 暗黑金主题适配 */
.qz-theme-darkgold .qz-back-to-top {
    background-color: rgba(50, 50, 50, 0.85);
    color: #d4af37;
    border: 1px solid #d4af37;
}
/* ========================================= */
/* 🎁 礼物卡 (压缩精致版) */
/* ========================================= */
.message.gift-card {
    /* 核心修复：强制忽略代码空格，防止卡片被撑大 */
    white-space: normal !important; 
    
    background: #fff;
    color: #333;
    width: 220px; /* 宽度从 250 -> 220 */
    padding: 12px 15px; /* 边距大幅减小 */
    border-radius: 16px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
    border: 1px solid rgba(0,0,0,0.03);
    text-align: center;
    font-family: 'Helvetica Neue', sans-serif;
    position: relative;
    overflow: hidden;
    margin: -5px; /* 抵消一部分原有气泡的内边距，让它贴边 */
}
/* 光晕也调小一点 */
.message.gift-card::after {
    content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255,192,203,0.1), transparent);
    transform: rotate(45deg); pointer-events: none;
}
.gift-icon-main {
    font-size: 32px; /* 图标缩小 */
    color: #ff8da1; margin-bottom: 6px;
    filter: drop-shadow(0 4px 6px rgba(255, 141, 161, 0.3));
}
.gift-title { font-size: 14px; font-weight: 700; color: #2d3436; margin-bottom: 2px; }
.gift-price { font-size: 12px; color: #b2bec3; font-weight: 500; margin-bottom: 10px; }
.gift-btn {
    background: #2d3436; color: #fff; padding: 6px 0; /* 按钮变薄 */
    border-radius: 8px;
    font-size: 11px; font-weight: 600; cursor: pointer; transition: 0.2s;
    display: block; width: 100%;
}
.gift-btn i { margin-right: 4px; }


/* ========================================= */
/* 🥡 外卖小票 (压缩精致版) */
/* ========================================= */
.message.takeout-card {
    /* 核心修复 */
    white-space: normal !important;
    
    background: #fff; 
    width: 230px; /* 宽度缩小 */
    border-radius: 4px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    border: 1px solid #eee;
    font-family: 'Courier New', monospace;
    position: relative;
    margin: -5px; /* 抵消气泡内边距 */
}
.takeout-card::before {
    content: ''; position: absolute; top: -4px; left: 0; right: 0; height: 8px;
    background: radial-gradient(circle, transparent 3px, #fff 4px);
    background-size: 8px 8px; background-position: 0 4px;
}
.takeout-header {
    padding: 10px 12px 8px; /* 头部压缩 */
    border-bottom: 1px dashed #ddd;
    display: flex; justify-content: space-between; align-items: center;
}
.takeout-shop { font-weight: 800; font-size: 12px; color: #333; }
.takeout-status { font-size: 9px; background: #333; color: #fff; padding: 1px 4px; border-radius: 2px; }

.takeout-list { 
    padding: 8px 12px; 
    max-height: 120px; /* 限制高度，防止太长 */
    overflow-y: auto;
}
.takeout-row { display: flex; justify-content: space-between; font-size: 11px; color: #555; margin-bottom: 4px; }

.takeout-total {
    border-top: 1px dashed #ddd; padding: 8px 12px;
    display: flex; justify-content: space-between; font-weight: 800; font-size: 14px;
}
/* 备注区压缩 */
.takeout-note-box {
    background: #fff9c4; padding: 6px 8px; margin: 0 12px 10px;
    border-radius: 3px; border-left: 2px solid #fbc02d;
    font-size: 10px; color: #555; line-height: 1.3;
}
.takeout-note-title { font-weight: bold; margin-bottom: 1px; color: #f57f17; font-size: 9px; }

.takeout-actions { display: flex; border-top: 1px solid #f0f0f0; }
.takeout-action-btn {
    flex: 1; text-align: center; padding: 8px 0; font-size: 10px; font-weight: 600; /* 按钮压缩 */
    color: #333; cursor: pointer;
}
/* ========================================= */
/* ✨ Ins风：通用优雅弹窗 (替代丑丑的alert) */
/* ========================================= */
/* 1. 全屏遮罩：带模糊效果 */
.ins-modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.2); /* 淡淡的黑 */
    backdrop-filter: blur(10px);    /* 强力毛玻璃 */
    z-index: 99999;                 /* 保证在最上层 */
    display: flex; align-items: center; justify-content: center;
    opacity: 0; animation: insFadeIn 0.3s forwards; /* 淡入动画 */
}

/* 2. 弹窗卡片：居中、圆角、阴影 */
.ins-modal-box {
    background: #fff;
    width: 75%; max-width: 320px;
    border-radius: 30px;
    padding: 30px 25px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.1);
    transform: scale(0.8); animation: insScaleUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

/* 3. 弹窗内容样式 */
.ins-modal-icon { font-size: 40px; color: #ff8da1; margin-bottom: 15px; }
.ins-modal-title { font-size: 16px; font-weight: 700; color: #2d3436; margin-bottom: 10px; font-family: 'Helvetica Neue', sans-serif; }
.ins-modal-text { 
    font-size: 14px; color: #636e72; line-height: 1.6; margin-bottom: 25px; 
    white-space: pre-wrap; /* 保留换行 */
    text-align: left; /* 文字左对齐更易读，或者 center 也可以 */
    background: #fdfdfd; padding: 15px; border-radius: 15px; border: 1px solid #f5f5f5;
}

/* 4. 关闭按钮 */
.ins-modal-close {
    background: #2d3436; color: #fff; border: none;
    padding: 10px 30px; border-radius: 20px;
    font-size: 13px; font-weight: 600; cursor: pointer;
    box-shadow: 0 5px 15px rgba(45, 52, 54, 0.3);
    transition: transform 0.1s;
}
.ins-modal-close:active { transform: scale(0.95); }

/* 动画关键帧 */
@keyframes insFadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes insScaleUp { from { transform: scale(0.8); } to { transform: scale(1); } }
/* ========================================= */
/* 📱 反向查手机 (Phone Simulator) 专属样式 */
/* ========================================= */
#phone-simulator-screen {
    background-color: #222;
    color: #333;
}

/* 模拟器容器 */
.ps-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background: #fff;
    position: relative;
}

/* 顶部状态栏模拟 */
.ps-status-bar {
    height: 30px;
    background: #fff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 15px;
    font-size: 12px;
    font-weight: bold;
    border-bottom: 1px solid rgba(0,0,0,0.05);
}

/* 内容区域 */
.ps-screen-content {
    flex: 1;
    overflow-y: auto;
    position: relative;
    /* 隐藏滚动条 */
    scrollbar-width: none; 
}
.ps-screen-content::-webkit-scrollbar { display: none; }

/* --- 微信风格 --- */
.ps-wx-header {
    height: 44px;
    background: #ededed;
    border-bottom: 1px solid #dcdcdc;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 15px;
    font-size: 16px;
    font-weight: bold;
    position: sticky; top: 0; z-index: 10;
}
.ps-wx-list { padding: 15px; background: #f2f2f2; min-height: 100%; }
.ps-wx-msg { display: flex; gap: 10px; margin-bottom: 15px; }
.ps-wx-msg.me { flex-direction: row-reverse; }
.ps-wx-avatar { width: 40px; height: 40px; border-radius: 4px; background: #ddd; flex-shrink: 0; }
.ps-wx-content { max-width: 70%; }
.ps-wx-name { font-size: 12px; color: #999; margin-bottom: 2px; }
.ps-wx-msg.me .ps-wx-name { display: none; text-align: right; }
.ps-wx-bubble { 
    padding: 10px 12px; border-radius: 4px; font-size: 15px; line-height: 1.5; 
    background: #fff; word-break: break-all; position: relative;
}
.ps-wx-msg.me .ps-wx-bubble { background: #95ec69; }
.ps-wx-time { text-align: center; font-size: 12px; color: #ccc; margin: 15px 0; }

/* --- 抖音风格 --- */
.ps-dy-container { background: #161823; min-height: 100%; padding: 10px; color: white; }
.ps-dy-item { display: flex; gap: 12px; margin-bottom: 15px; }
.ps-dy-cover { width: 60px; height: 80px; background: #333; border-radius: 4px; display:flex; align-items:center; justify-content:center; color:#555;}

/* --- 浏览器风格 --- */
.ps-br-container { background: #fff; min-height: 100%; }
.ps-br-item { padding: 15px; border-bottom: 1px solid #f9f9f9; display: flex; align-items: center; gap: 12px; }

/* --- 支付宝风格 --- */
.ps-ali-container { background: #f5f5f5; min-height: 100%; }
.ps-ali-header { background: #1677ff; padding: 20px; color: white; height: 100px; display:flex; flex-direction:column; justify-content:center; }
.ps-ali-item { background: #fff; padding: 15px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #f0f0f0; }

/* --- 底部 Dock 栏 --- */
.ps-dock {
    height: 60px;
    background: #f7f7f7;
    border-top: 1px solid #ccc;
    display: flex;
    justify-content: space-around;
    align-items: center;
}
.ps-dock-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 10px;
    color: #999;
    cursor: pointer;
}
.ps-dock-item.active { color: #07c160; } /* 微信绿 */
.ps-dock-item.active[data-app="alipay"] { color: #1677ff; }
.ps-dock-item.active[data-app="tiktok"] { color: #fff; text-shadow: 0 0 5px rgba(0,0,0,0.5); } 
/* 适配抖音底栏背景 */
.ps-dock.dark-mode { background: #000; border-top: 1px solid #333; }

.ps-dock-icon { font-size: 24px; margin-bottom: 2px; }

/* 浮动操作按钮 */
.ps-fab {
    position: absolute; bottom: 80px; right: 20px;
    width: 50px; height: 50px; border-radius: 50%;
    background: var(--theme-primary); color: white;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    cursor: pointer; z-index: 100;
}
/* ========================================= */
/* 🚑 抖音底栏消失 & 布局紧急修复补丁 */
/* ========================================= */

/* 1. 强制限制模拟器容器的高度，防止被内容撑爆 */
.ps-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* 关键：隐藏溢出，防止底栏被挤走 */
    background: #fff;
    position: relative;
    height: 100%; /* 确保占满父容器 */
    min-height: 0; /* Flex布局嵌套滚动的关键修正 */
}

/* 2. 修正屏幕内容的滚动机制 */
.ps-screen-content {
    flex: 1;
    overflow-y: auto; /* 让内容在内部滚动，而不是撑大容器 */
    height: auto;     /* 移除固定高度 */
    min-height: 0;    /* 配合父级 Flex */
}

/* 3. 专门修复抖音界面的高度问题 */
.ps-dy-container {
    background: #161823;
    min-height: auto !important; /* 覆盖原来的 100%，由 Flex 控制高度 */
    height: 100%; /* 占满剩余空间 */
    padding: 10px;
    color: white;
    overflow-y: auto; /* 允许内部滚动 */
}

/* 4. 修复底部 Dock 栏在暗黑模式下的显示 */
.ps-dock {
    flex-shrink: 0; /* 防止被挤压 */
    z-index: 50;    /* 确保层级最高 */
    position: relative;
}

/* 抖音模式(dark-mode)下的底栏样式 */
.ps-dock.dark-mode {
    background-color: #000 !important; /* 纯黑背景 */
    border-top: 1px solid #333 !important; /* 深色边框 */
}

/* 暗黑模式下，未选中的图标强制变亮一点的灰色，否则看不见 */
.ps-dock.dark-mode .ps-dock-item {
    color: #666 !important; 
}

/* 暗黑模式下，选中的图标强制变纯白 */
.ps-dock.dark-mode .ps-dock-item.active {
    color: #fff !important;
    text-shadow: 0 0 10px rgba(255,255,255,0.5); /* 加点发光效果 */
}
/* --- 虚拟伴侣移植版样式 --- */
#companion-screen { font-family: 'Nunito', sans-serif; }

#cp-character {
    width: 100%; height: 100%; 
    background-position: center; background-size: cover; background-repeat: no-repeat;
    transition: all 0.5s ease;
}
#cp-character.breathe { animation: cp-breathe-anim 6s infinite ease-in-out; transform-origin: bottom center; }
@keyframes cp-breathe-anim { 0% { transform: scale(1); } 50% { transform: scale(1.03); } 100% { transform: scale(1); } }

/* 热区 */
#cp-zone-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
.cp-mode-edit #cp-zone-container { background: rgba(0,0,0,0.3); pointer-events: auto; }
.cp-zone-circle { position: absolute; transform: translate(-50%, -50%); border-radius: 50%; box-sizing: border-box; }
.cp-mode-play .cp-zone-circle { background: transparent; cursor: pointer; pointer-events: auto; }
.cp-mode-play .cp-zone-circle:active { background: rgba(255,255,255,0.2); }
.cp-mode-edit .cp-zone-circle { background: rgba(255, 255, 255, 0.2); border: 2px dashed #ff8b8b; z-index: 11; pointer-events: auto; }
.cp-mode-edit .cp-zone-circle.selected { background: rgba(142, 197, 252, 0.5); border: 2px solid #fff; box-shadow: 0 0 10px white; }

/* UI 元素 */
#cp-timer-display {
    position: absolute; top: 80px; width: 100%; text-align: center;
    font-size: 50px; font-weight: bold; color: white; 
    text-shadow: 0 2px 10px rgba(0,0,0,0.3); display: none; z-index: 5; pointer-events: none;
}
#cp-bubble {
    position: absolute; bottom: 220px; left: 50%; transform: translateX(-50%); width: 80%;
    background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(10px);
    padding: 15px 20px; border-radius: 20px; box-shadow: 0 5px 20px rgba(0,0,0,0.05);
    text-align: center; font-size: 15px; color: #444; z-index: 20;
    transition: opacity 0.3s, transform 0.3s;
    pointer-events: none; /* 让点击穿透到立绘 */
}
#cp-bubble::after {
    content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%) rotate(45deg);
    width: 12px; height: 12px; background: rgba(255,255,255,0.85);
}

.cp-controls-container {
    position: absolute; bottom: 40px; left: 0; width: 100%;
    display: flex; flex-direction: column; align-items: center; gap: 15px; z-index: 30;
}
#cp-task-input {
    padding: 12px 20px; border-radius: 25px; border: 1px solid rgba(0,0,0,0.1);
    background: rgba(255,255,255,0.9); width: 260px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}
.cp-main-btn {
    padding: 12px 35px; border-radius: 50px; border: none;
    background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
    color: white; font-weight: 600; font-size: 16px; cursor: pointer;
    box-shadow: 0 5px 15px rgba(142, 197, 252, 0.4);
}
.cp-btn-stop { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); box-shadow: 0 5px 15px rgba(255, 154, 158, 0.4); }

/* 编辑器与设置 */
#cp-editor-toolbar {
    position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 90%;
    background: white; padding: 15px; border-radius: 16px; box-shadow: 0 5px 30px rgba(0,0,0,0.1);
    z-index: 100; display: none; flex-direction: column;
}
.cp-toolbar-row { display: flex; align-items: center; gap: 10px; font-size: 14px; }
.cp-mini-input { width: 80px; padding: 5px; border: 1px solid #ddd; border-radius: 4px; }
.cp-btn-del { background: #ffefef; color: #ff6b6b; border: none; padding: 5px 10px; border-radius: 4px; font-size: 12px; }
.cp-big-btn { width: 100%; padding: 12px; border-radius: 8px; border: none; cursor: pointer; font-weight: bold; }

#cp-settings-panel {
    display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: #fff; z-index: 200; flex-direction: column;
}
.image-upload-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px; }
.upload-box {
    background: #f4f4f4; border-radius: 8px; height: 80px;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    cursor: pointer; border: 2px dashed #ddd; overflow: hidden;
}
.upload-box.has-img { border-style: solid; border-color: #8ec5fc; }
.preview { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 20px; background-size: cover; background-position: center; }
/* --- 立绘管理样式修复补丁 --- */

/* 1. 让上传盒子变高一点，不再是扁扁的 80px */
.upload-box {
    height: 130px !important; /* 增加高度，给文字留出空间 */
    padding: 8px !important;  /* 内边距，让内容不贴边 */
    justify-content: space-between !important; /* 图片和文字上下撑开 */
    border: 1px solid #e0e0e0 !important; /* 边框柔和一点 */
    background-color: #fff !important;
}

/* 2. 图片预览区域：自动占据剩余空间 */
.upload-box .preview {
    width: 100% !important;
    height: auto !important; /* 取消固定高度 */
    flex-grow: 1 !important; /* 关键：自动填满上半部分 */
    background-size: contain !important; /* 改为 contain，保证图片完整显示不被裁剪 */
    background-repeat: no-repeat !important;
    background-position: center !important;
    border-radius: 4px;
    background-color: #f7f9fa; /* 给图片区加个浅底色 */
    margin-bottom: 6px !important; /* 和文字拉开距离 */
    
    /* 优化 Emoji 预览的大小 */
    font-size: 28px !important; 
}

/* 3. 文字标签：固定在底部，不被压缩 */
.upload-box .label {
    font-size: 12px !important;
    color: #666 !important;
    font-weight: 600 !important;
    text-align: center;
    flex-shrink: 0 !important; /* 关键：禁止文字被压缩 */
    height: 18px !important;
    line-height: 18px !important;
}

/* 4. 选中/有图片状态的美化 */
.upload-box.has-img {
    border: 2px solid var(--theme-primary) !important; /* 上传后边框变绿 */
    background-color: #f0f9eb !important; /* 微微泛绿的背景 */
}
.upload-box.has-img .preview {
    background-color: transparent !important; /* 有图片后去掉底色 */
}
/* --- 沉浸式模式 (Immersive Mode) --- */

/* 1. 当父容器有 .immersive 类时，隐藏多余元素 */
#companion-screen.immersive .api-header,           /* 顶栏 */
#companion-screen.immersive .cp-controls-container,/* 底部控制栏 */
#companion-screen.immersive #cp-editor-toolbar    /* 编辑栏 */ {    /* 倒计时 (可选，如果你想保留倒计时，把这行删掉) */
    display: none !important;
}

/* 2. 调整容器高度，占满全屏 */
#companion-screen.immersive #cp-app-container {
    height: 100vh !important;
    width: 100vw !important;
}

/* 3. 确保气泡和立绘依然可见 */
#companion-screen.immersive #cp-character,
#companion-screen.immersive #cp-bubble,
#companion-screen.immersive #cp-zone-container {
    display: block !important;
}
</style>
</head>
<body>
    <div id="app-container">
        <div id="screen">
            <div id="main-screen">
                <div class="app-header">
    <div class="app-title">聊天</div>
    <div>
        <i class="fas fa-user-plus action-btn" id="add-contact-btn" title="添加联系人"></i>
        <i class="fas fa-users action-btn" id="create-group-btn" title="创建群聊" style="margin-left: 15px;"></i>
    </div>
</div>
                
                <div class="contacts-container">
                </div>
                
                <div class="bottom-nav">
                    <div class="nav-item active" id="nav-chat">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-discover">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot"></div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-sms">
    <div class="nav-item-content">
        <div class="nav-icon"><i class="fas fa-sms"></i></div>
        <div>短信</div>
    </div>
</div>
                    <div class="nav-item" id="nav-profile">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="sms-screen" style="display: none; flex-direction: column; height: 100%;">
    <div class="app-header">
        <div class="app-title">秘密空间</div>
        <div></div>
    </div>

    <div class="feed-tabs" id="sms-tabs">
        <button class="feed-tab-btn active" data-tab="my-sms"><i class="fas fa-envelope"></i> 我的短信</button>
        <button class="feed-tab-btn" data-tab="snoop-mode"><i class="fas fa-user-secret"></i> 窥探模式</button>
    </div>

    <div class="contacts-container" id="sms-content-container" style="flex-grow: 1; overflow-y: auto;">
        <div style="text-align: center; padding: 50px 20px; color: #888;">
            <p>这里是短信和秘密的起点...</p>
        </div>
    </div>

    <div class="bottom-nav">
        <div class="nav-item" id="nav-chat-sms">
            <div class="nav-item-content">
                <div class="nav-icon"><i class="fas fa-comment"></i></div>
                <div>聊天</div>
            </div>
        </div>
        <div class="nav-item" id="nav-discover-sms">
            <div class="nav-item-content">
                <div class="nav-icon"><i class="fas fa-compass"></i></div>
                <div>发现</div>
            </div>
        </div>
        <div class="nav-item active" id="nav-sms-sms">
            <div class="nav-item-content">
                <div class="nav-icon"><i class="fas fa-sms"></i></div>
                <div>短信</div>
            </div>
        </div>
                <div class="nav-item" id="nav-profile-sms">
            <div class="nav-item-content">
                <div class="nav-icon"><i class="fas fa-user"></i></div>
                <div>我</div>
            </div>
        </div>
    </div>
</div>
<div id="snooped-phone-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-snooped-phone"><i class="fas fa-arrow-left"></i></div>
      <div class="api-title" id="snooped-contact-name">TA的手机</div>
        <div class="action-btn" id="refresh-snoop-data-btn" title="强制刷新数据">
            <i class="fas fa-sync-alt"></i>
            </div>
    </div>
    <div id="snoop-last-synced" style="font-size: 12px; color: #888; text-align: center; padding: 5px 0; background-color: #e9ecef;">
        上次同步时间: 暂无记录
    </div>
    <div class="api-content" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; padding: 30px 25px;">

            <div class="attachment-menu-item" data-snoop-app="shopping">
                <div class="icon-wrapper"><i class="fas fa-shopping-cart" style="color: #ff5722;"></i></div>
                <div class="label">🍑宝</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="memos">
                <div class="icon-wrapper"><i class="fas fa-sticky-note" style="color: #ffc107;"></i></div>
                <div class="label">备忘录</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="videos">
                <div class="icon-wrapper"><i class="fab fa-youtube" style="color: #f44336;"></i></div>
                <div class="label">抖Yin</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="novels">
                <div class="icon-wrapper"><i class="fas fa-book-reader" style="color: #9c27b0;"></i></div>
                <div class="label">小说</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="couple_app">
                <div class="icon-wrapper"><i class="fas fa-heartbeat" style="color: #ec407a;"></i></div>
                <div class="label">甜蜜空间</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="sms">
                <div class="icon-wrapper"><i class="fas fa-comment-dots" style="color: #4caf50;"></i></div>
                <div class="label">短信</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="call_log">
                <div class="icon-wrapper"><i class="fas fa-phone-alt" style="color: #2196f3;"></i></div>
                <div class="label">通话记录</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="browser">
                <div class="icon-wrapper"><i class="fab fa-safari" style="color: #03a9f4;"></i></div>
                <div class="label">浏览器</div>
            </div>

            <div class="attachment-menu-item" data-snoop-app="music">
                <div class="icon-wrapper"><i class="fas fa-music" style="color: #1DB954;"></i></div>
                <div class="label">音乐</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="photos">
                <div class="icon-wrapper"><i class="fas fa-images" style="color: #4CAF50;"></i></div>
                <div class="label">相册</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="assets">
                <div class="icon-wrapper"><i class="fas fa-wallet" style="color: #FFC107;"></i></div>
                <div class="label">资产</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="wechat">
                <div class="icon-wrapper"><i class="fab fa-weixin" style="color: #07C160;"></i></div>
                <div class="label">微信</div>
            </div>

            </div>
</div>
<div id="snooped-app-content-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-snooped-app"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title" id="snooped-app-title">应用内容</div>
        <div class="action-btn" id="refresh-snoop-app-btn" title="单独刷新此应用">
            <i class="fas fa-sync-alt"></i>
        </div>
        </div>
    <div class="api-content" id="snooped-app-content-body" style="flex-grow: 1; overflow-y: auto; padding: 10px;">
        </div>
</div>
            <div id="chat-screen">
                <div class="chat-header">
    <div class="back-btn" id="back-from-chat">
        <i class="fas fa-arrow-left"></i>
    </div>
    <div class="chat-info">
        <div class="chat-name" id="chat-contact-name"></div>
        <div class="chat-status" id="chat-contact-status"></div>
    </div>
    <div>
        <i class="fas fa-search action-btn" id="search-chat-btn" title="搜索聊天记录" style="margin-right: 15px; position: relative; z-index: 10000;" onclick="event.stopPropagation(); showChatSearch();"></i>
        <i class="fas fa-ellipsis-v action-btn" id="more-chat-options-btn" title="更多操作"></i>
    </div>
</div>
                <div id="chat-options-menu" style="display: none;">
                    <div class="chat-option-item" id="rewind-btn-menu"><i class="fas fa-undo fa-fw"></i> <span>回溯回复</span></div>
                    <div class="chat-option-item" id="summarize-chat-btn-menu"><i class="fas fa-feather-alt fa-fw"></i> <span>总结对话</span></div>
                    <div class="chat-option-item" id="toggle-chat-pet-btn-menu"><i class="fas fa-paw fa-fw"></i> <span>显示/隐藏宠物</span></div>
<div class="chat-option-item" id="delete-history-btn-menu"><i class="fas fa-trash-alt fa-fw"></i> <span>编辑消息</span></div>
<div class="chat-option-divider"></div>
<div class="chat-option-item" id="block-contact-btn-menu"><i class="fas fa-ban fa-fw"></i> <span>拉黑TA</span></div>
<div class="chat-option-item" id="contact-settings-btn-menu"><i class="fas fa-cog fa-fw"></i> <span>联系人设置</span></div>
                </div>
                <div id="heart-voice-panel" style="display: none;">
    <div class="hv-item">
        <span class="hv-icon">😊</span>
        <span class="hv-label">情绪：</span>
        <span class="hv-value" id="hv-emotion"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">💭</span>
        <span class="hv-label">思绪：</span>
        <span class="hv-value" id="hv-thoughts"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">❤️</span>
        <span class="hv-label">心率：</span>
        <span class="hv-value" id="hv-heart-rate"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">😶‍🌫️</span>
        <span class="hv-label">醋意：</span>
        <span class="hv-value" id="hv-jealousy"></span>
    </div>
</div>
                <div class="chat-messages" id="chat-messages">
                </div>
                <div id="emoticon-picker"></div>
                <div id="attachment-menu"></div>
                <div id="reply-preview-bar" style="display: none;"></div>
                <div class="chat-input-area" id="chat-input-area">
<div class="emoji-btn" id="emoji-btn"><i class="far fa-smile"></i></div>
                    <button class="attachment-btn" id="attachment-btn"><i class="fas fa-plus"></i></button>
                    <textarea id="message-input" placeholder="输入消息..." rows="1"></textarea>
                    <button id="send-btn" class="input-action-btn" title="发送消息"><i class="fas fa-arrow-up"></i></button>
                    <button id="request-reply-btn" class="input-action-btn" title="请求AI回复"><i class="fas fa-apple-whole"></i></button>
                </div>
<div id="edit-mode-bar">
    <button id="delete-selected-btn" class="edit-action-btn">删除已选</button>
    <button id="favorite-selected-btn" class="edit-action-btn" style="background-color: #ffc107; color: #333;">收藏已选</button>
    
    <button id="forward-selected-btn" class="edit-action-btn" style="background-color: #3498db; color: white;">转发已选</button>
    
    <button id="cancel-edit-btn" class="edit-action-btn">取消</button>
</div>
            </div>
            
            <div id="profile-screen">
                <div class="profile-header">
                    <div class="avatar-container">
                        <img src="https://via.placeholder.com/100/A0DCF8/FFFFFF?text=ME" alt="我的头像" class="profile-avatar" id="my-profile-avatar">
                        <div class="change-avatar-btn" id="change-avatar-btn">
                            <i class="fas fa-camera"></i>
                        </div>
                    </div>
                    <div class="profile-name" id="profile-name">我的名字</div>
                    <div class="profile-status" id="profile-status">在线</div>
                </div>
                
                <div class="profile-actions">
                    <div class="action-item" id="edit-status-btn">
                        <div class="action-icon">
                            <i class="fas fa-comment"></i>
                        </div>
                        <div class="action-label">我的状态</div>
                    </div>
                </div>
                
                <div class="profile-details">
                    <div class="detail-item">
                        <div class="detail-label">昵称</div>
                        <div class="detail-value" id="nickname-value">我的昵称</div>
                        <div class="edit-btn" data-field="name">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">个性签名</div>
                        <div class="detail-value" id="signature-value">我的个性签名</div>
                        <div class="edit-btn" data-field="signature">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">地区</div>
                        <div class="detail-value" id="region-value">我的地区</div>
                        <div class="edit-btn" data-field="region">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">生日</div>
                        <div class="detail-value" id="birthday-value">我的生日</div>
                        <div class="edit-btn" data-field="birthday">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    <div class="detail-item" id="copyright-entry-btn" style="margin-top: 20px; border-bottom: 1px solid #f0f0f0;">
    <div class="detail-label" style="color: #d32f2f;">
        <i class="fas fa-shield-alt" style="margin-right: 10px; font-size: 18px;"></i>
        正版认证 & 售后
    </div>
    <div class="detail-value" style="font-size: 12px; color: #ef5350;">防走丢 / 进群补票</div>
    <i class="fas fa-chevron-right" style="color: #ccc;"></i>
</div>
                    <div class="detail-item" id="appearance-settings-btn" style="margin-top: 20px;">
    <div class="detail-label"><i class="fas fa-palette" style="margin-right: 8px; color: var(--theme-primary);"></i>外观设置</div>
    <div class="detail-value">背景、气泡、字体</div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>

<div class="detail-item" id="my-wallet-btn" style="margin-top: 20px;">

                        <div class="detail-label"><i class="fas fa-wallet" style="margin-right: 8px; color: var(--theme-primary);"></i>我的钱包</div>
                        <div class="detail-value" id="my-balance-value" style="color: #E6A23C; font-weight: bold;">¥ 1000.00</div>
                        <i class="fas fa-chevron-right" style="color:#999;"></i>
                    </div>
                    
                    <div class="detail-item" style="margin-top: 20px; flex-direction: column; align-items: stretch; padding: 10px; background-color: transparent; border: none; box-shadow: none;">
                        <button class="form-button" id="import-char-card-btn" style="margin-top: 0; margin-bottom: 10px; background-color: #9b59b6;"> <i class="fas fa-id-card-alt"></i> 导入角色卡 (仅支持PNG图片) </button>
<input type="file" id="import-char-card-input" accept="image/*" style="display: none;">
<button class="form-button" id="export-data-btn" style="margin-top: 0; margin-bottom: 10px; background-color: var(--theme-secondary);"><i class="fas fa-download"></i> 导出数据 (备份)</button>
                        
                        <button class="form-button" id="export-light-data-btn" style="margin-top: 0; margin-bottom: 10px; background-color: #81c784;"> <i class="fas fa-feather-alt"></i> 局部导出 (自定义导出数据表) </button>
                        <button class="form-button" id="import-data-btn" style="margin-top: 0; background-color: #7f8c8d;"><i class="fas fa-upload"></i> 导入数据 (恢复)</button>
                        <input type="file" id="import-file-input" accept=".json" style="display: none;">
                    </div>
                    <div class="detail-item" style="margin-top: 10px;">
                        <button class="form-button" id="initialize-app-btn" style="background-color: #e74c3c; width: 100%;">
                            <i class="fas fa-undo"></i> 初始化应用 (清除所有数据)
                        </button>
                    </div>
                </div>
                
                <div class="bottom-nav">
                    <div class="nav-item" id="nav-chat-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-discover-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot"></div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-sms">
    <div class="nav-item-content">
        <div class="nav-icon"><i class="fas fa-sms"></i></div>
        <div>短信</div>
    </div>
</div>
                    <div class="nav-item active" id="nav-profile-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="char-profile-screen">
                <div class="chat-header">
                    <div class="back-btn" id="back-from-char-profile">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                     <div class="chat-info" style="font-weight: 600;"> 资料 </div>
                     <div style="width: 40px;"></div>
                </div>
                <div class="profile-details">
                    <div style="background-color: white; padding: 20px; border-radius: 10px;">
                        <div class="contact-item" style="padding: 0; border-bottom: none; align-items: flex-start;">
                             <div class="avatar-container" style="width: 70px; height: 70px; margin: 0;">
                                 <img src="" alt="联系人头像" class="profile-avatar" id="char-profile-avatar" style="width: 70px; height: 70px; border-radius: 8px;">
                                 <div class="change-avatar-btn" id="change-char-avatar-btn" style="width: 25px; height: 25px;">
                                     <i class="fas fa-camera" style="font-size: 12px;"></i>
                                 </div>
                             </div>
                             <div class="contact-info" style="margin-left: 20px;">
                                 <div id="char-profile-name" class="contact-name" style="font-size: 22px; font-weight: bold;"></div>
                                 <div id="char-profile-signature-display" class="contact-last-message" style="margin-top: 5px; white-space: normal;"></div>
                             </div>
                        </div>
                    </div>
                    
                    <div id="pet-container-wrapper"></div>
                    
                    <div class="discover-section" style="margin-top: 20px; border-radius: 10px;">
                        <div class="detail-item" id="edit-char-name-btn" style="padding:15px; background:white; border-radius: 10px 10px 0 0;">
                            <div class="detail-label">设置备注</div>
                            <div class="detail-value" id="char-name-value"></div>
                            <i class="fas fa-chevron-right" style="color:#999;"></i>
                        </div>
                         <div class="detail-item" id="edit-char-signature-btn" style="padding:15px; background:white;">
                             <div class="detail-label">设置签名</div>
                             <div class="detail-value" id="char-signature-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                         <div class="detail-item" id="view-char-diary-btn" style="padding:15px; background:white;">
                             <div class="detail-label">他的日记</div>
                             <div class="detail-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                         <div class="detail-item" id="view-memory-album-btn" style="padding:15px; background:white;">
    <div class="detail-label">我们的小窝相册</div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="view-memory-core-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-brain" style="margin-right: 8px; color: #AB47BC;"></i> <b>记忆核心</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="view-schedule-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-calendar-alt" style="margin-right: 8px; color: #64b5f6;"></i> <b>我的日程表</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="view-events-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-heart" style="margin-right: 8px; color: #ec407a;"></i> <b>我们的日子</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="view-relationship-network-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-users" style="margin-right: 8px; color: #ff7043;"></i> <b>TA的关系网</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="char-more-info-btn" style="padding:15px; background:white; border-radius: 0 0 10px 10px;">
                             <div class="detail-label">更多信息</div>
                             <div class="detail-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                    </div>
                    
                    <div style="padding: 20px 0;">
                        <button class="form-button" id="delete-contact-btn" style="background-color: #e74c3c; width: 100%;">删除联系人</button>
                    </div>

                </div>
            </div>
            
            <div id="discover-screen">
                <div class="discover-header">
                    <div class="discover-title">发现</div>
                </div>
                
                <div class="discover-content">
                    <div class="discover-section">
                        <div class="discover-item" id="moments-btn">
                            <div class="discover-icon">
                                <i class="fas fa-comments"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛</div>
                                <div class="discover-desc">看看大家在聊什么</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
<div class="discover-item" id="open-social-zone-btn">
    <div class="discover-icon">
        <i class="fas fa-star"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">koko空间</div>
        <div class="discover-desc">好友动态</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
                        <div class="discover-item" id="investment-center-btn">
    <div class="discover-icon"><i class="fas fa-landmark"></i></div>
    <div class="discover-info">
        <div class="discover-name">Koko 游戏中心</div>
        <div class="discover-desc">和TA一起玩吧</div>
    </div>
    <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
</div>
                    <div class="discover-item" id="shopping-center-btn">
                            <div class="discover-icon">
                                <i class="fas fa-shopping-bag"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">购物中心</div>
                                <div class="discover-desc">发现好物，与TA分享</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                    <div class="discover-section">
                        <div class="discover-item" id="emoticon-library-btn">
                            <div class="discover-icon">
                                <i class="far fa-grin-alt"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">表情包库</div>
                                <div class="discover-desc">管理和添加我的表情包</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="music-library-btn">
                        
                            <div class="discover-icon">
                                <i class="fas fa-music"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">音乐库</div>
                                <div class="discover-desc">管理和添加我的歌曲</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="forum-archives-btn">
                            <div class="discover-icon">
                                <i class="fas fa-archive"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛档案馆</div>
                                <div class="discover-desc">管理和切换不同的世界线</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="forum-category-btn">
                            <div class="discover-icon">
                                <i class="fas fa-tags"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛板块管理</div>
                                <div class="discover-desc">添加或编辑你的专属板块</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                         <div class="discover-item" id="user-persona-presets-btn">
                            <div class="discover-icon">
                                <i class="fas fa-theater-masks"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">用户面具预设</div>
                                <div class="discover-desc">管理你在对话中的不同身份</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="world-book-btn">
                            <div class="discover-icon">
                                <i class="fas fa-book"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">世界书</div>
                                <div class="discover-desc">探索世界知识</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="thought-presets-btn">
                            <div class="discover-icon">
                                <i class="fas fa-brain"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">思维预设</div>
                                <div class="discover-desc">管理AI的“破限”模式</div>
                            </div>
                            
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>    
                            </div>
                        </div>
                        <div class="discover-item" onclick="window.open('https://www.xiaohongshu.com/user/profile/67382078000000001c01951d?xsec_token=YBfrN-IIvdSPK2t1l95UJMhWtuMLn9U_lUCIOMS1LVRDw=&xsec_source=app_share&xhsshare=CopyLink&appuid=67382078000000001c01951d&apptime=1756779911&share_id=df9cd221b1944d819f1cd87b2c9fb2ee')">
    <div class="discover-icon">
        <i class="fas fa-user-circle"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">作者主页</div>
        <div class="discover-desc">点击跳转到我的小红书</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
<div class="discover-item" id="map-management-btn">
    <div class="discover-icon">
        <i class="fas fa-map-marked-alt"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">地图管理中心</div>
        <div class="discover-desc">创建和编辑你的世界地图</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
<div class="discover-item" id="automation-btn">
    <div class="discover-icon">
        <i class="fas fa-robot"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">自动回复设置</div>
        <div class="discover-desc">让角色们自己找你聊天</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
    <div class="discover-item" id="lock-screen-photos-btn">
        <div class="discover-icon">
            <i class="fas fa-photo-video"></i>
        </div>
        <div class="discover-info">
            <div class="discover-name">锁屏相册</div>
            <div class="discover-desc">管理锁屏界面轮播的照片</div>
        </div>
        <div class="discover-arrow">
            <i class="fas fa-chevron-right"></i>
        </div>
</div>
<div class="discover-item" id="favorites-btn">
    <div class="discover-icon">
        <i class="fas fa-star"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">我的收藏</div>
        <div class="discover-desc">查看收藏的聊天记录</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
                    </div>
                    
                    <div class="discover-section">
                         <div class="discover-item" id="square-api-settings-btn">
                            <div class="discover-icon">
                                <i class="fas fa-rss-square"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛API设置</div>
                                <div class="discover-desc">为论坛帖子、评论生成配置专属API</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
<div class="discover-item" id="api-settings-btn">
                            <div class="discover-icon">
                                <i class="fas fa-comments-dollar"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">聊天API设置</div>
                                <div class="discover-desc">为聊天功能配置API</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
<div class="discover-item" id="snoop-api-settings-btn">
    <div class="discover-icon">
        <i class="fas fa-user-secret"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">窥探API设置</div>
        <div class="discover-desc">为窥探模式配置专属API</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
</div>
                </div>
                 <div class="bottom-nav">
                    <div class="nav-item" id="nav-chat-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item active" id="nav-discover-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot"></div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-sms">
    <div class="nav-item-content">
        <div class="nav-icon"><i class="fas fa-sms"></i></div>
        <div>短信</div>
    </div>
</div>
                    <div class="nav-item" id="nav-profile-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="thought-preset-management-screen" class="preset-management-screen">
                <div class="api-header"> 
                    <div class="back-btn" id="back-from-thought-presets">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">思维预设管理</div>
                    <div class="action-btn" id="add-thought-preset-btn">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>
                <div class="api-content">
                    <div id="thought-presets-list" class="preset-list">
                    </div>
                    <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-thought-preset-message">
                        <p>还没有思维预设。</p>
                        <p>点击右上角"+"添加新的预设。</p>
                    </div>
                </div>
            </div>
            
            <div id="world-book-screen">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-world-book">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">世界书</div>
                    <div>
                        <i class="fas fa-plus action-btn" id="add-world-book-btn"></i>
                    </div>
                </div>
                
                <div class="world-book-content">
                    <div class="world-book-list" id="world-book-list">
                    </div>
                </div>
            </div>

            <div id="emoticon-library-screen">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-emoticon-library">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">表情包库</div>
<div>
    <span class="action-btn" id="manage-emoticon-btn" style="font-size: 14px; margin-right: 10px; cursor: pointer;">管理</span>
    <i class="fas fa-plus action-btn" id="add-emoticon-btn"></i>
</div>
                </div>
                <div class="emoticon-library-content">
                    <div class="emoticon-grid" id="emoticon-library-grid">
                    </div>
                    <div id="no-emoticon-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                        <i class="far fa-grin-alt" style="font-size: 48px; margin-bottom: 15px;"></i>
                        <p>你的表情包库是空的</p>
                        <p>点击右上角 "+" 添加你的第一个表情包吧！</p>
                    </div>
                </div><div id="emo-batch-action-bar" style="display: none; padding: 15px; background: white; border-top: 1px solid #eee; justify-content: space-between; align-items: center;">
    <span id="emo-selected-count" style="color: #666; font-size: 14px;">已选 0 项</span>
    <div style="display: flex; gap: 10px;">
        <button id="emo-batch-cancel-btn" class="edit-action-btn" style="background-color: #bdc3c7; color: #333;">取消</button>
        <button id="emo-batch-delete-btn" class="edit-action-btn" style="background-color: var(--soft-red); color: white;">删除</button>
    </div>
</div>
            </div>

            <div id="music-library-screen">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-music-library">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">音乐库</div>
                    <div>
                        <i class="fas fa-plus action-btn" id="add-music-btn"></i>
                    </div>
                </div>
                <div class="api-content" id="music-library-content">
                    <div id="music-library-list"></div>
                    <div id="no-music-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                        <i class="fas fa-music" style="font-size: 48px; margin-bottom: 15px;"></i>
                        <p>你的音乐库是空的</p>
                        <p>点击右上角 "+" 添加你的第一首歌吧！</p>
                    </div>
                </div>
            </div>
            <div id="api-settings-screen">
                <div class="api-header">
                    <div class="back-btn" id="back-from-api">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">聊天API设置</div>
                </div>
                
                <div class="api-content">
                   <div class="form-group">
            <label class="form-label">API预设</label>
            <div class="form-group-inline">
                <select class="form-input" id="api-preset-select">
                    <option value="">-- 手动配置或选择预设 --</option>
                </select>
                <button id="manage-api-presets-btn" title="管理预设" class="form-button" style="width: auto; padding: 10px 15px; font-size: 14px; flex-shrink: 0; margin-top: 0;">
                    管理
                </button>
            </div>
        </div>
                     <div class="form-group">
                        <label class="form-label">API密钥</label>
                        <input type="password" class="form-input" id="api-key-input" placeholder="输入聊天API密钥">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">API 基础地址 (Base URL)</label>
                        <div class="form-group-inline">
                            <input type="text" class="form-input" id="api-endpoint-input" placeholder="例如: https://api.openai.com">
                            <button id="fetch-models-btn" title="拉取模型列表">
                                <i class="fas fa-sync-alt"></i> 拉取
                            </button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">模型选择</label>
                        <select class="form-input" id="model-select">
                        </select>
                    </div>
                    <div class="form-group">
    <label class="form-label">温度 (Temperature)</label>
    <input type="number" class="form-input" id="api-temperature-input" placeholder="0.0 - 2.0 (留空默认 1.0)" step="0.1" min="0" max="2">
    <p style="font-size: 12px; color: #888; margin-top: 5px;">
        值越低越理性(0.2)，值越高越有创意(1.2)。日常聊天推荐 0.7-1.0。
    </p>
</div>

<div class="form-group">
    <label class="form-label">最大回复长度 (Max Tokens)</label>
    <input type="number" class="form-input" id="api-max-tokens-input" placeholder="例如 2000 (留空则不限制)" step="100">
    <p style="font-size: 12px; color: #888; margin-top: 5px;">
        限制 AI 单次回复的字数。如果经常回复截断，请调大此值。
    </p>
</div>
                    <div class="form-group">
                        <label class="form-label">短期对话记忆条数 (当前私聊)</label>
                        <input type="number" class="form-input" id="context-length-input" value="20" min="2" max="100" title="决定AI能记住当前私聊窗口中最近的几句话。">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">长期线性记忆条数 (跨场景)</label>
                        <input type="number" class="form-input" id="long-term-memory-length-input" value="30" min="5" max="200" title="决定AI能从“统一时序记忆流”中看到多少最近的事件（包括私聊和论坛）。这是AI的核心记忆。">
                    </div>
                    <div class="form-group" style="border-top: 2px dashed #ddd; padding-top: 20px; margin-top: 20px;">
    <label class="form-label" style="font-size: 18px; font-weight: 600;">语音服务 API (MiniMax)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        为语音消息和视频通话提供声音。请在 MiniMax 开放平台获取。
    </p>

    <div class="form-group">
        <label class="form-label">MiniMax Group ID</label>
        <input type="text" class="form-input" id="minimax-group-id-input" placeholder="输入你的 MiniMax Group ID">
    </div>
    
    <div class="form-group">
        <label class="form-label">MiniMax API Key</label>
        <input type="password" class="form-input" id="minimax-api-key-input" placeholder="输入你的 MiniMax API Key">
    </div>
</div>
<div class="form-group">
    <label class="form-label" style="font-size: 18px; font-weight: 600;">语音服务 API (SiliconFlow)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        作为 MiniMax 的备选。请在硅基流动官网获取。
    </p>
    <div class="form-group">
        <label class="form-label">SiliconFlow API Key</label>
        <input type="password" class="form-input" id="siliconflow-api-key-input" placeholder="输入你的 SiliconFlow API Key">
    </div>
</div>
                    <button class="form-button" id="save-api-settings-btn">保存设置</button>
                    <button class="form-button" id="save-as-api-preset-btn" style="margin-top: 10px; background-color: var(--theme-secondary);">另存为预设</button>
                </div>
            </div>

             <div id="square-api-settings-screen">
                <div class="api-header">
                    <div class="back-btn" id="back-from-square-api">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">论坛API设置</div>
                </div>
                
                <div class="api-content">
                     <div class="form-group" style="border: 1px solid var(--theme-secondary); background: #f1f8e9;">
                        <p style="color: var(--text-gray); font-size: 14px; line-height: 1.6;">
                            此处的API配置将专门用于论坛中的内容生成，例如刷新帖子、生成AI评论回复等。如果留空，将默认使用“聊天API设置”中的配置。
                        </p>
                    </div>
                    <div class="form-group">
                        <label class="form-label">论坛专用API密钥 (可选)</label>
                        <input type="password" class="form-input" id="square-api-key-input" placeholder="输入论坛专用API密钥">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">论坛专用API基础地址 (可选)</label>
                        <div class="form-group-inline">
                            <input type="text" class="form-input" id="square-api-endpoint-input" placeholder="输入论坛专用Base URL">
                            <button id="fetch-square-models-btn" title="拉取模型列表">
                                <i class="fas fa-sync-alt"></i> 拉取
                            </button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">论坛专用模型选择 (可选)</label>
                        <select class="form-input" id="square-model-select">
                        </select>
                    </div>
                    <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">🎭 我的论坛身份</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">选择一个“用户面具”作为你在论坛的身份，AI会根据这个身份与你互动。</p>
            <select class="form-input" id="forum-persona-select">
                <option value="">-- 不使用特定身份 --</option>
            </select>
        </div>

        <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">📚 论坛世界观</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">选择一本或多本“世界书”来定义论坛的背景故事，所有AI内容都将基于此设定。</p>
            <div class="world-book-list" id="forum-worldbook-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
                </div>
        </div>

        <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">🎬 论坛风格描述</label>
             <p style="font-size: 13px; color: #888; margin-bottom: 10px;">用文字告诉AI你希望论坛呈现什么样的氛围和文风。例如：“整体风格黑暗压抑，人们的对话充满谜语和不安。”</p>
            <textarea class="form-textarea" id="forum-style-description" placeholder="输入你想要的风格描述..." style="height: 100px;"></textarea>
        </div>
        <div class="form-group">
    <label class="form-label" style="font-size: 16px; font-weight: 600;">🎭 允许发帖的角色</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        在这里勾选的角色，AI才有权限让他们在论坛发帖。如果全部不勾选，AI将只会创建新的“路人甲”进行发言。
    </p>
    <div class="world-book-list" id="forum-allowed-posters-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
        </div>
</div>
                    <button class="form-button" id="save-square-api-settings-btn">保存设置</button>
                </div>
            </div>
            <div id="snoop-api-settings-screen" style="display: none;"> <div class="api-header">
        <div class="back-btn" id="back-from-snoop-api"> <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">窥探API设置</div> </div>
    
    <div class="api-content">
         <div class="form-group" style="border: 1px solid var(--theme-secondary); background: #f1f8e9;">
            <p style="color: var(--text-gray); font-size: 14px; line-height: 1.6;">
                此处的API配置将专门用于“窥探模式”的内容生成。
                <br><br>
                <strong>如果留空，将自动使用“聊天API设置”中的配置作为备选。</strong>
            </p>
        </div>
        <div class="form-group">
            <label class="form-label">窥探专用API密钥 (可选)</label>
            <input type="password" class="form-input" id="snoop-api-key-input" placeholder="输入窥探专用API密钥"> </div>
        
        <div class="form-group">
            <label class="form-label">窥探专用API基础地址 (可选)</label>
            <div class="form-group-inline">
                <input type="text" class="form-input" id="snoop-api-endpoint-input" placeholder="输入窥探专用Base URL"> <button id="fetch-snoop-models-btn" title="拉取模型列表"> <i class="fas fa-sync-alt"></i> 拉取
                </button>
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">窥探专用模型选择 (可选)</label>
            <select class="form-input" id="snoop-model-select"> </select>
        </div>
        
        <button class="form-button" id="save-snoop-api-settings-btn">保存设置</button> </div>
</div>
            
            <div id="add-world-book-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title" id="world-book-modal-title">添加世界书</div>
                        <div class="close-btn" id="close-world-book-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">书名</label>
                            <input type="text" class="form-input" id="book-name-input" placeholder="输入书名">
                        </div>
                        <div class="form-group">
    <label class="form-label">分类 (可选)</label>
    <input type="text" class="form-input" id="book-category-input" list="category-suggestions" placeholder="例如：人物设定 (可直接选择或输入新分类)">
    <datalist id="category-suggestions"></datalist>
</div>
                        <div class="form-group">
                            <label class="form-label">内容</label>
                            <textarea class="form-textarea" id="book-content-input" placeholder="输入内容..."></textarea>
                        </div>
                        
                        <button class="form-button" id="save-world-book-btn">保存</button>
                    </div>
                </div>
            </div>

            <div id="add-emoticon-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">批量添加表情包</div>
                        <div class="close-btn" id="close-emoticon-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                    </div>
                </div>
            </div>

            <div id="add-music-modal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="add-music-modal-title">添加歌曲</div>
            <div class="close-btn" id="close-add-music-modal">
                <i class="fas fa-times"></i>
            </div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">歌曲名 (*)</label>
                <input type="text" class="contact-form-input" id="add-music-title-input" placeholder="例如：晴天">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌手 (*)</label>
                <input type="text" class="contact-form-input" id="add-music-artist-input" placeholder="例如：周杰伦">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌曲URL (*)</label>
                <input type="text" class="contact-form-input" id="add-music-url-input" placeholder="http://music.163.com/song/media/outer/url?id=....mp3">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌词 (LRC格式, 可选)</label>
                <textarea class="form-textarea" id="add-music-lrc-input" placeholder="将从歌词API获取的LRC文本粘贴到这里..." style="height: 100px; font-size: 12px;"></textarea>
            </div>
            <button class="form-button" id="save-music-btn">保存到音乐库</button>
        </div>
    </div>
</div>
<div id="export-selector-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 2000;">
    <div class="modal-content" style="max-height: 80vh; display: flex; flex-direction: column;">
        <div class="modal-header">
            <div class="modal-title">选择要导出的数据</div>
            <div class="close-btn" id="close-export-selector-modal">&times;</div>
        </div>
        <div class="modal-body" style="flex-grow: 1; overflow-y: auto; padding: 15px;">
            <p style="font-size: 13px; color: #666; margin-bottom: 15px;">请勾选你需要备份的数据表：</p>
            
            <div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #eee;">
                <span style="color: var(--theme-primary); cursor: pointer; font-size: 14px; margin-right: 15px;" onclick="toggleExportCheckboxes(true)">全选</span>
                <span style="color: #999; cursor: pointer; font-size: 14px;" onclick="toggleExportCheckboxes(false)">清空</span>
            </div>

            <div id="export-options-list" class="world-book-list" style="gap: 8px;">
                </div>
            
            <button class="form-button" id="confirm-custom-export-btn" style="margin-top: 15px; background-color: var(--theme-primary);">
                <i class="fas fa-file-export"></i> 开始导出
            </button>
        </div>
    </div>
</div>
            
            <div id="add-contact-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">添加联系人</div>
                        <div class="close-btn" id="close-contact-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">姓名</label>
                            <input type="text" class="contact-form-input" id="contact-name-input" placeholder="输入姓名">
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">人设</label>
                            <textarea class="contact-form-textarea" id="contact-persona-input" placeholder="输入人设描述..."></textarea>
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">头像URL (可选)</label>
                            <input type="text" class="contact-form-input" id="contact-avatar-input" placeholder="输入头像URL，例如：https://example.com/avatar.jpg">
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">关联世界书</label>
                            <select class="contact-form-select" id="world-book-select" multiple>
                            </select>
                        </div>
                        <div style="margin: 10px 0 15px 0; padding: 12px; background-color: #fff1f0; border: 1px solid #ffa39e; border-radius: 6px; font-size: 0.9em;">
                            <div style="color: #d9363e; font-weight: bold; margin-bottom: 6px; display: flex; align-items: center;">
                                <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i> 
                                禁止使用未经授权的IP/素材（包括但不限于：角色卡、世界书、HTML小剧场、思维预设、背景图等）。因使用违规或来源不明的素材导致的数据损坏、隐私泄露或版权纠纷，作者概不负责。
                            </div>
                            <div style="color: #555; font-size: 0.95em;">
                                <i class="fas fa-users" style="margin-right: 6px; color: #888;"></i>
                                售前群群号：
                                <span style="font-weight: bold; color: #096dd9; user-select: all;">482466918</span>
                            </div>
                        </div>
                        <button class="form-button" id="save-contact-btn">添加联系人</button>
                    </div>
                </div>
            </div>
            
            <div id="contact-settings-screen">
                <div class="contact-settings-header">
                    <div class="back-btn" id="back-from-contact-settings">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="contact-settings-title">更多信息</div>
                </div>
                
                <div class="contact-settings-content">
                <div class="mask-editor">
                        <div class="mask-editor-title">显示设置</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
                            <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">在聊天中隐藏角色头像</label>
                            <label class="switch">
                                <input type="checkbox" id="hide-avatar-toggle">
                                <span class="slider round"></span>
                            </label>
                        </div>
                        <p style="font-size: 13px; color: #888; margin-top: 5px;">开启后，仅在聊天界面中不再显示该角色的头像。</p>
                    </div>
                    <div class="mask-editor">
    <div class="mask-editor-title">个性化聊天背景</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        为你们的聊天设置一张专属壁纸。
    </p>
    <div style="display: flex; gap: 10px;">
        <button class="form-button" id="upload-contact-background-btn" style="flex: 1; background-color: var(--theme-secondary);">
            <i class="fas fa-upload"></i> 上传背景
        </button>
        <button class="form-button" id="reset-contact-background-btn" style="flex: 1; background-color: #7f8c8d;">
            <i class="fas fa-undo"></i> 恢复默认
        </button>
    </div>
</div>

<div class="mask-editor">
    <div class="mask-editor-title">自定义我的头像</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        仅在此聊天中，将“我”的头像显示为特定样式。
    </p>
    <div style="text-align: center; margin-bottom: 15px;">
        <img id="custom-user-avatar-preview" src="" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none;">
    </div>
    <div style="display: flex; gap: 10px;">
        <button class="form-button" id="upload-contact-user-avatar-btn" style="flex: 1; background-color: var(--theme-secondary);">
            <i class="fas fa-camera"></i> 上传头像
        </button>
        <button class="form-button" id="reset-contact-user-avatar-btn" style="flex: 1; background-color: #7f8c8d;">
            <i class="fas fa-undo"></i> 恢复默认
        </button>
    </div>
</div>
<div class="mask-editor">
    <div class="mask-editor-title">专属气泡样式 (CSS)</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        在这里为该联系人编写专属CSS。留空则使用全局默认样式。
    </p>
    <div class="mask-editor-group">
        <textarea class="mask-editor-textarea" id="contact-bubble-css-input" placeholder="例如：&#10;&#10;/* 把对方的气泡变粉 */&#10;.message.received {&#10;  background-color: #ffe4e1 !important;&#10;  color: #d81b60 !important;&#10;  border-radius: 20px 20px 20px 0 !important;&#10;}&#10;&#10;/* 把自己的气泡变黑 */&#10;.message.sent {&#10;  background-color: #333 !important;&#10;  color: #fff !important;&#10;}" style="height: 180px; font-family: monospace; font-size: 12px;"></textarea>
    </div>
</div>
<div class="mask-editor">
    <div class="mask-editor-title">语音声线设置</div>
    <div class="mask-editor-group">
        <label class="mask-editor-label">语音服务商</label>
        <select class="form-input" id="char-voice-provider-select">
            <option value="">-- 不使用语音 --</option>
            <option value="minimax">MiniMax</option>
            <option value="siliconflow">硅基流动 (SiliconFlow)</option>
        </select>
    </div>
    <div class="mask-editor-group">
        <label class="mask-editor-label">音色 ID (Voice ID)</label>
        <input type="text" class="form-input" id="char-voice-id-input" placeholder="选择服务商后，在此粘贴对应的音色ID">
    </div>
    <p style="font-size: 13px; color: #888; margin-top: 10px;">
        请前往所选服务商的开放平台获取音色ID。
    </p>
</div>
                    <div class="user-mask-editor">
                        <div class="user-mask-title">用户面具设置</div>
                        <div class="mask-editor-group">
                            <label class="mask-editor-label">用户面具描述</label>
                            <textarea class="user-mask-textarea" id="user-mask-textarea" placeholder="描述你在这个对话中扮演的角色..."></textarea>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label class="form-label">选择预设面具</label>
                        <select class="form-input" id="select-user-persona-preset">
                            <option value="">-- 选择或输入自定义面具 --</option>
                        </select>
                    </div>
                    <div class="mask-editor">
    <div class="mask-editor-title">我的语音声线设置 (在此聊天中)</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        为“我”在此次对话中设置专属声音。
    </p>
    <div class="mask-editor-group">
        <label class="mask-editor-label">语音服务商</label>
        <select class="form-input" id="user-voice-provider-select">
            <option value="">-- 不使用语音 --</option>
            <option value="minimax">MiniMax</option>
            <option value="siliconflow">硅基流动 (SiliconFlow)</option>
        </select>
    </div>
    <div class="mask-editor-group">
        <label class="mask-editor-label">音色 ID (Voice ID)</label>
        <input type="text" class="form-input" id="user-voice-id-input" placeholder="粘贴“我”的音色ID">
    </div>
</div>
<div class="user-mask-editor">
    <div class="user-mask-title">我的聊天昵称</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        设置一个只在当前聊天中显示的昵称。如果留空，将使用你的全局昵称。
    </p>
    <div class="mask-editor-group">
        <input type="text" class="form-input" id="custom-user-name-input" placeholder="输入只在此聊天中显示的昵称...">
    </div>
</div>

                    <div class="mask-editor">
    <div class="mask-editor-title">对话模式</div>
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
        <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">叙事模式 (单气泡长回复)</label>
        <label class="switch">
            <input type="checkbox" id="narrative-mode-toggle">
            <span class="slider round"></span>
        </label>
    </div>
</div>

                   <div class="mask-editor">
    <div class="mask-editor-title">时间感知</div>
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
        <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">允许TA感知现实时间</label>
        <label class="switch">
            <input type="checkbox" id="time-awareness-toggle">
            <span class="slider round"></span>
        </label>
    </div>
    <p style="font-size: 13px; color: #888; margin-top: 5px;">开启后，TA会知道当前的真实日期和时间，并可能在对话中提及（如“早上好”、“深夜了”等）。</p>
</div>
                     <div class="mask-editor">
                        <div class="mask-editor-title">联系人面具设置</div>
                        <div class="mask-editor-group">
                            <label class="mask-editor-label">联系人面具描述</label>
                            <textarea class="mask-editor-textarea" id="char-mask-textarea" placeholder="描述这个联系人的角色设定..."></textarea>
                        </div>
                    </div>

                    <div class="form-group" style="background-color: white; border-radius: 10px; padding: 15px; margin-bottom: 15px; margin-top:-5px;">
                        <label class="form-label">思维预设 (破限模式)</label>
                        <select class="form-input" id="thought-preset-select">
                        </select>
                    </div>
                    
                    <div class="world-book-selector">
                        <div class="world-book-selector-title">关联世界书（用于聊天）</div>
                        <div class="world-book-list" id="world-book-selector-list">
                        </div>
                        <div class="world-book-selector" style="margin-top: 15px;">
    <div class="world-book-selector-title">关联世界书 (用于窥探功能)</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        选择那些包含角色日常背景、世界通用设定的书，AI会参考它们生成窥探内容。
    </p>
    <div class="world-book-list" id="snoop-world-book-selector-list">
        </div>
        </div>
                        <div class="world-book-selector" style="margin-top: 15px;">
    <div class="world-book-selector-title">关联地图</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        为该角色选择一张主活动地图。AI会基于此地图信息进行对话。
    </p>
    <select class="form-input" id="contact-map-select">
        <option value="">-- 不关联任何地图 --</option>
        </select>
</div>
                    </div>
                    
                    <button class="save-settings-btn" id="save-contact-settings-btn">保存设置</button>
                    <input type="file" id="import-char-card-input" accept=".json,.png" style="display: none;"> <button class="save-settings-btn" id="export-char-card-btn" style="background-color: #9b59b6; margin-top: 15px;"> <i class="fas fa-image"></i> 导出角色卡 (生成图片) </button>
                    <button class="save-settings-btn" id="clear-chat-history-btn" style="background-color: #e74c3c; margin-top: 15px;">清空聊天记录</button>
                </div>
            </div>

            <div id="moments-screen">
                <div class="moments-header">
                <div id="feed-status-indicator" style="display: none;"></div>
                    <div class="back-btn" id="back-from-moments">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="moments-title">论坛</div>
                    <div class="header-actions">
                        <i class="fas fa-sync-alt action-btn" id="refresh-feed-btn" title="刷新"></i>
                        <i class="fas fa-plus-circle action-btn" id="post-moment-btn" title="发布动态"></i>
                    </div>
                </div>
                <div id="feed-tabs-container" class="feed-tabs"></div>
                <div id="feed-sub-tabs-container" class="feed-sub-tabs" style="display: none;"></div>
                <div class="moments-content" id="moments-content">
                    <div class="posts-list" id="posts-list"></div>
                </div>
            </div>

            <div id="post-detail-screen">
                <div class="moments-header">
                    <div class="back-btn" id="back-from-post-detail"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title">帖子详情</div>
                    <div class="header-actions">
                        <i class="fas fa-sync-alt action-btn" id="refresh-post-comments-btn" title="刷新评论"></i>
                    </div>
                </div>
                <div class="post-detail-content">
                    <div id="post-detail-container"></div>
                    <div class="comments-section">
                        <div class="comments-title">全部评论</div>
                        <div id="comments-list"></div>
                    </div>
                </div>
                
                <div id="comment-image-preview-container" style="display: none; padding: 5px 15px; background-color: #f7f7f7; border-top: 1px solid #ddd; position: relative;">
                    <img id="comment-image-preview" src="" style="width: 60px; height: 60px; border-radius: 8px; object-fit: cover;">
                    <button id="remove-comment-image-btn" style="position: absolute; top: 0px; left: 60px; background: rgba(0,0,0,0.5); color: white; border: 1px solid white; border-radius: 50%; width: 22px; height: 22px; cursor: pointer; font-size: 14px; line-height: 20px;">&times;</button>
                </div>
                <input type="file" id="comment-image-uploader" accept="image/*" style="display: none;">
                <div class="comment-input-area">
                    <i class="fas fa-image" id="add-comment-image-btn" style="font-size: 22px; color: #555; margin-right: 12px; cursor: pointer; padding: 5px;"></i>
                    <input type="text" id="comment-input" placeholder="留下你的精彩评论吧...">
                    <button id="submit-comment-btn">发送</button>
                </div>
            </div>

            <div id="trending-topic-screen">
                 <div class="moments-header">
                    <div class="back-btn" id="back-from-trending-topic"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title" id="trending-topic-title">话题区</div>
                    <div style="width: 40px;"></div>
                </div>
                <div class="moments-content">
                    <div id="trending-topic-description-container" style="display: none;"></div>
                    <div class="posts-list" id="trending-topic-posts-list"></div>
                </div>
            </div>
            
            <div id="diary-screen">
<div class="moments-header">
    <div class="back-btn" id="back-from-diary">
        <i class="fas fa-arrow-left"></i>
    </div>
    <div class="moments-title" id="diary-title">他的日记</div>
    <div class="header-actions">
         <i class="fas fa-edit action-btn" id="edit-diary-btn" title="编辑"></i>
    </div>
</div>
                <div class="diary-content" id="diary-content-list">
                    </div>
                    <div id="diary-edit-mode-bar" style="display: none;">
    <button id="delete-selected-diary-btn" class="edit-action-btn">删除已选</button>
    <button id="cancel-diary-edit-btn" class="edit-action-btn">取消</button>
</div>
            </div>

            <div id="memory-album-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
                <div class="moments-header">
                    <div class="back-btn" id="back-from-memory-album"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title">小窝相册</div>
                </div>
                <div class="diary-content" id="memory-album-list">
                    </div>
            </div>

            <div id="post-moment-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发布动态</div>
                        <div class="close-btn" id="close-post-moment-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
<div class="form-group" style="padding:0; box-shadow:none; border:none;">
                            <textarea class="form-textarea" id="moment-content-input" placeholder="有什么新鲜事想分享？"></textarea>
                        </div>
                        
                        <div id="post-image-preview-container" style="display: none; margin-top: 10px; position: relative; max-width: 200px;">
                            <img id="post-image-preview" src="" style="width: 100%; border-radius: 8px;">
                            <button id="remove-post-image-btn" style="position: absolute; top: -5px; right: -5px; background: rgba(0,0,0,0.6); color: white; border: 1px solid white; border-radius: 50%; width: 22px; height: 22px; cursor: pointer; font-size: 14px; line-height: 20px;">&times;</button>
                        </div>
                        <input type="file" id="post-image-uploader" accept="image/*" style="display: none;">
                        <div class="form-group" style="padding:0; box-shadow:none; border:none;">
                             <label class="form-label">选择板块</label>
                             <select id="post-category-select" class="form-input">
                                 <option value="daily">日常</option>
                                 <option value="food">美食</option>
                                 <option value="gossip">八卦</option>
                                 <option value="horror">恐怖</option>
                             </select>
                         </div>
                        <div class="moment-extra-actions">
                            <i class="fas fa-image moment-action-btn" id="add-post-image-btn" title="添加图片"></i>
                            <i class="fas fa-wallet moment-action-btn" id="add-post-red-packet-btn" title="添加红包"></i>
                        </div>
                        <button class="form-button" id="publish-moment-btn">发布</button>
                    </div>
                </div>
            </div>         
            
            <div id="user-persona-management-screen" class="preset-management-screen">
                <div class="api-header">
                    <div class="back-btn" id="back-from-user-persona-management">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">用户面具预设</div>
                    <div class="action-btn" id="add-user-persona-preset-btn">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>
                <div class="api-content">
                    <div id="user-persona-presets-list" class="preset-list">
                    </div>
                    <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-user-persona-message">
                        <p>还没有用户面具预设。</p>
                        <p>点击右上角"+"添加新的面具。</p>
                    </div>
                </div>
            </div>
            <div id="automation-screen" class="preset-management-screen">
    <div class="api-header">
        <div class="back-btn" id="back-from-automation">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">自动回复设置</div>
        <div style="width: 40px;"></div>
    </div>
    <div class="api-content">
        <div class="form-group">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <label class="form-label" style="margin-bottom: 0; font-size: 16px; font-weight: 600;">启用自动回复</label>
                <label class="switch">
                    <input type="checkbox" id="automation-enabled-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <p id="automation-status-indicator" style="font-size: 13px; color: #888; margin-top: 10px; text-align: center;">
                当前已关闭
            </p>
        </div>

        <div class="form-group">
            <label class="form-label">检查间隔 (秒)</label>
            <input type="number" class="form-input" id="automation-interval-input" value="300" min="30">
            <p style="font-size: 13px; color: #888; margin-top: 5px;">建议设置不低于60秒，以免API调用过于频繁。</p>
        </div>
        
        <div class="form-group">
            <label class="form-label">每次随机回复人数</label>
            <div style="display: flex; gap: 15px; align-items: center;">
                <span>最少</span>
                <input type="number" class="form-input" id="automation-min-replies-input" value="1" min="1" style="width: 60px; text-align: center;">
                <span>最多</span>
                <input type="number" class="form-input" id="automation-max-replies-input" value="2" min="1" style="width: 60px; text-align: center;">
                <span>人</span>
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">选择参与自动回复的角色</label>
            <div class="world-book-list" id="automation-contact-list" style="max-height: 250px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
                </div>
        </div>

        <button class="form-button" id="save-automation-settings-btn">保存设置</button>
    </div>
</div>
<div id="favorites-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="moments-header"> <div class="back-btn" id="back-from-favorites"><i class="fas fa-arrow-left"></i></div>
        <div class="moments-title">我的收藏</div>
        <div style="width: 40px;"></div>
    </div>
    <div class="api-content" id="favorites-content-list" style="padding: 10px;">
        </div>
</div>
<div id="user-persona-preset-modal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="user-persona-modal-title">添加用户面具预设</div>
            <div class="close-btn" id="close-user-persona-preset-modal">
                <i class="fas fa-times"></i>
            </div>
        </div>
        <div class="modal-body">
            
            <div class="contact-form-group" style="text-align: center;">
                <label class="contact-form-label">面具头像 (可选)</label>
                <img id="user-persona-avatar-preview" src="" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none; margin-bottom: 10px; cursor: pointer;">
                <button class="form-button" id="upload-persona-avatar-btn" style="background-color: var(--theme-secondary);">
                    <i class="fas fa-upload"></i> 上传头像
                </button>
            </div>

            <div class="form-group">
                <label class="form-label">面具名称 (*)</label>
                <input type="text" class="form-input" id="user-persona-name-input" placeholder="例如：Koko酱">
            </div>

            <div class="form-group">
                <label class="form-label">个性签名 (可选)</label>
                <input type="text" class="form-input" id="user-persona-signature-input" placeholder="会显示在论坛帖子上，30字内为佳">
            </div>
            <div class="form-group">
                <label class="form-label">面具描述 (给AI看的人设) (*)</label>
                <textarea class="form-textarea" id="user-persona-description-input" placeholder="详细描述你扮演的角色，例如：一个活泼的见习魔法师..."></textarea>
            </div>
            
            <button class="form-button" id="save-user-persona-preset-btn">保存</button>
        </div>
    </div>
</div>
            
            <div id="api-preset-management-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-api-presets">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">API预设管理</div>
        <div style="width: 40px;"></div> </div>
    <div class="api-content">
        <div id="api-presets-list" class="preset-list">
            </div>
        <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-api-preset-message">
            <p>还没有任何API预设。</p>
            <p>在“聊天API设置”页面配置好后，点击“另存为预设”来创建你的第一个预设吧！</p>
        </div>
    </div>
</div>

            <div id="thought-preset-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title" id="thought-preset-modal-title">添加思维预设</div>
                        <div class="close-btn" id="close-thought-preset-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">预设名称</label>
                            <input type="text" class="form-input" id="thought-preset-name-input" placeholder="例如：深度角色扮演">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">预设指令 (Prompt)</label>
                            <textarea class="form-textarea" id="thought-preset-prompt-input" placeholder="详细描述AI需要遵守的思维规则..."></textarea>
                        </div>
                        
                        <button class="form-button" id="save-thought-preset-btn">保存</button>
                    </div>
                </div>
            </div>
            
            <div id="send-picture-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发送图片</div>
                        <div class="close-btn" id="close-send-picture-modal">&times;</div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group" style="padding:0; background:none;">
                            <label class="form-label">图片描述</label>
                            <textarea class="form-textarea" id="send-picture-description-input" placeholder="由于是模拟，请输入图片的文字描述..." style="height: 120px;"></textarea>
                        </div>
                        <button class="form-button" id="confirm-send-picture-btn">发送</button>
                    </div>
                </div>
            </div>

            <div id="send-voice-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发送语音</div>
                        <div class="close-btn" id="close-send-voice-modal">&times;</div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group" style="padding:0; background:none;">
                            <label class="form-label">语音内容</label>
                            <textarea class="form-textarea" id="send-voice-text-input" placeholder="请输入您想通过语音发送的文字..." style="height: 120px;"></textarea>
                        </div>
                        <button class="form-button" id="confirm-send-voice-btn">发送</button>
                    </div>
                </div>
            </div>

            <div id="send-red-packet-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发红包</div>
                        <div class="close-btn" id="close-send-red-packet-modal">&times;</div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">金额 (元)</label>
                            <input type="number" class="contact-form-input" id="send-red-packet-amount-input" placeholder="0.00">
                        </div>
                        <div class="contact-form-group">
                            <label class="contact-form-label">祝福语 (可选)</label>
                            <input type="text" class="contact-form-input" id="send-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
                        </div>
                        <button class="form-button" id="confirm-send-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
                    </div>
                </div>
            </div>

            <div id="send-transfer-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">转账</div>
                        <div class="close-btn" id="close-send-transfer-modal">&times;</div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">转账金额 (元)</label>
                            <input type="number" class="contact-form-input" id="send-transfer-amount-input" placeholder="0.00">
                        </div>
                        <button class="form-button" id="confirm-send-transfer-btn">转账</button>
                    </div>
                </div>
            </div>
            <div id="chat-search-overlay" style="display: none;">
    <div class="search-header">
        <div class="search-input-wrapper">
            <i class="fas fa-search search-icon"></i>
            <input type="text" id="chat-search-input" placeholder="搜索聊天记录">
            <i class="fas fa-times-circle clear-search-btn" id="clear-search-btn" style="display: none;"></i>
        </div>
        <button id="close-search-btn">取消</button>
    </div>
    <div id="search-results-container">
        <div class="search-placeholder">输入关键词搜索</div>
    </div>
</div>
<div id="qzone-guestbook-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f4f5f7; overflow-y: auto; position: relative; z-index: 120;">
    
    <div class="qz-navbar scrolled" style="position:sticky; top:0; background: #fff; color: #000; border-bottom: 1px solid #eee;">
        <div class="back-btn" id="back-from-guestbook"><i class="fas fa-chevron-left"></i> 返回</div>
        <div class="nav-title">留言板</div>
        <div class="nav-actions" id="gb-write-btn" style="font-size: 14px; cursor: pointer;">留言</div>
    </div>

    <div style="padding: 10px 15px; background: #fff; margin-bottom: 10px;">
        <div id="gb-quick-input-trigger" style="background-color: #f2f2f2; border-radius: 20px; height: 40px; display: flex; align-items: center; padding: 0 15px; color: #999; font-size: 14px; cursor: pointer;">
            <i class="fas fa-pen" style="margin-right: 8px;"></i> 留个言吧...
            <i class="far fa-smile" style="margin-left: auto; font-size: 20px;"></i>
        </div>
    </div>

    <div id="guestbook-list" style="padding: 0 10px 20px 10px; display: flex; flex-direction: column; gap: 10px;">
        </div>
    
    <div style="text-align: center; color: #ccc; font-size: 12px; padding-bottom: 20px;">已加载全部</div>
</div>

<div id="guestbook-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; align-items: flex-end;">
    <div style="width: 100%; background: #fff; padding: 15px; border-radius: 12px 12px 0 0; display: flex; flex-direction: column;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <span onclick="document.getElementById('guestbook-modal').style.display='none'" style="color:#666;">取消</span>
            <span style="font-weight:bold;">写留言</span>
            <span id="submit-guestbook-btn" style="color:#FFD700; font-weight:bold;">发送</span>
        </div>
        <textarea id="guestbook-input" style="width: 100%; height: 100px; border: none; resize: none; outline: none; font-size: 16px;" placeholder="主人寄语..."></textarea>
    </div>
</div>
<div id="qzone-journal-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f9f9f9; overflow-y: auto; position: relative; z-index: 110;">
    
    <div class="qz-navbar scrolled" style="position:sticky; top:0;">
        <div class="back-btn" id="back-from-journal"><i class="fas fa-chevron-left"></i> 返回空间</div>
        <div class="nav-title">我的手账本</div>
        <div class="nav-actions">
            <i class="fas fa-pen-nib" id="qz-write-journal-btn"></i>
        </div>
    </div>

    <div id="qzone-journal-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        </div>
</div>

<div id="journal-editor-modal" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 2100; flex-direction: column;">
    
    <div style="padding: 10px 15px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; background: #fff; z-index: 10;">
        <span id="close-journal-editor" style="color: #666; cursor: pointer;">取消</span>
        <span style="font-weight: bold;">✨ 我的手账 ✨</span>
        <button id="save-journal-btn" style="background: #FFD700; border: none; padding: 5px 15px; border-radius: 20px; color: #6f4e00; font-weight: bold; box-shadow: 0 2px 5px rgba(255, 215, 0, 0.3);">保存</button>
    </div>

    <input type="text" id="journal-title-input" placeholder="📅 日期 / 标题..." style="padding: 15px; font-size: 18px; font-weight: bold; border: none; background: transparent; outline: none;">

    <div class="journal-toolbar">
        <div class="tool-btn" id="tool-format-btn" title="文字排版/字体"><i class="fas fa-text-height"></i></div>
        <div class="tool-btn" id="tool-note-btn" title="插入便利贴"><i class="fas fa-sticky-note"></i></div>
        <div class="tool-btn" id="tool-color-btn" title="换笔颜色"><i class="fas fa-palette" style="color:#ff4081;"></i></div>
        <div class="tool-btn" id="tool-sticker-btn" title="贴纸"><i class="far fa-smile-wink"></i></div>
        <div class="tool-btn" id="tool-line-btn" title="胶带/分割线"><i class="fas fa-grip-lines"></i></div>
        <div class="tool-btn" id="tool-date-btn" title="盖日期章"><i class="fas fa-stamp"></i></div>
    </div>

    <input type="color" id="journal-color-picker" style="display:none;" value="#333333">

    <div id="journal-paper-container" class="tmpl-default" style="flex-grow: 1; position: relative; overflow: hidden; transition: all 0.3s;">
       <div id="journal-content-editor" contenteditable="true" class="journal-paper-canvas font-normal" placeholder="记录当下的心情... (支持贴图哦)"></div>
    </div>

    <div id="journal-sticker-panel" style="display: none; height: 120px; background: #fff; border-top: 1px solid #eee; overflow-x: auto; white-space: nowrap; padding: 10px;">
        </div>
        <div id="journal-tape-panel" style="display: none; padding: 10px; background: #f8f9fa; border-bottom: 1px solid #eee; overflow-x: auto; white-space: nowrap; gap: 15px; align-items: center;">
        </div>
        <div id="journal-note-panel" style="display: none; padding: 10px; background: #f8f9fa; border-bottom: 1px solid #eee; overflow-x: auto; white-space: nowrap; gap: 15px; align-items: center;">
        </div>
        <div id="journal-stamp-panel" style="display: none; padding: 10px; background: #f8f9fa; border-bottom: 1px solid #eee; overflow-x: auto; white-space: nowrap; gap: 20px; align-items: center;">
        </div>
        <div id="journal-format-panel" style="display: none; padding: 15px; background: #fff; border-bottom: 1px solid #eee; flex-direction: column; gap: 15px;">
        
        <div style="display: flex; gap: 15px; justify-content: space-around;">
            <div class="format-btn" data-cmd="bold" title="加粗"><i class="fas fa-bold"></i></div>
            <div class="format-btn" data-cmd="italic" title="斜体"><i class="fas fa-italic"></i></div>
            <div class="format-btn" data-cmd="underline" title="下划线"><i class="fas fa-underline"></i></div>
            <div class="format-btn" data-cmd="strikeThrough" title="删除线"><i class="fas fa-strikethrough"></i></div>
            <div class="format-btn" data-cmd="hiliteColor" data-val="#fff59d" title="荧光笔"><i class="fas fa-highlighter" style="color:#fbc02d;"></i></div>
        </div>

        <div style="display: flex; gap: 20px; justify-content: center; border-top: 1px dashed #eee; padding-top: 10px;">
            <div class="format-btn" data-cmd="justifyLeft" title="左对齐"><i class="fas fa-align-left"></i></div>
            <div class="format-btn" data-cmd="justifyCenter" title="居中"><i class="fas fa-align-center"></i></div>
            <div class="format-btn" data-cmd="justifyRight" title="右对齐"><i class="fas fa-align-right"></i></div>
        </div>
    </div>

    <div style="padding: 10px; background: #fff; border-top: 1px solid #eee; display: flex; gap: 10px; overflow-x: auto; z-index: 10;">
        <div class="paper-swatch tmpl-default selected" data-tmpl="tmpl-default" title="纯白"></div>
        <div class="paper-swatch tmpl-grid-pink" data-tmpl="tmpl-grid-pink" title="粉色方格"></div>
        <div class="paper-swatch tmpl-kraft" data-tmpl="tmpl-kraft" title="牛皮纸"></div>
        <div class="paper-swatch tmpl-dot" data-tmpl="tmpl-dot" title="点阵"></div>
        <div class="paper-swatch tmpl-cloud" data-tmpl="tmpl-cloud" title="蓝天"></div>
    </div>
</div>

<div id="journal-detail-modal" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 2100; flex-direction: column;">
    <div class="qz-navbar scrolled" style="position:sticky; top:0; background: rgba(255,255,255,0.9);">
        <div class="back-btn" id="close-journal-detail"><i class="fas fa-times"></i> 关闭</div>
        <div class="nav-actions">
            <i class="far fa-trash-alt" id="delete-current-journal-btn" style="color: #ff4d4f;"></i>
        </div>
    </div>
    <div id="journal-detail-content" class="tmpl-default" style="flex-grow: 1; overflow-y: auto; padding: 30px 20px;">
        <h2 id="journal-detail-title" style="margin-bottom: 10px;"></h2>
        <div id="journal-detail-date" style="font-size: 12px; opacity: 0.7; margin-bottom: 20px;"></div>
        <div id="journal-detail-text" class="journal-paper-canvas"></div>
    </div>
</div>
<div id="social-zone-screen" style="display: none; flex-direction: column; width: 100%; height: 100%; background-color: #f4f5f7; overflow-y: auto; overflow-x: hidden; position: absolute; top: 0; left: 0; z-index: 100; scrollbar-width: none; -ms-overflow-style: none;">
    
    <div class="qz-navbar" id="qz-navbar">
        <div class="back-btn" id="back-from-social-zone"><i class="fas fa-chevron-left"></i> 返回</div>
        <div class="nav-title" id="qz-nav-title" style="opacity:0;">好友动态</div>
        <div class="nav-actions">
            <i class="fas fa-sync-alt" id="qz-refresh-btn" style="font-size: 20px; margin-right: 15px; cursor: pointer;"></i>
            <i class="fas fa-plus-circle" id="qz-add-post-btn" style="font-size: 22px;"></i>
        </div>
    </div>

<div class="qz-header-wrapper">
        <div class="qz-cover" id="qz-cover-img">
            <div class="qz-cover-overlay"></div>
        </div>

        <div class="qz-profile-container">
            <div class="qz-avatar-box">
                <img id="qz-user-avatar" src="" class="qz-avatar-img">
            </div>
            <div class="qz-info-box">
                <div class="qz-nickname-row">
    <span id="qz-user-name" class="qz-name-text"></span>
    <span id="qz-svip-display" class="qz-svip-badge">SVIP<i id="qz-svip-level">8</i></span>
    <div id="qz-badge-container" style="display:inline-flex; gap:3px; margin-left:5px;"></div>
    </div>
                <div class="qz-visitors">访客 2333 · 浏览 1.2w</div>
            </div>
        </div>

        <div class="qz-tab-bar" style="display: flex; justify-content: space-around; padding: 45px 0 15px 0; background: #fff; width: 100%;">
            
            <div class="qz-tab-item" id="qz-tab-status">
                <div class="qz-tab-icon"><i class="far fa-comment-dots"></i></div>
                <span>说说</span>
            </div>
            
            <div class="qz-tab-item" id="qz-nav-journal">
    <div class="qz-tab-icon"><i class="fas fa-book"></i></div>
    <span>日志</span>
</div>
            
            <div class="qz-tab-item" onclick="showGuestbookScreen()">
    <div class="qz-tab-icon"><i class="fas fa-briefcase"></i></div>
    <span>留言</span>
</div>
            
            <div class="qz-tab-item" id="qz-tab-more-btn">
    <div class="qz-tab-icon"><i class="fas fa-bars"></i></div>
    <span>更多</span>
</div>

        </div>
    <div class="qz-quick-post-area">
        <div class="qz-search-bar" id="qz-open-editor">
            <img id="qz-tiny-avatar" src="" style="width:24px; height:24px; border-radius:50%; margin-right:8px;">
            <span>说点什么吧...</span>
        </div>
    </div>

    <div id="social-zone-list" class="qz-feed-container"></div>
    <div id="qz-back-to-top" class="qz-back-to-top"><i class="fas fa-arrow-up"></i></div>
</div>

<div id="qz-post-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 2000; flex-direction: column;">
    
    <div style="padding: 15px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; flex-shrink: 0;">
        <span id="qz-close-post" style="font-size: 16px; color: #666; cursor: pointer;">取消</span>
        <span style="font-weight: bold;">写说说</span>
        
        <div style="display:flex; align-items:center; gap:10px;">
            <div id="qz-visibility-btn" style="font-size: 12px; color: #666; background: #f0f0f0; padding: 4px 10px; border-radius: 15px; cursor: pointer; display: flex; align-items: center;">
                <i class="fas fa-globe" style="margin-right: 4px;"></i> <span>公开</span>
            </div>
            <button id="qz-submit-post" style="background: #FFD700; border: none; padding: 5px 15px; border-radius: 4px; font-weight: bold; color: #6f4e00; cursor: pointer;">发表</button>
        </div>
    </div> 
    <textarea id="qz-post-input" style="width: 100%; height: 120px; padding: 15px; border: none; font-size: 16px; resize: none;" placeholder="分享新鲜事..."></textarea>
    
    <div id="qz-preview-grid" style="padding: 0 15px; display: flex; flex-wrap: wrap; gap: 8px;">
        <div id="qz-add-img-btn" style="width: 100px; height: 100px; background: #f0f0f0; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #999; cursor: pointer; border-radius: 4px;">
            <i class="fas fa-camera" style="font-size: 24px; margin-bottom: 5px;"></i>
            <span style="font-size: 12px;">照片/视频</span>
        </div>

        <div id="qz-add-sim-img-btn" style="width: 100px; height: 100px; background: #e3f2fd; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #1565c0; cursor: pointer; border-radius: 4px;">
            <i class="fas fa-magic" style="font-size: 24px; margin-bottom: 5px;"></i>
            <span style="font-size: 12px;">模拟图片</span>
        </div>
    </div>

</div>
<input type="file" id="qz-img-uploader" accept="image/*" multiple style="display: none;">
<input type="file" id="qz-img-uploader" accept="image/*" style="display: none;">
</div>
<div id="investment-center-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-investment-center"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title">Koko 游戏中心</div>
        <div style="width: 40px;"></div> </div>
    
    <div class="api-content" style="padding: 20px;">
        
        <div class="discover-section" style="margin-bottom: 20px; box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
            <div class="discover-item" id="open-scratch-card-modal-btn" style="padding: 20px; cursor: pointer;">
                <div class="discover-icon" style="background-color: #FFF3E0; color: #E6A23C; font-size: 24px;"><i class="fas fa-ticket-alt"></i></div>
                <div class="discover-info">
                    <div class="discover-name" style="font-size: 18px; font-weight: 600;">Koko彩票站</div>
                    <div class="discover-desc">幸运7, 中国红, 暴富钻石</div>
                </div>
                <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
            </div>
        </div>
    <input type="file" id="qz-cover-uploader" accept="image/*" style="display: none;">    
        <div class="discover-section" style="box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
            <div class="discover-item" id="open-stock-market-btn" style="padding: 20px; cursor: pointer;">
                <div class="discover-icon" style="background-color: #FFEBEE; color: #f44336; font-size: 24px;"><i class="fas fa-chart-line"></i></div>
                <div class="discover-info">
                    <div class="discover-name" style="font-size: 18px; font-weight: 600;">Koko交易所</div>
                    <div class="discover-desc">KokoCoin (KOK) 实时行情</div>
                </div>
                <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
            </div>
        </div>
                    <div class="discover-section" style="margin-bottom: 20px; box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
                <div class="discover-item" id="start-sea-turtle-btn" style="padding: 20px; cursor: pointer;">
                    <div class="discover-icon" style="background-color: #e0f7fa; color: #0097a7; font-size: 24px;"><i class="fas fa-water"></i></div>
                    <div class="discover-info">
                        <div class="discover-name" style="font-size: 18px; font-weight: 600;">海龟汤 (猜故事)</div>
                        <div class="discover-desc">众人猜谜</div>
                    </div>
                    <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
                </div>
            </div>
            <div class="discover-section" style="margin-bottom: 20px; box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
    <div class="discover-item" id="open-drift-bottle-btn" style="padding: 20px; cursor: pointer;">
        <div class="discover-icon" style="background-color: #E1F5FE; color: #039BE5; font-size: 24px;"><i class="fas fa-wine-bottle"></i></div>
        <div class="discover-info">
            <div class="discover-name" style="font-size: 18px; font-weight: 600;">漂流瓶</div>
            <div class="discover-desc">捡个瓶子，或者扔下心事</div>
        </div>
        <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
    </div>
</div>
<div class="discover-section" style="margin-bottom: 20px; box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
    <div class="discover-item" id="open-compatibility-btn" style="padding: 20px; cursor: pointer;">
        <div class="discover-icon" style="background-color: #FCE4EC; color: #E91E63; font-size: 24px;"><i class="fas fa-heart"></i></div>
        <div class="discover-info">
            <div class="discover-name" style="font-size: 18px; font-weight: 600;">情侣默契挑战</div>
            <div class="discover-desc">测测你和TA到底有多合拍</div>
        </div>
        <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
    </div>
</div>
<div class="discover-section" style="margin-bottom: 20px; box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
    <div class="discover-item" id="open-phone-sim-btn" style="padding: 20px; cursor: pointer;">
        <div class="discover-icon" style="background-color: #333; color: #fff; font-size: 24px;"><i class="fas fa-mobile-alt"></i></div>
        <div class="discover-info">
            <div class="discover-name" style="font-size: 18px; font-weight: 600;">反向查手机</div>
            <div class="discover-desc">生成虚拟手机记录，一键转发</div>
        </div>
        <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
    </div>
</div>
<!-- 找到 <div class="discover-item" id="open-phone-sim-btn" ...> ... </div> 所在的 discover-section -->
<!-- 在那个 section 闭合标签 </div> 之前，粘贴下面这段代码： -->

<div class="discover-item" id="open-companion-btn" style="margin-bottom: 20px; box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
    <div class="discover-icon" style="background-color: #e8eaf6; color: #7986cb; font-size: 24px;">
        <i class="fas fa-heart"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name" style="font-size: 18px; font-weight: 600;">虚拟伴侣 (番茄钟)</div>
        <div class="discover-desc">专注陪伴，摸摸头，AI 语音互动</div>
    </div>
    <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
</div>
    </div>
    </div>
<div id="drift-bottle-screen" style="display: none; flex-direction: column; height: 100%;">
    
    <div class="api-header" style="background: transparent; color: white; border: none; z-index: 10;">
        <div class="back-btn" id="back-from-drift-bottle" style="color: white; opacity: 0.8;"><i class="fas fa-arrow-left"></i></div>
        <div style="width: 40px;"></div>
    </div>

    <div class="stars-container">
        <div class="star" style="top: 20%; left: 30%; width: 2px; height: 2px; --duration: 3s; --opacity: 0.8;"></div>
        <div class="star" style="top: 50%; left: 10%; width: 3px; height: 3px; --duration: 5s; --opacity: 0.5;"></div>
        <div class="star" style="top: 10%; left: 80%; width: 2px; height: 2px; --duration: 4s; --opacity: 0.9;"></div>
        <div class="star" style="top: 70%; left: 85%; width: 3px; height: 3px; --duration: 6s; --opacity: 0.6;"></div>
        <div class="star" style="top: 40%; left: 60%; width: 1px; height: 1px; --duration: 2s; --opacity: 1;"></div>
        <div class="star" style="top: 80%; left: 40%; width: 2px; height: 2px; --duration: 7s; --opacity: 0.7;"></div>
    </div>

    <div class="cosmos-stage">
        <div class="orbit-ring orbit-1">
            <div class="orbit-dot"></div>
        </div>
        <div class="orbit-ring orbit-2">
            <div class="orbit-dot"></div>
        </div>

        <div class="glass-bottle-container planet-core">
            <i class="fas fa-satellite-dish" style="font-size: 40px; color: rgba(255,255,255,0.9);"></i>
        </div>

        <div class="cosmos-title">Cosmic Echo</div>
        <div class="cosmos-subtitle">等待宇宙尽头的回响</div>
    </div>

    <div class="cosmos-actions">
        <div class="cosmos-btn" id="throw-bottle-btn">
            <i class="fas fa-paper-plane"></i>
            <span>发射信号</span>
        </div>
        <div class="cosmos-btn" id="pick-bottle-btn">
            <i class="fas fa-radar"></i>
            <span>接收信号</span>
        </div>
    </div>

    <div id="throw-bottle-input-area" style="position: absolute; bottom: -400px; left: 0; width: 100%; padding: 20px; border-radius: 20px 20px 0 0; transition: bottom 0.3s ease; z-index: 20;">
        <h3 style="margin-bottom: 15px; font-weight:600;">发射信号</h3>
        <div class="contact-form-group" style="margin-bottom: 10px;">
            <label style="font-size:12px; color:rgba(255,255,255,0.6);">希望谁收到？</label>
            <select class="contact-form-input" id="throw-relation" style="margin-bottom:5px;">
                <option value="stranger">🌌 遥远的陌生人</option>
                <option value="connected">💫 有羁绊的人 (旧识/宿命)</option>
            </select>
            <input type="text" class="contact-form-input" id="throw-bottle-hint" placeholder="选填：例如“性别，年龄，性格”">
        </div>
        <textarea class="form-textarea" id="throw-bottle-content" placeholder="向宇宙发送你的心事..." style="height: 80px; margin-bottom: 15px;"></textarea>
        <div style="display: flex; gap: 10px;">
            <button class="form-button" id="confirm-throw-btn" style="background-color: #667eea;">发射</button>
            <button class="form-button" id="cancel-throw-btn" style="background-color: rgba(255,255,255,0.1); color: #fff;">取消</button>
        </div>
    </div>

    <div id="pick-bottle-input-area" style="position: absolute; bottom: -300px; left: 0; width: 100%; padding: 20px; border-radius: 20px 20px 0 0; transition: bottom 0.3s ease; z-index: 20;">
        <h3 style="margin-bottom: 15px; font-weight:600;">搜索信号</h3>
        <div class="contact-form-group" style="margin-bottom: 10px;">
            <label style="font-size:12px; color:rgba(255,255,255,0.6);">想搜索什么样的信号？</label>
            <select class="contact-form-input" id="pick-relation" style="margin-bottom:5px;">
                <option value="stranger">🌌 遥远的陌生人</option>
                <option value="connected">💫 有羁绊的人 (旧识/宿命)</option>
            </select>
            <input type="text" class="contact-form-input" id="pick-bottle-hint" placeholder="选填：例如“性别，年龄，性格”">
        </div>
        <div style="display: flex; gap: 10px;">
            <button class="form-button" id="confirm-pick-btn" style="background-color: #667eea;">开始搜索</button>
            <button class="form-button" id="cancel-pick-btn" style="background-color: rgba(255,255,255,0.1); color: #fff;">取消</button>
        </div>
    </div>
</div>
<div id="api-debug-screen" style="display: none; flex-direction: column; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f7f9fc; z-index: 2000;">
    <div class="api-header" style="background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
        <div class="back-btn" onclick="closeApiDebugScreen()">
            <i class="fas fa-chevron-left"></i> 返回
        </div>
        <div class="api-title" style="font-weight: 700;">API 调试台</div>
        <div style="width: 40px;"></div> </div>

    <div class="api-content" style="padding: 20px; overflow-y: auto;">
        
        <div style="background: white; border-radius: 16px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.06); margin-bottom: 20px;">
            <div style="font-size: 14px; color: #888; margin-bottom: 15px; display:flex; justify-content:space-between;">
                <span>📊 本次对话统计</span>
                <span id="debug-timestamp" style="font-size: 12px; background: #eee; padding: 2px 8px; border-radius: 4px;">无记录</span>
            </div>
            
            <div style="display: flex; justify-content: space-around; text-align: center;">
                <div>
                    <div style="font-size: 24px; font-weight: 800; color: #4facfe;" id="debug-input-tokens">-</div>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">Input Tokens</div>
                </div>
                <div style="width: 1px; background: #eee;"></div>
                <div>
                    <div style="font-size: 24px; font-weight: 800; color: #00f2fe;" id="debug-output-tokens">-</div>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">Output Tokens</div>
                </div>
                <div style="width: 1px; background: #eee;"></div>
                <div>
                    <div style="font-size: 24px; font-weight: 800; color: #ff9a9e;" id="debug-total-tokens">-</div>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">Total</div>
                </div>
            </div>
        </div>

        <div style="background: white; border-radius: 16px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.06); display: flex; flex-direction: column; height: 60%;">
            <div style="font-weight: 600; color: #333; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                <span><i class="fas fa-code"></i> 原始响应 (JSON)</span>
                <button onclick="copyDebugData()" style="background: #e0f7fa; color: #006064; border: none; padding: 5px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; font-weight: 600;">
                    <i class="far fa-copy"></i> 复制全部
                </button>
            </div>
            <textarea id="debug-raw-json" readonly 
                style="width: 100%; flex-grow: 1; background: #282c34; color: #abb2bf; padding: 15px; border-radius: 10px; border: none; font-family: 'Menlo', 'Monaco', monospace; font-size: 11px; line-height: 1.5; resize: none;"
                placeholder="等待 AI 回复中... \n\n请去和角色聊两句，这里就会自动显示最新的 API 原始数据。"></textarea>
        </div>

    </div>
</div>
<!-- ================= 虚拟伴侣 (移植版) 界面开始 ================= -->
<div id="companion-screen" style="display: none; flex-direction: column; height: 100%; position: absolute; top: 0; left: 0; width: 100%; background-color: #fdfbf7; z-index: 200;">
    <!-- 顶栏 -->
    <div class="api-header" style="background: rgba(255,255,255,0.8); backdrop-filter: blur(10px); z-index: 20;">
        <div class="back-btn" id="back-from-companion"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title">虚拟伴侣</div>
        <div class="action-btn" id="cp-settings-btn"><i class="fas fa-cog"></i></div>
    </div>

    <!-- 游戏容器 -->
    <div id="cp-app-container" style="position: relative; flex-grow: 1; overflow: hidden;">
        <div id="cp-character" class="breathe"></div>
        <div id="cp-zone-container"></div>
        <div id="cp-timer-display">25:00</div>
        <div id="cp-bubble">点击右上角设置 ⚙️ 上传立绘</div>

        <div class="cp-controls-container">
            <div id="cp-task-input-container">
                <input type="text" id="cp-task-input" placeholder="🎯 这次专注的目标是？" maxlength="20">
            </div>
            <div class="cp-btn-row-main">
                <!-- 去掉了 onclick -->
                <button id="cp-btn-start" class="cp-main-btn">🍅 开启专注</button>
                <button id="cp-btn-stop" class="cp-main-btn cp-btn-stop" style="display:none;">💔 放弃</button>
            </div>
        </div>

        <!-- 编辑器工具栏 -->
        <div id="cp-editor-toolbar">
            <div style="text-align: center; color: #aaa; font-size: 13px; margin-bottom:10px;">👇 点击屏幕添加热区，点击红圈编辑 👇</div>
            <div id="cp-selected-controls" style="display:none; flex-direction: column; gap: 10px; margin-bottom: 10px;">
                <div class="cp-toolbar-row">
                    <span>名称:</span>
                    <!-- 去掉了 oninput (我们会在JS里监听 input 事件) -->
                    <input type="text" id="cp-zone-name" class="cp-mini-input">
                    <!-- 去掉了 onclick -->
                    <button id="cp-btn-del-zone" class="cp-btn-del">删除</button>
                </div>
                <div class="cp-toolbar-row">
                    <span>大小:</span>
                    <!-- 去掉了 oninput -->
                    <input type="range" id="cp-zone-size" min="5" max="40" value="15">
                </div>
            </div>
            <!-- 去掉了 onclick -->
            <button id="cp-btn-save-edit" class="cp-big-btn" style="background:#333; color:white;">✅ 保存并退出编辑</button>
        </div>
    </div>

    <!-- 设置面板 -->
    <div id="cp-settings-panel">
        <div class="modal-header">
            <div class="modal-title">伴侣设置</div>
            <div class="close-btn" id="cp-close-settings-btn"><i class="fas fa-times"></i></div>
        </div>
        <div class="modal-body" style="overflow-y: auto; padding: 20px;">
            <!-- 去掉了 onclick -->
            <button id="cp-btn-enter-edit" class="cp-big-btn" style="background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); color:white; margin-bottom:20px;">👆 进入触摸热区编辑模式</button>
            
            <div class="section-title" style="font-weight:bold; margin-bottom:10px;">立绘管理</div>
            <div class="image-upload-grid">
                <!-- 常态 (加了 ID: cp-upload-box-normal) -->
                <div class="upload-box" id="cp-upload-box-normal">
                    <div class="preview" id="cp-preview-normal">🏠</div>
                    <div class="label">常态(必须)</div>
                    <!-- 去掉了 onchange -->
                    <input type="file" id="cp-file-normal" hidden accept="image/*">
                </div>
                <!-- 害羞 -->
                <div class="upload-box" id="cp-upload-box-shy">
                    <div class="preview" id="cp-preview-shy">😳</div>
                    <div class="label">害羞</div>
                    <input type="file" id="cp-file-shy" hidden accept="image/*">
                </div>
                <!-- 生气 -->
                <div class="upload-box" id="cp-upload-box-angry">
                    <div class="preview" id="cp-preview-angry">💢</div>
                    <div class="label">生气</div>
                    <input type="file" id="cp-file-angry" hidden accept="image/*">
                </div>
                <!-- 开心 -->
                <div class="upload-box" id="cp-upload-box-happy">
                    <div class="preview" id="cp-preview-happy">✨</div>
                    <div class="label">开心</div>
                    <input type="file" id="cp-file-happy" hidden accept="image/*">
                </div>
            </div>

            <!-- ▼▼▼ 替换开始：将原本的人设输入框改为联系人选择框 ▼▼▼ -->
<div class="contact-form-group" style="margin-top:20px;">
    <label class="contact-form-label">选择陪伴你的角色</label>
    <!-- 这里改成了 select，用来选联系人 -->
    <select id="cp-contact-select" class="contact-form-input" style="background: #f9f9f9;">
        <option value="">-- 请选择 --</option>
    </select>
    <p style="font-size:12px; color:#999; margin-top:5px;">
        * 选中后，AI 将自动读取该角色的【人设】、【你的设定】以及【最近50条聊天记忆】来生成陪伴语录。
    </p>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

            <!-- 原有的专注时长代码（不用动，仅作定位参考） -->
<div class="contact-form-group">
    <label class="contact-form-label">专注时长 (分钟)</label>
    <input type="number" id="cp-duration-input" class="contact-form-input" value="25">
</div>

<!-- ▼▼▼ 请确保这段代码存在于 id="cp-settings-panel" 里面 ▼▼▼ -->
<div class="contact-form-group">
    <label class="contact-form-label">关怀/打扰频率 (分钟)</label>
    <!-- 重点检查下面这一行，id 必须是 cp-care-interval-input -->
    <input type="number" id="cp-care-interval-input" class="contact-form-input" value="5" min="1">
    <p style="font-size:12px; color:#999; margin-top:5px;">* 设置为 0 则不触发关怀，安静陪伴。</p>
</div>
<!-- ▲▲▲ -->

            <!-- 去掉了 onclick -->
            <button id="cp-btn-gen-dialogue" class="form-button" style="background-color: #81c784; margin-top:10px;">✨ 一键生成热区台词</button>
            <button id="cp-btn-save-settings" class="form-button" style="margin-top:10px;">保存设置</button>
        </div>
    </div>
</div>
<!-- ================= 虚拟伴侣 界面结束 ================= -->
<!-- 反向查手机主界面 (V2 手动编辑版) -->
<div id="phone-simulator-screen" style="display: none; flex-direction: column; height: 100%; background-color: #222;">
    <div class="api-header" style="background: #333; color: white; border: none;">
        <div class="back-btn" id="back-from-phone-sim"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title">手机模拟器</div>
        <div class="action-btn" id="ps-ai-settings-btn" title="AI 生成设置"><i class="fas fa-magic"></i></div>
    </div>

    <div class="ps-container">
        <!-- 顶部状态条 -->
        <div class="ps-status-bar">
            <span id="ps-clock">12:00</span>
            <span><i class="fas fa-wifi"></i> <i class="fas fa-battery-full"></i></span>
        </div>

        <!-- 屏幕: 微信 (带改名功能版) -->
<div id="ps-screen-wechat" class="ps-screen-content">
    <div class="ps-wx-header">
        <div style="display: flex; align-items: center; gap: 8px;">
            <!-- 点击此处切换 单聊/群聊 -->
            <div class="ps-wx-title-area" onclick="togglePsWxMode()" style="cursor: pointer; display: flex; align-items: center; gap: 5px;">
                <span id="ps-wx-title">微信</span>
                <span id="ps-wx-mode-tag" style="font-size: 10px; background: #333; color: white; padding: 1px 4px; border-radius: 3px;">单聊</span>
            </div>
            
            <!-- ✨ 新增：修改群名的小铅笔图标 (默认隐藏) -->
            <i class="fas fa-pen" id="ps-rename-group-btn" title="修改群名称" style="font-size: 12px; color: #666; cursor: pointer; display: none; padding: 5px;"></i>
        </div>
        
        <i class="fas fa-ellipsis-h"></i>
    </div>
    <div id="ps-wx-list" class="ps-wx-list"></div>
</div>

        <!-- 屏幕: 抖音 -->
        <div id="ps-screen-tiktok" class="ps-screen-content ps-dy-container" style="display:none;">
            <h3 style="margin-bottom:15px;">喜欢</h3>
            <div id="ps-dy-list"></div>
        </div>

        <!-- 屏幕: 浏览器 -->
        <div id="ps-screen-browser" class="ps-screen-content ps-br-container" style="display:none;">
            <div style="padding:15px; font-weight:bold; font-size:18px; border-bottom:1px solid #eee;">历史记录</div>
            <div id="ps-br-list"></div>
        </div>

        <!-- 屏幕: 支付宝 -->
        <div id="ps-screen-alipay" class="ps-screen-content ps-ali-container" style="display:none;">
            <div class="ps-ali-header">
                <div style="font-size:13px; opacity:0.8;">本月支出</div>
                <div style="font-size:32px; font-weight:bold;">¥ <span id="ps-ali-total">0.00</span></div>
            </div>
            <div id="ps-ali-list"></div>
        </div>
        
        <!-- 右下角悬浮按钮组 -->
        <div style="position: absolute; bottom: 80px; right: 20px; display: flex; flex-direction: column; gap: 15px; z-index: 100;">
            <!-- 手动添加按钮 -->
            <div class="ps-fab" id="ps-add-btn" title="手动添加一条" style="position: static; background: #FF9800;">
                <i class="fas fa-plus"></i>
            </div>
            <!-- 打包转发按钮 -->
            <div class="ps-fab" id="ps-share-btn" title="打包转发" style="position: static;">
                <i class="fas fa-share"></i>
            </div>
        </div>

        <!-- 底部 Dock 栏 -->
        <div class="ps-dock" id="ps-dock">
            <div class="ps-dock-item active" data-app="wechat">
                <i class="fab fa-weixin ps-dock-icon"></i><span>微信</span>
            </div>
            <div class="ps-dock-item" data-app="tiktok">
                <i class="fab fa-tiktok ps-dock-icon"></i><span>抖音</span>
            </div>
            <div class="ps-dock-item" data-app="browser">
                <i class="fab fa-safari ps-dock-icon"></i><span>浏览器</span>
            </div>
            <div class="ps-dock-item" data-app="alipay">
                <i class="fab fa-alipay ps-dock-icon"></i><span>支付宝</span>
            </div>
        </div>
    </div>
</div>

<!-- 手动编辑弹窗 -->
<div id="ps-edit-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="ps-edit-title">编辑内容</div>
            <div class="close-btn" onclick="document.getElementById('ps-edit-modal').style.display='none'">&times;</div>
        </div>
        <div class="modal-body" id="ps-edit-form">
            <!-- 动态插入表单项 -->
        </div>
    </div>
</div>

<!-- 合并转发选择器弹窗 -->
<div id="ps-merge-selector-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 400;">
    <div class="modal-content" style="width: 85%; max-width: 320px;">
        <div class="modal-header">
            <div class="modal-title">选择要打包的数据</div>
            <div class="close-btn" onclick="document.getElementById('ps-merge-selector-modal').style.display='none'">&times;</div>
        </div>
        <div class="modal-body">
            <p style="font-size:12px; color:#888; margin-bottom:10px;">勾选多项可合并为一条聊天记录发送</p>
            
            <div id="ps-merge-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 动态生成选项 -->
            </div>

            <button class="form-button" id="ps-confirm-merge-btn" style="margin-top: 20px; background-color: var(--theme-primary);">
                下一步：选择联系人
            </button>
        </div>
    </div>
</div>
<!-- AI 生成设置弹窗 (保持不变，但为了完整性列在这里) -->
<div id="ps-ai-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">AI 生成设定</div>
            <div class="close-btn" id="close-ps-ai-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label class="form-label">剧情描述</label>
                <textarea class="form-textarea" id="ps-prompt-input" placeholder="例如：查到男朋友给女主播刷礼物的记录..." style="height: 100px;"></textarea>
            </div>
            <button class="form-button" id="ps-generate-btn" style="background-color: var(--theme-primary);"><i class="fas fa-magic"></i> 开始生成</button>
        </div>
    </div>
</div>
<div id="compatibility-screen" style="display: none; flex-direction: column; height: 100%; background-color: #fce4ec;">
    <div class="api-header">
        <div class="back-btn" id="back-from-compatibility"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title">默契大挑战</div>
        <div style="width: 40px;"></div>
    </div>

    <div class="cp-game-container">
        
        <div id="cp-step-0" class="cp-step-container active">
            <h3 style="text-align: center; color: var(--theme-primary);">💘 请选择挑战对象</h3>
            <p style="text-align: center; color: #666; font-size: 13px; margin-bottom: 20px;">AI将基于该角色的【人设】和【对你的印象】来填写问卷。</p>
            <div class="contact-picker-list" id="cp-contact-list" style="max-height: 300px; overflow-y: auto;"></div>
        </div>

        <div id="cp-step-1" class="cp-step-container">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <h3 style="margin:0; text-align: center; color: var(--theme-primary);">📝 准备问卷</h3>
                <button class="form-button" onclick="openSurveyLibraryModal()" style="width:auto; padding:5px 10px; font-size:12px; background:#673ab7;">
                    <i class="fas fa-book"></i> 题库
                </button>
            </div>

            <div style="text-align: center; margin-bottom: 10px;">
                <img id="cp-target-avatar" src="" style="width: 60px; height: 60px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <div id="cp-target-name" style="font-weight: bold; margin-top: 5px;"></div>
            </div>

            <div class="form-group" style="margin-top: 15px;">
                <label class="form-label">输入主题 (让AI生成):</label>
                <input type="text" class="form-input" id="cp-topic-input" placeholder="例如：恋爱价值观、同居习惯..." style="background: #f9f9f9;">
            </div>

            <div style="text-align: center; color: #999; margin: 10px 0;">—— 或者 ——</div>

            <button class="form-button" id="cp-upload-img-btn" style="background-color: #78909c;">
                <i class="fas fa-image"></i> 上传问卷截图 (识图)
            </button>
            <input type="file" id="cp-img-uploader" accept="image/*" style="display: none;">
            
            <button class="form-button" id="cp-start-btn" style="margin-top: 20px; background-color: var(--theme-primary);">
                <i class="fas fa-magic"></i> 生成并开始
            </button>
        </div>

        <div id="cp-step-2" class="cp-step-container">
            <div class="cp-progress-bar"><div class="cp-progress-fill" id="cp-progress-fill"></div></div>
            
            <div style="text-align:right; margin-bottom:5px;">
                <span onclick="saveCurrentSurveyToLib()" style="font-size:12px; color:#666; cursor:pointer; text-decoration:underline;">
                    <i class="far fa-save"></i> 收藏这套题
                </span>
            </div>

            <div style="text-align: center; color: #999; font-size: 12px; margin-bottom: 10px;">
                第 <span id="cp-current-num">1</span> / <span id="cp-total-num">5</span> 题
            </div>
            
            <div class="cp-question-card">
                <div class="cp-question-text" id="cp-question-text">加载中...</div>
                
                <textarea class="form-textarea" id="cp-answer-input" placeholder="写下你的答案..." style="height: 80px; display: none;"></textarea>
                
                <div id="cp-options-container"></div>

                <button class="form-button" id="cp-next-btn" style="margin-top: 20px;">下一题</button>
            </div>
        </div>

        <div id="cp-step-3" class="cp-step-container">
            <h3 style="text-align: center; color: var(--theme-primary);">✨ 默契报告 ✨</h3>
            
            <div class="cp-skin-selector">
                <div class="cp-skin-btn active" style="background:linear-gradient(135deg, #a18cd1, #fbc2eb);" onclick="switchCpSkin('default', this)" title="经典紫"></div>
                <div class="cp-skin-btn" style="background:#f48fb1;" onclick="switchCpSkin('pink', this)" title="甜蜜粉"></div>
                <div class="cp-skin-btn" style="background:#2c2c2c;" onclick="switchCpSkin('dark', this)" title="极客黑"></div>
                <div class="cp-skin-btn" style="background:#d7ccc8;" onclick="switchCpSkin('paper', this)" title="复古纸"></div>
                <div class="cp-skin-btn" style="background:#e0e5ec; border:1px solid #ccc;" onclick="switchCpSkin('neumorphism', this)" title="软萌拟态"></div>
                <div class="cp-skin-btn" style="background:linear-gradient(to right, #ffab91, #ffcc80);" onclick="switchCpSkin('summer', this)" title="仲夏夜"></div>
                <div class="cp-skin-btn" style="background:linear-gradient(180deg, #bbdefb, #fff);" onclick="switchCpSkin('snow', this)" title="富士山下"></div>
            </div>

            <div id="cp-capture-area" class="skin-default">
                <div id="cp-result-render"></div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="form-button" id="cp-save-img-btn" style="background-color: #4CAF50; flex: 1;">保存图片</button>
                
                <button class="form-button" onclick="shareCpResultToChat()" style="background-color: #2196F3; flex: 1;">
                    <i class="fas fa-paper-plane"></i> 分享给TA
                </button>
                
                <button class="form-button" id="cp-retry-btn" style="background-color: #78909c; flex: 1;">再玩一次</button>
            </div>
        </div>
    </div>
</div>
<div id="copyright-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 9999;">
    <div class="modal-content" style="max-height: 85vh; display: flex; flex-direction: column; background: #fff; width: 85%; max-width: 340px;">
        <div class="modal-header" style="background: linear-gradient(135deg, #ef5350, #c62828);">
            <div class="modal-title"><i class="fas fa-user-shield"></i> 作者公告 & 使用协议</div>
            <div class="close-btn" id="close-copyright-modal">&times;</div>
        </div>
        
        <div class="modal-body" style="overflow-y: auto; padding: 20px; font-size: 14px; line-height: 1.6; color: #333;">
            
            <div style="background: #e3f2fd; padding: 12px; border-radius: 8px; border-left: 4px solid #2196f3; margin-bottom: 15px;">
                <h4 style="margin: 0 0 5px 0; color: #1565c0; font-size: 15px;">📢 唯一官方售前群</h4>
                <p style="margin: 0;">群号：<strong style="font-size: 18px; color: #d32f2f; user-select: all;">[ 482466918 ]</strong></p>
                <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">* 除此群及作者本人外，其他任何销售渠道均为盗版。</p>
            </div>

            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 5px 0; color: #d32f2f;"><i class="fas fa-radiation"></i> 防走丢警示</h4>
                <p style="margin: 0; color: #555; text-align: justify;">为打击猖獗的二贩行为，<strong>本项目链接可能会不定期强制更换或加密</strong>。</p>
                <p style="margin: 5px 0 0 0; color: #c62828; font-weight: bold; font-size: 13px;">⚠️ 非官方渠道获取的旧链接将直接失效，无法进入，后果自负。</p>
            </div>

            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 5px 0;"><i class="fas fa-heart" style="color: #ec407a;"></i> 制作心声</h4>
                <p style="margin: 0; text-align: justify; color: #666;">“koko小手机”是作者kiko长期投入心血的作品。</p>
                <p style="margin: 8px 0 0 0; font-weight: bold; color: #333;">如果盗版持续吸血，严重打击创作热情，可能会导致项目被迫停更或关闭链接。</p>
            </div>

            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 5px 0; color: #43a047;"><i class="fas fa-tools"></i> 正版专属权益</h4>
                <ul style="margin: 0; padding-left: 20px; color: #555; font-size: 13px;">
                    <li>遇到Bug修复</li>
                    <li>操作疑问解答</li>
                    <li><strong>后续新功能许愿</strong></li>
                </ul>
            </div>

            <div style="background: #fff3e0; padding: 12px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 5px 0; color: #ef6c00;">🤝 致二贩受害者</h4>
                <p style="margin: 0; font-size: 13px;">心疼每一位因热爱而付费、却被二贩子利用的朋友。错的不是你，而是利用善意的人。欢迎回到正版怀抱，享受应有的更新服务。</p>
                <p style="margin: 5px 0 0 0; font-weight: bold; color: #e65100; font-size: 13px;">欢迎加入售前群“补票”支持正版！</p>
                <p style="margin: 3px 0 0 0; font-size: 12px; color: #f57c00;">这不仅能让你获得永久稳定的更新服务，也是对这款程序能活下去的最大支持。</p>
            </div>

            <div style="border-top: 2px dashed #e0e0e0; padding-top: 15px;">
                <h4 style="margin: 0 0 10px 0; color: #424242; font-size: 15px;"><i class="fas fa-gavel"></i> 免责与禁止事项</h4>
                <div style="background-color: #f5f5f5; border: 1px solid #eeeeee; border-radius: 6px; padding: 10px; font-size: 12px; color: #616161;">
                    <p style="margin: 0 0 8px 0;"><strong>1. 禁止使用未经授权素材：</strong></p>
                    <p style="margin: 0 0 10px 0; text-align: justify;">
                        本程序仅作为工具载体。<strong>严禁加载、使用任何未经原作者授权的素材</strong>（包括但不限于：角色卡、世界书、HTML小剧场、思维预设、背景图等）。因使用违规或来源不明的素材导致的数据损坏、隐私泄露或版权纠纷，作者概不负责。
                    </p>
                    <p style="margin: 0 0 8px 0;"><strong>2. koko小手机严禁二传二改：</strong></p>
                    <p style="margin: 0; text-align: justify;">
                        禁止以任何形式（包括但不限于倒卖、镜像站、网盘分享、整合包）<strong>二次分发</strong>本程序源代码或部署链接。一经发现，将追究相关责任并永久封禁相关服务支持。
                    </p>
                </div>
            </div>
            </div>
        
        <div class="modal-footer" style="padding: 15px; border-top: 1px solid #eee; text-align: center;">
            <button class="form-button" id="copy-group-id-btn" style="background-color: var(--theme-primary); width: 100%; font-weight: bold;">复制群号并关闭</button>
        </div>
    </div>
</div>
<div id="survey-library-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 3000;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">问卷题库</div>
            <div class="close-btn" onclick="document.getElementById('survey-library-modal').style.display='none'">&times;</div>
        </div>
        <div class="modal-body">
            <div id="survey-lib-list" class="preset-list" style="max-height:300px; overflow-y:auto;"></div>
        </div>
    </div>
</div>
<div id="bottle-content-modal">
    <div class="bottle-paper">
        <div id="bottle-loading" style="text-align: center; padding: 40px; display: none;">
            <i class="fas fa-spinner fa-spin" style="font-size: 30px; color: #888;"></i>
            <p style="margin-top: 10px; color: #666;">正在海里打捞...</p>
        </div>

        <div id="bottle-result" style="display: none;">
            <img id="bottle-avatar" src="" class="bottle-avatar-large">
            <div style="text-align: center; margin-bottom: 15px;">
                <h3 id="bottle-name" style="margin: 0; color: #333;">未知用户</h3>
                <p id="bottle-location" style="font-size: 12px; color: #888;">...</p>
            </div>
            
            <div class="bottle-info-section">
                <p class="bottle-text" id="bottle-message-text">...</p>
                <div style="font-size: 12px; color: #666; border-top: 1px dashed #ccc; padding-top: 10px;">
                    <p><strong>背景:</strong> <span id="bottle-bg-summary"></span></p>
                    <p><strong>资产:</strong> <span id="bottle-assets-summary"></span></p>
                </div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="form-button" id="reply-bottle-btn" style="background-color: var(--theme-primary);">打招呼 (加好友)</button>
                <button class="form-button" id="throw-back-btn" style="background-color: #7f8c8d;">扔回海里</button>
            </div>
        </div>
    </div>
</div>
<div id="qz-visibility-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 2100;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">谁可以看</div>
            <div class="close-btn" id="close-visibility-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="contact-picker-item" onclick="selectVisibility('public')">
                <label style="width: 100%; cursor: pointer; display:flex; align-items:center;">
                    <div style="width:40px; text-align:center; margin-right:10px; font-size:20px; color:#4CAF50;"><i class="fas fa-globe"></i></div>
                    <div style="flex:1;">
                        <div style="font-weight:bold;">公开</div>
                        <div style="font-size:12px; color:#999;">所有朋友可见</div>
                    </div>
                    <i class="fas fa-check" id="vis-check-public" style="color:var(--theme-primary); display:none;"></i>
                </label>
            </div>
            
            <div class="contact-picker-item" onclick="selectVisibility('private')">
                <label style="width: 100%; cursor: pointer; display:flex; align-items:center;">
                    <div style="width:40px; text-align:center; margin-right:10px; font-size:20px; color:#FFC107;"><i class="fas fa-lock"></i></div>
                    <div style="flex:1;">
                        <div style="font-weight:bold;">私密</div>
                        <div style="font-size:12px; color:#999;">仅自己可见</div>
                    </div>
                    <i class="fas fa-check" id="vis-check-private" style="color:var(--theme-primary); display:none;"></i>
                </label>
            </div>

            <div class="contact-picker-item" onclick="selectVisibility('partial')">
                <label style="width: 100%; cursor: pointer; display:flex; align-items:center;">
                    <div style="width:40px; text-align:center; margin-right:10px; font-size:20px; color:#2196F3;"><i class="fas fa-user-group"></i></div>
                    <div style="flex:1;">
                        <div style="font-weight:bold;">部分可见</div>
                        <div style="font-size:12px; color:#999;">选中的朋友可见</div>
                    </div>
                    <i class="fas fa-check" id="vis-check-partial" style="color:var(--theme-primary); display:none;"></i>
                </label>
            </div>

            <div id="visibility-contact-list" style="display:none; border-top:1px dashed #eee; margin-top:10px; padding-top:10px; max-height:200px; overflow-y:auto;">
                </div>
            
            <button class="form-button" id="confirm-visibility-btn" style="margin-top:15px;">确定</button>
        </div>
    </div>
</div>
<div id="qz-settings-modal">
    <div class="qz-settings-panel">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 style="margin:0; font-size:18px;">空间个性化</h2>
            <i class="fas fa-times" id="close-qz-settings" style="font-size:20px; cursor:pointer; color:#999;"></i>
        </div>

        <div class="qz-setting-group">
            <div class="qz-setting-title">主题风格</div>
            <div class="color-swatch-list">
                <div class="color-swatch active" style="background:#f4f5f7;" onclick="setQzoneTheme('default', this)" title="默认"></div>
                <div class="color-swatch" style="background:#F8BBD0;" onclick="setQzoneTheme('pink', this)" title="少女粉"></div>
                <div class="color-swatch" style="background:#212121; border:2px solid #d4af37;" onclick="setQzoneTheme('darkgold', this)" title="暗黑金"></div>
                <div class="color-swatch" style="background:#BBDEFB;" onclick="setQzoneTheme('blue', this)" title="天空蓝"></div>
            </div>
        </div>

        <div class="qz-setting-group">
            <div class="qz-setting-title">昵称颜色</div>
            <div style="display:flex; align-items:center; gap:10px;">
                <input type="color" id="qz-name-color-input" value="#ffffff">
                <span style="font-size:12px; color:#666;">点击色块选择颜色</span>
            </div>
        </div>

        <div class="qz-setting-group">
            <div class="qz-setting-title">全局背景图 (信息流背景)</div>
            <button class="form-button" id="upload-qz-bg-btn" style="background-color: var(--theme-secondary); width:auto; padding:8px 15px; font-size:14px;">
                <i class="fas fa-image"></i> 上传背景图
            </button>
            <button class="form-button" id="reset-qz-bg-btn" style="background-color: #ddd; color:#333; width:auto; padding:8px 15px; font-size:14px; margin-left:10px;">
                恢复默认
            </button>
            <input type="file" id="qz-bg-uploader" accept="image/*" style="display: none;">
        </div>

        <div class="qz-setting-group">
    <div class="qz-setting-title">身份标识</div>
    
    <div class="contact-form-group">
        <label class="form-label" style="font-size:12px;">手机型号小尾巴</label>
        <input type="text" class="form-input" id="qz-device-input" placeholder="例如: iPhone 18 Pro Max">
    </div>
    
    <div style="display:flex; gap:15px; align-items:center; margin-top:10px;">
        <div>
            <label class="form-label" style="font-size:12px;">SVIP 等级</label>
            <input type="number" class="form-input" id="qz-svip-level-input" value="8" style="width:60px;">
        </div>
        <label class="switch" style="margin-top:20px;">
            <input type="checkbox" id="qz-svip-toggle" checked>
            <span class="slider round"></span>
        </label>
        <span style="font-size:12px; color:#666; margin-top:20px;">显示SVIP</span>
    </div>

    <div style="margin-top: 15px;">
        <label class="form-label" style="font-size:12px;">SVIP 铭牌风格</label>
        <div style="display:flex; gap:10px; margin-top:5px;">
            <div class="svip-style-opt active" onclick="selectSvipStyle('yellow', this)" 
                 style="padding:5px 10px; background:linear-gradient(90deg, #FFC107, #FF9800); color:white; border-radius:4px; font-size:12px; cursor:pointer; border:2px solid transparent;">
                 经典黄
            </div>
            <div class="svip-style-opt" onclick="selectSvipStyle('black-gold', this)" 
                 style="padding:5px 10px; background:#000; color:#FFD700; border:1px solid #FFD700; border-radius:4px; font-size:12px; cursor:pointer;">
                 黑金版
            </div>
            <div class="svip-style-opt" onclick="selectSvipStyle('black-red', this)" 
                 style="padding:5px 10px; background:#1a0000; color:#FF5252; border:1px solid #FF5252; border-radius:4px; font-size:12px; cursor:pointer;">
                 黑红版
            </div>
        </div>
    </div>
</div>
        <div class="qz-setting-group">
    <div class="qz-setting-title">已开通服务 (多选)</div>
    <div class="badge-grid">
        <div class="badge-option" onclick="toggleQzBadge('yellow')" id="badge-opt-yellow">
            <i class="fas fa-gem badge-icon diamond-yellow"></i><span>黄钻</span>
        </div>
        <div class="badge-option" onclick="toggleQzBadge('red')" id="badge-opt-red">
            <i class="fas fa-gem badge-icon diamond-red"></i><span>红钻</span>
        </div>
        <div class="badge-option" onclick="toggleQzBadge('green')" id="badge-opt-green">
            <i class="fas fa-gem badge-icon diamond-green"></i><span>绿钻</span>
        </div>
        <div class="badge-option" onclick="toggleQzBadge('blue')" id="badge-opt-blue">
            <i class="fas fa-gem badge-icon diamond-blue"></i><span>蓝钻</span>
        </div>
        <div class="badge-option" onclick="toggleQzBadge('purple')" id="badge-opt-purple">
            <i class="fas fa-gem badge-icon diamond-purple"></i><span>紫钻</span>
        </div>
        <div class="badge-option" onclick="toggleQzBadge('star')" id="badge-opt-star">
            <i class="fas fa-star badge-icon icon-star"></i><span>星选</span>
        </div>
        <div class="badge-option" onclick="toggleQzBadge('music')" id="badge-opt-music">
            <i class="fas fa-music badge-icon" style="color:#8BC34A"></i><span>绿钻</span>
        </div>
        <div class="badge-option" onclick="toggleQzBadge('video')" id="badge-opt-video">
            <i class="fas fa-video badge-icon" style="color:#FF9800"></i><span>影视</span>
        </div>
    </div>
</div>
<div class="qz-setting-group">
            <div class="qz-setting-title">生态模拟 (自动刷新)</div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <label class="form-label" style="margin-bottom: 0;">启用好友自动发动态</label>
                <label class="switch">
                    <input type="checkbox" id="qz-auto-refresh-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
                <span style="font-size:12px; color:#666;">频率(秒):</span>
                <input type="number" class="form-input" id="qz-auto-refresh-interval" value="600" style="width:80px; padding:5px;">
                <span style="font-size:12px; color:#999;">(建议 > 300秒)</span>
            </div>
        </div>
        <div class="qz-setting-group">
            <div class="qz-setting-title">内容源设置</div>
            <p style="font-size:12px; color:#999; margin-bottom:10px;">勾选你想在空间看到动态的角色。未勾选的角色将保持沉默。</p>
            <div id="qz-allowed-posters-list" class="world-book-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                </div>
            <div style="margin-top: 5px; text-align: right;">
                <span style="font-size:12px; color:#576b95; cursor:pointer;" onclick="toggleAllQzonePosters(true)">全选</span>
                <span style="font-size:12px; color:#ccc;"> | </span>
                <span style="font-size:12px; color:#576b95; cursor:pointer;" onclick="toggleAllQzonePosters(false)">全不选</span>
            </div>
        </div>
        <button class="form-button" id="save-qz-settings-btn">保存所有设置</button>
    </div>
</div>
<div id="start-game-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">开始新游戏：海龟汤</div>
            <div class="close-btn" id="close-start-game-modal">&times;</div>
        </div>
        <div class="modal-body">
            
            <div class="contact-form-group">
                <label class="contact-form-label">主持人 (GM) 人设:</label>
                <textarea class="form-textarea" id="game-gm-persona-input" style="height: 60px; font-size: 14px;"></textarea>
            </div>

            <div class="contact-form-group">
                <label class="contact-form-label">你 (玩家) 的人设:</label>
                <select class="form-input" id="game-user-persona-select" style="font-size: 14px;">
                    </select>
            </div>
            
            <label class="contact-form-label">从联系人选择 AI 队友 (可选):</label>
            <div class="contact-picker-list" id="game-player-picker-list" style="max-height: 100px; overflow-y: auto;">
                </div>
            
            <label class="contact-form-label" style="margin-top: 15px;">从关系网选择 NPC 队友 (可选):</label>
            <div class="contact-picker-list" id="game-npc-picker-list" style="max-height: 100px; overflow-y: auto;">
                </div>
            
            <div class="contact-form-group" style="margin-top: 15px;">
                <label class="contact-form-label">手动添加NPC队友 (可选, 每行一个):</label>
                <textarea class="form-textarea" id="game-custom-npcs-input" style="height: 50px; font-size: 14px;" placeholder="Koko | 活泼、好奇心强的少女"></textarea>
            </div>
            
            <div class="contact-form-group" style="margin-top: 15px;">
                <label class="contact-form-label">汤底关键词 (可选):</label>
                <input type="text" class="contact-form-input" id="soup-keywords-input" placeholder="例如：恐怖、动物 (留空则完全随机)">
            </div>
            
            <button class="form-button" id="confirm-start-game-btn" style="margin-top: 15px;">
                <i class="fas fa-play"></i> 开始游戏
            </button>
        </div>
    </div>
</div>
<div id="game-chat-screen" style="display: none; flex: 1; flex-direction: column; height: 100%; background: #1c1c1e; color: white;">
    <div id="game-header" style="background-color: #2c2c2e; padding: 15px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #3a3a3c; flex-shrink: 0; position: relative;">
        <button id="game-surrender-btn" title="认输并查看答案" style="border: none; background: none; color: #8e8e93; font-size: 14px; cursor: pointer; padding: 5px;">
            <i class="fas fa-flag-checkered"></i> 认输
        </button>
        <h3 id="game-title" style="margin: 0; font-size: 18px; position: absolute; left: 50%; transform: translateX(-50%);">海龟汤游戏室</h3>
        <button id="game-exit-btn" title="退出游戏" style="border: none; background: none; color: #8e8e93; font-size: 16px; cursor: pointer; padding: 5px; width: 50px; text-align: right;">
            <i class="fas fa-times"></i>
        </button>
    </div>
    
    <div id="game-chat-log-wrapper" style="flex: 1; overflow-y: auto; position: relative;">
        <div id="game-puzzle-area-pinned" style="position: sticky; top: 0; background-color: #2c2c2e; padding: 15px; margin: 8px; border-radius: 12px; border: 1px solid #3a3a3c; z-index: 5; color: #8e8e93; font-size: 15px; line-height: 1.5;">
            <strong>汤面：</strong>
            <span id="game-puzzle-text"><i class="fas fa-spinner fa-spin"></i> 主持人正在创作谜题中...</span>
        </div>
        <div id="game-chat-log" style="padding: 8px; display: flex; flex-direction: column;">
            </div>
    </div>
    
    <div id="game-input-area" style="display: flex; padding: 8px 10px; border-top: 1px solid #3a3a3c; background: #2c2c2e; align-items: flex-end; position: relative;">
        <textarea id="game-user-input" placeholder="输入..." rows="1" style="flex: 1; border: 1px solid #3a3a3c; border-radius: 20px; padding: 8px 15px; font-size: 15px; outline: none; resize: none; min-height: 20px; max-height: 100px; overflow-y: auto; background: #3a3a3c; color: #ffffff;"></textarea>
        <button id="game-discuss-btn" class="game-input-btn" title="和队友讨论 (主持人不回答)" style="background-color: #34c759; color: white;">
            <i class="fas fa-comments"></i>
        </button>
        <button id="game-ask-host-btn" class="game-input-btn" title="向主持人提问 (是/否)" style="background-color: #ff453a; color: white;">
            <i class="fas fa-question"></i>
        </button>
        <button id="game-play-again-btn" style="display: none; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 2; border: none; background-color: #34c759; color: white; border-radius: 20px; padding: 10px 20px; cursor: pointer; font-size: 15px; font-weight: 600;">
            <i class="fas fa-redo"></i> 再玩一局
        </button>
    </div>
</div>
<div id="stock-market-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-stock-market"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title">Koko 交易所</div>
        <div style="width: 40px;"></div> 
    </div>

    <div class="feed-tabs" id="stock-tabs-container">
        <button class="feed-tab-btn active" data-stock-id="KOK"><i class="fas fa-coins"></i> KokoCoin (KOK)</button>
        <button class="feed-tab-btn" data-stock-id="TECH"><i class="fas fa-microchip"></i> 科技股 (TECH)</button>
        <button class="feed-tab-btn" data-stock-id="BIO"><i class="fas fa-dna"></i> 医药股 (BIO)</button>
    </div>
    
    <div id="stock-news-feed" style="height: 250px; border-bottom: 1px solid #eee; overflow-y: auto; padding: 8px 12px; font-size: 13px;">
        <div class="news-item" style="color: #888;">交易所启动中，等待最新消息...</div>
    </div>

    <div class="api-content" style="padding: 15px; flex-grow: 1; overflow-y: auto;">
        
        <div id="stock-chart-container" style="width: 100%; height: 200px; background: #fff; border-radius: 8px;"></div>
        
        <div class="form-group" style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: baseline;">
                <label class="form-label" style="font-size: 18px;">当前价格:</label>
                <div id="stock-current-price" style="font-size: 24px; font-weight: bold; color: #f44336;">¥100.00</div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: 10px;">
                <label class="form-label">我的持仓:</label>
                <div id="stock-my-shares">0 股 (成本: ¥0.00)</div>
            </div>
<div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: 5px;">
                <label class="form-label">持仓市值:</label>
                <div id="stock-my-value" style="font-weight: 500;">¥0.00</div>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: 5px;">
                <label class="form-label">持仓盈亏:</label>
                <div id="stock-holding-pl" style="font-weight: bold;">¥0.00</div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: 5px;">
                <label class="form-label">累计盈亏:</label>
                <div id="stock-cumulative-pl" style="font-weight: bold;">¥0.00</div>
            </div>
            </div>

        <div class="form-group" style="display: flex; gap: 10px; align-items: center;">
            <input type="number" id="stock-amount-input" class="form-input" placeholder="输入股数" min="1" step="1">
            <button class="form-button" id="stock-buy-btn" style="width: auto; margin: 0; padding: 12px 20px;">买入</button>
            <button class="form-button" id="stock-sell-btn" style="width: auto; margin: 0; padding: 12px 20px; background-color: #7f8c8d;">卖出</button>
        </div>
        <p style="text-align: center; font-size: 12px; color: #999;">*交易将收取 1.5% 的手续费*</p>
    </div>
</div>
<div id="scratch-card-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">Koko彩票站</div>
            <div class="close-btn" id="close-scratch-card-modal">&times;</div>
        </div>
        <div class="modal-body" style="text-align: center;">
            <p style="margin-bottom: 20px;">选择你想买的刮刮乐：</p>
            
            <button class="form-button buy-scratch-card-btn" data-price="20" data-game-type="lucky_7" style="background-color: #66bb6a; margin-top: 10px;">
                买一张 20元「幸运 7」
            </button>
            <button class="form-button buy-scratch-card-btn" data-price="50" data-game-type="china_red" style="background-color: #f44336; margin-top: 10px;">
                买一张 50元「中国红」
            </button>
            <button class="form-button buy-scratch-card-btn" data-price="100" data-game-type="diamond" style="background-color: #42a5f5; margin-top: 10px;">
                买一张 100元「暴富钻石」
            </button>

            <div id="scratch-result-area" style="margin-top: 25px; padding: 15px; background: #f0f0f0; border-radius: 8px; display: none;">
                <h3 id="scratch-result-title" style="margin-bottom: 15px;"></h3>
                
                <div id="scratch-grid-display" style="margin-bottom: 15px;">
                    </div>
                
                <p id="scratch-result-message" style="font-weight: bold;"></p>
            </div>
        </div>
    </div>
</div>
<div id="memory-core-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content" style="height: 70vh; display: flex; flex-direction: column;">
        <div class="modal-header" style="background: linear-gradient(135deg, #AB47BC 0%, #7B1FA2 100%);">
            <div class="modal-title">记忆核心 (Memory Core)</div>
            <div class="close-btn" id="close-memory-core-modal">&times;</div>
        </div>
        <div class="modal-body" style="flex-grow: 1; overflow-y: auto; background: #f3e5f5;">
            <div id="memory-usage-bar" style="text-align: right; font-size: 12px; color: #7B1FA2; margin-bottom: 10px;">容量: 0/20</div>
            <div id="memory-core-list" style="display: flex; flex-direction: column; gap: 10px;">
                </div>
            <div id="memory-empty-state" style="text-align: center; padding: 40px 20px; color: #999; display: none;">
                <i class="fas fa-brain" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"></i>
                <p>这里一片空白...</p>
                <p style="font-size: 12px; margin-top: 5px;">只有当发生触动灵魂的事件时，<br>Ta 才会主动将记忆写入这里。</p>
            </div>
        </div>
        <div style="padding: 15px; background: white; text-align: center; font-size: 12px; color: #666; border-top: 1px solid #eee;">
            这些是 Ta 选择记住的，请谨慎删除。
        </div>
    </div>
</div>
<div id="qz-comment-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; align-items: flex-end;">
    <div style="width: 100%; background: #f2f2f2; padding: 10px 15px; display: flex; align-items: flex-end; gap: 10px; border-radius: 12px 12px 0 0;">
        <textarea id="qz-comment-input" rows="1" style="flex-grow: 1; border: none; border-radius: 4px; padding: 10px; font-size: 16px; resize: none; max-height: 100px; background: #fff;" placeholder="回复楼主..."></textarea>
        <button id="qz-submit-comment-btn" style="background: #576b95; color: white; border: none; padding: 8px 15px; border-radius: 4px; font-weight: bold; margin-bottom: 2px;">发送</button>
    </div>
</div>
<div id="forum-category-management-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-category-management">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">论坛板块管理</div>
        <div class="action-btn" id="add-category-btn">
            <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content">
        <div id="category-list" class="preset-list">
            </div>
        <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-category-message">
            <p>还没有任何自定义板块。</p>
            <p>点击右上角“+”添加新的板块吧！</p>
        </div>
    </div>
</div>
<div id="lucky-char-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
    <div class="modal-content" style="max-height: 80vh; display: flex; flex-direction: column;">
        <div class="modal-header" style="background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%);">
            <div class="modal-title">幸运字符仓库</div>
            <div class="close-btn" id="close-lucky-char-modal">&times;</div>
        </div>
        <div class="modal-body" style="flex-grow: 1; overflow-y: auto; padding: 15px;">
            
            <div style="text-align: center; margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px dashed #ddd;">
                <p style="color: #666; font-size: 13px; margin-bottom: 10px;" id="lucky-draw-tips">
                    每日限抽 3 次，快来试试手气！
                </p>
                <button class="form-button" id="draw-lucky-char-btn" style="background-color: #9c27b0; color: white; width: auto; padding: 8px 25px; border-radius: 20px;">
                    <i class="fas fa-magic"></i> 抽取新字符
                </button>
            </div>

            <h3 class="mask-editor-title" style="font-size: 15px; margin-bottom: 10px;">我的收藏</h3>
            <div id="lucky-char-list" class="lucky-char-grid">
                </div>

        </div>
    </div>
</div>
<div id="edit-emoticon-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">编辑表情包</div>
            <div class="close-btn" id="close-edit-emoticon-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div style="text-align: center; margin-bottom: 15px;">
                <img id="edit-emo-preview" src="" style="max-height: 100px; max-width: 100%;">
            </div>

            <div class="contact-form-group">
                <label class="contact-form-label">表情名称</label>
                <input type="text" class="contact-form-input" id="edit-emo-name-input">
            </div>

            <div class="contact-form-group">
                <label class="contact-form-label">所属分组</label>
                <select class="contact-form-input" id="edit-emo-group-select">
                    </select>
            </div>

            <button class="form-button" id="save-edit-emoticon-btn">保存修改</button>
        </div>
    </div>
</div>
<div id="add-category-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="category-modal-title">添加新板块</div>
            <div class="close-btn" id="close-category-modal">&times;</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="category-id-input">
            <div class="contact-form-group">
                <label class="contact-form-label">板块名称 (*)</label>
                <input type="text" class="contact-form-input" id="category-name-input" placeholder="例如：K-POP专区">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">板块描述/要求 (*)</label>
                <textarea class="contact-form-textarea" id="category-description-input" placeholder="请告诉AI这个板块是关于什么的，需要生成什么样的帖子内容..."></textarea>
            </div>
            <button class="form-button" id="save-category-btn">保存板块</button>
        </div>
    </div>
</div>
        </div>
    </div>

    <div id="chat-pet-container" style="display: none; position: fixed; z-index: 999; cursor: move; bottom: 80px; left: 20px;">
    
    <div id="pet-quick-menu">
        <div class="pet-menu-item" id="quick-toggle-narrative">
            <span class="pet-menu-label">叙事模式</span>
            <label class="mini-switch">
                <input type="checkbox" id="pet-narrative-check">
                <span class="mini-slider"></span>
            </label>
        </div>
        </div>
    <div class="slime">
        <div class="blush left"></div>
        <span class="mouth"></span> 
        <div class="blush right"></div>
    </div>
    <div class="slime-shadow"></div>
</div>

    <input type="file" id="moments-bg-upload" accept="image/*" style="display: none;">
    <div id="red-packet-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div id="red-packet-content" style="background-color: #DB5A48; width: 85%; max-width: 300px; border-radius: 10px; text-align: center; color: #FADFC6; position: relative; padding-bottom: 30px;">
            <div id="close-red-packet-modal" style="position: absolute; top: 10px; left: 15px; font-size: 24px; color: #FADFC6; cursor: pointer;">&times;</div>
            <div style="padding: 40px 0 20px;">
                <img id="red-packet-sender-avatar" src="" style="width: 50px; height: 50px; border-radius: 6px; margin-bottom: 10px;">
                <div id="red-packet-sender-name" style="font-size: 16px;"></div>
                <div id="red-packet-blessing-text" style="font-size: 22px; margin-top: 15px; font-weight: bold; padding: 0 20px;">恭喜发财，大吉大利！</div>
            </div>
            <div id="open-red-packet-btn" style="background-color: #FADDC4; width: 80px; height: 80px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto; color: #C35645; font-size: 50px; font-weight: bold; cursor: pointer; transform: rotate(0deg); transition: transform 0.5s ease;">开</div>
            <div id="red-packet-result" style="display: none; padding-top: 20px;">
                <div id="red-packet-amount-text" style="font-size: 40px; font-weight: bold; color: white;"></div>
                <div id="red-packet-collected-by" style="font-size: 14px; margin-top: 10px;"></div>
                <a id="view-red-packet-details" href="#" style="font-size: 12px; color: #FADFC4; text-decoration: none; margin-top: 15px; display: inline-block;">查看领取详情 &gt;</a>
            </div>
        </div>
    </div>
    <input type="file" id="avatar-uploader" accept="image/*" style="display: none;">
<input type="file" id="persona-avatar-uploader" accept="image/*" style="display: none;">
<input type="file" id="group-npc-avatar-uploader" accept="image/*" style="display: none;">
    <div id="transfer-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 200;">
        <div class="modal-content" style="max-width: 320px; background-color: #f7f9f9;">
            <div class="modal-header">
                <div class="modal-title" id="transfer-modal-title">转账</div>
                <div class="close-btn" id="close-transfer-modal">&times;</div>
            </div>
            <div class="modal-body">
                <div id="transfer-confirm-view">
                    <div class="transfer-sender-profile">
                        <img id="transfer-sender-avatar" src="" class="transfer-sender-avatar">
                        <div class="transfer-sender-info">
                            <div class="transfer-sender-name" id="transfer-sender-name"></div>
                            <div class="transfer-recipient-name" id="transfer-recipient-text"></div>
                        </div>
                    </div>
                    <div class="transfer-amount-display">
                        <span>¥</span><span id="transfer-amount-value"></span>
                    </div>
                    <div class="transfer-action-area">
                        <button id="confirm-transfer-btn" class="form-button">确认收款</button>
                        <button id="return-transfer-btn" class="form-button">退还</button>
                    </div>
                </div>
                <div id="transfer-status-view" style="display: none;">
                    <div class="transfer-amount-display">
                        <span>¥</span><span id="transfer-status-amount-value"></span>
                    </div>
                    <div class="transfer-status-info">
                        <i id="transfer-status-icon" class="fas fa-check-circle"></i>
                        <span id="transfer-status-text">已收款</span>
                    </div>
                    <div id="transfer-status-sender-info" class="transfer-status-subtext"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="wallet-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
        <div class="api-header"> 
            <div class="back-btn" id="back-from-wallet">
                <i class="fas fa-arrow-left"></i>
            </div>
            <div class="api-title">收支明细</div>
            <div style="width:40px;"></div>
        </div>
        <div class="api-content" style="padding: 0;">
            <div id="transaction-list">
                </div>
            <div id="no-transaction-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                <p>还没有任何收支记录哦。</p>
            </div>
        </div>
    </div>

    <audio id="global-audio-player"></audio>
    <audio id="voice-message-player"></audio>
    <audio id="notification-sound-player"></audio>
<div id="send-music-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content" style="max-height: 90%; display: flex; flex-direction: column;">
        <div class="modal-header">
            <div class="modal-title">搜索并分享音乐</div>
            <div class="close-btn" id="close-send-music-modal">&times;</div>
        </div>
        
        <div class="modal-body" style="overflow-y: auto; flex-grow: 1;">
            <div style="background: var(--card-background); padding: 12px; border-radius: 12px; border: 1px solid var(--border-color); margin-bottom: 20px;">
                <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                    <input type="text" id="music-search-keyword-modal" class="form-input" placeholder="输入歌名搜索..." style="margin: 0; flex: 1; background: white !important;">
                    <button id="music-search-btn-modal" class="form-button" style="width: auto; margin: 0; padding: 0 20px; flex-shrink: 0; background-color: var(--theme-accent, #007AFF);"><i class="fas fa-search"></i></button>
                </div>
                <div id="music-search-results-modal" style="max-height: 180px; overflow-y: auto; font-size: 13px;">
                    <p style="color: #999; text-align: center; padding: 10px;">在这里搜索，结果会显示在下方</p>
                </div>
            </div>

            <div id="music-library-picker" style="margin-bottom: 20px; border-top: 1px dashed #eee; padding-top: 15px;"></div>

            <div style="background: #f9f9f9; padding: 15px; border-radius: 12px;">
                <div class="contact-form-group">
                    <label class="contact-form-label">歌曲名 (*)</label>
                    <input type="text" class="contact-form-input" id="send-music-title-input" placeholder="例如：晴天">
                </div>
                <div class="contact-form-group" style="display: flex; gap: 10px;">
                    <div style="flex: 1;">
                        <label class="contact-form-label">歌手 (*)</label>
                        <input type="text" class="contact-form-input" id="send-music-artist-input" placeholder="例如：周杰伦">
                    </div>
                </div>
                 <div class="contact-form-group">
                    <label class="contact-form-label">歌曲链接 URL (*)</label>
                    <input type="text" class="contact-form-input" id="send-music-url-input" placeholder="http://...">
                </div>
                <textarea id="send-music-lrc-input" style="display: none;"></textarea>
                <input type="hidden" id="send-music-cover-input">

                <div style="display: flex; align-items: center; margin-top: 15px;">
                    <input type="checkbox" id="notify-ai-checkbox" checked style="margin-right: 10px;">
                    <label for="notify-ai-checkbox" style="color: #666; font-size: 14px;">通知对方并邀请评论</label>
                </div>
            </div>
        </div>
        
        <div style="padding: 15px; border-top: 1px solid #eee; background: #fff;">
            <button class="form-button" id="confirm-send-music-btn" style="margin: 0; width: 100%; background-color: var(--theme-accent, #007AFF);">确认分享</button>
        </div>
    </div>
</div>
    <div id="create-forum-red-packet-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">在帖子中添加红包</div>
                <div class="close-btn" id="close-forum-red-packet-modal">&times;</div>
            </div>
            <div class="modal-body">
                <div class="contact-form-group">
                    <label class="contact-form-label">总金额 (元)</label>
                    <input type="number" class="contact-form-input" id="forum-red-packet-amount-input" placeholder="0.00">
                </div>
                <div class="contact-form-group">
                    <label class="contact-form-label">红包个数</label>
                    <input type="number" class="contact-form-input" id="forum-red-packet-count-input" placeholder="填写个数，比如10">
                </div>
                <div class="contact-form-group">
                    <label class="contact-form-label">祝福语 (可选)</label>
                    <input type="text" class="contact-form-input" id="forum-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
                </div>
                <button class="form-button" id="confirm-forum-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
            </div>
        </div>
    </div>

    <div id="repost-contact-picker-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">转发给</div>
                <div class="close-btn" id="close-repost-modal">&times;</div>
            </div>
            <div class="modal-body">
                <div class="contact-picker-list" id="repost-contact-list"></div>
                <div class="contact-form-group">
                    <label class="contact-form-label">留言 (可选)</label>
                    <input type="text" class="contact-form-input" id="repost-message-input" placeholder="说点什么吧...">
                </div>
                <button class="form-button" id="confirm-repost-btn">发送</button>
            </div>
        </div>
    </div>
    <div id="custom-prompt-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="custom-prompt-title">修改信息</div>
            </div>
            <div class="modal-body">
                <div class="contact-form-group">
<textarea class="form-textarea" id="custom-prompt-input" style="height: 120px; font-size: 15px;"></textarea>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="form-button" id="custom-prompt-cancel-btn" style="background-color: #bdc3c7; flex: 1;">取消</button>
                    <button class="form-button" id="custom-prompt-confirm-btn" style="flex: 1;">确定</button>
                </div>
            </div>
        </div>
    </div>

    <div id="custom-confirm-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="custom-confirm-title">请确认</div>
            </div>
            <div class="modal-body">
                <p id="custom-confirm-text" style="line-height: 1.6; font-size: 16px; margin-bottom: 20px;"></p>
                <div style="display: flex; gap: 10px;">
                    <button class="form-button" id="custom-confirm-cancel-btn" style="background-color: #bdc3c7; flex: 1;">取消</button>
                    <button class="form-button" id="custom-confirm-confirm-btn" style="flex: 1;">确定</button>
                </div>
            </div>
        </div>
    </div>
   
     <div id="music-player-card" style="display: none;">
        <div class="player-header" id="player-header">
            <i class="fas fa-chevron-down player-collapse-btn" id="player-collapse-btn"></i>
            <span class="player-header-title">一起听歌中</span>
            <div class="header-collapsed-content">
                <div class="header-avatar-stack">
                    <img id="header-user-avatar" class="header-avatar">
                    <img id="header-contact-avatar" class="header-avatar">
                </div>
                <span id="header-lyric" class="header-lyric">...</span>
            </div>
            <i class="fas fa-times" id="player-close-btn"></i>
        </div>
        
        <div class="player-main-content">
            <div class="player-avatar-stack" id="player-avatar-stack">
                <img id="player-user-avatar" class="player-avatar">
                <img id="player-contact-avatar" class="player-avatar">
            </div>
            <div class="player-song-info">
                <div id="player-title" class="player-title"></div>
                <div id="player-artist" class="player-artist"></div>
            </div>
            <div class="lyrics-container" id="lyrics-container">
                <div class="lyrics-wrapper" id="lyrics-wrapper"></div>
            </div>
            <div class="player-controls-wrapper">
                <div class="player-progress-bar-wrapper">
                    <span id="player-current-time">00:00</span>
                    <div class="player-progress-bar" id="player-progress-bar">
                        <div class="player-progress" id="player-progress"></div>
                    </div>
                    <span id="player-duration">00:00</span>
                </div>
                <div class="player-controls">
                    <i class="fas fa-repeat player-control-btn" id="player-mode-btn" title="列表循环"></i>
                    <i class="fas fa-backward-step player-control-btn" id="player-prev-btn"></i>
                    <i class="fas fa-play-circle player-control-btn player-play-btn" id="player-play-btn"></i>
                    <i class="fas fa-forward-step player-control-btn" id="player-next-btn"></i>
                    <i class="fas fa-list-ul player-control-btn" id="player-playlist-btn" title="播放列表"></i>
                </div>
            </div>
        </div>

        <div class="player-playlist-view" id="player-playlist-view">
            <ul id="playlist-list" style="list-style: none; margin: 0; padding: 0;"></ul>
        </div>
    </div>
    <div id="red-packet-details-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 250;">
        <div class="modal-content" style="max-width: 340px; background-color: #f7f9f9;">
            <div class="modal-header" style="background-color: #f7f9f9; color: var(--text-dark); border-bottom: 1px solid #eee;">
                <div class="modal-title" id="red-packet-details-title">红包详情</div>
                <div class="close-btn" id="close-red-packet-details-modal">&times;</div>
            </div>
            <div class="modal-body" style="padding: 0; max-height: 400px; overflow-y: auto;">
                <div id="red-packet-details-header" style="text-align: center; padding: 20px; border-bottom: 1px solid #eee;">
                    <img id="details-sender-avatar" src="" style="width: 60px; height: 60px; border-radius: 8px; margin-bottom: 10px;">
                    <div id="details-sender-name" style="font-weight: 600;"></div>
                    <div id="details-blessing" style="color: var(--text-gray); margin-top: 5px; font-size: 14px;"></div>
                </div>
                <div id="red-packet-details-summary" style="font-size: 14px; color: var(--text-gray); padding: 10px 15px; background-color: #f0f2f5;"></div>
                <div id="red-packet-claimer-list">
                    </div>
            </div>
        </div>
    </div>
    <div id="appearance-settings-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header"> 
        <div class="back-btn" id="back-from-appearance-settings">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">自由外观设置</div>
        <div style="width:40px;"></div>
    </div>
    <div class="api-content">
    <div class="form-group" style="background: #e3f2fd; border: 1px solid #90caf9; padding: 15px;">
        <label class="form-label" style="font-size: 16px; font-weight: 600; color: #1565c0;">🎨 主题预设管理</label>
        <p style="font-size: 13px; color: #555; margin-bottom: 10px;">
            你可以将当前的所有外观设置（背景、气泡CSS、字体、大小等）保存为一个预设，方便一键切换。
        </p>
        <div class="form-group-inline">
            <select class="form-input" id="theme-preset-select" style="flex-grow: 1;">
                <option value="">-- 选择预设以应用 --</option>
            </select>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button class="form-button" id="save-theme-preset-btn" style="background-color: var(--theme-primary); flex: 2;">
                <i class="fas fa-save"></i> 保存当前为新预设
            </button>
            <button class="form-button" id="delete-theme-preset-btn" style="background-color: var(--soft-red); flex: 1; display: none;">
                <i class="fas fa-trash-alt"></i> 删除
            </button>
        </div>
    </div>
    <div class="form-group" style="padding: 10px 15px 15px 15px;">
    <label class="form-label" style="font-size: 16px; font-weight: 600;">🎨 实时预览</label>
    <div style="background: #e0e0e0; padding: 10px; border-radius: 8px;">
        <iframe id="appearance-preview-frame" style="width: 100%; height: 280px; border: 1px solid #ccc; border-radius: 8px; background: #fff; transform: scale(1.0); overflow: hidden;"></iframe>
    </div>
</div>
            <div class="form-group">
            <label class="form-label">自动锁屏延迟 (秒)</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
                当程序在此时间内无任何操作，将自动显示锁屏。填 0 则禁用此功能。
            </p>
            <input type="number" class="form-input" id="auto-lock-delay-input" placeholder="例如: 60">
        </div>
        <div class="form-group">
            <label class="form-label">自定义聊天背景</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">从你的设备上传一张图片作为背景。</p>
            <button class="form-button" id="upload-background-btn" style="background-color: var(--theme-secondary); margin-bottom: 10px;">
                <i class="fas fa-upload"></i> 上传本地图片
            </button>
            <button class="form-button" id="reset-background-btn" style="background-color: #7f8c8d;">
                <i class="fas fa-undo"></i> 恢复默认背景
            </button>
            <input type="file" id="background-file-input" accept="image/*" style="display: none;">
        </div>

        <div class="form-group">
            <label class="form-label">自定义气泡CSS</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此粘贴CSS代码来定义气泡样式。留空则使用默认样式。</p>
            <textarea class="form-textarea" id="bubble-css-input" placeholder="例如：&#10;.message.sent {&#10;  background: #333 !important;&#10;  color: #fff !important;&#10;  border-radius: 20px 20px 0 20px !important;&#10;}" style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
        </div>

        <div class="form-group">
            <label class="form-label">自定义主题CSS</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此粘贴CSS代码来定义整体主题。你可以修改颜色、图标等任何样式。</p>
            <textarea class="form-textarea" id="theme-css-input" placeholder="在此输入你的自定义主题CSS..." style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
        </div>
        <div class="form-group">
        <label class="form-label">自定义叙事模式CSS (可选)</label>
        <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此处输入样式可覆盖默认效果。清空则恢复默认。</p>
        <textarea class="form-textarea" id="narrative-css-input" placeholder="/* 默认样式参考 */&#10;.narrative-psychology { color: #66bb6a; }&#10;.narrative-action { color: #517655; }" style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
    </div>
        <div class="form-group">
            <label class="form-label">自定义字体URL</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">输入 `.ttf`, `.woff`, 或 `.woff2` 格式的字体文件链接。</p>
            <input type="text" class="form-input" id="font-url-input" placeholder="例如：https://.../myfont.woff2">
            <p style="font-size: 13px; color: #888; margin-top: 10px;">为上面的字体指定一个CSS名称（仅英文）。</p>
            <input type="text" class="form-input" id="font-name-input" placeholder="例如：MyCustomFont" style="margin-top: 5px;">
        </div>
        <div class="form-group">
        <label class="form-label">全局字体大小 (px)</label>
        <p style="font-size: 13px; color: #888; margin-bottom: 10px;">调整应用内大部分文字的大小。推荐范围 13-18。</p>
        <input type="number" class="form-input" id="font-size-input" placeholder="默认 15" step="0.5" min="12" max="20">
    </div>
    <div class="form-group">
    <label class="form-label">全局字距 (px)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">调整文字之间的间隙。推荐 0 - 2。</p>
    <input type="number" class="form-input" id="letter-spacing-input" placeholder="默认 0" step="0.1">
</div>

<div class="form-group">
    <label class="form-label">全局字体粗细 (100-900)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">调整文字的厚度。400为正常，700为加粗。注意：可能会影响图标显示。</p>
    <input type="number" class="form-input" id="font-weight-input" placeholder="默认不强制" step="100" min="100" max="900">
</div>
<div class="form-group">
    <label class="form-label">页面整体缩放比例 (0.5 - 2.0)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        类似于浏览器的缩放功能。默认为 1.0。<br>
        <span style="color:var(--theme-primary);">提示：如果觉得界面太大或太小，可以调整此值 (例如 0.8 或 1.2)。</span>
    </p>
    <input type="number" class="form-input" id="page-zoom-input" placeholder="默认 1.0" step="0.05" min="0.5" max="2.0">
</div>
<div class="form-group">
    <label class="form-label">全屏模式</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        点击下方按钮，让浏览器进入或退出沉浸式全屏状态。
    </p>
    <button class="form-button" id="toggle-fullscreen-btn" style="background-color: #546e7a;">
        <i class="fas fa-expand"></i> 切换全屏状态
    </button>
</div>
<div class="form-group">
    <label class="form-label">自定义消息提示音 URL</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">输入 mp3/wav 音频链接。留空则静音。</p>
    <div class="form-group-inline">
        <input type="text" class="form-input" id="notification-sound-input" placeholder="例如: https://.../ding.mp3">
        <button class="form-button" id="test-notification-sound-btn" style="width: auto; margin: 0; background-color: var(--theme-secondary);">
            <i class="fas fa-play"></i> 试听
        </button>
    </div>
</div>
    <div class="form-group">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
                <label class="form-label" style="margin-bottom: 0; font-size: 16px; font-weight: 600;">显示火花与幸运字符</label>
                <label class="switch">
                    <input type="checkbox" id="show-spark-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <p style="font-size: 13px; color: #888; margin-top: 5px;">
                关闭后，聊天界面左上角将不再显示“连续互动火花”和“幸运字符收集”入口。
            </p>
        </div>

        <div class="form-group" style="margin-top: 20px;">
            <label class="form-label">主题分享</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">将当前的外观设置（背景、颜色、字体等）导出为主题包，或导入别人的主题。</p>
            <div style="display: flex; gap: 10px;">
                <button class="form-button" id="export-theme-btn" style="flex: 1; background-color: #909399; margin-top:0;"><i class="fas fa-file-export"></i> 导出主题</button>
                <button class="form-button" id="import-theme-btn" style="flex: 1; background-color: var(--theme-primary); margin-top:0;"><i class="fas fa-file-import"></i> 导入主题</button>
            </div>
             <input type="file" id="theme-file-input" accept=".json" style="display: none;">
        </div>
        <button class="form-button" id="save-appearance-btn" style="margin-top: 20px;">应用并保存设置</button>
    </div>
</div>

<div id="create-wheel-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">创建转盘游戏</div>
            <div class.="close-btn" id="close-create-wheel-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">转盘名称</label>
                <input type="text" class="contact-form-input" id="wheel-name-input" placeholder="例如：今天吃什么？">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">转盘选项</label>
                <div id="wheel-options-container">
                    </div>
                <button class="form-button" id="add-wheel-option-btn" style="margin-top: 10px; background-color: var(--theme-secondary);">+ 添加选项</button>
            </div>
            <button class="form-button" id="confirm-send-wheel-btn">发起转盘</button>
        </div>
    </div>
</div>
<div id="incoming-call-screen">
    <div>
        <img id="incoming-caller-avatar" src="" style="width: 100px; height: 100px; border-radius: 50%; border: 3px solid white; margin-bottom: 15px;">
        <div id="incoming-caller-name" style="font-size: 24px; font-weight: 600;"></div>
        <div style="font-size: 16px; margin-top: 10px;">邀请你进行视频通话...</div>
    </div>
    <div style="width: 100%; display: flex; justify-content: space-around; padding: 0 40px;">
        <div id="decline-call-btn" style="cursor: pointer;">
            <div style="width: 70px; height: 70px; background-color: var(--soft-red); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 30px;"><i class="fas fa-phone-slash"></i></div>
            <div style="margin-top: 10px;">拒绝</div>
        </div>
        <div id="accept-call-btn" style="cursor: pointer;">
            <div style="width: 70px; height: 70px; background-color: var(--theme-primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 30px;"><i class="fas fa-video"></i></div>
            <div style="margin-top: 10px;">接听</div>
        </div>
    </div>
</div>

<div id="video-call-screen">
    <div class="video-call-card-content">
        <div class="video-call-header">
            <span id="call-contact-name"></span>
            <span id="call-status"></span>
        </div>
        <div class="video-call-main">
            <div class="narrative-feed" id="narrative-feed"></div>
        </div>
        <div class="video-call-input-area">
            <textarea id="video-call-input" placeholder="输入你的回应..." rows="1"></textarea>
            <button id="video-call-send-btn"><i class="fas fa-paper-plane"></i></button>
        </div>
        <div class="video-call-controls">
            <div class="control-btn hang-up" id="hang-up-btn" style="margin: 0 auto;"><i class="fas fa-phone-slash"></i><span>挂断</span></div>
        </div>
    </div>
</div>
<div id="sms-chat-screen" style="display: none; flex-direction: column; height: 100%; background-color: #ffffff;">
<div class="app-header sms-header">
    <div class="back-btn" id="back-from-sms-chat">
        <i class="fas fa-arrow-left"></i>
    </div>
    <div class="chat-info">
        <div class="chat-name" id="sms-chat-contact-name">联系人名字</div>
        <div class="chat-status" id="sms-chat-contact-status" style="font-size: 12px;">短信</div>
    </div>
    <div style="width: 40px; text-align: right;">
        <i class="fas fa-edit action-btn" id="edit-sms-btn" title="编辑短信" style="color: black; padding: 10px; margin:-10px;"></i> </div>
    </div>

    <div class="chat-messages" id="sms-chat-messages" style="background-color: #ffffff;">
        <div id="sms-chat-placeholder" style="text-align: center; color: #999; padding: 20px;">开始发送短信吧...</div>
    </div>
    <div class="chat-messages" id="sms-chat-messages" style="background-color: #ffffff;">
    </div>

<div id="sms-edit-mode-bar" style="display: none; padding: 10px 15px; background-color: #f0f0f0; border-top: 1px solid #ddd; justify-content: space-between; align-items: center; flex-shrink: 0;">
    <button id="delete-selected-sms-btn" class="edit-action-btn" style="background-color: var(--soft-red); color: white;">删除已选</button>
    <button id="cancel-sms-edit-btn" class="edit-action-btn" style="background-color: #bdc3c7; color: #333;">取消</button>
</div>
<div class="chat-input-area" id="sms-input-area" style="background-color: #f7f7f7;">
    <button class="input-action-btn" id="sms-upload-image-btn" title="发送图片" style="background-color: #e0e0e0; color: #555;">
        <i class="fas fa-image"></i>
    </button>
    <textarea id="sms-message-input" placeholder="发送短信..." rows="1" style="background-color: white;"></textarea>
    <button id="sms-send-btn" class="input-action-btn" title="发送短信" style="width: auto; padding: 0 18px; border-radius: 22px; background-color: #0B81FF; color: white;">发送</button>
    <button id="sms-request-reply-btn" class="input-action-btn" title="请求AI回复" style="background-color: #0B81FF; color: var(--text-on-primary); border-radius: 50%; width: 38px; height: 38px;">
        <i class="fas fa-reply"></i> </button>
    </div>
</div>
<input type="file" id="sms-image-upload-input" accept="image/*" style="display: none;">
<div id="shopping-screen" style="display: none; flex-direction: column;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-shopping">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="moments-title">购物中心</div>
        <div class="header-actions">
            <i class="fas fa-sync-alt action-btn" id="refresh-products-btn" title="刷新"></i>
        </div>
    </div>
    <div class="comment-input-area" style="border-top: none; border-bottom: 1px solid #ddd; padding: 8px 15px;">
        <input type="search" id="product-search-input" placeholder="搜索商品..." style="border-radius: 18px; flex-grow: 1; border: 1px solid #ddd; padding: 8px 15px; font-size: 15px;">
        <button id="product-search-btn" style="background-color: var(--theme-primary); color: white; border: none; border-radius: 18px; padding: 8px 20px; margin-left: 10px; font-weight: 600; cursor: pointer;">搜索</button>
    </div>
    <div id="shopping-tabs-container" class="feed-tabs"></div>
    <div class="moments-content" id="shopping-content">
        <div class="product-list" id="product-list">
            </div>
    </div>
</div>

<div id="share-product-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">分享商品给</div>
            <div class="close-btn" id="close-share-product-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div id="share-product-info" style="padding: 10px; background: #f9f9f9; border-radius: 8px; margin-bottom: 15px; text-align: center;"></div>
            
            <div class="contact-picker-list" id="share-product-recipient-list" style="max-height: 150px; overflow-y: auto; margin-bottom: 15px;">
                </div>
            
            <div class="contact-form-group">
                <label class="contact-form-label">附言 (可选)</label>
                <input type="text" class="contact-form-input" id="share-product-message-input" placeholder="可以跟TA说句话...">
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="form-button" id="gift-product-btn" style="flex: 1; background-color: #e67e22;">送给他/她</button>
                <button class="form-button" id="request-payment-btn" style="flex: 1; background-color: #3498db;">请他/她付款</button>
            </div>
        </div>
    </div>
</div>
<div id="schedule-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-schedule"><i class="fas fa-arrow-left"></i></div>
        <div class="moments-title" id="schedule-title">我的日程表</div>
        <div class="header-actions">
            <i class="fas fa-plus action-btn" id="add-schedule-item-btn" title="添加日程"></i>
        </div>
    </div>
    <div class="diary-content" id="schedule-content-list">
        </div>
</div>

<div id="events-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-events"><i class="fas fa-arrow-left"></i></div>
        <div class="moments-title" id="events-title">我们的日子</div>
        <div class="header-actions">
            <i class="fas fa-plus action-btn" id="add-event-item-btn" title="添加新事件"></i>
        </div>
    </div>
    <div class="diary-content" id="events-content-list">
        </div>
</div>
<div id="create-group-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">创建群聊</div>
            <div class="close-btn" id="close-create-group-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">群聊名称</label>
                <input type="text" class="contact-form-input" id="group-name-input" placeholder="为你的群聊起个名字">
            </div>
            <label class="contact-form-label">选择成员 (至少2位)</label>
            <div class="contact-picker-list" id="group-member-picker-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <button class="form-button" id="confirm-create-group-btn" style="margin-top: 15px;">创建</button>
        </div>
    </div>
</div>
<div id="create-npc-for-group-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">为群聊添加NPC</div>
            <div class="close-btn" id="close-create-npc-modal">&times;</div>
        </div>
        <div class="modal-body">
            
            <div class="contact-form-group" style="background:#fff3e0; padding:10px; border-radius:8px; border:1px solid #ffe0b2;">
                <label class="contact-form-label" style="color:#ef6c00; font-weight:bold;">🚀 方式一：从现有关系网导入</label>
                <select class="contact-form-input" id="group-import-npc-select" style="margin-top:5px;">
                    <option value="">-- 正在扫描全网 NPC... --</option>
                </select>
                <p style="font-size:11px; color:#ef6c00; margin-top:5px;">* 选中后会自动填充下方信息，你可以保留原 ID 以维持关系记忆。</p>
            </div>

            <div style="text-align: center; margin: 15px 0; color: #ccc; font-size:12px;">—— 或者 ——</div>

            <div class="contact-form-group">
                <label class="contact-form-label">方式二：手动创建 / 修改信息</label>
                <input type="text" class="contact-form-input" id="group-npc-name-input" placeholder="NPC 姓名">
            </div>
            
            <div class="contact-form-group">
                <label class="contact-form-label">NPC 人设</label>
                <textarea class="contact-form-textarea" id="group-npc-persona-input" placeholder="输入 NPC 的人设描述..." style="height: 80px;"></textarea>
            </div>
            
            <div class="contact-form-group">
                <label class="contact-form-label">NPC 头像</label>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <img id="group-npc-avatar-preview" src="" alt="预览" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover; border: 1px solid #eee; display: none;">
                    <button class="form-button" id="upload-group-npc-avatar-btn" style="background-color: var(--theme-secondary); width: auto; padding: 5px 15px; font-size: 13px; margin: 0;">
                        <i class="fas fa-upload"></i> 上传/更换
                    </button>
                </div>
            </div>

            <input type="hidden" id="group-npc-original-id">

            <button class="form-button" id="confirm-create-npc-btn" style="margin-top: 15px;">确认添加</button>
        </div>
    </div>
</div>
<div id="group-settings-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header"> 
        <div class="back-btn" id="back-from-group-settings">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">群聊设置</div>
        <button id="save-group-settings-btn" class="form-button" style="width: auto; padding: 6px 15px; font-size: 14px; margin-right: 10px;">保存</button>
    </div>
    <div class="api-content" style="padding: 20px;">
        
        <div class="user-mask-editor">
            <div class="user-mask-title">我的面具 (在此群聊中)</div>
            <div class="mask-editor-group">
                <label class="mask-editor-label">面具描述</label>
                <textarea class="user-mask-textarea" id="group-user-mask-textarea" placeholder="描述你在这个群聊中扮演的角色..."></textarea>
            </div>
        </div>
        <div class="form-group" style="margin-bottom: 20px;">
            <label class="form-label">选择预设面具</label>
            <select class="form-input" id="group-select-user-persona-preset">
                <option value="">-- 选择或输入自定义面具 --</option>
            </select>
        </div>

        <div class="mask-editor">
            <div class="mask-editor-title">高级设置</div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
                <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">允许群成员感知现实时间</label>
                <label class="switch">
                    <input type="checkbox" id="group-time-awareness-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-top: 1px solid #f0f0f0;">
                <div class="detail-label">私聊与群聊记忆互通</div>
                <label class="switch">
                    <input type="checkbox" id="group-memory-share-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
        </div>

        <div class="world-book-selector" style="margin-top: 20px;">
            <div class="world-book-selector-title">关联世界书</div>
            <div class="world-book-list" id="group-world-book-selector-list">
                </div>
        </div>

<div class="form-group" style="margin-top: 20px;">
        <div class="form-label" style="padding-left: 5px; display: flex; justify-content: space-between; align-items: center;">
            <span>群成员 (<span id="group-member-count">0</span>)</span>
            <div> <i class="fas fa-user-plus preset-action-btn" id="add-group-member-btn" title="添加联系人"></i>
                <i class="fas fa-user-secret preset-action-btn" id="add-npc-member-btn" title="添加NPC" style="margin-left: 10px;"></i> </div>
        </div>
        <div id="group-members-list" style="max-height: 200px; overflow-y: auto;">
        </div>
    </div>


       <button class="form-button" id="clear-group-chat-history-btn" style="background-color: #e74c3c; margin-top: 20px;">
            <i class="fas fa-eraser"></i> 清空聊天记录
        </button>
        
        <button class="form-button" id="disband-group-btn" style="background-color: #e74c3c; margin-top: 15px;">
            解散群聊
        </button>
    </div>
</div>
<div id="group-transfer-recipient-picker-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">选择收款人</div>
            <div class="close-btn" id="close-group-transfer-picker-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="contact-picker-list" id="group-transfer-recipient-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <div class="contact-form-group" style="margin-top: 15px;">
                <label class="contact-form-label">转账金额 (元)</label>
                <input type="number" class="contact-form-input" id="group-transfer-amount-input" placeholder="0.00">
            </div>
            <button class="form-button" id="confirm-group-transfer-btn">确认转账</button>
        </div>
    </div>
</div>
<div id="product-detail-screen" style="display: none; flex-direction: column;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-product-detail">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="moments-title">商品详情</div>
        <div style="width: 40px;"></div> </div>
    <div class="moments-content" id="product-detail-content" style="padding: 15px;">
        <div id="product-main-info"></div>
        
        <div class="comments-section" style="margin-top: 20px;">
            <div class="comments-title" style="padding-bottom: 10px; margin-bottom: 10px;">宝贝评价</div>
            <div id="buyer-comments-list">
                </div>
        </div>
    </div>
    <div class="comment-input-area" id="detail-action-bar">
        <button id="share-from-detail-btn" class="form-button" style="width: 100%; margin: 0; background-color: var(--theme-secondary);">
            <i class="fas fa-paper-plane"></i> 分享给...
        </button>
    </div>
</div>
<div id="add-group-member-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">添加群成员</div>
            <div class="close-btn" id="close-add-group-member-modal">&times;</div>
        </div>
        <div class="modal-body">
            <label class="contact-form-label">选择要添加的联系人</label>
            <div class="contact-picker-list" id="add-member-picker-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <button class="form-button" id="confirm-add-group-members-btn" style="margin-top: 15px;">确认添加</button>
        </div>
    </div>
</div>
<input type="file" id="contact-background-uploader" accept="image/*" style="display: none;">
<input type="file" id="contact-user-avatar-uploader" accept="image/*" style="display: none;">
<audio id="slime-sound" preload="auto" src="https://wenlongting.github.io/my-songs2/bubble-pop-389501.mp3"></audio>
<div id="forum-archives-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-forum-archives">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">论坛档案馆</div>
        <div style="width: 40px;"></div> </div>
    <div class="api-content">
        <div id="forum-archives-list" class="preset-list">
            </div>
        <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-forum-archives-message">
            <p>还没有任何论坛存档。</p>
            <p>在“论坛API设置”中更改世界观后，选择“存档并开启新世界线”来创建你的第一个存档吧！</p>
        </div>
    </div>
</div>
<div id="map-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header">
        <div class="back-btn" id="back-from-map-screen">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title" id="map-title">城市地图</div>
        <div class="action-btn" id="add-map-location-btn" title="在此处添加新地点">
             <i class="fas fa-plus"></i>
        </div>
    </div>
    
    <div id="map-breadcrumbs" style="padding: 8px 15px; background: #fff; border-bottom: 1px solid #eee; font-size: 14px; color: #555; display: flex; gap: 5px; align-items: center;">
        <span class="breadcrumb-item active" data-id="root" style="cursor: pointer; font-weight: bold;">🗺️ 世界全景</span>
    </div>

    <div class="api-content" style="padding: 0; flex-grow: 1; overflow: auto; position: relative;">
        
        <div id="map-grid-container" style="position: relative; width: 1000px; height: 1000px; background-color: #e8f5e9; overflow: hidden; cursor: crosshair; margin: 0 auto;">
        </div>

<div id="map-directory-panel" style="position: fixed; top: 120px; right: 20px; width: 160px; max-height: 400px; background: rgba(255,255,255,0.9); backdrop-filter: blur(5px); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); display: flex; flex-direction: column; overflow: hidden; border: 1px solid rgba(255,255,255,0.5); transition: all 0.3s ease;">
    <div id="map-directory-header" style="padding: 10px; background: #f7f9fa; font-weight: bold; font-size: 13px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
        <span>📍 区域地点</span>
        <i id="map-directory-toggle-icon" class="fas fa-chevron-down" style="color: #999; transition: transform 0.3s;"></i>
    </div>
    <div id="map-directory-list" style="flex-grow: 1; overflow-y: auto; padding: 5px;">
        </div>
</div>
            <div id="map-directory-list" style="flex-grow: 1; overflow-y: auto; padding: 5px;">
            </div>
        </div>
    </div>
</div>
<div id="map-location-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="map-location-modal-title">添加新地点</div>
            <div class="close-btn" id="close-map-location-modal">&times;</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="location-id-input">
            <input type="hidden" id="location-x-input">
            <input type="hidden" id="location-y-input">
            
            <div class="contact-form-group">
                <label class="contact-form-label">地点名称</label>
                <input type="text" class="contact-form-input" id="location-name-input" placeholder="例如：街角咖啡馆">
            </div> 
            <div class="contact-form-group">
                <label class="contact-form-label">地点图标 (Font Awesome class)</label>
                <input type="text" class="contact-form-input" id="location-icon-input" value="fas fa-map-marker-alt" placeholder="例如：fas fa-store">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">地点描述</label>
                <textarea class="contact-form-textarea" id="location-description-input" placeholder="描述一下这个地方..."></textarea>
            </div>
            <button class="form-button" id="save-map-location-btn">保存地点</button>
            <button class="form-button" id="delete-map-location-btn" style="background-color: #e74c3c; margin-top: 10px; display: none;">删除地点</button>
        </div>
    </div>
</div>
<div id="map-management-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header">
        <div class="back-btn" id="back-from-map-management">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">地图管理中心</div>
        <div class="action-btn" id="create-new-map-btn" title="创建新地图">
            <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content">
        <div class="preset-list" id="map-list">
            </div>
    </div>
</div>

<div id="map-details-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="map-details-modal-title">创建新地图</div>
            <div class="close-btn" id="close-map-details-modal">&times;</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="map-id-input">
            <div class="contact-form-group">
                <label class="contact-form-label">地图名称</label>
                <input type="text" class="contact-form-input" id="map-name-input" placeholder="例如：赛博都市'夜之城'">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">宏观描述 (天气/氛围/地图比例等)</label>
                <textarea class="contact-form-textarea" id="map-description-input" placeholder="例如：永远下着酸雨，霓虹灯光芒四射，空气中弥漫着拉面和臭氧的味道（地图比例尺：每20像素的距离约等于10米）。"></textarea>
            </div>
            <button class="form-button" id="save-map-details-btn">保存地图</button>
        </div>
    </div>
</div>
<div id="send-location-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">选择一个地点</div>
            <div class="close-btn" id="close-location-picker-modal">&times;</div>
        </div>
        <div class="modal-body" style="padding: 10px; max-height: 300px; overflow-y: auto;">
            <div id="location-picker-list"></div>
        </div>
    </div>
</div>
<div id="schedule-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="schedule-modal-title">添加日程</div>
            <span class="close-btn" id="close-schedule-modal">&times;</span>
        </div>
        <div class="modal-body">
            <input type="hidden" id="schedule-item-id">
            <div class="contact-form-group">
                <label class="contact-form-label">日程名称</label>
                <input type="text" id="schedule-name-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">星期几</label>
                <select id="schedule-day-select" class="contact-form-input">
                    <option value="monday">星期一</option>
                    <option value="tuesday">星期二</option>
                    <option value="wednesday">星期三</option>
                    <option value="thursday">星期四</option>
                    <option value="friday">星期五</option>
                    <option value="saturday">星期六</option>
                    <option value="sunday">星期日</option>
                </select>
            </div>
            <div class="contact-form-group" style="display: flex; gap: 10px;">
                <div style="flex: 1;">
                    <label class="contact-form-label">开始时间</label>
                    <input type="time" id="schedule-start-input" class="contact-form-input">
                </div>
                <div style="flex: 1;">
                    <label class="contact-form-label">结束时间</label>
                    <input type="time" id="schedule-end-input" class="contact-form-input">
                </div>
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">地点 (可选)</label>
                <input type="text" id="schedule-location-input" class="contact-form-input">
            </div>
<button id="save-schedule-item-btn" class="form-button">保存</button>
            <button id="delete-schedule-item-btn" class="form-button" style="background-color: var(--soft-red); margin-top: 10px; display: none;">删除日程</button>
        </div>
    </div>
</div>

<div id="event-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="event-modal-title">添加重要日子</div>
            <span class="close-btn" id="close-event-modal">&times;</span>
        </div>
        <div class="modal-body">
            <input type="hidden" id="event-item-id">
            <div class="contact-form-group">
                <label class="contact-form-label">事件名称</label>
                <input type="text" id="event-name-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">日期</label>
                <input type="date" id="event-date-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">类型</label>
                <select id="event-type-select" class="contact-form-input">
                    <option value="anniversary">纪念日</option>
                    <option value="period">生理期</option>
                    <option value="custom">其他</option>
                </select>
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">备注 (可选)</label>
                <textarea id="event-notes-input" class="contact-form-textarea" style="height: 80px;"></textarea>
            </div>
            <button id="save-event-item-btn" class="form-button">保存</button>
            <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
        </div>
    </div>
</div>
<div id="contact-item-menu" style="display: none; position: absolute; z-index: 100;">
    <div class="menu-item" id="menu-item-pin"><i class="fas fa-thumbtack fa-fw"></i> <span>置顶聊天</span></div>
    <div class="menu-item" id="menu-item-group"><i class="fas fa-folder fa-fw"></i> <span>移动到分组...</span></div>
    <div class="menu-item" id="menu-item-rewind"><i class="fas fa-undo fa-fw"></i> <span>回溯最后回复 (急救)</span></div>
</div>
<div id="group-selector-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">移动联系人到...</div>
            <div class="close-btn" id="close-group-selector-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div id="group-selector-list" class="contact-picker-list" style="max-height: 250px;"></div>
            
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="form-button" id="manage-groups-btn" style="background-color: #7f8c8d; flex: 1;">管理分组</button>
                <button class="form-button" id="create-new-group-btn" style="background-color: var(--theme-secondary); flex: 1;">创建新分组</button>
            </div>
        </div>
    </div>
</div>
<div id="lock-screen" style="display: none;">
    <div class="lock-screen-background"></div>

    <div class="lock-screen-body">
        <div class="widget-row">
            <div class="lock-block photo-block">
                <div class="placeholder-text"><i class="fas fa-images"></i><p>照片轮播区</p></div>
            </div>
            <div class="right-column">
                <div class="lock-block widget">
                    <div class="widget-header"><i class="fas fa-clipboard"></i> 备忘录</div>
                    <div id="lock-screen-memo" class="widget-content memo-content">点击这里编辑你的备忘录...</div>
                </div>
                <div class="lock-block widget">
                    <div class="widget-header"><i class="fas fa-heart"></i> 纪念日</div>
                    <div id="lock-screen-countdown" class="widget-content countdown-content">
                        <div class="countdown-days">XX</div>
                        <div class="countdown-label">距离 [事件名]</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="widget-row">
            <div id="lock-screen-time-widget" class="lock-block widget">
                <div id="lock-screen-time">20:50</div>
                <div id="lock-screen-date">10月5日 星期日</div>
            </div>
            <div id="lock-screen-music-widget" class="lock-block widget">
                <div class="widget-header"><i class="fas fa-music"></i> 正在播放</div>
                <div id="lock-screen-music-player" class="widget-content music-content">
                    <span id="lock-screen-song-info">暂无音乐播放</span>
                    <div class="music-controls">
                        <i class="fas fa-backward-step"></i>
                        <i class="fas fa-play"></i>
                        <i class="fas fa-forward-step"></i>
                    </div>
                </div>
            </div>
        </div>

<div id="lock-screen-notification-widget" class="lock-block widget-row">
    <i class="fas fa-comment-dots"></i>
    <div class="notification-scroll-wrapper">
        <div id="lock-screen-notification-text">Koko: 你在干嘛呀？ (这里将是滚动区域)</div>
    </div>
    </div>
    </div>

    <div class="lock-screen-footer">
        <span>点击任意位置解锁</span>
    </div>
</div>
<div id="lock-screen-photos-screen" class="preset-management-screen">
    <div class="api-header">
        <div class="back-btn" id="back-from-lock-screen-photos">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">锁屏相册</div>
        <div class="action-btn" id="add-lock-screen-photo-btn">
            <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content">
        <div class="emoticon-grid" id="lock-screen-photos-grid">
            </div>
        <div id="no-lock-screen-photos-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
            <i class="fas fa-images" style="font-size: 48px; margin-bottom: 15px;"></i>
            <p>你的锁屏相册是空的</p>
            <p>点击右上角 "+" 添加第一张照片吧！</p>
        </div>
    </div>
</div>
<input type="file" id="lock-screen-photo-uploader" accept="image/*" style="display: none;">
<input type="file" id="character-avatar-uploader" accept="image/*" style="display: none;">
<input type="file" id="journal-sticker-uploader" accept="image/*" style="display: none;">
<div id="relationship-network-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-relationship-network"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title" id="relationship-network-title">关系网络</div>
    </div>
<div class="api-content">
    <div style="margin-bottom: 20px;">
        <h3 class="mask-editor-title" style="padding: 15px 15px 0 15px; margin-bottom: 15px;">关系图预览</h3>
        <div id="relationship-graph-container" style="width: 100%; height: 350px; border: 1px solid #eee; border-radius: 8px;"></div>
    </div>

    <div class="form-group">
        <h3 class="mask-editor-title">角色名册管理</h3>
        <div id="character-list" class="preset-list" style="gap: 0; max-height: 150px; overflow-y: auto; margin-bottom: 15px;">
            </div>
        <button class="form-button" id="add-to-roster-btn" style="background-color: var(--theme-secondary);">+ 添加角色到名册</button>
    </div>

    <div class="form-group">
        <h3 class="mask-editor-title">编辑关系</h3>
        <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-bottom: 15px;">
            <div style="flex: 1;">
                <label class="contact-form-label">从 (From)</label>
                <select class="contact-form-input" id="relation-source-select"></select>
            </div>
            <div style="align-self: flex-end; padding-bottom: 5px; font-size: 20px;">→</div>
            <div style="flex: 1;">
                <label class="contact-form-label">到 (To)</label>
                <select class="contact-form-input" id="relation-target-select"></select>
            </div>
        </div>
        <div class="contact-form-group">
            <label class="contact-form-label">关系类型</label>
            <select class="contact-form-input" id="relation-type-select">
                <option value="朋友">朋友</option>
                <option value="恋人">恋人</option>
                <option value="家人">家人</option>
                <option value="兄妹">兄妹</option>
                <option value="姐弟">姐弟</option>
                <option value="同事">同事</option>
                <option value="竞争对手">竞争对手</option>
                <option value="敌人">敌人</option>
                <option value="暗恋对象">暗恋对象</option>
                <option value="自定义">自定义...</option>
            </select>
        </div>
        <div class="contact-form-group">
            <label class="contact-form-label">关系细节描述</label>
            <textarea class="form-textarea" id="relation-detail-input" placeholder="例如：青梅竹马，非常在乎对方..."></textarea>
        </div>
        <button class="form-button" id="save-relationship-btn">添加/更新关系</button>
    </div>

    <div class="form-group" style="margin-top: 20px;">
        <h3 class="mask-editor-title">现有关系列表</h3>
        <div id="relationship-list" class="preset-list" style="gap: 0;"></div>
    </div>
</div>

<div id="character-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="character-modal-title">添加新角色</div>
            <div class="close-btn" id="close-character-modal">&times;</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="character-id-input">
            <div class="contact-form-group">
                <label class="contact-form-label">角色姓名</label>
                <input type="text" class="contact-form-input" id="character-name-input" placeholder="输入NPC的姓名">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">角色头像</label>
                <div style="text-align: center; margin-bottom: 10px;">
                    <img id="character-avatar-preview" src="" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none;">
                </div>
                <div class="contact-form-group">
                <label class="contact-form-label">角色人设 (*)</label>
                <textarea class="form-textarea" id="character-persona-input" placeholder="输入NPC的人设描述，海龟汤游戏会用到..." style="height: 100px;"></textarea>
            </div>
                <button class="form-button" id="upload-character-avatar-btn" style="background-color: var(--theme-secondary);">
                    <i class="fas fa-upload"></i> 上传本地图片
                </button>
            </div>
            <button class="form-button" id="save-character-btn">保存角色</button>
        </div>
    </div>
</div>
<div id="add-to-roster-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">添加角色到名册</div>
            <div class="close-btn" id="close-add-to-roster-modal">&times;</div>
        </div>
<div class="modal-body">
    <div class="contact-form-group">
        <label class="contact-form-label" style="font-weight:bold; color:var(--theme-primary);">方式一：导入真实联系人</label>
        <div style="display:flex; gap:5px;">
            <select class="contact-form-input" id="import-contact-select" style="flex:1;">
                </select>
            <button class="form-button" id="confirm-import-contact-btn" style="width:auto; margin:0; padding:0 15px; font-size:13px;">导入</button>
        </div>
    </div>

    <div class="contact-form-group" style="margin-top: 20px; border-top: 1px dashed #ddd; padding-top: 15px;">
        <label class="contact-form-label" style="font-weight:bold; color:#FF9800;">方式二：借用其他人的 NPC</label>
        <p style="font-size:12px; color:#999; margin-bottom:5px;">(例如：把 A 的“前男友”导入到 B 的关系网里)</p>
        <div style="display:flex; gap:5px;">
            <select class="contact-form-input" id="import-existing-npc-select" style="flex:1;">
                <option value="">-- 扫描全网 NPC 中... --</option>
            </select>
            <button class="form-button" id="confirm-import-npc-btn" style="width:auto; margin:0; padding:0 15px; font-size:13px; background-color:#FF9800;">复用</button>
        </div>
    </div>

    <div style="text-align: center; margin: 20px 0; color: #ccc; font-size:12px;">—— 或者 ——</div>

    <button class="form-button" id="switch-to-create-npc-btn" style="background-color: #7f8c8d;">方式三：创建一个全新的 NPC</button>
</div>
    </div>
</div>
<script src="https://cdn.bootcdn.net/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<script>
    // --------------------------------------------------------------------
    // 1. 自定义数据库模块 
    // --------------------------------------------------------------------
    class AppStorage {
        constructor(dbName, version, storesConfig) {
            this.dbName = dbName;
            this.version = version;
            this.storesConfig = storesConfig;
            this.db = null;
        }

        /**
         * 初始化并打开数据库连接
         * 这是所有操作的第一步
         */
        async init() {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    resolve();
                    return;
                }

                const request = indexedDB.open(this.dbName, this.version);

                request.onerror = (event) => {
                    console.error("数据库打开失败:", event.target.error);
                    reject(event.target.error);
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log("数据库连接成功!");
                    resolve();
                };

                // 当数据库版本更新时 (包括首次创建)
                request.onupgradeneeded = (event) => {
                    this.db = event.target.result;
                    console.log(`数据库版本更新至: ${this.version}`);
                    for (const storeName in this.storesConfig) {
                        if (!this.db.objectStoreNames.contains(storeName)) {
                            const storeOptions = { keyPath: this.storesConfig[storeName].keyPath };
                            if(this.storesConfig[storeName].autoIncrement) {
                                storeOptions.autoIncrement = true;
                            }
                            const objectStore = this.db.createObjectStore(storeName, storeOptions);
                            
                            // (可选) 为之后可能的搜索创建索引
                            if (this.storesConfig[storeName].indexes) {
                                this.storesConfig[storeName].indexes.forEach(index => {
                                    objectStore.createIndex(index, index, { unique: false });
                                });
                            }
                            console.log(`对象仓库 (表) "${storeName}" 创建成功。`);
                        }
                    }
                };
            });
        }

        /**
         * 封装一个通用的数据库事务操作
         * @param {string} storeName 表名
         * @param {'readonly'|'readwrite'} mode 事务模式
         * @param {(store: IDBObjectStore) => IDBRequest} operation 具体操作
         */
        _transaction(storeName, mode, operation) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error("数据库未初始化。"));
                    return;
                }
                const transaction = this.db.transaction(storeName, mode);
                const store = transaction.objectStore(storeName);
                const request = operation(store);

                request.onsuccess = () => {
                    resolve(request.result);
                };

                request.onerror = (event) => {
                    console.error(`在 "${storeName}" 上的操作失败:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        
        /**
         * 添加或更新一条数据 (put = add + update)
         * @param {string} storeName 表名
         * @param {object} item 要存入的数据
         */
        async put(storeName, item) {
            return this._transaction(storeName, 'readwrite', (store) => store.put(item));
        }

        /**
         * 批量添加或更新数据
         * @param {string} storeName 表名
         * @param {Array<object>} items 数据数组
         */
        async bulkPut(storeName, items) {
             return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error("数据库未初始化。"));
                    return;
                }
                const transaction = this.db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                
                let completed = 0;
                
                const putNext = () => {
                    if (completed < items.length) {
                        const request = store.put(items[completed]);
                        request.onsuccess = () => {
                            completed++;
                            putNext();
                        };
                         request.onerror = (event) => {
                             // 如果一个失败，则终止整个事务
                            transaction.abort();
                            reject(event.target.error);
                        };
                    } else {
                        // 所有操作都已加入队列
                    }
                };

                putNext();

                transaction.oncomplete = () => {
                    resolve();
                };

                transaction.onerror = (event) => {
                     console.error(`在 "${storeName}" 上的批量操作失败:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * 根据主键获取一条数据
         * @param {string} storeName 表名
         * @param {*} key 主键
         */
        async get(storeName, key) {
            return this._transaction(storeName, 'readonly', (store) => store.get(key));
        }

        /**
         * 获取一个表中的所有数据
         * @param {string} storeName 表名
         */
        async getAll(storeName) {
            return this._transaction(storeName, 'readonly', (store) => store.getAll());
        }

        /**
         * 根据主键删除一条数据
         * @param {string} storeName 表名
         * @param {*} key 主键
         */
        async delete(storeName, key) {
            return this._transaction(storeName, 'readwrite', (store) => store.delete(key));
        }

        /**
         * 清空一个表的所有数据
         * @param {string} storeName 表名
         */
        async clear(storeName) {
            return this._transaction(storeName, 'readwrite', (store) => store.clear());
        }
        
        /**
         * 完全删除数据库
         */
        async deleteDatabase() {
            return new Promise((resolve, reject) => {
                // 删除前必须先关闭连接
                if (this.db) {
                    this.db.close();
                    this.db = null;
                }
                const request = indexedDB.deleteDatabase(this.dbName);
                
                request.onsuccess = () => {
                    console.log(`数据库 "${this.dbName}" 删除成功。`);
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error(`数据库 "${this.dbName}" 删除失败:`, event.target.error);
                    reject(event.target.error);
                };

                request.onblocked = () => {
                    console.warn(`数据库删除被阻塞，请关闭其他页面后重试。`);
                    reject(new Error("数据库删除被阻塞。"));
                };
            });
        }
    }


const dbConfig = {
    contacts: { keyPath: 'id' },
    worldBooks: { keyPath: 'id', indexes: ['category'] },
    posts: { keyPath: 'id', autoIncrement: false },
    userPersonaPresets: { keyPath: 'id' },
    emoticons: { keyPath: 'id' },
    musicLibrary: { keyPath: 'id' },
    thoughtPresets: { keyPath: 'id' },
    apiSettings: { keyPath: 'id' },
    squareApiSettings: { keyPath: 'id' },
    myProfile: { keyPath: 'id' },
    transactions: { keyPath: 'id' },
    trendingTopics: { keyPath: 'id' },
    userSettings: { keyPath: 'id' },
    apiPresets: { keyPath: 'id' },
    forumSettings: { keyPath: 'id' },
    forumArchives: { keyPath: 'id' },
    contactGroups: { keyPath: 'id' },
    lockScreenPhotos: { keyPath: 'id' },
    maps: { keyPath: 'id' },
    relationshipNetworks: { keyPath: 'contactId' },
    // ▼▼▼ 在这里添加下面这行新代码 ▼▼▼
    snoopData: { keyPath: 'contactId' },
    // ▲▲▲ 新代码添加结束 ▲▲▲
    emoticonGroups: { keyPath: 'id' },
    snoopApiSettings: { keyPath: 'id' },
    favorites: { keyPath: 'id' },
    stockMarket: { keyPath: 'id' },
    stockEvents: { keyPath: 'id' },
    forumCategories: { keyPath: 'id' },
    surveyLibrary: { keyPath: 'id' },
    themePresets: { keyPath: 'id' }
};
// ▼▼▼ 把这里的版本号数字加 1 (例如 13 -> 19) ▼▼▼
const kokoMemory = new AppStorage('AppleNarrativeDB_Native_V1', 24, dbConfig);
// ▲▲▲ 版本号修改结束 ▲▲▲

    // --------------------------------------------------------------------
    // 3. 应用主逻辑 
    // --------------------------------------------------------------------
    
    document.addEventListener('DOMContentLoaded', async function() {
        
      // ==========================================================
        // V9.1 新增：悬浮播放器相关辅助函数 (修正位置)
        // ==========================================================
        let currentSongIndex = 0;
        let lyrics = [];
        let currentLyricIndex = -1;

        // 【修正后】的新版本
async function openMusicPlayer() {
    state.musicSessionContactId = state.activeChatId;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const card = document.getElementById('music-player-card');
    if (card.style.display === 'flex') return;

    card.style.display = 'flex';

    // 确保播放列表结构存在
    if (!contact.sharedPlaylist || !contact.sharedPlaylist.tracks) {
        contact.sharedPlaylist = { tracks: [], currentIndex: 0, playbackMode: 'repeat-all' };
    }

    // 决定要播放的歌曲
    let songToPlayIndex = contact.sharedPlaylist.currentIndex || 0;
    let playlistToUse = contact.sharedPlaylist.tracks;

    // 如果联系人播放列表为空，但音乐库不为空，则自动从音乐库加载第一首歌开始播放
    if (playlistToUse.length === 0 && state.musicLibrary.length > 0) {
        const firstLibrarySong = state.musicLibrary[0];
        // 将音乐库的第一首歌“添加”到联系人播放列表
        contact.sharedPlaylist.tracks.push(firstLibrarySong);
        playlistToUse = contact.sharedPlaylist.tracks;
        songToPlayIndex = 0; // 播放刚刚添加的这首歌
        await kokoMemory.put('contacts', contact);
    }
    
    // 如果到最后还是没有任何歌曲可以播放，则提示并关闭
    if (playlistToUse.length === 0) {
        alert('播放列表是空的！请先在音乐库添加歌曲，或在聊天中分享一首歌。');
        card.style.display = 'none';
        return;
    }
    
    switchSong(songToPlayIndex);
}

        function closeMusicPlayer() {
            state.musicSessionContactId = null;
            document.getElementById('music-player-card').style.display = 'none';
            document.getElementById('player-playlist-view').classList.remove('active');
            globalAudioPlayer.pause();
        }

        // --- ↓↓↓ 用这个新函数，替换掉你原来的 switchSong 函数 ↓↓↓ ---

async function switchSong(index, autoPlay = true, notifyAI = false) { // 1. 这里增加了 async 和 notifyAI 参数
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.sharedPlaylist.tracks || contact.sharedPlaylist.tracks.length === 0) return;

    currentSongIndex = (index + contact.sharedPlaylist.tracks.length) % contact.sharedPlaylist.tracks.length;
    contact.sharedPlaylist.currentIndex = currentSongIndex;
    const song = contact.sharedPlaylist.tracks[currentSongIndex];

    if (!song || !song.url) {
        console.error("要播放的歌曲无效:", song);
        return;
    }
    
    const newSrc = song.url;
    const oldSrc = globalAudioPlayer.src;

    const sourceMessage = contact.history.find(m => m.type === 'music_share' && m.content.url === song.url);
    currentlyPlayingMsgId = sourceMessage ? sourceMessage.id : null;

    if (oldSrc !== newSrc) {
        globalAudioPlayer.src = newSrc;
    }

    document.getElementById('player-user-avatar').src = state.myProfile.avatar;
    document.getElementById('header-user-avatar').src = state.myProfile.avatar;
    document.getElementById('player-contact-avatar').src = contact.avatar;
    document.getElementById('header-contact-avatar').src = contact.avatar;
    document.getElementById('player-title').textContent = song.title;
    document.getElementById('player-artist').textContent = song.artist;

    lyrics = parseLyrics(song.lrc || `[00:00.00]${song.title}\n[00:05.00](暂无歌词)`);
    renderLyrics();
    renderPlaylist();

    if (autoPlay) {
        globalAudioPlayer.play().catch(e => console.error("播放失败", e));
    }

    // 2. ▼▼▼ 这里是新增的核心逻辑 ▼▼▼
    // 如果 notifyAI 为 true，并且歌曲真的切换了，就执行“递纸条”操作
    if (notifyAI && oldSrc !== newSrc) {
        // 纸条内容：告诉AI歌曲已切换
        const systemPrompt = `[SYSTEM: 歌曲已经切换为《${song.title}》，演唱者是 ${song.artist}。]`;
        
        // 核心改动：只创建一条隐藏的系统指令，不触发AI自动回复
        await createAndAddMessage({ type: 'text', content: systemPrompt }, 'system_instruction');
    }
}

 // 这是功能完整的最终版 updateUI 函数，请用它替换掉您代码里现有的版本
function updateUI() {
    // --- 更新悬浮播放器 (这部分是原有的，不变) ---
    const card = document.getElementById('music-player-card');
    if (card && card.style.display !== 'none') {
        const isPlaying = !globalAudioPlayer.paused;
        document.getElementById('player-play-btn').className = `fas ${isPlaying ? 'fa-pause-circle' : 'fa-play-circle'} player-control-btn player-play-btn`;

        if (globalAudioPlayer.duration && isFinite(globalAudioPlayer.duration)) {
            const progressPercent = (globalAudioPlayer.currentTime / globalAudioPlayer.duration) * 100;
            document.getElementById('player-progress').style.width = `${progressPercent}%`;
            const formatTime = (s) => new Date(s * 1000).toISOString().substr(14, 5);
            document.getElementById('player-current-time').textContent = formatTime(globalAudioPlayer.currentTime);
            document.getElementById('player-duration').textContent = formatTime(globalAudioPlayer.duration);
        }

        if (lyrics.length > 0) {
            let newLyricIndex = lyrics.findIndex(line => line.time > globalAudioPlayer.currentTime);
            if (newLyricIndex === -1) { newLyricIndex = lyrics.length; }
            newLyricIndex = newLyricIndex - 1;
            if (newLyricIndex !== currentLyricIndex) {
                currentLyricIndex = newLyricIndex;
                const lyricsWrapper = document.getElementById('lyrics-wrapper');
                const allLyricLines = lyricsWrapper.querySelectorAll('.lyric-line');
                allLyricLines.forEach(line => line.classList.remove('active'));
                if (allLyricLines[currentLyricIndex]) {
                    allLyricLines[currentLyricIndex].classList.add('active');
                    const activeLineText = allLyricLines[currentLyricIndex].textContent;
                    document.getElementById('header-lyric').textContent = activeLineText;
                    const lyricsContainer = document.getElementById('lyrics-container');
                    const scrollOffset = allLyricLines[currentLyricIndex].offsetTop - (lyricsContainer.offsetHeight / 2) + (allLyricLines[currentLyricIndex].offsetHeight / 2);
                    lyricsWrapper.style.transform = `translateY(-${scrollOffset}px)`;
                }
            }
        } else {
             document.getElementById('header-lyric').textContent = "纯音乐，请欣赏";
        }
    }

    // ▼▼▼ 【新增】更新锁屏音乐组件的逻辑 ▼▼▼
    const lockScreenMusicWidget = document.getElementById('lock-screen-music-widget');
    if (lockScreenMusicWidget) {
        const songInfoEl = document.getElementById('lock-screen-song-info');
        const playBtn = lockScreenMusicWidget.querySelector('.fa-play, .fa-pause');
        const contact = state.contacts.find(c => c.id === state.musicSessionContactId);

        if (!globalAudioPlayer.paused && contact) {
            // 如果正在播放
            const song = contact.sharedPlaylist.tracks[currentSongIndex];
            if(song) {
                songInfoEl.textContent = `${song.title} - ${song.artist}`;
            }
            if(playBtn) playBtn.className = 'fas fa-pause';
        } else {
            // 如果是暂停或停止状态
            songInfoEl.textContent = '暂无音乐播放';
            if(playBtn) playBtn.className = 'fas fa-play';
        }
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲
}

        function renderPlaylist() {
    const playlistList = document.getElementById('playlist-list');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const songMap = new Map();
    const createKey = (song) => `${(song.title || '').trim()}|${(song.artist || '').trim()}`;

    state.musicLibrary.forEach(song => {
        songMap.set(createKey(song), song);
    });

    if (contact.history) {
        contact.history
            .filter(msg => msg.type === 'music_share')
            .forEach(msg => {
                const song = msg.content;
                const key = createKey(song);
                if (!songMap.has(key)) {
                    songMap.set(key, song);
                }
            });
    }

    const finalPlaylist = Array.from(songMap.values());
    contact.sharedPlaylist.tracks = finalPlaylist;

    playlistList.innerHTML = '';
    const currentPlayingSong = contact.sharedPlaylist.tracks[contact.sharedPlaylist.currentIndex];

    finalPlaylist.forEach(song => {
        const isCurrentlyPlaying = currentPlayingSong && createKey(currentPlayingSong) === createKey(song);

        const item = document.createElement('li');
        item.className = 'playlist-item';
        if (isCurrentlyPlaying) {
            item.classList.add('playing');
        }
        item.innerHTML = `<div class="playlist-title">${song.title}</div><div class="playlist-artist">${song.artist || ''}</div>`;
        
        item.addEventListener('click', async () => {
            const songIndexToPlay = contact.sharedPlaylist.tracks.findIndex(t => createKey(t) === createKey(song));
            if (songIndexToPlay !== -1) {
                switchSong(songIndexToPlay, true, true);
            }
            document.getElementById('player-playlist-view').classList.remove('active');
        });
        playlistList.appendChild(item);
    });
}
        
        // 全新重构的终极版歌-词-解-析-函-数！(已添加换行符净化)
function parseLyrics(lrc) {
    const result = [];
    if (!lrc) {
        return result;
    }

    const lyricRegex = /((?:\[\d{2}:\d{2}\.\d{2,3}\])+)([^\[]*)/g;
    let match;

    while ((match = lyricRegex.exec(lrc)) !== null) {
        // ▼▼▼ 核心修改在这里 ▼▼▼
        // 将所有 \n 替换为空格，然后去除首尾多余空格
        const text = match[2].replace(/\\n/g, ' ').trim(); 
        // ▲▲▲ 修改结束 ▲▲▲

        if (text) {
            const timeMatches = match[1].match(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/g);
            for (const timeMatch of timeMatches) {
                const timeParts = timeMatch.match(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/);
                const time = parseInt(timeParts[1]) * 60 + parseInt(timeParts[2]) + parseInt(timeParts[3]) / 1000;
                result.push({ time, text });
            }
        }
    }

    result.sort((a, b) => a.time - b.time);
    return result;
}

        function renderLyrics() {
            const lyricsWrapper = document.getElementById('lyrics-wrapper');
            lyricsWrapper.innerHTML = '';
            lyrics.forEach(line => { lyricsWrapper.innerHTML += `<p class="lyric-line">${line.text}</p>`; });
        }  
        
        const STRANGER_AVATARS = [
            'https://i.postimg.cc/bY1R2JMv/Camera-XHS-17550612722421040g2sg31f81ntj2ma7g5obt6vigkl57bvgbiq8.jpg',
            'https://i.postimg.cc/9fvGD5YT/Camera-XHS-17550612774061040g2sg31f81ntj2ma805obt6vigkl57jpbsck8.jpg',
            'https://i.postimg.cc/KzSMZ7mD/Camera-XHS-17550612817931040g2sg31f81ntj2ma8g5obt6vigkl57nqa52qg.jpg',
            'https://i.postimg.cc/Kvq3KhZz/Camera-XHS-17550612853331040g2sg31f81ntj2ma905obt6vigkl57r19gv30.jpg',
            'https://i.postimg.cc/MHsHj1J4/Camera-XHS-17550612887251040g2sg31f81ntj2ma9g5obt6vigkl57ptgto48.jpg',
            'https://i.postimg.cc/3JBVm96W/Camera-XHS-17550612921721040g2sg31f81ntj2maa05obt6vigkl5700r4t2g.jpg'
        ];

        // ✨✨✨ 用下面这个完整的代码块，替换掉你原来的 INITIAL_STATE ✨✨✨
        const INITIAL_STATE = {
            contacts: [],
            worldBooks: [],
            posts: [],
            userPersonaPresets: [],
            emoticons: [],
            emoticonGroups: [{ id: 'default', name: '默认分组' }],
            musicLibrary: [],
            thoughtPresets: [],
            apiSettings: { 
    apiKey: '', 
    model: '', 
    endpoint: '', 
    contextLength: 20, 
    longTermMemoryLength: 30,
    // ▼▼▼ 新增这两行 ▼▼▼
    minimaxGroupId: '',
    minimaxApiKey: '',
    // ▲▲▲ 新增结束 ▲▲▲
    siliconflowApiKey: '',
    temperature: 1.0,
    maxTokens: 0
},
            squareApiSettings: { apiKey: '', model: '', endpoint: '' },
            snoopApiSettings: { apiKey: '', model: '', endpoint: '' },
            myProfile: { id: "main", name: "我的名字", avatar: "https://s21.ax1x.com/2025/11/09/pZ9F0Re.png", status: "在线", signature: "我的个性签名", region: "我的地区", birthday: "我的生日", balance: 1000,investments: {}
     },
            transactions: [],
            trendingTopics: [],
            activeChatId: null,
            activeFeedTab: 'recommended',
            activeFeedSubTab: 'daily',
            activePostId: null,
            hasNewPosts: false,
            postsToDisplay: 20,
            activeCall: null,
            musicSessionContactId: null,
            apiPresets: [],
            themePresets: [],
            forumSettings: {
                id: 'main',
                personaId: '',
                worldBookIds: [],
                styleDescription: '',
                allowedPosterIds: []
            },
            activeForumArchiveId: 'default', // 【新增】追踪当前激活的论坛存档ID
            forumArchives: [], //  你原来代码的最后一行
            forumCategories: [],
            aiTypingStatus: {},
            // ▼▼▼ 在这里添加新代码 ▼▼▼
            automationSettings: {
                isEnabled: false,
                interval: 300,       // 默认300秒
                selectedContactIds: [],
                minReplies: 1,       // 每次最少回复1人
                maxReplies: 2        // 每次最多回复2人
            },
            currentChatMode: 'chat'
        };

        let state = JSON.parse(JSON.stringify(INITIAL_STATE)); // 这是你原来的代码
        
        // ▼▼▼▼▼▼ 添加下面这三行（开后门） ▼▼▼▼▼▼
        window.state = state;           // 把 state 挂到窗口上
        window.kokoMemory = kokoMemory; // 把数据库挂到窗口上
        window.openChat = openChat;     // 把打开聊天函数挂到窗口上
        // ▲▲▲▲▲▲ 添加结束 ▲▲▲▲▲▲
        state.currentChatMode = state.currentChatMode || 'chat';
        let automationTimer = null;
        let nextAutomationTimestamp = 0;
        let activeReplyTarget = null;
        let chatPagination = {};
        let isInitialPostLoad = true;
        let editingBookId = null;
        let editingUserPersonaId = null;
        let editingThoughtPresetId = null;
        let editModeState = { active: false, selectedMessageIds: new Set() };
        let pendingPostImage = null;
        let pendingCommentImage = null; 
        let diaryEditModeState = { active: false, selectedEntryIds: new Set() };
        let batchedPetActions = [];
        let pendingForumRedPacket = null;
        let callTimerInterval = null;
        let smsEditModeState = { active: false, selectedMessageIds: new Set() };
        let currentEditingPersonaAvatar = null;
        // (全局变量)
let stockPriceInterval = null;
let currentStockData = {
    id: 'KOK',
    price: 100.00,
    history: [] // 存放 [时间戳, 价格]
};
let myStockChart = null;
let activeEmoticonGroupId = 'default'; // 当前选中的表情分组ID
let currentUserEmoticonTab = 'default'; // 记录用户在聊天界面当前看的分组
// --- 地图嵌套功能状态 ---
let currentMapParentId = null; // 当前正在查看哪个地点内部 (null表示在查看世界地图)
let mapNavigationStack = []; // 存储导航历史: [{id: 'loc_1', name: '夜之城'}, ...]
let editingGroupNpcId = null; // 用于记录当前正在编辑群聊NPC的ID
let lastNotificationTime = 0;
        
        
        // --- NEW: V7.0 新增: 音乐播放相关全局变量 ---
        let listenTimeInterval = null;
        const globalAudioPlayer = document.getElementById('global-audio-player');
        
        const feedStatusEl = document.getElementById('feed-status-indicator');
        
        // ✨✨✨ 用下面这个完整的函数，替换掉你原来的 loadDataFromDB 函数 ✨✨✨
async function loadDataFromDB() {
    try {
        const [
            contacts, worldBooks, posts, userPersonaPresets, 
            emoticons, musicLibrary, thoughtPresets, apiSettings, squareApiSettings, myProfile,
            transactions,
            trendingTopics,
            apiPresets,
            forumSettings,
            // 【核心修复 - 第2部分：读取选择】
            // 在程序启动时，一并读取用户设置
            userSettings, 
            forumArchives,
            maps,
            snoopApiSettings,
            forumCategories,
            emoticonGroups,
            themePresets
        ] = await Promise.all([
            kokoMemory.getAll('contacts'),
            kokoMemory.getAll('worldBooks'),
            kokoMemory.getAll('posts'),
            kokoMemory.getAll('userPersonaPresets'),
            kokoMemory.getAll('emoticons'),
            kokoMemory.getAll('musicLibrary'),
            kokoMemory.getAll('thoughtPresets'),
            kokoMemory.get('apiSettings', 'main'),
            kokoMemory.get('squareApiSettings', 'main'),
            kokoMemory.get('myProfile', 'main'),
            kokoMemory.getAll('transactions'),
            kokoMemory.getAll('trendingTopics'),
            kokoMemory.getAll('apiPresets'),
            kokoMemory.get('forumSettings', 'main'),
            // 【核心修复 - 第2部分：读取选择】
            kokoMemory.get('userSettings', 'main'),
            kokoMemory.getAll('forumArchives'),
            kokoMemory.getAll('maps'),
            kokoMemory.get('snoopApiSettings', 'main'),
            kokoMemory.getAll('forumCategories'),
            kokoMemory.getAll('emoticonGroups'),
            kokoMemory.getAll('themePresets')
        ]);

        if (!myProfile) {
            console.log("数据库为空，使用初始状态填充。");
            const initialProfile = { id: 'main', ...INITIAL_STATE.myProfile };
            await kokoMemory.put('myProfile', initialProfile);
            state.myProfile = initialProfile;
            const initialApiSettings = { id: 'main', ...INITIAL_STATE.apiSettings };
            await kokoMemory.put('apiSettings', initialApiSettings);
            state.apiSettings = initialApiSettings;
            const initialSquareApiSettings = { id: 'main', ...INITIAL_STATE.squareApiSettings };
            await kokoMemory.put('squareApiSettings', initialSquareApiSettings);
            state.squareApiSettings = initialSquareApiSettings;
            await kokoMemory.bulkPut('thoughtPresets', INITIAL_STATE.thoughtPresets);
            state.thoughtPresets = INITIAL_STATE.thoughtPresets;
            const initialForumSettings = { id: 'main', ...INITIAL_STATE.forumSettings };
            await kokoMemory.put('forumSettings', initialForumSettings);
            state.forumSettings = initialForumSettings;
            const initialSnoopApiSettings = { id: 'main', ...INITIAL_STATE.snoopApiSettings };
            await kokoMemory.put('snoopApiSettings', initialSnoopApiSettings);
            state.snoopApiSettings = initialSnoopApiSettings;
            isInitialPostLoad = true;
        } else {
            console.log("从数据库加载数据。");
            state.contacts = contacts;
            state.worldBooks = worldBooks;
            state.posts = posts;
            state.userPersonaPresets = userPersonaPresets;
            state.emoticons = emoticons;
            state.musicLibrary = musicLibrary;
            state.thoughtPresets = thoughtPresets.length > 0 ? thoughtPresets : INITIAL_STATE.thoughtPresets;
            state.apiSettings = apiSettings ? { ...INITIAL_STATE.apiSettings, ...apiSettings } : { id: 'main', ...INITIAL_STATE.apiSettings };
            state.squareApiSettings = squareApiSettings ? { ...INITIAL_STATE.squareApiSettings, ...squareApiSettings } : { id: 'main', ...INITIAL_STATE.squareApiSettings };
            state.myProfile = { ...INITIAL_STATE.myProfile, ...myProfile };
            state.myProfile.balance = state.myProfile.balance || 1000;
            state.myProfile.investments = state.myProfile.investments || {};
                     // ▼▼▼ 把下面这段新代码粘贴到这里 ▼▼▼
            // (遍历所有已保存的股票投资，确保它们都有 cumulativeProfitLoss 字段)
            for (const stockId in state.myProfile.investments) {
                if (state.myProfile.investments.hasOwnProperty(stockId)) {
                    // 如果旧数据没有这个字段，就给它初始化为 0
                    state.myProfile.investments[stockId].cumulativeProfitLoss = state.myProfile.investments[stockId].cumulativeProfitLoss || 0;
                }
            }
            // ▲▲▲ 粘贴到这里结束 ▲▲▲
            state.transactions = transactions;
            state.trendingTopics = trendingTopics;
            state.apiPresets = apiPresets || [];
            state.forumSettings = forumSettings ? { ...INITIAL_STATE.forumSettings, ...forumSettings } : { id: 'main', ...INITIAL_STATE.forumSettings };
            state.forumSettings.allowedPosterIds = state.forumSettings.allowedPosterIds || [];
            state.forumArchives = forumArchives || [];
            state.maps = maps || []; 
            state.snoopApiSettings = snoopApiSettings ? { ...INITIAL_STATE.snoopApiSettings, ...snoopApiSettings } : { id: 'main', ...INITIAL_STATE.snoopApiSettings };
            state.forumCategories = forumCategories || []; // <-- ✨ 在这里添加新的一行
            state.themePresets = themePresets || [];
                        // ▼▼▼▼▼▼ 把这段新代码粘贴到这里 ▼▼▼▼▼▼
            // 初始化分组逻辑
            if (!emoticonGroups || emoticonGroups.length === 0) {
                // 如果是旧用户（还没有分组表），创建一个默认分组
                const defaultGroup = { id: 'default', name: '默认分组' };
                await kokoMemory.put('emoticonGroups', defaultGroup);
                state.emoticonGroups = [defaultGroup];
            } else {
                state.emoticonGroups = emoticonGroups;
            }
            
            // 兼容性处理：如果旧的表情包没有 groupId 字段，把它们归入“默认分组”
            let hasEmoticonUpdates = false;
            state.emoticons.forEach(emo => {
                if (!emo.groupId) {
                    emo.groupId = 'default';
                    hasEmoticonUpdates = true;
                }
            });
            if (hasEmoticonUpdates) {
                await kokoMemory.bulkPut('emoticons', state.emoticons);
            }
            // ▲▲▲▲▲▲ 新代码粘贴结束 ▲▲▲▲▲▲
            // 【核心修复 - 第2部分：应用选择】
            // 在所有数据加载后，检查是否存在已保存的激活存档ID，并应用它
            if (userSettings && userSettings.activeForumArchiveId) {
                state.activeForumArchiveId = userSettings.activeForumArchiveId;
            }
            // ▼▼▼ 在这里添加新代码 ▼▼▼
            if (userSettings && userSettings.automationSettings) {
                state.automationSettings = { ...INITIAL_STATE.automationSettings, ...userSettings.automationSettings };
            }
            // ▲▲▲ 新代码添加结束 ▲▲▲

            isInitialPostLoad = state.posts.length < 20;
        }
        
        state.contacts.forEach(contact => {
            contact.history = contact.history || [];
            contact.diary = contact.diary || [];
            contact.blockedStatus = contact.blockedStatus || 'none'; 
            contact.history.forEach((msg, index) => { 
                if (!msg.id) msg.id = `msg_${Date.now()}_${index}`; 
                if (!msg.type) msg.type = 'text';
            });
            contact.worldBooks = contact.worldBooks || []; 
            contact.userPersona = contact.userPersona || '';
            contact.thoughtPreset = contact.thoughtPreset || 'deep_roleplay_regex'; 
            contact.signature = contact.signature || ''; 
            contact.isNarrativeMode = contact.isNarrativeMode ?? false;
            contact.apiCallCounter = contact.apiCallCounter || 0;
            contact.gold_coins = contact.gold_coins || 50;
            contact.memories = contact.memories || [];
            contact.isChatPetVisible = contact.isChatPetVisible ?? false;
            if (contact.pet) {
                contact.pet.xp = contact.pet.xp || 0;
                contact.pet.level = contact.pet.level || 1;
                contact.pet.form = contact.pet.form || 'baby';
            }
            contact.customChatBackground = contact.customChatBackground || null;
            contact.customUserAvatar = contact.customUserAvatar || null;
            
            contact.sharedPlaylist = contact.sharedPlaylist || { tracks: [], currentIndex: 0, playbackMode: 'list', isPlaying: false };
            contact.totalListenTime = contact.totalListenTime || 0;
            contact.firstChatDate = contact.firstChatDate || (contact.history.length > 0 ? contact.history[0].timestamp : Date.now());
            contact.isAvatarHidden = contact.isAvatarHidden ?? false;
            contact.customBubbleCss = contact.customBubbleCss || null;
            contact.customUserName = contact.customUserName || null;

            // ▼▼▼ 在这里添加下面三行新代码 ▼▼▼
            contact.isGroup = contact.isGroup || false;     // 顺便初始化 isGroup
            contact.members = contact.members || [];       // 顺便初始化 members
            contact.npcMembers = contact.npcMembers || []; // 确保NPC数组(npcMembers)一定存在！
            // ▲▲▲ 新代码添加结束 ▲▲▲
            // ▼▼▼ 在这里粘贴下面2行新代码 ▼▼▼
            contact.userVoiceProvider = contact.userVoiceProvider || '';
            contact.userVoiceId = contact.userVoiceId || '';
            // ▲▲▲ 粘贴结束 ▲▲▲
        });
        state.posts.forEach(p => { if (!p.archiveId) p.archiveId = 'default'; });

    } catch (error) {
        console.error("从IndexedDB加载数据失败:", error);
        alert("加载数据失败，应用将使用初始状态。请检查浏览器设置或控制台错误。");
    }
}
        
        // --- 新增：用于替代 prompt() 的自定义弹窗函数 ---
        function showCustomPrompt(title, currentValue = '') {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-prompt-modal');
                const titleEl = document.getElementById('custom-prompt-title');
                const inputEl = document.getElementById('custom-prompt-input');
                const confirmBtn = document.getElementById('custom-prompt-confirm-btn');
                const cancelBtn = document.getElementById('custom-prompt-cancel-btn');

                titleEl.textContent = title;
                inputEl.value = currentValue;
                modal.style.display = 'flex';
                inputEl.focus();

                const confirmHandler = () => {
                    cleanup();
                    resolve(inputEl.value);
                };

                const cancelHandler = () => {
                    cleanup();
                    resolve(null); // 返回 null，与原生 prompt() 的行为保持一致
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', confirmHandler);
                    cancelBtn.removeEventListener('click', cancelHandler);
                    modal.style.display = 'none';
                };
                
                // 每次都重新绑定事件，防止重复监听
                confirmBtn.addEventListener('click', confirmHandler, { once: true });
                cancelBtn.addEventListener('click', cancelHandler, { once: true });
            });
        }
/**
 * (推荐) 辅助函数：将时间戳转换为AI可读的【混合时间】
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式如 "(今天 14:30)", "(昨天 09:15)", "(周二 18:00)", 或 "(10月05日 12:00)"
 */
function formatHybridTimeForAI(timestamp) {
    const msgDate = new Date(timestamp);

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    // 设为6天前（用于判断是否在本周内）
    const sixDaysAgo = new Date(today);
    sixDaysAgo.setDate(sixDaysAgo.getDate() - 6);

    // 格式化时间 HH:MM
    const formatTime = (date) => {
        const h = date.getHours().toString().padStart(2, '0');
        const m = date.getMinutes().toString().padStart(2, '0');
        return `${h}:${m}`;
    };

    if (msgDate >= today) {
        return `(今天 ${formatTime(msgDate)})`;
    } else if (msgDate >= yesterday) {
        return `(昨天 ${formatTime(msgDate)})`;
    } else if (msgDate >= sixDaysAgo) {
        const dayNames = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
        return `(${dayNames[msgDate.getDay()]} ${formatTime(msgDate)})`;
    } else {
        // 超过一周，显示月日
        const m = (msgDate.getMonth() + 1).toString().padStart(2, '0');
        const d = msgDate.getDate().toString().padStart(2, '0');
        return `(${m}月${d}日 ${formatTime(msgDate)})`;
    }
}
        // --- 新增：用于替代 confirm() 的自定义确认函数 ---
        function showCustomConfirm(title, message, isDanger = false) {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-confirm-modal');
                const titleEl = document.getElementById('custom-confirm-title');
                const textEl = document.getElementById('custom-confirm-text');
                const confirmBtn = document.getElementById('custom-confirm-confirm-btn');
                const cancelBtn = document.getElementById('custom-confirm-cancel-btn');

                titleEl.textContent = title;
                textEl.innerHTML = message.replace(/\n/g, '<br>'); // 支持换行
                modal.style.display = 'flex';

                if (isDanger) {
                    confirmBtn.classList.add('danger');
                } else {
                    confirmBtn.classList.remove('danger');
                }

                const confirmHandler = () => {
                    cleanup();
                    resolve(true);
                };

                const cancelHandler = () => {
                    cleanup();
                    resolve(false);
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', confirmHandler);
                    cancelBtn.removeEventListener('click', cancelHandler);
                    modal.style.display = 'none';
                };
                
                confirmBtn.addEventListener('click', confirmHandler, { once: true });
                cancelBtn.addEventListener('click', cancelHandler, { once: true });
            });
        }
// 1. 数据表中文名称映射
const STORE_DISPLAY_NAMES = {
    contacts: "👥 联系人列表",
    contactGroups: "📁 联系人分组",
    worldBooks: "📚 世界书 (设定集)",
    posts: "💬 论坛/空间帖子",
    userPersonaPresets: "🎭 用户面具预设",
    emoticons: "😀 表情包库",
    emoticonGroups: "📂 表情包分组",
    musicLibrary: "🎵 音乐库",
    thoughtPresets: "🧠 思维预设",
    apiSettings: "⚙️ 聊天API设置",
    squareApiSettings: "🏙️ 论坛API设置",
    snoopApiSettings: "🕵️ 窥探API设置",
    myProfile: "👤 我的个人资料",
    transactions: "💰 钱包收支记录",
    trendingTopics: "🔥 热搜话题",
    userSettings: "🛠️ 全局用户设置 (外观/背景等)",
    apiPresets: "💾 API配置预设",
    forumSettings: "🎨 论坛风格设置",
    forumArchives: "🏛️ 论坛档案馆",
    lockScreenPhotos: "🖼️ 锁屏相册",
    maps: "🗺️ 地图数据",
    relationshipNetworks: "🕸️ 关系网络",
    snoopData: "📱 窥探模式数据 (手机缓存)",
    favorites: "⭐ 我的收藏",
    stockMarket: "📈 股票行情",
    stockEvents: "📰 股票新闻",
    forumCategories: "🏷️ 论坛自定义板块"
};

// 2. 打开导出选择弹窗
async function openExportSelectorModal() {
    const modal = document.getElementById('export-selector-modal');
    const listEl = document.getElementById('export-options-list');
    listEl.innerHTML = '';

    // 遍历所有数据库表
    Object.keys(dbConfig).forEach(storeName => {
        const displayName = STORE_DISPLAY_NAMES[storeName] || storeName; // 如果没定义中文名，就显示英文名
        
        const item = document.createElement('div');
        item.className = 'world-book-item';
        item.style.padding = '10px';
        item.style.marginBottom = '0';
        
        // 默认勾选一些常用的 (联系人、世界书、分组)
        const defaultChecked = ['contacts', 'worldBooks', 'contactGroups', 'userSettings'].includes(storeName) ? 'checked' : '';

        item.innerHTML = `
            <input type="checkbox" class="world-book-checkbox export-store-check" id="export-store-${storeName}" value="${storeName}" ${defaultChecked}>
            <label for="export-store-${storeName}" class="world-book-name" style="font-size: 14px;">${displayName}</label>
        `;
        listEl.appendChild(item);
    });

    modal.style.display = 'flex';
}

// 3. 全选/反选 辅助函数
window.toggleExportCheckboxes = function(checked) {
    document.querySelectorAll('.export-store-check').forEach(cb => cb.checked = checked);
};

// 4. 执行自定义导出
async function performCustomExport() {
    const selectedStores = Array.from(document.querySelectorAll('.export-store-check:checked')).map(cb => cb.value);

    if (selectedStores.length === 0) {
        return alert("请至少选择一项数据！");
    }

    const confirmBtn = document.getElementById('confirm-custom-export-btn');
    const originalText = confirmBtn.innerHTML;
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 正在打包...';

    try {
        const dataToExport = {};

        for (const storeName of selectedStores) {
            // 从数据库获取数据
            const data = await kokoMemory.getAll(storeName);
            
            // 针对单条数据表（如 myProfile），如果是数组且只有一个元素，我们优化一下导出结构（可选，为了兼容性保持数组也行）
            // 这里为了保持和你原本 exportLightData 的逻辑一致，我们直接存入
            dataToExport[storeName] = data;
        }

        // 生成文件
        const jsonString = JSON.stringify(dataToExport, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        // 文件名带上时间戳
        const dateStr = new Date().toLocaleDateString().replace(/\//g, '-');
        const dbVersion = kokoMemory.version;
        a.download = `Koko_Custom_Backup_v${dbVersion}_${dateStr}.json`;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        document.getElementById('export-selector-modal').style.display = 'none';
        alert(`成功导出 ${selectedStores.length} 个数据表！`);

    } catch (error) {
        console.error('导出失败:', error);
        alert(`导出失败: ${error.message}`);
    } finally {
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = originalText;
    }
}
/**
 * (新) 导出数据(备份) V4 - 辅助函数
 * 使用游标（Cursor）逐行读取一张表，并将每行转为字符串存入数组。
 * 内存占用极低。
 */
function streamTableToBlobParts(db, storeName) {
    return new Promise((resolve, reject) => {
        const parts = []; // 存放这张表的所有数据（字符串格式）
        const transaction = db.transaction(storeName, 'readonly');
        const store = transaction.objectStore(storeName);
        const request = store.openCursor();

        request.onsuccess = event => {
            const cursor = event.target.result;
            if (cursor) {
                // 如果游标存在（即还有数据）
                try {
                    // 1. 获取这一行数据
                    const row = cursor.value;
                    // 2. 转换成JSONL字符串
                    const line = JSON.stringify({ table: storeName, data: row }) + '\n';
                    // 3. 存入数组
                    parts.push(line);
                    // 4. 继续取下一行
                    cursor.continue();
                } catch (error) {
                    // 捕获序列化错误
                    reject(error);
                    transaction.abort();
                }
            } else {
                // 5. 游标为null，说明这张表读完了，返回所有字符串
                resolve(parts);
            }
        };
        request.onerror = event => {
            reject(event.target.error);
        };
    });
}        
/**
 * (新) 导出数据 (V4.1 - 最终版：游标 + Blob + .json 兼容)
 * 内存优化 + 浏览器兼容 + 文件后缀兼容
 */
async function exportData() {
    alert("正在准备数据，请稍候...\n数据量大时可能需要几十秒，请勿关闭页面。");
    try {
        let finalBlobParts = []; // 存放所有表的所有字符串
        
        for (const storeName in dbConfig) {
            console.log(`正在打包 ${storeName}...`);
            
            // 1. 处理单条设置的表 (如 myProfile)
            if (['myProfile', 'apiSettings', 'squareApiSettings', 'forumSettings', 'userSettings', 'snoopApiSettings'].includes(storeName)) {
                const row = await kokoMemory.get(storeName, 'main');
                if (row) {
                    const line = JSON.stringify({ table: storeName, data: row }) + '\n';
                    finalBlobParts.push(line);
                }
            } else {
                // 2. 处理大型表 (如 contacts, posts)
                // 调用 V4 辅助函数，逐行读取
                const tableParts = await streamTableToBlobParts(kokoMemory.db, storeName);
                finalBlobParts = finalBlobParts.concat(tableParts);
            }
        }

        console.log("所有数据打包完毕，正在生成文件...");
        
        // 3. 使用 new Blob() 高效合并所有字符串块，生成最终文件
        
        // ✅✅✅ 核心修复点在这里 ✅✅✅
        // 1. 我们把文件类型伪装成 'application/json'
        const blob = new Blob(finalBlobParts, { type: 'application/json' }); 
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        const dbVersion = kokoMemory.version;
        // 2. 我们把文件后缀名伪装成 '.json'
        a.download = `koko_backup_v${dbVersion}.json`;
        // ✅✅✅ 修复结束 ✅✅✅
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert(`数据已成功导出为 ${a.download} 文件！\n(此文件使用内存优化格式，导入时会自动识别)`);

    } catch (error) {
        console.error('导出数据失败:', error);
        alert(`导出数据失败: ${error.message}`);
    }
}
        
// --- 新增：导入数据功能 (V3 - 兼容 JSON 和 JSONL) ---
async function importData(event) {
    const file = event.target.files[0];
    if (!file) return;

    const confirmed = await showCustomConfirm('导入数据', '警告：导入数据将会覆盖当前所有数据！确定要继续吗？', true);
    if (!confirmed) {
        event.target.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = async (e) => {
        let dataToImport = {};
        const fileContent = e.target.result;

        try {
            // --- 步骤 1: 尝试按旧的 JSON 格式解析 ---
            dataToImport = JSON.parse(fileContent);
            console.log("检测到旧版 .json 备份文件。");

        } catch (jsonError) {
            // --- 步骤 2: 如果 JSON 解析失败，尝试按新的 .jsonl 格式解析 ---
            console.warn("JSON 解析失败，尝试按 .jsonl 格式解析...");
            try {
                const lines = fileContent.split('\n');
                dataToImport = {}; // 确保是空对象

                for (const line of lines) {
                    if (!line.trim()) continue; // 跳过空行

                    const parsedLine = JSON.parse(line);
                    const { table, data } = parsedLine;
                    
                    if (!table || data === undefined) continue;

                    if (!dataToImport[table]) {
                        dataToImport[table] = []; // 初始化为一个数组
                    }
                    dataToImport[table].push(data);
                }
                
                // 关键一步：将 "单条目" 数据（如 myProfile）从数组解包回对象
                const singleItemStores = ['myProfile', 'apiSettings', 'squareApiSettings', 'snoopApiSettings', 'forumSettings', 'userSettings'];
                for (const storeName of singleItemStores) {
                    if (dataToImport[storeName] && Array.isArray(dataToImport[storeName]) && dataToImport[storeName].length > 0) {
                        dataToImport[storeName] = dataToImport[storeName][0]; // 只取第一个（也应该是唯一一个）
                    }
                }
                console.log("成功按 .jsonl 格式解析备份文件。");

            } catch (jsonlError) {
                // --- 步骤 3: 两种格式都失败了 ---
                console.error('导入失败，文件既不是 JSON 也不是 JSONL 格式:', jsonlError);
                alert(`导入失败：文件格式不正确，无法解析。\n错误信息: ${jsonlError.message}`);
                event.target.value = '';
                return;
            }
        }
        
        // --- 步骤 4: (这是你原有的逻辑，保持不变) ---
        //   无论数据来自 .json 还是 .jsonl，到这里 dataToImport 的结构都应该是一致的了
        try {
            const supportedStores = Object.keys(dbConfig);
            let importedCount = 0;
            let skippedCount = 0;

            for (const storeName in dataToImport) {
                if (supportedStores.includes(storeName)) {
                    if (dataToImport[storeName]) {
                        await kokoMemory.clear(storeName); // 清空表
                        
                        if (Array.isArray(dataToImport[storeName])) {
                            await kokoMemory.bulkPut(storeName, dataToImport[storeName]);
                        } else {
                            // 导入单条目数据 (e.g., myProfile)
                            await kokoMemory.put(storeName, dataToImport[storeName]);
                        }
                        importedCount++;
                    }
                } else {
                    console.warn(`跳过导入：当前版本不包含数据表 "${storeName}"。`);
                    skippedCount++;
                }
            }
            
            let alertMessage = `数据导入完成！\n\n- 成功导入 ${importedCount} 个数据表。\n- 跳过了 ${skippedCount} 个不兼容的数据表。`;
            if (skippedCount > 0) {
                alertMessage += '\n\n（注意：部分新版本数据因不兼容已被忽略）';
            }
            alertMessage += '\n\n页面即将刷新以应用更改。';

            alert(alertMessage);
            setTimeout(() => window.location.reload(), 1500);

        } catch (error) {
            console.error('导入数据时出错:', error);
            alert(`导入失败：数据写入数据库时出错: ${error.message}`);
        } finally {
            event.target.value = '';
        }
    };
    reader.readAsText(file);
}

        // ▼▼▼ 用下面这两个【新版】JS函数，替换掉旧的 showFeedStatus 和 hideFeedStatus ▼▼▼

function showFeedStatus(text = '正在刷新论坛...') {
    const header = document.querySelector('.moments-header');
    const indicator = document.getElementById('feed-status-indicator');
    
    if (indicator && header) {
        indicator.textContent = text;
        indicator.style.display = 'block'; // 1. 显示“正在刷新...”
        header.classList.add('is-loading'); // 2. 给顶栏添加标记，让CSS去隐藏“论坛”二字
    }
}

function hideFeedStatus() {
    const header = document.querySelector('.moments-header');
    const indicator = document.getElementById('feed-status-indicator');
    
    if (indicator && header) {
        indicator.style.display = 'none'; // 1. 隐藏“正在刷新...”
        header.classList.remove('is-loading'); // 2. 移除顶栏标记，让CSS把“论坛”二字还回来
    }
}

// ▲▲▲ 替换结束 ▲▲▲
        
        function renderMyProfile() {
            document.getElementById('my-profile-avatar').src = state.myProfile.avatar;
            document.getElementById('profile-name').textContent = state.myProfile.name;
            document.getElementById('profile-status').textContent = state.myProfile.status;
            document.getElementById('nickname-value').textContent = state.myProfile.name;
            document.getElementById('signature-value').textContent = state.myProfile.signature;
            document.getElementById('region-value').textContent = state.myProfile.region;
            document.getElementById('birthday-value').textContent = state.myProfile.birthday;
            document.getElementById('my-balance-value').textContent = `¥ ${state.myProfile.balance.toFixed(2)}`;
        }

        // ... 此处省略大量未修改的函数 (renderContacts, createContactItem 等) ...
        // ... The bulk of the functions from the original file remain unchanged ...
        
        // 此处省略了大量未修改的函数，它们与之前的版本完全相同
        // 确保您已经包含了从 renderContacts 到 handleAvatarUpload 的所有函数
        
        function fieldNameToChinese(field) {
            const map = { name: '昵称', signature: '个性签名', region: '地区', birthday: '生日', status: '状态', avatar: '头像URL' };
            return map[field] || field;
        }

// ▼▼▼ (V3 - 记住折叠状态版) 替换旧的 renderContacts ▼▼▼
async function renderContacts() {
    const contactsContainer = document.querySelector('.contacts-container');
    const fragment = document.createDocumentFragment();

    // 1. 获取所有需要的数据
    const allContacts = state.contacts;
    const allGroups = await kokoMemory.getAll('contactGroups') || [];
    
    // 1b. (新!) 读取“未分组”的折叠状态 (?? false 的意思是如果没存过，就默认展开)
    const isUngroupedCollapsed = userSettings.isUngroupedCollapsed ?? false;

    // 2. 将联系人进行分类
    const pinnedContacts = allContacts.filter(c => c.isPinned);
    const nonPinnedContacts = allContacts.filter(c => !c.isPinned);

    const groupedContacts = allGroups.map(group => ({
        ...group,
        // (新!) 同时读取这个组的折叠状态
        isCollapsed: group.isCollapsed ?? false, // 默认展开
        contacts: nonPinnedContacts.filter(c => c.groupId === group.id)
            .sort((a, b) => (b.history?.slice(-1)[0]?.timestamp || 0) - (a.history?.slice(-1)[0]?.timestamp || 0))
    }));

    const ungroupedContacts = nonPinnedContacts.filter(c => !c.groupId)
        .sort((a, b) => (b.history?.slice(-1)[0]?.timestamp || 0) - (a.history?.slice(-1)[0]?.timestamp || 0));

    let hasContent = false;

    // 3. 渲染置顶联系人 (这部分不变)
    if (pinnedContacts.length > 0) {
        hasContent = true;
        const sectionTitle = document.createElement('div');
        sectionTitle.className = 'section-title';
        sectionTitle.textContent = '置顶聊天';
        fragment.appendChild(sectionTitle);
        pinnedContacts.forEach(contact => fragment.appendChild(createContactItem(contact)));
    }

    // 4. 渲染所有分组和其下的联系人
    groupedContacts.forEach(group => {
        if (group.contacts.length > 0) {
            hasContent = true;
            const sectionTitle = document.createElement('div');
            
            // ▼▼▼ 核心修改 1：渲染时就加上 'collapsed' 类 (如果需要) ▼▼▼
            sectionTitle.className = `section-title collapsible-title ${group.isCollapsed ? 'collapsed' : ''}`;
            // (新!) 加上 data-group-id 方便点击时保存
            sectionTitle.dataset.groupId = group.id; 
            
            sectionTitle.innerHTML = `
                <span>${group.name}</span>
                <span class="collapse-icon">▼</span>
            `;
            fragment.appendChild(sectionTitle); 

            group.contacts.forEach(contact => {
                const item = createContactItem(contact);
                // ▼▼▼ 核心修改 2：如果组是折叠的，联系人默认隐藏 ▼▼▼
                if (group.isCollapsed) {
                    item.style.display = 'none';
                }
                fragment.appendChild(item);
            });
        }
    });

    // 5. 渲染未分组的联系人
    if (ungroupedContacts.length > 0) {
        hasContent = true;
        const sectionTitle = document.createElement('div');
        
        // ▼▼▼ 核心修改 3：同样应用 'collapsed' 类和 data-group-id ▼▼▼
        sectionTitle.className = `section-title ${groupedContacts.some(g => g.contacts.length > 0) ? 'collapsible-title' : ''} ${isUngroupedCollapsed ? 'collapsed' : ''}`;
        sectionTitle.dataset.groupId = 'ungrouped'; // 给“未分组”一个特殊ID
        
        sectionTitle.innerHTML = `
            <span>我的联系人</span>
            ${groupedContacts.some(g => g.contacts.length > 0) ? '<span class="collapse-icon">▼</span>' : ''}
        `;
        fragment.appendChild(sectionTitle);

        ungroupedContacts.forEach(contact => {
            const item = createContactItem(contact);
            // ▼▼▼ 核心修改 4：如果“未分组”是折叠的，联系人默认隐藏 ▼▼▼
            if (isUngroupedCollapsed) {
                item.style.display = 'none';
            }
            fragment.appendChild(item);
        });
    }

    // 6. 渲染空状态 (不变)
    if (!hasContent) {
        const emptyEl = document.createElement('div');
        emptyEl.style = "text-align: center; padding: 50px 20px; color: #888;";
        emptyEl.innerHTML = `<i class="fas fa-user-plus" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有联系人</p><p>点击右上角"+"添加新联系人</p>`;
        fragment.appendChild(emptyEl);
    }
    
    contactsContainer.replaceChildren(fragment);
}
// ▲▲▲ 替换结束 ▲▲▲
        
// 用这个新版本替换掉原来的 createContactItem 函数
function createContactItem(contact) {
    const item = document.createElement('div');
    item.className = 'contact-item';
    item.dataset.contactId = contact.id;
    const lastMessage = contact.history && contact.history.length > 0 ? contact.history[contact.history.length - 1] : null;

    const isGroup = contact.isGroup === true;
    const groupMemberCount = isGroup ? `(${contact.members.length})` : '';
    
    // 处理最后一条消息的发送者名字 (群聊显示)
    let lastMessageSenderName = '';
    if (isGroup && lastMessage && lastMessage.sender !== 'user') {
        // 尝试查找发送者名字
        let sender = state.contacts.find(c => c.id === lastMessage.sender);
        if (!sender && contact.npcMembers) {
             sender = contact.npcMembers.find(n => n.id === lastMessage.sender);
        }
        if(sender) {
            lastMessageSenderName = `${sender.name}: `;
        }
    }

    // 处理最后一条消息的内容预览
    let lastMessageText;
    if (lastMessage) {
        switch (lastMessage.type) {
            case 'html': lastMessageText = '[静态内容]'; break;
            case 'image': case 'uploaded_image': case 'picture_description': lastMessageText = '[图片]'; break;
            case 'voice': lastMessageText = '[语音]'; break;
            case 'red_packet': lastMessageText = '[红包]'; break;
            case 'transfer': lastMessageText = '[转账]'; break;
            case 'music_share': lastMessageText = `[音乐] ${lastMessage.content.title}`; break;
            case 'location_share': lastMessageText = `[位置] ${lastMessage.content.name}`; break;
            case 'post_share': lastMessageText = '[分享的帖子]'; break;
            case 'product_share': lastMessageText = '[分享的商品]'; break;
            case 'chat_history_share': lastMessageText = '[聊天记录]'; break;
            case 'game_wheel': lastMessageText = '[转盘游戏]'; break;
            case 'system_notification': lastMessageText = lastMessage.content; break;
            case 'recall_ai': lastMessageText = '[撤回了一条消息]'; break;
            default: lastMessageText = lastMessage.content;
        }
        if (lastMessage.sender === 'user' && lastMessage.type !== 'system_notification') {
            lastMessageText = '我: ' + lastMessageText;
        }
        if (lastMessage.isRecalled) {
            lastMessageText = '你撤回了一条消息';
        }
    } else {
        lastMessageText = isGroup ? '快来发起第一次群聊吧！' : contact.persona;
    }
    
    // 处理头像
    let avatarHTML = '';
    if (isGroup) {
        if (contact.avatar) {
            avatarHTML = `<img src="${contact.avatar}" onerror="this.onerror=null;this.src='https://via.placeholder.com/50/DDD/666?text=G';" alt="${contact.name}头像">`;
        } else {
            avatarHTML = `<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size: 22px; color: var(--theme-primary);"><i class="fas fa-users"></i></div>`;
        }
    } else {
        avatarHTML = (contact.avatar ? `<img src="${contact.avatar}" onerror="this.onerror=null;this.src='https://via.placeholder.com/50/DDD/666?text=U';" alt="${contact.name}头像">` : `<i class="fas fa-user"></i>`);
    }

  // ▼▼▼ 【核心修正：火花图标逻辑 (带开关)】 ▼▼▼
    let sparkHTML = '';
    
    // 1. 读取开关状态 (如果没有设置，默认为 true/显示)
    // 注意：这里直接读取全局的 userSettings 变量
    const isShowSpark = userSettings.showSparkAndLuckyChar !== false;

    // 2. 判定条件增加：必须 isShowSpark 为 true 才会显示
    if (!isGroup && contact.sparkData && contact.sparkData.streak > 0 && isShowSpark) {
        const spark = getSparkInfo(contact.sparkData.streak);
        if (spark) {
            sparkHTML = `<span class="${spark.className}" style="margin-left: 5px; font-size: 13px;">${spark.icon}</span>`;
        }
    }
    // ▲▲▲ 【修正结束】 ▲▲▲

    item.innerHTML = `
        <div class="contact-avatar">${avatarHTML}</div>
        <div class="contact-info">
            <div class="contact-name">${contact.name} ${groupMemberCount} ${sparkHTML}</div>
            <div class="contact-last-message"></div>
        </div>
        <div class="contact-time-info" style="text-align: right;">
            <i class="fas fa-ellipsis-v contact-options-btn" data-contact-id="${contact.id}"></i> 
            ${lastMessage ? `<div class="contact-time">${lastMessage.time}</div>` : ''}
            ${contact.unreadCount > 0 ? `<div class="unread-count">${contact.unreadCount}</div>` : ''}
        </div>
    `;
    
    // 安全地插入消息内容 (防止HTML注入，但名字部分我们上面已经用innerHTML处理过了)
    item.querySelector('.contact-last-message').textContent = lastMessageSenderName + lastMessageText;
    
    // ★★★ 注意：这里删除了原代码中覆盖 contact-name 的那行 textContent 赋值 ★★★
    // 否则火花图标会被覆盖掉。

    return item;
}        
// ▼▼▼ 新增辅助函数：更新分类下拉列表 ▼▼▼
function updateCategoryDatalist() {
    const dataList = document.getElementById('category-suggestions');
    dataList.innerHTML = ''; // 清空旧选项
    
    // 1. 获取所有已存在的分类，并去重
    const categories = new Set();
    state.worldBooks.forEach(book => {
        if (book.category && book.category.trim() !== '') {
            categories.add(book.category);
        }
    });
    
    // 2. 生成选项标签
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        dataList.appendChild(option);
    });
}
// ▲▲▲ 新增结束 ▲▲▲
// ✨✨✨ (修正版) 世界书渲染函数：支持记住折叠状态 ✨✨✨
async function renderWorldBooks() {
    const worldBookList = document.getElementById('world-book-list');
    worldBookList.innerHTML = '';

    // 1. 获取所有数据
    const books = state.worldBooks;
    // 读取用户设置，获取“已折叠的分类列表”
    // (如果以前没存过，默认为空数组)
    const settings = await kokoMemory.get('userSettings', 'main') || {};
    const collapsedCategories = settings.collapsedWorldBookCategories || [];

    if (books.length === 0) {
        worldBookList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-book" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有世界书</p><p>点击右上角"+"添加新世界书</p></div>`;
        return;
    }

    // 2. 按 category 分组
    const groupedBooks = books.reduce((acc, book) => {
        const category = book.category || '未分类';
        if (!acc[category]) {
            acc[category] = [];
        }
        acc[category].push(book);
        return acc;
    }, {});

    // 3. 渲染
    for (const category in groupedBooks) {
        // 检查当前分类是否被用户折叠过
        const isCollapsed = collapsedCategories.includes(category);

        // --- 渲染标题 ---
        const sectionTitle = document.createElement('div');
        // 如果已折叠，加上 'collapsed' 类
        sectionTitle.className = `section-title collapsible-title ${isCollapsed ? 'collapsed' : ''}`;
        // 🌟 关键：把分类名字存到 data 属性里
        sectionTitle.dataset.wbCategory = category; 
        
        sectionTitle.innerHTML = `
            <span>${category}</span>
            <span class="collapse-icon">▼</span>
        `;
        worldBookList.appendChild(sectionTitle);

        // --- 渲染书籍 ---
        groupedBooks[category].forEach(book => {
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.dataset.bookId = book.id;
            
            // 如果分类被折叠，默认隐藏书籍
            if (isCollapsed) {
                bookItem.style.display = 'none';
            }

            bookItem.innerHTML = `
                <div class="book-header">
                    <div class="book-name">${book.name}</div>
                    <div class="preset-actions">
                        <span class="preset-action-btn delete delete-world-book-btn" title="删除世界书">
                            <i class="fas fa-trash-alt"></i>
                        </span>
                    </div>
                </div>
                <div class="book-content">${book.content.substring(0, 100)}...</div>
            `;
            
            bookItem.addEventListener('click', function() { 
                editWorldBook(this.dataset.bookId); 
            });

            const deleteBtn = bookItem.querySelector('.delete-world-book-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', deleteWorldBook);
            }
            
            worldBookList.appendChild(bookItem);
        });
    }
}
        
// ✨✨✨ 用这个【完整、可折叠版】，替换旧的 updateWorldBookSelectors 函数 ✨✨✨
function updateWorldBookSelectors() {
    const worldBookSelect = document.getElementById('world-book-select');
    const worldBookSelectorList = document.getElementById('world-book-selector-list');
    worldBookSelect.innerHTML = '';
    worldBookSelectorList.innerHTML = '';

    const noBookOption = document.createElement('option');
    noBookOption.value = '';
    noBookOption.textContent = '-- 无关联世界书 --';
    worldBookSelect.appendChild(noBookOption);
    
    // 同样先按 category 分组
    const groupedBooks = state.worldBooks.reduce((acc, book) => {
        const category = book.category || '未分类';
        if (!acc[category]) {
            acc[category] = [];
        }
        acc[category].push(book);
        return acc;
    }, {});

    // 按照分类渲染两个选择器
    for (const category in groupedBooks) {
        // --- 更新下拉选择器 (带分组) ---
        const optgroup = document.createElement('optgroup');
        optgroup.label = category;
        groupedBooks[category].forEach(book => {
            const option = document.createElement('option');
            option.value = book.id;
            option.textContent = book.name;
            optgroup.appendChild(option);
        });
        worldBookSelect.appendChild(optgroup);

        // --- 更新带复选框的选择器 (带分组标题) ---
        const categoryTitle = document.createElement('div');
        categoryTitle.className = 'section-title collapsible-title'; // 加上新样式类
        categoryTitle.style.paddingTop = '10px';
        categoryTitle.innerHTML = `
            <span>${category}</span>
            <span class="collapse-icon">▼</span>
        `;
        worldBookSelectorList.appendChild(categoryTitle);

        groupedBooks[category].forEach(book => {
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="book-setting-${book.id}" value="${book.id}"><label for="book-setting-${book.id}" class="world-book-name">${book.name}</label>`;
            worldBookSelectorList.appendChild(bookItem);
        });
    }
}

// --- (替换) createPostItem 函数 (V2.1 - 支持帖子图片) ---
        function createPostItem(post, isDetailView = false) {
            const postItem = document.createElement('div');
            postItem.className = 'post-item';
            if (!isDetailView) {
                 postItem.dataset.postId = post.id;
            }

            const author = post.author;
            if (!author) return null;

            // (自动提取标题的逻辑保持不变)
            let title = '';
            if (isDetailView) {
                title = post.title;
            } else {
                const sentenceEndings = ['.', '。', '!', '！', '?', '？', '\n'];
                let firstSentenceIndex = -1;
                for (const ending of sentenceEndings) {
                    const index = post.content.indexOf(ending);
                    if (index !== -1 && (firstSentenceIndex === -1 || index < firstSentenceIndex)) {
                        firstSentenceIndex = index;
                    }
                }
                if (firstSentenceIndex !== -1 && firstSentenceIndex < 50) {
                    title = post.content.substring(0, firstSentenceIndex + 1);
                } else if (post.content.length > 25) {
                    title = post.content.substring(0, 25) + '...';
                } else {
                    title = post.content;
                }
            }
            // (标题逻辑结束)

            const authorName = author.name;
            const authorAvatar = author.avatar || 'https://via.placeholder.com/45/DDD/666?text=U';
            const isLiked = post.likes.includes(state.myProfile.name);

            // (红包逻辑保持不变)
            let redPacketHTML = '';
            if (post.redPacket) {
                redPacketHTML = `<div class="forum-red-packet-card" data-post-id="${post.id}">...</div>`; 
            }

            // ▼▼▼ 新增的图片逻辑 ▼▼▼
            let imageHTML = '';
            if (post.image) {
                imageHTML = `<img src="${post.image}" class="post-image-content">`;
            }
            // ▲▲▲ 新增结束 ▲▲▲

            if (isDetailView) {
                // --- 详情页布局 ---
                postItem.innerHTML = `
                    <div class="post-delete-btn" data-post-id="${post.id}" title="删除帖子"><i class="fas fa-trash-alt"></i></div>
                    <div class="post-item-avatar"><img src="${authorAvatar}" onerror="this.onerror=null;this.src='https://via.placeholder.com/45/DDD/666?text=U';" alt="${authorName}的头像"></div>
                    <div class="post-content-area">
                        <div>
                            <span class="post-author-name">${authorName}</span>
                            ${author.id && !author.id.startsWith('stranger_') ? `<span class="post-author-handle">@${author.id.replace('_','')}</span>` : ''}
                        </div>
                        ${ author.signature ? `<div class="post-author-signature">${author.signature}</div>` : '' }
                        <div class="post-text">${parseMentions(post.content.replace(/\n/g, '<br>'))}</div>
                        
                        ${imageHTML} ${redPacketHTML}
                        <div class="post-meta">${formatTimeAgo(post.timestamp)}</div>
                        <div class="post-actions">
                            <span class="post-action-btn repost-btn" data-post-id="${post.id}"><i class="fas fa-retweet"></i> ${post.reposts > 0 ? post.reposts : '转发'}</span>
                            <span class="post-action-btn comment-btn" data-post-id="${post.id}"><i class="far fa-comment"></i> ${post.comments.length > 0 ? post.comments.length : '评论'}</span>
                            <span class="post-action-btn like-btn ${isLiked ? 'liked' : ''}" data-post-id="${post.id}"><i class="${isLiked ? 'fas' : 'far'} fa-heart"></i> ${post.likes.length > 0 ? post.likes.length : '赞'}</span>
                        </div>
                    </div>`;
            } else {
                // --- 列表页布局 ---
                postItem.innerHTML = `
                    <div class="post-delete-btn" data-post-id="${post.id}" title="删除帖子"><i class="fas fa-trash-alt"></i></div>
                    <div class="post-content-area">
                        <h3>${parseMentions(title)}</h3>
                        
                        ${imageHTML} <div class="post-card-meta-line">
                            <span class="post-author-info">由 <strong>${authorName}</strong> 发布</span>
                            <span class="post-meta">${formatTimeAgo(post.timestamp)}</span>
                        </div>
                        ${redPacketHTML}
                        <div class="post-actions">
                            <span class="post-action-btn repost-btn" data-post-id="${post.id}"><i class="fas fa-retweet"></i> ${post.reposts > 0 ? post.reposts : '转发'}</span>
                            <span class="post-action-btn comment-btn" data-post-id="${post.id}"><i class="far fa-comment"></i> ${post.comments.length > 0 ? post.comments.length : '评论'}</span>
                            <span class="post-action-btn like-btn ${isLiked ? 'liked' : ''}" data-post-id="${post.id}"><i class="${isLiked ? 'fas' : 'far'} fa-heart"></i> ${post.likes.length > 0 ? post.likes.length : '赞'}</span>
                        </div>
                    </div>`;
            }

            return postItem;
        }

// ▼▼▼ 步骤七：用这个【隔离修复版】替换旧的 renderFeed ▼▼▼

async function renderFeed() {
    const postsList = document.getElementById('posts-list');
    const tabsContainer = document.getElementById('feed-tabs-container');
    const subTabsContainer = document.getElementById('feed-sub-tabs-container');
    
    // 1. (不变) 渲染主标签页
    tabsContainer.innerHTML = `
        <button class="feed-tab-btn ${state.activeFeedTab === 'recommended' ? 'active' : ''}" data-tab="recommended"><i class="fas fa-home"></i> 推荐</button>
        <button class="feed-tab-btn ${state.activeFeedTab === 'following' ? 'active' : ''}" data-tab="following"><i class="fas fa-user-friends"></i> 关注</button>
        <button class="feed-tab-btn ${state.activeFeedTab === 'trending' ? 'active' : ''}" data-tab="trending"><i class="fas fa-fire"></i> 热搜</button>
    `;

    // 2. (不变) 渲染子标签页
    if (state.activeFeedTab === 'recommended') {
        subTabsContainer.style.display = 'flex';
        let subTabsHTML = `
            <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'daily' ? 'active' : ''}" data-subtab="daily">日常</button>
            <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'food' ? 'active' : ''}" data-subtab="food">美食</button>
            <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'gossip' ? 'active' : ''}" data-subtab="gossip">八卦</button>
            <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'horror' ? 'active' : ''}" data-subtab="horror">恐怖</button>
        `;
        state.forumCategories.forEach(category => {
            const isActive = state.activeFeedSubTab === category.id;
            subTabsHTML += `<button class="feed-sub-tab-btn ${isActive ? 'active' : ''}" data-subtab="${category.id}">${category.name}</button>`;
        });
        subTabsContainer.innerHTML = subTabsHTML;
    } else {
        subTabsContainer.style.display = 'none';
    }
    
    postsList.innerHTML = ''; 

    // 3. (不变) 渲染“热搜”页
    if (state.activeFeedTab === 'trending') {
        // ... (热搜渲染逻辑太长，此处省略，保持你原有的代码即可，或者往下看完整版) ...
        // 为了方便你复制，这里还是把热搜逻辑放上：
        const trendingListEl = document.createElement('ol');
        trendingListEl.className = 'trending-list';
        if (state.trendingTopics.length === 0) {
             trendingListEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><p>热搜榜空空如也，刷新一下试试？</p></div>`;
        } else {
            state.trendingTopics.forEach((topic, index) => {
                const item = document.createElement('li');
                item.className = 'trending-item';
                item.dataset.topicTitle = topic.title;
                item.dataset.description = topic.description;
                item.innerHTML = `
                    <div class="trending-rank ${index < 3 ? 'top-3' : ''}">${index + 1}</div>
                    <div class="trending-info">
                        <div class="trending-title">${topic.title}</div>
                        <div class="trending-meta"><i class="fas fa-fire" style="color: #ff8a65;"></i> ${topic.heat}万</div>
                    </div>
                    ${topic.tag ? `<div class="trending-tag">${topic.tag}</div>` : ''}
                `;
                trendingListEl.appendChild(item);
            });
        }
        postsList.appendChild(trendingListEl);
        return;
    }

    // 4. ✨ 核心改造：数据隔离 ✨
    let postsToShow = [];
    const contactIds = state.contacts.map(c => c.id);
    
    // 第一步：只获取属于当前“世界线”的帖子
    const activePosts = state.posts.filter(p => p.archiveId === state.activeForumArchiveId);

    // 第二步：【关键】剔除掉所有属于 'qzone' 类别的帖子！
    const forumOnlyPosts = activePosts.filter(p => p.category !== 'qzone');

    if (state.activeFeedTab === 'following') {
        // 关注页：只显示好友和我的帖子 (但必须是经过筛选的 forumOnlyPosts)
        postsToShow = forumOnlyPosts.filter(p => p.author.id === 'myProfile' || contactIds.includes(p.author.id));
    } else { 
        // 推荐页：按子分类筛选
        postsToShow = forumOnlyPosts.filter(p => p.category === state.activeFeedSubTab);
    }
    
    // 5. (不变) 排序和显示
    const sortedPosts = [...postsToShow].sort((a, b) => b.timestamp - a.timestamp);
    const postsToDisplay = (state.activeFeedTab === 'following') ? sortedPosts : sortedPosts.slice(0, state.postsToDisplay);

    if (postsToDisplay.length === 0) {
        const emptyMessage = state.activeFeedTab === 'following' 
            ? '你关注的人还没有在论坛发布动态哦'
            : '这里空空如也，点击右上角刷新看看';
        postsList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-couch" style="font-size: 48px; margin-bottom: 15px;"></i><p>${emptyMessage}</p></div>`;
    } else {
        postsToDisplay.forEach(post => {
            const postItem = createPostItem(post);
            if (postItem) postsList.appendChild(postItem);
        });
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// (替换) renderUserPersonaPresets (修复了签名行样式)
async function renderUserPersonaPresets() {
    const userPersonaPresetsList = document.getElementById('user-persona-presets-list');
    const noUserPersonaMessage = document.getElementById('no-user-persona-message');
    userPersonaPresetsList.innerHTML = '';
    noUserPersonaMessage.style.display = state.userPersonaPresets.length === 0 ? 'block' : 'none';
    state.userPersonaPresets.forEach(preset => {
        const presetItem = document.createElement('div');
        presetItem.className = 'preset-item';
        presetItem.dataset.presetId = preset.id;
        
        presetItem.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${preset.name}</div>
                
                <div class="preset-desc" style="font-size: 13px; color: #666; font-style: italic; border-left: 2px solid #eee; padding-left: 8px; margin-top: 5px; margin-bottom: 8px;
                    /* --- 强制重置掉继承的样式 --- */
                    display: block;
                    white-space: normal;
                    overflow: visible;
                    text-overflow: clip;
                    -webkit-line-clamp: unset;
                ">
                    签名: ${preset.signature || '(未设置)'}
                </div>
                <div class="preset-desc">${preset.description}</div>
            </div>
            <div class="preset-actions">
                <span class="preset-action-btn edit-preset-btn" title="编辑面具"><i class="fas fa-edit"></i></span>
                <span class="preset-action-btn delete delete-preset-btn" title="删除面具"><i class="fas fa-trash-alt"></i></span>
            </div>
        `;
        
        userPersonaPresetsList.appendChild(presetItem);
    });
    await updateUserPersonaPresetSelect();
}
        
async function renderThoughtPresets() {
    const thoughtPresetsList = document.getElementById('thought-presets-list');
    const noThoughtPresetMessage = document.getElementById('no-thought-preset-message');
    thoughtPresetsList.innerHTML = '';
    noThoughtPresetMessage.style.display = state.thoughtPresets.length === 0 ? 'block' : 'none';
    
    state.thoughtPresets.forEach(preset => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.dataset.presetId = preset.id;

        // ▼▼▼ 核心修改开始：根据ID决定显示哪些按钮 ▼▼▼
        let actionButtonsHTML = '';

        if (preset.id === 'deep_roleplay_regex') {
            // 🛑 情况A：如果是那个自带的保密预设
            // 只显示【删除】按钮，绝对不给【编辑】按钮
            actionButtonsHTML = `
                <div class="preset-actions">
                    <span class="preset-action-btn delete delete-thought-preset-btn" title="删除预设">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
        } else {
            // ✅ 情况B：如果是用户自己创建的普通预设
            // 显示【编辑】和【删除】两个按钮
            actionButtonsHTML = `
                <div class="preset-actions">
                    <span class="preset-action-btn edit-thought-preset-btn" title="编辑预设">
                        <i class="fas fa-edit"></i>
                    </span>
                    <span class="preset-action-btn delete delete-thought-preset-btn" title="删除预设">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
        }
        // ▲▲▲ 核心修改结束 ▲▲▲

        // 为了更安全，如果是保密预设，也可以把列表里的预览文字隐藏掉（可选，我这里顺便帮你加上了逻辑）
        const descText = (preset.id === 'deep_roleplay_regex') ? '****** (内容受保护，不可查看) ******' : preset.prompt;

        item.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${preset.name}</div>
                <div class="preset-desc" style="white-space: pre-wrap;">${descText}</div>
            </div>
            ${actionButtonsHTML} 
        `;
        
        thoughtPresetsList.appendChild(item);
    });
}
// --- 核心函数：打开编辑表情弹窗 ---
function openEditEmoticonModal(emoticon) {
    const modal = document.getElementById('edit-emoticon-modal');
    const preview = document.getElementById('edit-emo-preview');
    const nameInput = document.getElementById('edit-emo-name-input');
    const groupSelect = document.getElementById('edit-emo-group-select');
    const saveBtn = document.getElementById('save-edit-emoticon-btn');
    const closeBtn = document.getElementById('close-edit-emoticon-modal');

    // 1. 填充数据
    preview.src = emoticon.url;
    nameInput.value = emoticon.name;

    // 2. 动态填充“分组下拉菜单”
    groupSelect.innerHTML = '';
    state.emoticonGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        if (group.id === emoticon.groupId) {
            option.selected = true;
        }
        groupSelect.appendChild(option);
    });

    // 3. 显示弹窗
    modal.style.display = 'flex';

    // 4. 绑定关闭事件
    const closeModal = () => { modal.style.display = 'none'; };
    closeBtn.onclick = closeModal;

    // 5. 绑定保存事件 (使用克隆节点防止重复绑定)
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

    newSaveBtn.addEventListener('click', async () => {
        const newName = nameInput.value.trim();
        const newGroupId = groupSelect.value;

        if (!newName) return alert('表情名称不能为空');

        // 更新数据
        emoticon.name = newName;
        emoticon.groupId = newGroupId;

        // 保存到数据库
        await kokoMemory.put('emoticons', emoticon);

        // 刷新界面
        await renderEmoticonLibrary();
        
        closeModal();
        
        // 如果用户改了分组，表情会从当前列表消失（因为它去了新分组），给个提示比较友好
        if (newGroupId !== activeEmoticonGroupId) {
            // 这里的 activeEmoticonGroupId 是我们在第二步里定义的全局变量
            alert(`表情已移动到“${state.emoticonGroups.find(g=>g.id===newGroupId).name}”分组`);
        }
    });
}
// --- 表情包批量管理状态 ---
let isEmoEditMode = false;
let selectedEmoIds = new Set();
async function renderEmoticonLibrary() {
    const container = document.querySelector('.emoticon-library-content');
    container.innerHTML = ''; // 清空容器

    // --- 1. 渲染分组标签栏 ---
    const tabsContainer = document.createElement('div');
    tabsContainer.className = 'feed-sub-tabs';
    tabsContainer.style.marginBottom = '15px';
    tabsContainer.style.padding = '0 5px';
    
    let tabsHTML = '';
    state.emoticonGroups.forEach(group => {
        const isActive = group.id === activeEmoticonGroupId ? 'active' : '';
        tabsHTML += `<button class="feed-sub-tab-btn ${isActive} group-tab-btn" data-group-id="${group.id}">${group.name}</button>`;
    });
    // 在编辑模式下隐藏添加分组按钮，防止误操作
    if (!isEmoEditMode) {
        tabsHTML += `<button class="feed-sub-tab-btn" id="create-emo-group-btn" style="color: var(--theme-primary); border-color: var(--theme-primary);"><i class="fas fa-plus"></i></button>`;
    }
    
    tabsContainer.innerHTML = tabsHTML;
    container.appendChild(tabsContainer);

    // --- 2. 渲染当前分组的操作栏 ---
    // 编辑模式下隐藏这个栏
    if (activeEmoticonGroupId !== 'default' && !isEmoEditMode) {
        const actionHeader = document.createElement('div');
        actionHeader.style.cssText = "display: flex; justify-content: space-between; margin-bottom: 10px; padding: 0 5px;";
        actionHeader.innerHTML = `
            <span style="font-size: 12px; color: #888;">当前分组操作:</span>
            <div>
                <span class="preset-action-btn" id="rename-emo-group-btn" style="margin-right: 10px; cursor: pointer;"><i class="fas fa-edit"></i> 重命名</span>
                <span class="preset-action-btn delete" id="delete-emo-group-btn" style="cursor: pointer;"><i class="fas fa-trash-alt"></i> 删除分组</span>
            </div>
        `;
        container.appendChild(actionHeader);
    }

    // --- 3. 渲染表情网格 ---
    const grid = document.createElement('div');
    grid.className = 'emoticon-grid';
    grid.id = 'emoticon-library-grid';

    const filteredEmoticons = state.emoticons.filter(e => e.groupId === activeEmoticonGroupId);

    if (filteredEmoticons.length === 0) {
        const noMsg = document.createElement('div');
        noMsg.style.cssText = "text-align: center; padding: 50px 20px; color: #888; grid-column: 1 / -1;";
        noMsg.innerHTML = `
            <i class="far fa-grin-alt" style="font-size: 48px; margin-bottom: 15px;"></i>
            <p>此分组是空的</p>
            <p>点击右上角 "+" 批量导入表情到当前分组！</p>
        `;
        grid.appendChild(noMsg);
    } else {
        filteredEmoticons.forEach(emo => {
            const item = document.createElement('div');
            // 核心修改：根据模式添加 class
            const isSelected = selectedEmoIds.has(emo.id);
            item.className = `emoticon-item ${isEmoEditMode ? 'is-selecting' : ''} ${isSelected ? 'selected' : ''}`;
            item.style.cursor = 'pointer'; 
            
            // 核心修改：添加 check-mark 元素
            item.innerHTML = `
                <img src="${emo.url}" alt="${emo.name}" onerror="this.src='https://via.placeholder.com/60?text=Error';">
                <div class="emoticon-name">${emo.name}</div>
                <div class="emoticon-check-mark"><i class="fas fa-check"></i></div>
                ${!isEmoEditMode ? `<button class="emoticon-delete-btn" data-emoticon-id="${emo.id}">&times;</button>` : ''}
            `;
            
            // 绑定点击事件
            item.addEventListener('click', (e) => {
                if (e.target.closest('.emoticon-delete-btn')) return;
                
                if (isEmoEditMode) {
                    // --- 批量模式：切换选中状态 ---
                    if (selectedEmoIds.has(emo.id)) {
                        selectedEmoIds.delete(emo.id);
                        item.classList.remove('selected');
                    } else {
                        selectedEmoIds.add(emo.id);
                        item.classList.add('selected');
                    }
                    // 更新底部计数文字
                    document.getElementById('emo-selected-count').textContent = `已选 ${selectedEmoIds.size} 项`;
                } else {
                    // --- 普通模式：打开编辑弹窗 ---
                    openEditEmoticonModal(emo);
                }
            });

            grid.appendChild(item);
        });
    }
    container.appendChild(grid);

    // --- 4. 重新绑定事件 (页签切换等) ---
    tabsContainer.querySelectorAll('.group-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            activeEmoticonGroupId = btn.dataset.groupId;
            renderEmoticonLibrary();
        });
    });

    // ... (保留原来的创建/重命名/删除分组事件绑定代码，这里不再重复，保持原样即可，或者从上面复制一份完整的事件绑定逻辑下来) ...
    // 为了代码简洁，建议把你原来 renderEmoticonLibrary 里的事件绑定部分（B, D, E）复制回来
    
    // [补全] 新建分组点击事件
    const createGroupBtn = container.querySelector('#create-emo-group-btn');
    if(createGroupBtn) {
        createGroupBtn.addEventListener('click', async () => {
            const name = await showCustomPrompt('新建表情分组', '请输入分组名称');
            if (name && name.trim()) {
                const newGroup = { id: 'emo_group_' + Date.now(), name: name.trim() };
                state.emoticonGroups.push(newGroup);
                await kokoMemory.put('emoticonGroups', newGroup);
                activeEmoticonGroupId = newGroup.id; 
                renderEmoticonLibrary();
            }
        });
    }
    // [补全] 重命名/删除分组事件... (请确保这一部分和你原来的代码一致)
    const renameBtn = document.getElementById('rename-emo-group-btn');
    if(renameBtn) {
        renameBtn.addEventListener('click', async () => {
            const group = state.emoticonGroups.find(g => g.id === activeEmoticonGroupId);
            const newName = await showCustomPrompt('重命名分组', group.name);
            if(newName && newName.trim()) {
                group.name = newName.trim();
                await kokoMemory.put('emoticonGroups', group);
                renderEmoticonLibrary();
            }
        });
    }
    const deleteGroupBtn = document.getElementById('delete-emo-group-btn');
    if(deleteGroupBtn) {
        deleteGroupBtn.addEventListener('click', async () => {
            const confirmed = await showCustomConfirm('删除分组', '删除分组不会删除里面的表情，它们会移动到“默认分组”。确定删除吗？', true);
            if(confirmed) {
                state.emoticons.forEach(e => { if(e.groupId === activeEmoticonGroupId) e.groupId = 'default'; });
                await kokoMemory.bulkPut('emoticons', state.emoticons);
                state.emoticonGroups = state.emoticonGroups.filter(g => g.id !== activeEmoticonGroupId);
                await kokoMemory.delete('emoticonGroups', activeEmoticonGroupId);
                activeEmoticonGroupId = 'default';
                renderEmoticonLibrary();
            }
        });
    }
    
    // 单个删除按钮逻辑
    grid.querySelectorAll('.emoticon-delete-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const emoticonId = e.currentTarget.dataset.emoticonId;
            const confirmed = await showCustomConfirm('删除表情', '确定要删除这个表情包吗？', true);
            if (confirmed) {
                state.emoticons = state.emoticons.filter(e => e.id !== emoticonId);
                await kokoMemory.delete('emoticons', emoticonId);
                renderEmoticonLibrary();
            }
        });
    });
}

        async function renderMusicLibrary() {
            const list = document.getElementById('music-library-list');
            const noMusicMsg = document.getElementById('no-music-message');
            list.innerHTML = '';

            if (state.musicLibrary.length === 0) {
                noMusicMsg.style.display = 'block';
            } else {
                noMusicMsg.style.display = 'none';
                state.musicLibrary.forEach(song => {
                    const item = document.createElement('div');
                    item.className = 'music-item';
                    item.innerHTML = `
                        <div class="music-info">
                            <div class="music-title">${song.title}</div>
                            <div class="music-artist">${song.artist}</div>
                        </div>
                        <button class="music-delete-btn" data-music-id="${song.id}"><i class="fas fa-trash-alt"></i></button>
                    `;
                    list.appendChild(item);
                });

                list.querySelectorAll('.music-delete-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const musicId = e.currentTarget.dataset.musicId;
                        const confirmed = await showCustomConfirm('删除歌曲', '确定要从曲库删除这首歌吗？', true);
                        if (confirmed) {
                            state.musicLibrary = state.musicLibrary.filter(s => s.id !== musicId);
                            await kokoMemory.delete('musicLibrary', musicId);
                            await renderMusicLibrary();
                        }
                    });
                });
            }
        }

        function renderMusicPickerInModal() {
            const picker = document.getElementById('music-library-picker');
            picker.innerHTML = '';

            if (state.musicLibrary.length > 0) {
                picker.innerHTML = '<div class="picker-title">从曲库选择</div>';
                const list = document.createElement('div');
                list.className = 'picker-list';
                state.musicLibrary.forEach(song => {
                    const item = document.createElement('div');
                    item.className = 'picker-item';
                    item.textContent = `${song.title} - ${song.artist}`;
                    item.addEventListener('click', () => {
                        document.getElementById('send-music-title-input').value = song.title;
                        document.getElementById('send-music-artist-input').value = song.artist;
                        document.getElementById('send-music-url-input').value = song.url;
                        // ▼▼▼ 在这里添加填充歌词的代码 ▼▼▼
                        document.getElementById('send-music-lrc-input').value = song.lrc || '';
                    });
                    list.appendChild(item);
                });
                picker.appendChild(list);
            } else {
                picker.innerHTML = '<div class="picker-title" style="text-align:center; color:#999;">你的曲库是空的</div>';
            }
        }

function renderEmoticonPicker() {
    const picker = document.getElementById('emoticon-picker');
    picker.innerHTML = '';
    
    // 1. 渲染顶部的分组标签栏 (用户可以随便点)
    const tabsBar = document.createElement('div');
    tabsBar.style.cssText = "display: flex; overflow-x: auto; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #eee; gap: 8px; flex-shrink: 0; min-height: 35px;";
    
    // 渲染所有分组的按钮
    state.emoticonGroups.forEach(group => {
        const btn = document.createElement('button');
        const isActive = group.id === currentUserEmoticonTab;
        btn.className = isActive ? 'feed-sub-tab-btn active' : 'feed-sub-tab-btn';
        btn.style.padding = "4px 10px";
        btn.style.fontSize = "12px";
        btn.textContent = group.name;
        
        btn.onclick = (e) => {
            e.stopPropagation(); // 防止点击按钮时关闭表情面板
            currentUserEmoticonTab = group.id; // 更新当前选中的标签
            renderEmoticonPicker(); // 重新渲染面板
        };
        tabsBar.appendChild(btn);
    });
    picker.appendChild(tabsBar);

    // 2. 筛选出当前用户选中的分组下的表情
    const filteredEmoticons = state.emoticons.filter(e => e.groupId === currentUserEmoticonTab);

    if (filteredEmoticons.length > 0) {
        // 创建网格容器，复用 .emoticon-grid 样式
        const grid = document.createElement('div');
        grid.className = 'emoticon-grid';
        // 移除 padding 以适应聊天窗口的小空间
        grid.style.padding = '0';
        
        filteredEmoticons.forEach(emo => {
            const item = document.createElement('div');
            item.className = 'emoticon-item';
            item.innerHTML = `
                <img src="${emo.url}" alt="${emo.name}" style="height: 50px;"> 
                <div class="emoticon-name">${emo.name}</div>
            `;
            item.addEventListener('click', async () => {
                await createAndAddMessage({ 
                    type: 'image', 
                    url: emo.url,
                    isEmoticon: true,
                    emoticonName: emo.name
                });
                picker.classList.remove('active');
            });
            grid.appendChild(item);
        });
        picker.appendChild(grid);
    } else {
        const emptyMsg = document.createElement('div');
        emptyMsg.style.cssText = "color: #999; text-align: center; padding: 20px; width: 100%;";
        emptyMsg.textContent = '此分组下没有表情包';
        picker.appendChild(emptyMsg);
    }
}

        function renderWalletScreen() {
            const listEl = document.getElementById('transaction-list');
            const noTransactionMsg = document.getElementById('no-transaction-message');
            listEl.innerHTML = '';

            if (!state.transactions || state.transactions.length === 0) {
                noTransactionMsg.style.display = 'block';
                return;
            }
            noTransactionMsg.style.display = 'none';

            const sortedTransactions = [...state.transactions].sort((a, b) => b.timestamp - a.timestamp);

            sortedTransactions.forEach(tx => {
                const item = document.createElement('div');
                item.className = 'transaction-item';
                const amountClass = tx.type === 'income' ? 'income' : 'expense';
                const amountSign = tx.type === 'income' ? '+' : '-';

                item.innerHTML = `
                    <div class="transaction-info">
                        <div class="desc">${tx.description}</div>
                        <div class="time">${new Date(tx.timestamp).toLocaleString()}</div>
                    </div>
                    <div class="transaction-amount ${amountClass}">
                        ${amountSign}${tx.amount.toFixed(2)}
                    </div>
                `;
                listEl.appendChild(item);
            });
        }


        async function updateUserPersonaPresetSelect() {
            const selectUserPersonaPreset = document.getElementById('select-user-persona-preset');
            selectUserPersonaPreset.innerHTML = '<option value="">-- 选择或输入自定义面具 --</option>';
            state.userPersonaPresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectUserPersonaPreset.appendChild(option);
            });
        }

        async function populateThoughtPresetSelect() {
            const select = document.getElementById('thought-preset-select');
            const currentVal = select.value;
            select.innerHTML = '';
            
            const noPresetOption = document.createElement('option');
            noPresetOption.value = ""; 
            noPresetOption.textContent = "-- 无预设 (使用默认角色扮演) --";
            select.appendChild(noPresetOption);

            if (state.thoughtPresets.length === 0) {
                return;
            }
            state.thoughtPresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                select.appendChild(option);
            });

            if (state.thoughtPresets.some(p => p.id === currentVal) || currentVal === "") {
                select.value = currentVal;
            }
        }

        async function updateNotificationDots() {
            const dots = document.querySelectorAll('.moments-notification-dot');
            if (state.hasNewPosts) {
                dots.forEach(dot => dot.style.display = 'block');
            } else {
                dots.forEach(dot => dot.style.display = 'none');
            }
        }
        
        function formatTimeAgo(timestamp) {
            return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function parseMentions(text) {
            if (!text) return '';
            const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
            return text.replace(mentionRegex, (match) => {
                return `<span class="mention">${match}</span>`;
            });
        }

       
// ▼▼▼ 使用这个【修正后】的函数替换旧函数 ▼▼▼
function hideAllScreens() {
    document.querySelectorAll(
        '#screen > div, #wallet-screen, #appearance-settings-screen, #shopping-screen, #product-detail-screen, #forum-archives-screen, #map-screen, #map-management-screen, #schedule-screen, #events-screen, #lock-screen-photos-screen, #relationship-network-screen, #snooped-app-content-screen, #sms-chat-screen, #favorites-screen, #investment-center-screen, #stock-market-screen, #forum-category-management-screen' // <-- ✨ 核心修复：在这里加上你的新页面ID
    ).forEach(el => el.style.display = 'none');
}

// ▼▼▼ 使用这个【全新版本】替换掉旧的 setActiveNav 函数 ▼▼▼
function setActiveNav(activeNavId) {
    // 获取页面上所有的底栏按钮
    document.querySelectorAll('.bottom-nav .nav-item').forEach(item => {
        // 先把所有按钮都灭掉
        item.classList.remove('active');

        // 聪明地判断：只点亮ID第一部分匹配的按钮
        // 比如 activeNavId 是 'chat'，那么 'nav-chat'、'nav-chat-2'、'nav-chat-sms' 都会被点亮
        if (item.id.startsWith('nav-' + activeNavId)) {
            item.classList.add('active');
        }
    });
}
// ▲▲▲ 替换结束 ▲▲▲
        
        async function showMainScreen() { hideAllScreens(); document.getElementById('main-screen').style.display = 'flex'; setActiveNav('chat'); await renderContacts(); }
        function showDiscoverScreen() { hideAllScreens(); document.getElementById('discover-screen').style.display = 'flex'; setActiveNav('discover'); }
        async function showProfileScreen() { hideAllScreens(); document.getElementById('profile-screen').style.display = 'flex'; setActiveNav('profile'); await renderMyProfile(); }
        // ▼▼▼ 把这个新函数，和你其他的 show...Screen 函数放在一起 ▼▼▼
async function showSmsScreen() {
    hideAllScreens();
    const smsScreen = document.getElementById('sms-screen');
    smsScreen.style.display = 'flex';
    setActiveNav('sms');
    // ✨ 新增调用：渲染短信会话列表 ✨
    await renderSmsConversations();
    // ✨ 确保处理页签切换（如果用户在窥探模式下） ✨
    handleSmsTabClick({ target: smsScreen.querySelector('.feed-tab-btn[data-tab="my-sms"]') }); // 默认显示“我的短信”
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲
        
        async function showFeedScreen() { 
            hideAllScreens(); 
            document.getElementById('moments-screen').style.display = 'flex'; 
            if (state.hasNewPosts) {
                state.hasNewPosts = false;
                updateNotificationDots();
            }
            //自动刷新功能注释掉，Produced by Kiko
            //if (isInitialPostLoad && state.posts.length === 0) {
                 //if (state.trendingTopics.length === 0) {
                    //await generateRandomTrendingTopicsAI();
                //}
                //await generatePostsForRecommendedTab(10);
                //isInitialPostLoad = false;
            //}
            await renderFeed();
        }

        async function showPostDetailScreen(postId) {
            state.activePostId = postId;
            hideAllScreens();
            document.getElementById('post-detail-screen').style.display = 'flex';
            await renderPostDetail();
        }
        
        async function showTrendingTopicScreen(topicTitle, topicDescription) {
            hideAllScreens();
            const screen = document.getElementById('trending-topic-screen');
            screen.style.display = 'flex';

            // 填充标题和描述 (这部分不变)
            document.getElementById('trending-topic-title').textContent = `# ${topicTitle.replace(/#/g, '')} #`;

            const descriptionContainer = document.getElementById('trending-topic-description-container');
            if (topicDescription) {
                descriptionContainer.textContent = topicDescription;
                descriptionContainer.style.display = 'block';
            } else {
                descriptionContainer.style.display = 'none';
            }

            const listEl = document.getElementById('trending-topic-posts-list');
            listEl.innerHTML = '';

            // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼

            // 1. 提取不带#号的核心关键词，让搜索更灵活
            const coreTopic = topicTitle.replace(/#/g, "").trim();

            // 2. 关键修复：筛选时，必须同时满足两个条件：
            //    - 帖子必须属于当前激活的“世界线” (archiveId)
            //    - 帖子的内容必须包含这个核心关键词
            const relatedPosts = state.posts.filter(p =>
                p.archiveId === state.activeForumArchiveId && p.content.includes(coreTopic)
            );

            // ▲▲▲▲▲▲▲▲▲▲ 修复结束 ▲▲▲▲▲▲▲▲▲▲


            if (relatedPosts.length === 0) {
                 listEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-comment-slash" style="font-size: 48px; margin-bottom: 15px;"></i><p>该话题下还没有帖子</p></div>`;
                 return;
            }

            relatedPosts.sort((a,b) => b.timestamp - a.timestamp).forEach(post => {
                const postItem = createPostItem(post);
                if (postItem) listEl.appendChild(postItem);
            });
        }

        async function showThoughtPresetManagementScreen() { hideAllScreens(); document.getElementById('thought-preset-management-screen').style.display = 'flex'; await renderThoughtPresets(); }
        async function showEmoticonLibraryScreen() { hideAllScreens(); document.getElementById('emoticon-library-screen').style.display = 'flex'; await renderEmoticonLibrary(); }
        async function showMusicLibraryScreen() { hideAllScreens(); document.getElementById('music-library-screen').style.display = 'flex'; await renderMusicLibrary(); }
        async function showUserPersonaManagementScreen() { hideAllScreens(); document.getElementById('user-persona-management-screen').style.display = 'flex'; await renderUserPersonaPresets(); }

        async function showCharProfileScreen() {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            
            const diaryButton = document.getElementById('view-char-diary-btn');
            if (contact.isGroup) {
                // 如果是群聊，就隐藏日记按钮
                diaryButton.style.display = 'none';
            } else {
                // 如果是个人，就确保日记按钮是显示的
                diaryButton.style.display = 'flex';
            }
            
            batchedPetActions = [];
            
            document.getElementById('char-profile-avatar').src = contact.avatar || `https://via.placeholder.com/70/DDD/666?text=${contact.name.substring(0,1).toUpperCase()}`;
            document.getElementById('char-profile-name').textContent = contact.name;
            document.getElementById('char-name-value').textContent = contact.name;
            document.getElementById('char-signature-value').textContent = contact.signature || '未设置';
            document.getElementById('char-profile-signature-display').textContent = `个性签名: ${contact.signature || '...'}`;


            hideAllScreens();
            document.getElementById('char-profile-screen').style.display = 'flex';

            renderPet(contact);
        }

        // --- MODIFIED: V7.0 修改为“小窝时光胶囊” ---
        async function showMemoryAlbum(contact) {
            hideAllScreens();
            document.getElementById('memory-album-screen').style.display = 'flex';
            renderMemoryAlbum(contact);
        }

        // --- MODIFIED: V7.0 渲染全新的时光胶囊 ---
        function renderMemoryAlbum(contact) {
            const listEl = document.getElementById('memory-album-list');
            listEl.innerHTML = '';
            if (!contact) return;

            // 格式化时长
            function formatDuration(totalSeconds) {
                if (!totalSeconds) return '0 分钟';
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                let result = '';
                if (hours > 0) result += `${hours} 小时 `;
                if (minutes > 0 || hours === 0) result += `${minutes} 分钟`;
                return result.trim();
            }

            const daysSinceFirstChat = Math.floor((Date.now() - contact.firstChatDate) / (1000 * 60 * 60 * 24));

            let albumHTML = `
                <div class="album-section">
                    <div class="album-section-title">我们的里程碑</div>
                    <div class="album-milestone-item">
                        <span class="album-item-icon"><i class="fas fa-calendar-check"></i></span>
                        <span class="album-item-label">初次相遇</span>
                        <span class="album-item-value">${new Date(contact.firstChatDate).toLocaleDateString()}</span>
                    </div>
                    <div class="album-milestone-item">
                        <span class="album-item-icon"><i class="fas fa-heart"></i></span>
                        <span class="album-item-label">已相识</span>
                        <span class="album-item-value">${daysSinceFirstChat} 天</span>
                    </div>
                </div>

                <div class="album-section">
                    <div class="album-section-title">共同的记忆</div>
                     <div class="album-stat-item">
                        <span class="album-item-icon"><i class="fas fa-music"></i></span>
                        <span class="album-item-label">一起听歌</span>
                        <span class="album-item-value">${formatDuration(contact.totalListenTime)}</span>
                    </div>
                </div>

                <div class="album-section">
                    <div class="album-section-title">珍藏的瞬间</div>
                    <div class="album-memory-grid" id="memory-grid-content">
                        </div>
                </div>
            `;
            listEl.innerHTML = albumHTML;

            const gridContent = document.getElementById('memory-grid-content');
            if (!contact.memories || contact.memories.length === 0) {
                 gridContent.innerHTML = `<p style="color:#888; grid-column: 1 / -1;">还没有珍藏的瞬间...</p>`;
            } else {
                 const sortedMemories = [...contact.memories].sort((a, b) => b.timestamp - a.timestamp);
                 sortedMemories.forEach(memo => {
                    const entryEl = document.createElement('div');
                    entryEl.className = 'album-memory-item';
                    entryEl.title = new Date(memo.timestamp).toLocaleString();
                    entryEl.innerHTML = `<i class="fas fa-quote-left"></i> ${memo.description}`;
                    gridContent.appendChild(entryEl);
                });
            }
        }
// ==========================================================
// =========== ▼▼▼ 新增：API格式转换引擎 ▼▼▼ =================
// ==========================================================

/**
 * 将 OpenAI 格式的请求体，转换为 Gemini 格式
 * @param {object} openAiPayload - OpenAI 格式的请求体
 * @returns {object} Gemini 格式的请求体
 */
function convertOpenAiToGemini(openAiPayload) {
    const geminiContents = [];
    let lastRole = "";
    // Gemini 要求 system prompt 必须在最前面，且不能连续出现
    const systemPrompt = openAiPayload.messages.find(msg => msg.role === 'system');
    const chatMessages = openAiPayload.messages.filter(msg => msg.role !== 'system');

    for (const msg of chatMessages) {
        // 角色转换：'assistant' -> 'model', 其他 ('user', 'system') -> 'user'
        let role = (msg.role === 'assistant') ? 'model' : 'user';
        
        // Gemini 严格要求 user 和 model 角色交替出现
        if (role === lastRole && geminiContents.length > 0) {
            // 如果连续出现同角色，将内容合并到上一个条目的 parts 里
            geminiContents[geminiContents.length - 1].parts.push({ text: msg.content });
        } else {
            // 否则，正常添加新角色条目
            geminiContents.push({
                role: role,
                parts: [{ text: msg.content }]
            });
            lastRole = role;
        }
    }

    const geminiPayload = { contents: geminiContents };
    // 如果有 system prompt，将其作为特殊参数添加
    if(systemPrompt) {
        geminiPayload.systemInstruction = {
            role: 'user', // Gemini 的 system prompt 角色也是 user
            parts: [{text: systemPrompt.content}]
        }
    }
    
    return geminiPayload;
}


/**
 * 将 Gemini API 的响应体，转换为 OpenAI 格式
 * @param {object} geminiData - 从 Gemini API 收到的原始响应数据
 * @param {string} modelId - App 请求时使用的模型ID
 * @returns {object} OpenAI 格式的响应体
 */
function convertGeminiToOpenAi(geminiData, modelId) {
    // 检查是否有有效内容返回
    if (!geminiData.candidates || geminiData.candidates.length === 0 || !geminiData.candidates[0].content || !geminiData.candidates[0].content.parts) {
        // 如果 Gemini 因为安全或其他原因阻止了回复，这里会没有 candidates
        const blockReason = geminiData.promptFeedback?.blockReason || '未知原因';
        const safetyRatings = geminiData.promptFeedback?.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ') || '无';
        
        return {
            choices: [{
                message: {
                    role: "assistant",
                    content: `抱歉，Gemini API 阻止了回复。原因: ${blockReason}。安全评级: ${safetyRatings}`
                },
                finish_reason: "stop",
            }]
        };
    }
    
    const responseContent = geminiData.candidates[0].content.parts[0].text;

    const openAIResponse = {
        id: "chatcmpl-" + Date.now(),
        object: "chat.completion",
        created: Math.floor(Date.now() / 1000),
        model: modelId,
        choices: [{
            index: 0,
            message: {
                role: "assistant",
                content: responseContent,
            },
            finish_reason: "stop",
        }],
        usage: { // 伪造 usage 数据，有些客户端需要这个
            prompt_tokens: 0,
            completion_tokens: 0,
            total_tokens: 0,
        }
    };
    
    return openAIResponse;
}

// ==========================================================
// =========== ▲▲▲ 新增代码粘贴到此结束 ▲▲▲ =================
// ==========================================================


// (替换) “编辑面具”函数：修复了 event.target 的BUG
async function editUserPersonaPreset(event) {
    event.stopPropagation();
    
    // ▼▼▼ 核心修复点在这里 ▼▼▼
    // 错误代码：event.currentTarget.closest('.preset-item')
    // 正确代码：event.target.closest('.preset-item')
    const presetId = event.target.closest('.preset-item').dataset.presetId;
    // ▲▲▲ 修复结束 ▲▲▲

    const preset = state.userPersonaPresets.find(p => p.id === presetId);
    if (preset) {
        editingUserPersonaId = presetId;
        currentEditingPersonaAvatar = preset.avatar || null; 
        
        document.getElementById('user-persona-modal-title').textContent = '编辑用户面具预设';
        document.getElementById('user-persona-name-input').value = preset.name;
        document.getElementById('user-persona-signature-input').value = preset.signature || '';
        document.getElementById('user-persona-description-input').value = preset.description;

        const preview = document.getElementById('user-persona-avatar-preview');
        if (preset.avatar) {
            preview.src = preset.avatar;
            preview.style.display = 'block';
        } else {
            preview.src = '';
            preview.style.display = 'none';
        }

        document.getElementById('user-persona-preset-modal').style.display = 'flex';
    }
}

// ▼▼▼ 请用这个【最终修正版】完整替换旧函数 ▼▼▼
async function deleteUserPersonaPreset(event) {
    event.stopPropagation(); // 阻止事件冒泡

    const confirmed = await showCustomConfirm('删除面具', '确定要删除此用户面具预设吗？', true);
    if (!confirmed) {
        return; // 用户点击了“取消”
    }
    
    // --- 核心修正点在这里 ---
    // 我们需要从 event.target (实际被点击的元素) 来查找父级
    const presetItem = event.target.closest('.preset-item');
    if (!presetItem) {
        console.error("删除失败：无法找到 preset-item 元素。");
        return;
    }
    const presetId = presetItem.dataset.presetId;
    // --- 修正结束 ---

    if (!presetId) {
        console.error("删除失败：无法在HTML元素上找到预设ID。");
        return;
    }

    const presetToDelete = state.userPersonaPresets.find(p => p.id === presetId);

    // 1. 从程序的内存（state）中过滤掉这个预设
    state.userPersonaPresets = state.userPersonaPresets.filter(p => p.id !== presetId);

    // 2. 从浏览器的数据库中删除这条记录
    await kokoMemory.delete('userPersonaPresets', presetId);

    // 3. 自动清理所有联系人对这个已删除面具的引用
    if (presetToDelete) {
        for (const contact of state.contacts) {
            if (contact.userPersona === presetToDelete.description) {
                contact.userPersona = ''; // 清空这个设置
                await kokoMemory.put('contacts', contact); // 保存对联系人的修改
            }
        }
    }

    // 4. 重新渲染预设列表，让界面立刻刷新
    await renderUserPersonaPresets();
}
// ▲▲▲ 替换到这里结束 ▲▲▲
        /**
 * 删除一本世界书
 */
async function deleteWorldBook(event) {
    // 这行是防止点击删除时，意外触发了进入编辑页面的效果
    event.stopPropagation(); 

    const bookId = event.currentTarget.closest('.world-book-item').dataset.bookId;
    const book = state.worldBooks.find(b => b.id === bookId);
    if (!book) return;

    // 弹出确认框，防止误删
    const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？\n\n注意：如果任何联系人正在使用这本书，他们的关联也会被解除。`, true);

    if (confirmed) {
        // 1. 从 state 缓存中删除这本书
        state.worldBooks = state.worldBooks.filter(b => b.id !== bookId);

        // 2. 从数据库中删除这本书
        await kokoMemory.delete('worldBooks', bookId);

        // 3. (重要!) 检查并移除所有联系人对这本书的引用
        state.contacts.forEach(contact => {
            if (contact.worldBooks && contact.worldBooks.includes(bookId)) {
                contact.worldBooks = contact.worldBooks.filter(id => id !== bookId);
                // 异步保存对联系人的修改，不阻塞后续UI更新
                kokoMemory.put('contacts', contact); 
            }
        });

        // 4. 重新渲染世界书列表，让界面刷新
        await renderWorldBooks();

        // 5. 更新所有用到世界书的下拉选择器
        await updateWorldBookSelectors();
    }
}

// --- 用这个新版本，替换掉旧的 editThoughtPreset 函数 ---

async function editThoughtPreset(event) {
    event.stopPropagation();
    
    // ▼▼▼ 核心修正点 ▼▼▼
    // 将 event.currentTarget 修改为 event.target，和删除按钮的逻辑保持一致
    const presetId = event.target.closest('.preset-item').dataset.presetId;
    // ▲▲▲ 修正结束 ▲▲▲

    const preset = state.thoughtPresets.find(p => p.id === presetId);
    if (preset) {
        editingThoughtPresetId = presetId;
        document.getElementById('thought-preset-modal-title').textContent = '编辑思维预设';
        document.getElementById('thought-preset-name-input').value = preset.name;
        document.getElementById('thought-preset-prompt-input').value = preset.prompt;
        document.getElementById('thought-preset-modal').style.display = 'flex';
    }
}

// --- 用这个新版本，替换掉旧的 deleteThoughtPreset 函数 ---

async function deleteThoughtPreset(event) {
    event.stopPropagation();
    const confirmed = await showCustomConfirm('删除预设', '确定要删除此思维预设吗？', true);
    if (confirmed) {
        // 核心修正：和修复好的“面具预设”一样，使用 event.target
        const presetItem = event.target.closest('.preset-item');
        if (!presetItem) {
            console.error("删除失败：无法找到 preset-item 元素。");
            return;
        }
        const presetId = presetItem.dataset.presetId;
        
        // 后续的删除逻辑保持不变
        state.thoughtPresets = state.thoughtPresets.filter(p => p.id !== presetId);
        await kokoMemory.delete('thoughtPresets', presetId);
        await renderThoughtPresets(); // 重新渲染列表
    }
}

        function findAuthorById(authorId) {
            if (authorId === 'myProfile') {
                return { id: 'myProfile', ...state.myProfile };
            }
            return state.contacts.find(c => c.id === authorId);
        }
        
        async function toggleLike(event) {
            event.stopPropagation();
            const postId = event.currentTarget.dataset.postId;
            const post = state.posts.find(p => p.id === postId);
            if (post) {
                const myName = state.myProfile.name;
                const likeIndex = post.likes.indexOf(myName);
                if (likeIndex === -1) {
                    post.likes.push(myName);
                } else {
                    post.likes.splice(likeIndex, 1);
                }
                await kokoMemory.put('posts', post);
                
                if (document.getElementById('moments-screen').style.display === 'flex') {
                    await renderFeed(); 
                } else if (document.getElementById('post-detail-screen').style.display === 'flex') {
                    await renderPostDetail();
                }
            }
        }
        
        function editWorldBook(bookId) {
            const book = state.worldBooks.find(b => b.id === bookId);
            if (book) {
                editingBookId = bookId;
                document.getElementById('world-book-modal-title').textContent = '编辑世界书';
                document.getElementById('book-name-input').value = book.name;
                document.getElementById('book-content-input').value = book.content;
                document.getElementById('add-world-book-modal').style.display = 'flex';
            }
        }
        
// ▼▼▼ 使用这个【新版本】替换掉您原来的 fetchModels 函数 ▼▼▼
async function fetchModels(endpointBase, apiKey, modelSelectEl, btn) {
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 拉取中';
    btn.disabled = true;

    if (!endpointBase) {
        alert('请输入API基础地址');
        btn.innerHTML = '<i class="fas fa-sync-alt"></i> 拉取';
        btn.disabled = false;
        return;
    }

    let fetchUrl;
    let fetchOptions = {};

    if (endpointBase.includes('generativelanguage.googleapis.com')) {
        console.log("正在使用 Gemini 方式拉取模型...");
        fetchUrl = `https://${endpointBase}/v1beta/models?key=${apiKey}`;
        fetchOptions = {}; 
    } else {
        console.log("正在使用 OpenAI 兼容方式拉取模型...");
        
        // ★★★ 核心修改在这里 ★★★
        const cleanEndpoint = normalizeApiEndpoint(endpointBase); // 1. 清洁地址
        fetchUrl = `${cleanEndpoint}/v1/models`; // 2. 安全拼接
        
        fetchOptions = { headers: { 'Authorization': `Bearer ${apiKey}` } };
    }

    try {
        const response = await fetch(fetchUrl, fetchOptions);
        if (!response.ok) {
            const errorData = await response.json();
            if (errorData.error && errorData.error.message) {
                 throw new Error(errorData.error.message);
            }
            throw new Error('未知的网络错误');
        };
        const data = await response.json();
        
        let models;
        if (data.models) { 
            models = data.models.map(model => model.name.replace('models/', '')).sort();
        } else if (data.data) {
            models = data.data.map(model => model.id).sort();
        } else {
            models = [];
        }

        updateModelDropdown(models, modelSelectEl, modelSelectEl.value);
        alert(`成功拉取 ${models.length} 个模型！`);
    } catch (error) {
        console.error('拉取模型失败:', error);
        alert(`拉取模型失败: ${error.message}\n\n请检查基础地址和API密钥是否正确。`);
    } finally {
        btn.innerHTML = '<i class="fas fa-sync-alt"></i> 拉取';
        btn.disabled = false;
    }
}
// ==========================================================
// =========== ▼▼▼ 把这个新函数粘贴到您的代码里 ▼▼▼ ==========
// ==========================================================
/**
 * 规范化API端点地址，移除末尾的 / 和 /v1
 * @param {string} endpoint - 用户输入的原始端点地址
 * @returns {string} - 返回一个干净的、不带/v1的基础地址
 */
function normalizeApiEndpoint(endpoint) {
    if (!endpoint) return '';
    let url = endpoint.trim();
    // 循环移除末尾的斜杠，防止用户输入多个 (e.g., "https://api.com//")
    while (url.endsWith('/')) {
        url = url.slice(0, -1);
    }
    // 移除末尾的 /v1
    if (url.endsWith('/v1')) {
        url = url.slice(0, -3);
    }
    return url;
}
// ==========================================================
// =========== ▲▲▲ 新函数粘贴到此结束 ▲▲▲ =================
// ==========================================================
        
        function updateModelDropdown(models, modelSelect, currentModel) {
            modelSelect.innerHTML = ''; 

            if (models && models.length > 0) {
                models.forEach(modelId => {
                    const option = document.createElement('option');
                    option.value = modelId;
                    option.textContent = modelId;
                    if (modelId === currentModel) {
                        option.selected = true;
                    }
                    modelSelect.appendChild(option);
                });
            } else if (currentModel) { 
                const option = document.createElement('option');
                option.value = currentModel;
                option.textContent = currentModel;
                option.selected = true;
                modelSelect.appendChild(option);
            } else {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "未能拉取到模型或列表为空";
                modelSelect.appendChild(option);
            }
        }

        const MESSAGES_PER_PAGE = 30;

        function enterEditMode() {
            editModeState.active = true;
            editModeState.selectedMessageIds.clear();
            document.getElementById('chat-screen').classList.add('chat-screen-edit-mode');
            document.getElementById('chat-input-area').style.display = 'none';
            document.getElementById('edit-mode-bar').style.display = 'flex';
            //renderChatMessages(state.contacts.find(c => c.id === state.activeChatId)); 
        }

async function exitEditMode() {
    editModeState.active = false; // 1. 告诉程序，我们不编辑了
    
    document.getElementById('chat-screen').classList.remove('chat-screen-edit-mode');
    document.getElementById('chat-input-area').style.display = 'flex'; // 2. 把输入框还给你
    document.getElementById('edit-mode-bar').style.display = 'none'; // 3. 隐藏编辑栏

    // 4. ✨【核心修复】✨
    //   我们不再粗暴地刷新整个聊天，而是温柔地
    //   把所有“蓝色高亮”的消息都取消掉，这样就不会乱跳了！
    document.querySelectorAll('.message-wrapper.selected').forEach(el => {
        el.classList.remove('selected');
    });
    
    // 5. 顺便清空选择记录
    editModeState.selectedMessageIds.clear();
}

        function handleMessageSelection(wrapper, message) {
            if (!editModeState.active) return;
            const msgId = wrapper.dataset.messageId;
            if (!msgId) return;

            if (editModeState.selectedMessageIds.has(msgId)) {
                editModeState.selectedMessageIds.delete(msgId);
                wrapper.classList.remove('selected');
            } else {
                editModeState.selectedMessageIds.add(msgId);
                wrapper.classList.add('selected');
            }
        }
        
        function openRepostModal(postId) {
            const post = state.posts.find(p => p.id === postId);
            if (!post) return;
            
            const modal = document.getElementById('repost-contact-picker-modal');
            const contactListEl = document.getElementById('repost-contact-list');
            const messageInput = document.getElementById('repost-message-input');
            messageInput.value = '';
            contactListEl.innerHTML = '';

            state.contacts.forEach(contact => {
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                item.innerHTML = `
                    <input type="checkbox" id="contact-check-${contact.id}" value="${contact.id}">
                    <label for="contact-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                        <img src="${contact.avatar}" alt="${contact.name}">
                        <span>${contact.name}</span>
                    </label>
                `;
                contactListEl.appendChild(item);
            });
            
            modal.style.display = 'flex';

            document.getElementById('close-repost-modal').onclick = () => modal.style.display = 'none';
            
            const confirmBtn = document.getElementById('confirm-repost-btn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', async () => {
                const selectedContactIds = Array.from(contactListEl.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedContactIds.length === 0) {
                    alert('请至少选择一个联系人');
                    return;
                }
                
                const accompanyingMessage = messageInput.value.trim();

                for (const contactId of selectedContactIds) {
                    const tempActiveChatId = state.activeChatId;
                    state.activeChatId = contactId; // 临时切换上下文
                    
                    await createAndAddMessage({ type: 'post_share', content: { postId } });
                    if (accompanyingMessage) {
                        await createAndAddMessage({ type: 'text', content: accompanyingMessage });
                    }
                    
                    state.activeChatId = tempActiveChatId; // 切换回来
                }
                
                modal.style.display = 'none';
                alert(`已成功分享给 ${selectedContactIds.length} 位联系人！`);
                post.reposts = (post.reposts || 0) + 1;
                await kokoMemory.put('posts', post);
                await renderFeed();
            });
        }

       // 【最终完美版】showRedPacketDetails 函数
// 它可以正确处理：私聊红包、群聊红包、论坛红包

// 【私聊逻辑修正版】showRedPacketDetails 函数
// 它能正确处理所有场景，并修正了私聊领取人的判断逻辑

async function showRedPacketDetails(packetData, senderProfile) {
    const modal = document.getElementById('red-packet-details-modal');
    const listEl = document.getElementById('red-packet-claimer-list');
    const summaryEl = document.getElementById('red-packet-details-summary');

    // 1. 设置通用的头部信息
    document.getElementById('details-sender-avatar').src = senderProfile.avatar;
    document.getElementById('details-sender-name').textContent = `${senderProfile.name}的红包`;
    document.getElementById('details-blessing').textContent = packetData.blessing;
    listEl.innerHTML = '';

    // 2. 智能判断红包类型并准备数据
    const isMultiPersonPacket = packetData.hasOwnProperty('count');
    let claimers = packetData.claimers || [];

    // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼
    // 兼容私聊红包，并正确判断领取人
    if (!isMultiPersonPacket && packetData.opened && claimers.length === 0) {
        
        // 判断是谁领取的
        let recipientId;
        if (senderProfile.id === 'myProfile') {
            // 如果发送人是“我”，那么领取人就是当前聊天的char
            recipientId = state.activeChatId;
        } else {
            // 如果发送人是char，那么领取人就是“我”
            recipientId = 'myProfile';
        }
        
        // 手动创建正确的领取者信息
        claimers = [{
            userId: recipientId,
            amount: parseFloat(packetData.amount)
        }];
    }
    // ▲▲▲▲▲▲▲▲▲▲ 核心修复点在这里 ▲▲▲▲▲▲▲▲▲▲

    // 3. 根据红包类型生成不同的汇总信息（这部分逻辑已是正确的）
    let summaryText = '';
    if (claimers.length === 0) {
        summaryText = '红包正在等待领取...';
    } else if (isMultiPersonPacket) {
        const totalAmount = packetData.totalAmount || packetData.amount;
        const totalClaimedAmount = claimers.reduce((sum, c) => sum + c.amount, 0);
        const claimedCount = claimers.length;
        const totalCount = packetData.count;
        if (claimedCount >= totalCount) {
            summaryText = `全部 ${totalCount} 个红包已被领完，共 ${totalAmount.toFixed(2)} 元。`;
        } else {
            summaryText = `已领取 ${claimedCount}/${totalCount} 个，共 ${totalClaimedAmount.toFixed(2)}/${totalAmount.toFixed(2)} 元。`;
        }
    } else {
        summaryText = `1个红包，共 ${parseFloat(packetData.amount).toFixed(2)} 元。`;
    }
    summaryEl.textContent = summaryText;

    // 4. 创建一个包含所有可能出现的“路人甲”的查找表（这部分逻辑已是正确的）
    const authorProfiles = new Map();
    authorProfiles.set('myProfile', state.myProfile);
    state.contacts.forEach(c => authorProfiles.set(c.id, c));
    state.posts.forEach(p => {
        if(p.author) authorProfiles.set(p.author.id, p.author);
        p.comments.forEach(c => {
            if(c.author) authorProfiles.set(c.author.id, c.author);
        });
    });

    // 5. 找出“手气最佳”（这部分逻辑已是正确的）
    let bestLuckClaimerId = null;
    if (isMultiPersonPacket && claimers.length > 1) {
        const bestLuckClaimer = claimers.reduce((max, current) => (current.amount > max.amount) ? current : max, claimers[0]);
        bestLuckClaimerId = bestLuckClaimer.userId;
    }

    // 6. 渲染领取者列表（这部分逻辑已是正确的）
    for (const claimer of claimers) {
        const claimerProfile = authorProfiles.get(claimer.userId) || { name: '一位路人', avatar: 'https://via.placeholder.com/40/DDD/666?text=?' };
        const item = document.createElement('div');
        item.className = 'claimer-item';
        let bestLuckHTML = '';
        if (claimer.userId === bestLuckClaimerId) {
            bestLuckHTML = '<span class="best-luck-badge">手气最佳</span>';
        }
        item.innerHTML = `
            <img src="${claimerProfile.avatar}" class="claimer-avatar">
            <div class="claimer-info">
                <div class="claimer-name">${claimerProfile.name}</div>
                <div class="claim-time">${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            </div>
            <div class="claim-amount">${claimer.amount.toFixed(2)} 元 ${bestLuckHTML}</div>
        `;
        listEl.appendChild(item);
    }

    modal.style.display = 'flex';
}
        
// 请用下面这个【完整】的函数，替换掉您代码里现有的 showRedPacketModal 函数

async function showRedPacketModal(message, senderProfile) {
    const packetData = message.content;
    const modal = document.getElementById('red-packet-modal');
    const chatContext = state.contacts.find(c => c.id === state.activeChatId);
    if (!chatContext || !senderProfile) return; // 增加安全检查

    // 1. 设置弹窗内容
    document.getElementById('red-packet-sender-avatar').src = senderProfile.avatar;
    document.getElementById('red-packet-sender-name').textContent = `${senderProfile.name}的红包`;
    document.getElementById('red-packet-blessing-text').textContent = packetData.blessing;

    // 2. 重置弹窗UI状态
    const openBtn = document.getElementById('open-red-packet-btn');
    openBtn.style.display = 'flex';
    openBtn.style.transform = 'rotate(0deg)';
    document.getElementById('red-packet-result').style.display = 'none';
    document.getElementById('red-packet-content').style.backgroundColor = '#DB5A48';

    // 3. 安全地绑定事件
    const newOpenBtn = openBtn.cloneNode(true);
    openBtn.parentNode.replaceChild(newOpenBtn, openBtn);

    const closeBtn = document.getElementById('close-red-packet-modal');
    const newCloseBtn = closeBtn.cloneNode(true);
    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

    const detailsLink = document.getElementById('view-red-packet-details');
    const newDetailsLink = detailsLink.cloneNode(true);
    detailsLink.parentNode.replaceChild(newDetailsLink, detailsLink);

    newCloseBtn.addEventListener('click', () => modal.style.display = 'none');

    // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼
    // 我们确保详情链接正确地调用了 showRedPacketDetails 函数，而不是 alert
    newDetailsLink.addEventListener('click', (e) => {
        e.preventDefault();
        showRedPacketDetails(packetData, senderProfile); 
    });
    // ▲▲▲▲▲▲▲▲▲▲ 核心修复点在这里 ▲▲▲▲▲▲▲▲▲▲

    // 4. 根据红包类型和状态决定显示内容（这部分逻辑我们之前已经完善了）
    const isGroupPacket = packetData.hasOwnProperty('count');
    
    if (isGroupPacket) {
        // --- 群聊红包逻辑 ---
        const myId = 'myProfile';
        const hasClaimed = packetData.claimers.some(c => c.userId === myId);
        const isDepleted = packetData.claimers.length >= packetData.count;

        if (hasClaimed) {
            const myClaim = packetData.claimers.find(c => c.userId === myId);
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `¥${myClaim.amount.toFixed(2)}`;
            document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
        } else if (isDepleted) {
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `手慢了`;
            document.getElementById('red-packet-collected-by').textContent = '红包派完了';
        } else {
            newOpenBtn.addEventListener('click', async () => {
                const remainingCount = packetData.count - packetData.claimers.length;
                const remainingAmount = packetData.totalAmount - packetData.claimers.reduce((sum, c) => sum + c.amount, 0);
                let amount = 0;
                if (remainingCount > 1) {
                    const avg = remainingAmount / remainingCount;
                    amount = Math.random() * avg * 1.8;
                    amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                } else { amount = remainingAmount; }
                amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                state.myProfile.balance += amount;
                await addTransaction('income', amount, `抢到 ${senderProfile.name} 的群红包`, chatContext.id);
                packetData.claimers.push({ userId: 'myProfile', amount: amount });
                
                await kokoMemory.put('myProfile', state.myProfile);
                await kokoMemory.put('contacts', chatContext);

                newOpenBtn.style.transform = 'rotate(720deg)';
                await sleep(500);
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                
                await sleep(1500);
                modal.style.display = 'none';
                await renderMyProfile();
                await openChat(chatContext.id);
            });
        }
    } else {
        // --- 私聊红包逻辑 ---
        if (packetData.opened) {
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `¥${packetData.amount}`;
            document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
        } else {
            newOpenBtn.addEventListener('click', async () => {
                const amount = parseFloat(packetData.amount);
                state.myProfile.balance += amount;
                await addTransaction('income', amount, `收到 ${senderProfile.name} 的红包`, senderProfile.id);
                packetData.opened = true;
                await kokoMemory.put('myProfile', state.myProfile);
                await kokoMemory.put('contacts', chatContext);
                
                newOpenBtn.style.transform = 'rotate(720deg)';
                await sleep(500);
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                
                await openChat(chatContext.id);
                //await requestAiReply(`[SYSTEM: 我刚刚打开了你发的红包，金额是${amount.toFixed(2)}元。]`);
                
                await sleep(1500);
                modal.style.display = 'none';
            });
        }
    }
    
    modal.style.display = 'flex';
}
        async function openForumRedPacketModal(postId) {
            const post = state.posts.find(p => p.id === postId);
            if (!post || !post.redPacket) return;

            const modal = document.getElementById('red-packet-modal');
            
            // 1. 设置弹窗内容
            document.getElementById('red-packet-sender-avatar').src = post.author.avatar;
            document.getElementById('red-packet-sender-name').textContent = `${post.author.name}的红包`;
            document.getElementById('red-packet-blessing-text').textContent = post.redPacket.blessing;

            // 2. 重置弹窗UI状态
            document.getElementById('open-red-packet-btn').style.display = 'flex';
            document.getElementById('open-red-packet-btn').style.transform = 'rotate(0deg)';
            document.getElementById('red-packet-result').style.display = 'none';
            document.getElementById('red-packet-content').style.backgroundColor = '#DB5A48';

            // 3. 【关键修复】使用克隆节点的方法安全地绑定事件，防止卡死
            const oldOpenBtn = document.getElementById('open-red-packet-btn');
            const newOpenBtn = oldOpenBtn.cloneNode(true);
            oldOpenBtn.parentNode.replaceChild(newOpenBtn, oldOpenBtn);

            const oldCloseBtn = document.getElementById('close-red-packet-modal');
            const newCloseBtn = oldCloseBtn.cloneNode(true);
            oldCloseBtn.parentNode.replaceChild(newCloseBtn, oldCloseBtn);

            const oldDetailsLink = document.getElementById('view-red-packet-details');
            const newDetailsLink = oldDetailsLink.cloneNode(true);
            oldDetailsLink.parentNode.replaceChild(newDetailsLink, oldDetailsLink);

            // 4. 为新克隆的按钮添加事件监听
            newCloseBtn.addEventListener('click', () => modal.style.display = 'none');
            newDetailsLink.addEventListener('click', (e) => {
                e.preventDefault();
                showRedPacketDetails(post.redPacket, post.author);
            });

            // 5. 根据红包状态决定显示内容
            const myId = 'myProfile';
            // ▼▼▼ 修正点 ▼▼▼
            const hasClaimed = post.redPacket.claimers && post.redPacket.claimers.some(c => c.userId === myId);
            const isDepleted = post.redPacket.claimers && post.redPacket.claimers.length >= post.redPacket.count;
            // ▲▲▲ 修正点 ▲▲▲

            if (hasClaimed) {
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                const myClaim = post.redPacket.claimers.find(c => c.userId === myId);
                document.getElementById('red-packet-amount-text').textContent = `¥${myClaim.amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
            } else if (isDepleted) {
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `手慢了`;
                document.getElementById('red-packet-collected-by').textContent = '红包派完了';
            } else {
                newOpenBtn.addEventListener('click', async () => {
                    // 随机分配红包金额
                    const remainingCount = post.redPacket.count - (post.redPacket.claimers ? post.redPacket.claimers.length : 0);
                    const remainingAmount = post.redPacket.amount - (post.redPacket.claimers ? post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0) : 0);
                    let amount = 0;
                    if (remainingCount > 1) {
                        const avg = remainingAmount / remainingCount;
                        amount = Math.random() * avg * 2;
                        amount = Math.min(remainingAmount * 0.9, amount);
                    } else {
                        amount = remainingAmount;
                    }
                    amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                    // 更新余额和交易记录
                    state.myProfile.balance += amount;
                    await addTransaction('income', amount, `抢到 ${post.author.name} 的论坛红包`, null);
                    
                    // 更新红包状态
                    if (!post.redPacket.claimers) post.redPacket.claimers = [];
                    post.redPacket.claimers.push({ userId: myId, amount: amount });
                    
                    // 保存数据
                    await kokoMemory.put('myProfile', state.myProfile);
                    await kokoMemory.put('posts', post);

                    // 播放动画并更新UI
                    newOpenBtn.style.transform = 'rotate(720deg)';
                    await sleep(500);
                    newOpenBtn.style.display = 'none';
                    document.getElementById('red-packet-result').style.display = 'block';
                    document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                    document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                    document.getElementById('red-packet-content').style.backgroundColor = '#E4A095';

                    await sleep(1500);
                    modal.style.display = 'none';
                    await renderMyProfile();
                });
            }
            
            modal.style.display = 'flex';
        }

        async function openChat(contactId) {
            if (editModeState.active) await exitEditMode();
            const contact = state.contacts.find(c => c.id === contactId);
            if (!contact) return;
// ✨ 核心V2：动态注入联系人专属CSS (保证最高优先级)

// 1. 先移除旧的（如果存在），防止上次的样式残留
let oldTag = document.getElementById('contact-specific-bubble-style');
if (oldTag) {
    oldTag.remove();
}

// 2. 只有在有内容时，才创建并注入新的 <style> 标签
if (contact.customBubbleCss) {
    const styleTag = document.createElement('style');
    styleTag.id = 'contact-specific-bubble-style';
    styleTag.textContent = contact.customBubbleCss;

    // 3. 关键：appendChild 会把它放在 <head> 的末尾，确保它覆盖所有其他主题
    document.head.appendChild(styleTag);
}
            state.activeChatId = contactId;
            // 在 openChat 函数中...

// --- 核心修复：应用聊天背景 (防闪烁版) ---
const chatScreen = document.getElementById('chat-screen');
const savedSettings = await kokoMemory.get('userSettings', 'main');
let finalBackgroundUrl = null; // 默认没有任何自定义背景

// 决定最终使用哪个背景URL
if (contact.customChatBackground) {
    // 优先级1：使用联系人的专属背景
    finalBackgroundUrl = contact.customChatBackground;
} else if (savedSettings && savedSettings.chatBackground) {
    // 优先级2：如果联系人没有专属背景，则使用全局设置的背景
    finalBackgroundUrl = savedSettings.chatBackground;
}

// 关键修复：只有在 finalBackgroundUrl 确实有值（即找到了自定义背景）时才设置它
if (finalBackgroundUrl) {
    chatScreen.style.backgroundImage = `url(${finalBackgroundUrl})`;
} else {
    // 否则，清除行内样式，让 CSS 文件里的默认背景图能够显示出来
    chatScreen.style.backgroundImage = '';
}
// --- 修复结束 ---
            updateChatInputLockState(contact.blockedStatus);
            const messagesContainer = document.getElementById('chat-messages'); if (contact.isNarrativeMode) { messagesContainer.classList.add('narrative-mode-active'); } else { messagesContainer.classList.remove('narrative-mode-active'); }
            
            chatPagination[contactId] = 1;

            document.getElementById('chat-messages').innerHTML = '';

            hideAllScreens();
            document.getElementById('chat-screen').style.display = 'flex';
      // 1. 设置名字 (保持纯净，不加火花)
    document.getElementById('chat-contact-name').textContent = contact.name;

// 2. 【核心修改】处理左上角的火花
    const backBtn = document.getElementById('back-from-chat');
    
    // ▼▼▼ 【核心修复】不管有没有火花，先无条件清除所有旧图标！ ▼▼▼
    backBtn.querySelectorAll('.spark-icon-header').forEach(el => el.remove());
    backBtn.querySelectorAll('.lucky-char-badge').forEach(el => el.remove());
    // ▲▲▲ 修复结束 ▲▲▲

    // ▼▼▼ ✨【新增开关判断】只有开关开启时，才渲染火花和字符 ✨ ▼▼▼
    if (userSettings.showSparkAndLuckyChar !== false) { 

        // 2b. 如果有连续互动，插入新火花 + 幸运字符
        if (!contact.isGroup && contact.sparkData && contact.sparkData.streak > 0) {
            const spark = getSparkInfo(contact.sparkData.streak);
            if (spark) {
                // --- 1. 渲染火花 ---
                const sparkSpan = document.createElement('span');
                sparkSpan.className = `spark-icon-header ${spark.className}`;
                sparkSpan.textContent = spark.icon;
                sparkSpan.title = `🔥 连续互动 ${spark.label}`;
                
                sparkSpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    alert(`🔥 你们已经连续互动 ${contact.sparkData.streak} 天啦！`);
                });
                backBtn.appendChild(sparkSpan);

                // --- 2. 渲染幸运字符 ---
                const luckySpan = document.createElement('span');
                
                if (contact.luckyChar) {
                    const data = contact.luckyChar;
                    const type = data.type || 'common';
                    
                    // 样式
                    luckySpan.className = `lucky-char-badge lucky-char-${type}`;
                    if (data.isCompleted) {
                        luckySpan.classList.add('completed');
                    }
                    
                    // 构建字母 HTML
                    let htmlContent = "";
                    const fullWord = data.word;
                    
                    for (let i = 0; i < fullWord.length; i++) {
                        const letter = fullWord[i];
                        if (i < data.unlockedCount) {
                            htmlContent += `<span class="char-letter unlocked">${letter}</span>`;
                        } else {
                            htmlContent += `<span class="char-letter locked">${letter}</span>`;
                        }
                    }
                    luckySpan.innerHTML = htmlContent;
                    
                    // Tooltip
                    if (data.isCompleted) {
                        luckySpan.title = `✨ 已集齐：${data.word} (点击进入仓库)`;
                    } else {
                        const need = Math.max(0, 20 - data.dailyMessageCount);
                        const status = data.lastUnlockDate === new Date().toLocaleDateString() 
                            ? "今天任务已完成" 
                            : `还需聊 ${need} 句点亮下一个`;
                        luckySpan.title = `收集进度: ${data.unlockedCount}/${fullWord.length}\n${status}`;
                    }

                } else {
                    // 未解锁状态 (+)
                    luckySpan.className = `lucky-char-badge`;
                    luckySpan.style.background = '#e0e0e0';
                    luckySpan.style.color = '#999';
                    luckySpan.style.border = '1px dashed #ccc';
                    luckySpan.style.boxShadow = 'none';
                    luckySpan.textContent = '+'; 
                    luckySpan.title = "点击抽取幸运字符";
                }
                
                // 点击事件
                luckySpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openLuckyCharModal(contact);
                });
                
                backBtn.appendChild(luckySpan);
            }
        }

    } // ▲▲▲ 判断结束 ▲▲▲

            // --- 💡 核心修复在这里 💡 ---
            const chatStatusEl = document.getElementById('chat-contact-status');
            
            // 1. 先判断是不是正在输入
            if (state.aiTypingStatus[contactId]) {
                // 如果“记录本”说TA正在输入，就显示“正在输入”
                chatStatusEl.textContent = contact.isGroup ? '群成员正在热烈讨论中...' : '对方正在输入...';
            } else {
                // 2. 如果没在输入，就显示TA保存的状态
                // ▼▼▼ 关键修改：优先读取 contact.status，没有才显示 '在线' ▼▼▼
                chatStatusEl.textContent = contact.status || '在线';
                // ▲▲▲ 修改结束 ▲▲▲
            }
            // --- 修复结束 ---
            
            const chatPetContainer = document.getElementById('chat-pet-container');
            if (contact.pet && contact.isChatPetVisible) {
                chatPetContainer.style.display = 'block';
                updateChatPetVisuals(contact);
            } else {
                chatPetContainer.style.display = 'none';
            }

            renderChatMessages(contact);
            if (contact.unreadCount) {
                contact.unreadCount = 0;
                await kokoMemory.put('contacts', contact);
            }
        }

// ▼▼▼ 用下面这个【完整修复版】替换旧的 renderChatMessages 函数 ▼▼▼

        function renderChatMessages(contact, loadAll = false) {
            const messagesContainer = document.getElementById('chat-messages');
            const isInitialRender = messagesContainer.innerHTML === '';
            
            if (isInitialRender) {
                messagesContainer.innerHTML = '';
            }

            const page = chatPagination[contact.id] || 1;
            const start = loadAll ? 0 : Math.max(0, contact.history.length - (page * MESSAGES_PER_PAGE));
            const end = loadAll ? contact.history.length : Math.max(0, contact.history.length - ((page - 1) * MESSAGES_PER_PAGE));
            
            const allMessagesInPage = contact.history.slice(start, end);

            // 智能过滤：检查当前是否处于编辑模式
            let messagesToRender;
            if (editModeState.active) {
                // 如果是编辑模式，就显示全部消息，不做任何过滤
                messagesToRender = allMessagesInPage;
            } else {
                // 如果是普通聊天模式，就和之前一样，把通话记录隐藏起来
                messagesToRender = allMessagesInPage.filter(msg => msg.type !== 'video_call_text');
            }

            const existingLoadMoreBtn = document.getElementById('load-more-messages');
            if (existingLoadMoreBtn) {
                existingLoadMoreBtn.remove();
            }
            
            let currentScrollHeight = messagesContainer.scrollHeight;

if (!contact || !contact.history || contact.history.length === 0) {
    messagesContainer.innerHTML = `<div id="chat-placeholder" style="text-align: center; color: #999; padding: 20px;">和 ${contact ? contact.name : ''} 开始聊天吧！</div>`;
    return;
}
            
// ▼▼▼ 从这里开始替换 ▼▼▼

            let fragment = document.createDocumentFragment();
messagesToRender.forEach((msg, index) => {
                let isFirstInSequence = true;
                
                // 智能判断逻辑：只有非系统消息才需要判断头像
                if (msg.type !== 'system_notification' && msg.sender !== 'system_instruction') {
                    
                    if (index > 0) { // 检查这是否不是第一条消息
                        // 1. 只看它“紧挨着”的前一条消息
                        const immediatelyPrecedingMsg = messagesToRender[index - 1];

                        // 2. 检查前一条消息是不是“会打断连续”的类型
                        const isSequenceBreaker = 
                            immediatelyPrecedingMsg.type === 'system_notification' ||
                            immediatelyPrecedingMsg.sender === 'system_instruction' ||
                            immediatelyPrecedingMsg.type === 'heart_voice' ||
                            immediatelyPrecedingMsg.type === 'recall_ai' ||
                            immediatelyPrecedingMsg.isRecalled === true; // <-- 你的撤回也算

                        // 3. 只有当“前一条”不是打断者时，才去判断发送者是否相同
                        if (!isSequenceBreaker) {
                            if (immediatelyPrecedingMsg.sender === msg.sender) {
                                isFirstInSequence = false; // 发送者相同，隐藏头像
                            }
                        }
                        // 4. 如果前一条是打断者，isFirstInSequence 保持为 true，显示头像
                    }
                    // 5. 如果这是第一条消息 (index === 0)，isFirstInSequence 保持为 true，显示头像
                }
                
                // 如果AI强制要求显示头像，则覆盖上面的判断
                if (msg.forceAvatar) {
                    isFirstInSequence = true;
                }

                const messageEl = createMessageElement(msg, contact, isFirstInSequence);
                if(messageEl) {
                     if (editModeState.active && editModeState.selectedMessageIds.has(msg.id)) {
                        messageEl.classList.add('selected');
                    }
                    fragment.appendChild(messageEl);
                }
            });
// ▲▲▲ 替换到这里结束 ▲▲▲
            
            if (isInitialRender) {
                messagesContainer.appendChild(fragment);
            } else {
                messagesContainer.insertBefore(fragment, messagesContainer.firstChild);
            }

            if (!loadAll && start > 0) {
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'load-more-messages';
                loadMoreBtn.textContent = '加载更早的记录...';
                loadMoreBtn.style.display = 'block';
                loadMoreBtn.onclick = () => {
                    chatPagination[contact.id]++;
                    renderChatMessages(contact);
                };
                messagesContainer.prepend(loadMoreBtn);
            }
            
            if (isInitialRender || editModeState.active) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            } else {
                 messagesContainer.scrollTop = messagesContainer.scrollHeight - currentScrollHeight;
            }
        }
/**
 * (安全版) 叙事模式格式化工具
 * 只处理可见文本节点，绝不破坏 HTML 标签、属性或 CSS 样式
 */
function formatNarrativeHtmlSafe(rawHtml) {
    // 1. 创建一个临时的 DOM 容器来解析 HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = rawHtml;

    // 2. 使用 TreeWalker 遍历所有“文本节点”
    const walker = document.createTreeWalker(
        tempDiv,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );

    const textNodes = [];
    while (walker.nextNode()) {
        textNodes.push(walker.currentNode);
    }

    // 3. 逐个处理文本节点
    textNodes.forEach(node => {
        // 🚨 核心保护：如果文本在 <style> 或 <script> 标签内，绝对不动它！
        if (node.parentNode && (node.parentNode.tagName === 'STYLE' || node.parentNode.tagName === 'SCRIPT')) {
            return;
        }

        let text = node.nodeValue;
        
        // 只有包含我们关心的符号时才处理
        if (/[\*\{\}“"”]/.test(text)) {
            let newHtml = text
                // 心理活动 { ... }
                .replace(/\{(.*?)\}/g, '<span class="narrative-psychology">$1</span>')
                // 动作描写 * ... *
                .replace(/\*(.*?)\*/g, '<span class="narrative-action">$1</span>')
                // 对话 “ ... ” (只匹配中文引号，防止破坏 HTML 属性的英文引号)
                .replace(/(?:“|”)(.*?)(?:“|”)/g, '<span class="narrative-speech">“$1”</span>');

            // 如果内容发生了变化，就用 span 包裹的新 HTML 替换掉原来的纯文本节点
            if (newHtml !== text) {
                const span = document.createElement('span');
                span.innerHTML = newHtml;
                node.parentNode.replaceChild(span, node);
            }
        }
    });

    return tempDiv.innerHTML;
}
        // --- C. 请用这个【完整版】函数替换您现有的 createMessageElement 函数 ---
        function createMessageElement(message, contact, isFirstInSequence) {
            // ... (函数声明)

// ▼▼▼ 替换为这段新代码 ▼▼▼
if (message.isRecalled === true) {
    // 关键修改：我们不再创建气泡，而是创建系统通知
    const wrapper = document.createElement('div');
    // 1. 样式改成“system-wrapper”，让它居中
    wrapper.className = 'message-wrapper system-wrapper'; 
    wrapper.dataset.messageId = message.id;

    // 2. 插入和系统通知一样的HTML，但内容是“你撤回了”
    wrapper.innerHTML = `
        <div class="system-notification" style="background-color: #e0e0e0; color: #888;">
            你撤回了一条消息
        </div>
    `;

    // 3. 仍然绑定多选点击（以防万一你想删除它）
    wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
    return wrapper; // 渲染完毕，直接返回
}
// ▲▲▲ 替换结束 ▲▲▲

// ... (你原来的 if (message.type === 'heart_voice') ... 等代码)
            if (message.type === 'heart_voice') return null;
            if (message.type === 'heart_voice') return null;
            if (message.sender === 'system_instruction') return null;

            if (message.type === 'system_notification') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-wrapper';
                wrapper.dataset.messageId = message.id;
                const notificationEl = document.createElement('div');
                notificationEl.className = 'system-notification';
                notificationEl.textContent = message.content;
                wrapper.appendChild(notificationEl);
                wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
                return wrapper;
            }

            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${message.sender === 'user' ? 'sent' : 'received'}`;
            // ✨ 这是修改后的正确代码 ✨
if (contact.isAvatarHidden && (message.sender === 'contact' || message.sender === contact.id)) {
    wrapper.classList.add('contact-avatar-hidden');

            }
             // ▼▼▼ 把下面这段新代码粘贴到这里 ▼▼▼
            // ▼▼▼ 核心修复：只在【非】叙事模式下，才隐藏 HTML 消息的头像 ▼▼▼
            // 如果是叙事模式 (contact.isNarrativeMode)，即使有 HTML，也当作普通气泡处理，保留头像
            if (message.type === 'html' && message.sender !== 'user' && !contact.isNarrativeMode) {
                wrapper.classList.add('ai-html-message');
                // 我们也借用这个已有的类来移除消息体的左边距
                wrapper.classList.add('contact-avatar-hidden'); 
            }
            // ▲▲▲ 修复结束 ▲▲▲
            // ▲▲▲ 新代码粘贴结束 ▲▲▲
            wrapper.dataset.messageId = message.id; 
            if (isFirstInSequence) {
                wrapper.classList.add('is-first-in-sequence');
                wrapper.style.marginTop = '10px';
            }

            const senderInfo = message.sender === 'user' ? state.myProfile : contact;
            
            // ▼▼▼ 在它下面，添加这段新的逻辑 ▼▼▼
    let finalSenderInfo = senderInfo;
    const isGroupChat = contact.isGroup === true;
    // ▼▼▼ ✨ 你的核心修改点在这里 ✨ ▼▼▼
            if (message.sender === 'user') {
                // 检查当前聊天（私聊或群聊）是否设置了自定义昵称
                if (contact.customUserName) {
                    // 如果设置了，就创建一个临时的 profile 对象，把名字改掉
                    // 注意：我们必须克隆(clone)它，否则会污染 state.myProfile
                    finalSenderInfo = { ...state.myProfile, name: contact.customUserName };
                } else {
                    // 否则，就用全局的 myProfile
                    finalSenderInfo = state.myProfile;
                }
            } 
            // ▲▲▲ ✨ 修改结束 ✨ ▲▲▲

    else if (isGroupChat && message.sender !== 'user') {
        // --- ✨ 修正开始 ✨ ---
        // 1. 先在主联系人列表里找
        let foundProfile = state.contacts.find(c => c.id === message.sender);
        
        if (!foundProfile && contact.npcMembers) {
            // 2. 没找到？去当前群聊的 NPC 列表里找
            foundProfile = contact.npcMembers.find(npc => npc.id === message.sender);
        }

        // 3. 
        if (foundProfile) {
            finalSenderInfo = foundProfile;
        } else {
            finalSenderInfo = { name: '未知成员', avatar: '' }; // 真的找不到了
        }
        // --- ✨ 修正结束 ✨ ---
    }
    const showAuthorName = isFirstInSequence;
    // ▲▲▲ 添加结束 ▲▲▲
    // --- 核心修改：决定最终要显示的头像URL ---
            let finalAvatarUrl = finalSenderInfo.avatar;
            if (message.sender === 'user' && contact.customUserAvatar) {
                // 如果是用户发的消息，并且当前联系人设置了自定义用户头像，就用它！
                finalAvatarUrl = contact.customUserAvatar;
            }
            // --- 修改结束 ---
            // --- 新增：构建引用消息框的HTML ---
            // --- 新增：构建引用消息框的HTML ---
            let quoteHTML = '';
            if (message.quote) {
                // ▼▼▼ 核心修复：去掉了所有的换行符和缩进空格，变成紧凑的一行 ▼▼▼
                quoteHTML = `<div class="message-quote" data-quoted-id="${message.quote.messageId}"><div class="sender">${message.quote.senderName}</div><div class="content">${message.quote.content}</div></div>`;
                // ▲▲▲ 修复结束 ▲▲▲
            }

            let messageContentHTML = '';

            switch (message.type) {
              // 在 createMessageElement 函数的 switch 语句中
case 'location_share': {
    const loc = message.content;
    messageContentHTML = `
        <div class="message location-share-card">
            <div class="location-card-icon"><i class="${loc.icon || 'fas fa-map-marker-alt'}"></i></div>
            <div class="location-card-info">
                <div class="name">${loc.name}</div>
                <div class="footer">位置信息 · 点击查看</div>
            </div>
        </div>`;
    break;
}
// ... 在 createMessageElement 函数的 switch 语句中 ...
// --- 🎁 最终版礼物：使用新弹窗 ---
case 'gift': {
    const gift = message.content;
    // 【关键】使用 encodeURIComponent 把心里话加密，安全地传给 onclick
    const encodedMsg = encodeURIComponent(gift.message || "愿你每天开心！");
    
    messageContentHTML = `
        <div class="message gift-card">
            <div class="gift-icon-main"><i class="fas fa-gift"></i></div>
            <div class="gift-title">${gift.title}</div>
            <div class="gift-price">¥ ${gift.price}</div>
            
            <div class="gift-btn" onclick="window.showInsGiftModal('${encodedMsg}')">
                <i class="fas fa-envelope-open-text"></i> OPEN
            </div>
        </div>`;
    break;
}

// --- 🥡 最终版外卖：取消所有交互 ---
case 'takeout': {
    const order = message.content;
    const itemsHtml = order.items.map(item => `
        <div class="takeout-row">
            <span>${item.name}</span>
            <span>x${item.count}</span>
        </div>`).join('');
    
    const noteHtml = order.note ? `
        <div class="takeout-note-box">
            <div class="takeout-note-title">REMARKS</div>
            ${order.note}
        </div>` : '';

    messageContentHTML = `
        <div class="message takeout-card">
            <div class="takeout-header">
                <span class="takeout-shop">${order.shopName}</span>
                <span class="takeout-status">${order.status}</span>
            </div>
            <div class="takeout-list">
                ${itemsHtml}
            </div>
            <div class="takeout-total">
                <span>Total</span>
                <span>¥ ${order.totalPrice}</span>
            </div>
            
            ${noteHtml}
            
            <div class="takeout-actions">
                <div class="takeout-action-btn" style="cursor: default; opacity: 0.7;">
                    联系骑手
                </div>
                <div class="takeout-action-btn" style="cursor: default; opacity: 0.7;">
                    再来一单
                </div>
            </div>
        </div>`;
    break;
}
// ... 在 switch (message.type) { 里面 ...

            // ▼▼▼ 在这里粘贴新的 case ▼▼▼
            case 'chat_history_share': {
                const data = message.content;
                
                // 这是一个辅助函数，用来把消息内容转成文字预览
                const getPreviewText = (msg) => {
                    switch(msg.type) {
                        case 'text':
                        case 'html': return msg.content.replace(/<[^>]+>/g, ''); // 移除HTML
                        case 'voice': return `[语音] ${msg.content.text}`;
                        case 'image':
                        case 'uploaded_image': return `[图片]${msg.isEmoticon ? msg.emoticonName : ''}`;
                        case 'picture_description': return `[图片] ${msg.content.description}`;
                        case 'red_packet': return `[红包] ${msg.content.blessing}`;
                        case 'transfer': return `[转账] ¥${msg.content.amount}`;
                        case 'music_share': return `[音乐] ${msg.content.title}`;
                        case 'location_share': return `[位置] ${msg.content.name}`;
                        case 'post_share': return `[分享的帖子]`;
                        case 'product_share': return `[分享的商品] ${msg.content.productDetails.name}`;
                        default: return `[${msg.type} 消息]`;
                    }
                };
                
                let itemsHTML = '';
                // 只显示最新的几条作为预览
                const messagesPreview = data.messages; // 最多预览5条

                for (const msg of messagesPreview) {
                    // 兼容 'user' 和 'myProfile'
                    const isSent = (msg.sender === 'user' || msg.sender === 'myProfile');
                    const senderName = data.participants[msg.sender]?.name || '未知';
                    const contentPreview = getPreviewText(msg);

                    itemsHTML += `
                        <div class="ch-item ${isSent ? 'sent' : 'received'}">
                            ${!isSent ? `<div class="ch-sender">${senderName}</div>` : ''}
                            <div class="ch-bubble">
                                ${contentPreview.substring(0, 100)}${contentPreview.length > 100 ? '...' : ''}
                            </div>
                        </div>
                    `;
                }
                

                // 组装成卡片
                messageContentHTML = `
                    <div class="message chat-history-card">
                        <div class="ch-header">${data.sourceChatName}</div>
                        <div class="ch-body">
                            ${itemsHTML}
                        </div>
                        <div class="ch-footer">聊天记录</div>
                    </div>`;
                break;
            }
            // ▲▲▲ new case 粘贴结束 ▲▲▲

// 在 case 'image': 的下面，添加一个新的 case
case 'uploaded_image':
    // 这个逻辑和 type: 'image' 非常像，但是 src 直接使用 Base64
    messageContentHTML = `
        <div class="message image-message">
            <div class="message-image-container ${message.sender === 'user' ? 'sent' : 'received'}">
                <img src="${message.content.base64}" class="message-image" alt="上传的图片">
            </div>
        </div>`;
    break;  
                case 'location_share': { const loc = message.content; messageContentHTML = ` <div class="message location-share-card"> <div class="location-card-icon"> <i class="${loc.icon || 'fas fa-map-marker-alt'}"></i> </div> <div class="location-card-info"> <div class="name">${loc.name}</div> <div class="footer">位置信息 · 点击查看</div> </div> </div>`; break; }
                case 'html':
                    let finalContent = message.content;

                    // ▼▼▼ 核心修复：使用安全函数进行美化 ▼▼▼
                    if (contact && contact.isNarrativeMode) {
                        // 调用刚才添加的安全函数，只美化文字，不破坏标签
                        finalContent = formatNarrativeHtmlSafe(finalContent);
                    }
                    // ▲▲▲ 修复结束 ▲▲▲

                    // 渲染逻辑
                    if (message.sender === 'user' || (contact && contact.isNarrativeMode)) {
                        // 加上气泡外壳
                        messageContentHTML = `<div class="message ${message.sender === 'user' ? 'sent' : 'received'}">${quoteHTML}${finalContent}</div>`;
                    } else {
                        // 普通模式下的功能卡片（无气泡）
                        messageContentHTML = `${quoteHTML}${finalContent}`;
                    }
                    break;
                case 'image':
                    messageContentHTML = `<div class="message image-message"><div class="message-image-container ${message.sender === 'user' ? 'sent' : 'received'}"><img src="${message.url}" class="message-image" alt="图片"></div></div>`;
                    break;
                case 'post_share': {
                    const post = state.posts.find(p => p.id === message.content.postId);
                    if (post) {
                        messageContentHTML = `
                        <div class="message post-share-card" data-post-id="${post.id}">
                            <div class="post-share-header">
                                <img src="${post.author.avatar}" class="post-share-avatar">
                                <span class="post-share-name">${post.author.name}</span>
                            </div>
                            <div class="post-share-content">${post.content}</div>
                            <div class="post-share-footer">分享的帖子</div>
                        </div>`;
                    } else {
                        messageContentHTML = `<div class="message received">帖子已被删除</div>`;
                    }
                    break;
                }
                // ▼▼▼ 把下面这段完整的 case 代码块粘贴进去 ▼▼▼
case 'product_share': {
    const shareData = message.content;
    const product = shareData.productDetails;
    const intentText = shareData.intent === 'gift' 
        ? `🎁 我送你一个礼物` 
        : `🥺 可以帮我付下款吗？`;

    // 重新构建卡片的HTML内容
    messageContentHTML = `
        <div class="message product-share-card">
            <div class="product-share-intent">${intentText}</div>
            <div class="product-share-body">
                <div class="product-share-info">
                    <div class="product-title">${product.name}</div>
                    
                    <div class="product-description" style="margin-top: 5px; font-size: 13px; color: #666; line-height: 1.5;">${product.description}</div>
                    
                    <div class="product-price" style="margin-top: 8px; text-align: right;"><span>¥</span>${product.price}</div>
                </div>
            </div>
            <div class="product-share-accompanying-msg">${shareData.accompanyingMessage}</div>
        </div>`;
    break;
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ... 在 switch (message.type) 内部 ...

case 'cp_share': {
    const data = message.content;
    // 渲染漂亮的卡片 UI (无分数版)
    messageContentHTML = `
        <div class="message cp-share-card" style="background: linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%); padding: 15px; border-radius: 12px; color: white; width: 220px; cursor:pointer;">
            <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px;">❤️ 默契问卷报告</div>
            <div style="font-size: 13px; opacity: 0.9; margin-bottom: 5px;">主题：${data.title}</div>
            
            <div style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; text-align: center; margin: 10px 0;">
                <i class="fas fa-clipboard-check" style="font-size: 24px;"></i>
                <div style="font-size: 12px; margin-top: 4px;">已完成 ${data.total} 道问答</div>
            </div>
            
            <div style="font-size: 12px; text-align: center; opacity: 0.8;">(点击查看我们的答案)</div>
        </div>`;
    break;
}
// ▼▼▼ 用这段【V4 - 统一居中版】代码替换旧的 'case recall_ai' ▼▼▼
    case 'recall_ai': {
        // 1. 获取发送者名字 (这个不变)
        const senderName = (contact.isGroup)
            ? (state.contacts.find(c => c.id === message.sender)?.name || '成员')
            : contact.name;
        
        // 2. 关键：创建【居中】的 wrapper (两个状态都用它)
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-wrapper'; 
        wrapper.dataset.messageId = message.id;

        if (message.isRevealed) {
            // --- 状态 2: 已点开 (渲染成“已揭示”的居中提示) ---
            // 内部的 div 使用了 'system-notification' 和 'recall-ai-revealed'
            wrapper.innerHTML = `
                <div class="system-notification recall-ai-revealed">
                    <span class="recall-prefix">[撤回内容]</span>
                    ${message.content.replace(/\n/g, '<br>')}
                </div>
            `;
        } else {
            // --- 状态 1: 未点开 (渲染成“占位符”的居中提示) ---
            // 内部的 div 使用了 'system-notification' 和 'recall-ai-placeholder'
            wrapper.innerHTML = `
                <div class="system-notification recall-ai-placeholder">
                    ${senderName} 撤回了一条消息
                </div>
            `;
        }
        
        // 3. 绑定点击事件 (这个不变)
        wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
        return wrapper; // 返回这个居中的 wrapper
    }
// ▲▲▲ 替换结束 ▲▲▲
case 'picture_description':
                    // [V-MOD 2.0] "翻转"卡片 HTML 结构

                    // 👇 你的占位图 URL 放在这里
                    const aiImageUrl = "https://s21.ax1x.com/2025/11/10/pZ9NqTx.jpg"; 

                    messageContentHTML = `
                        <div class="message picture-description ${message.sender === 'user' ? 'sent' : 'received'}">
                            <div class="message-image-container">
                                <img src="${aiImageUrl}" class="message-image" alt="AI 图片预览">

                                <div class="picture-description-text">
                                    ${message.content.description.replace(/\n/g, '<br>')}
                                </div>
                            </div>
                        </div>`;
                    break; // 确保 break 还在
                case 'voice':
                    const voiceData = message.content;
                    const width = Math.min(200, 80 + parseInt(voiceData.duration) * 5) + 'px';
                    messageContentHTML = `<div class="message voice ${message.sender === 'user' ? 'sent' : 'received'}" style="width: ${width};"><div class="voice-duration">${voiceData.duration}''</div><i class="fas fa-wifi"></i></div>`;
                    break;
                // 在 createMessageElement 函数的 switch 语句内...

case 'red_packet':
    const packetData = message.content;
    let statusHTML = '';
    let footerText = '聊天红包';

    if (packetData.hasOwnProperty('count')) {
        // 这是群聊红包
        const isDepleted = packetData.claimers.length >= packetData.count;
        if (isDepleted) {
            statusHTML = `<div class="red-packet-status">红包已被领完</div>`;
        } else {
            statusHTML = `<div class="red-packet-blessing">${packetData.blessing}</div>`;
        }
        footerText = '群聊红包';
    } else {
        // 这是私聊红包
        statusHTML = packetData.opened ? `<div class="red-packet-status">红包已被领取</div>` : `<div class="red-packet-blessing">${packetData.blessing}</div>`;
    }
    
    // 如果已经被我领取了，也显示为 opened 状态
    const myId = 'myProfile';
    const hasClaimed = packetData.claimers && packetData.claimers.some(c => c.userId === myId);
    const isOpened = packetData.opened || hasClaimed;

    messageContentHTML = `<div class="message red-packet ${isOpened ? 'opened' : ''} ${message.sender === 'user' ? 'sent' : 'received'}"><div class="red-packet-header"><div class="red-packet-icon">🧧</div>${statusHTML}</div><div class="red-packet-footer">${footerText}</div></div>`;
    break;
                // 在 createMessageElement 函数的 switch 语句内...

case 'transfer': {
    const transferData = message.content;
    let transferClasses = 'message transfer';
    if (transferData.returned) {
        transferClasses += ' returned';
    } else if (transferData.completed) {
        transferClasses += ' completed';
    }

    let footerText = '聊天转账';
    if (transferData.returned) {
        footerText = '转账已退还';
    } else if (transferData.completed) {
        footerText = message.sender === 'user' ? '对方已收款' : '已存入钱包';
    }

    // 新增：判断是否是群聊转账，并显示收款人
    let recipientInfoHTML = '';
    if (transferData.recipientId) {
        const recipient = state.contacts.find(c => c.id === transferData.recipientId);
        if (recipient) {
            recipientInfoHTML = `<div class="transfer-text">转账给 ${recipient.name}</div>`;
        }
    } else {
        recipientInfoHTML = `<div class="transfer-text">转账</div>`;
    }

    messageContentHTML = `
        <div class="${transferClasses} ${message.sender === 'user' ? 'sent' : 'received'}">
            <div class="transfer-header">
                <div class="transfer-icon"><i class="fas fa-money-bill-wave"></i></div>
                <div class="transfer-info">
                    ${recipientInfoHTML}
                    <div class="transfer-amount">¥ ${transferData.amount}</div>
                </div>
            </div>
            <div class="transfer-footer">${footerText}</div>
        </div>`;
    break;
}
case 'music_share':
    const music = message.content;
    // ✨ 智能判断：有封面就用<img>，没封面就用<i>图标 ✨
    const coverInner = music.cover 
        ? `<img src="${music.cover}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover; opacity: 0.9;">`
        : `<i class="fas fa-music"></i>`;

    messageContentHTML = `
    <div class="message music-share-card ${message.sender === 'user' ? 'sent' : 'received'}">
        <div class="music-card-cover">
            ${coverInner}
            <span class="music-card-play-btn"><i class="fas fa-play"></i></span>
        </div>
        <div class="music-card-info">
            <div class="music-card-title">${music.title}</div>
            <div class="music-card-artist">${music.artist || '未知艺术家'}</div>
            <div class="music-card-progress-bar"><div class="music-card-progress"></div></div>
            <div class="music-card-controls">
                <span class="music-card-time">00:00</span>
                <span class="music-card-loop-btn" title="列表循环"><i class="fas fa-repeat"></i></span>
            </div>
        </div>
    </div>`;
    break;
                case 'game_wheel': {
                    const wheel = message.content;
                    const myProfile = state.myProfile;
                    const contact = state.contacts.find(c => c.id === state.activeChatId);

                    const userResultHTML = wheel.results.user
                        ? `<div class="wheel-player-result">${wheel.results.user}</div>`
                        : `<button class="spin-btn" data-player="user">点击开转</button>`;

                    const contactResultHTML = wheel.results.contact
                        ? `<div class="wheel-player-result">${wheel.results.contact}</div>`
                        : `<div class="wheel-player-result">等待对方...</div>`;

                    messageContentHTML = `
                        <div class="message game-wheel-card">
                            <div class="wheel-card-title">🎲 ${wheel.name} 🎲</div>
                            <div class="wheel-card-result-area">
                                <div class="wheel-result-row">
                                    <span class="wheel-player-name">${myProfile.name}</span>
                                    ${userResultHTML}
                                </div>
                                <div class="wheel-result-row">
                                    <span class="wheel-player-name">${contact.name}</span>
                                    ${contactResultHTML}
                                </div>
                            </div>
                        </div>`;
                    break;
                }
                default: 
                    let formattedContent = message.content;
                    const tempDiv = document.createElement('div');
                    tempDiv.textContent = formattedContent;
                    formattedContent = tempDiv.innerHTML;
                    formattedContent = formattedContent.replace(/\{(.*?)\}/g, '<span class="narrative-psychology">$1</span>');
                    formattedContent = formattedContent.replace(/(?:&quot;|“|”|＂)(.*?)(?:&quot;|“|”|＂)/g, '<span class="narrative-speech">“$1”</span>');
                    formattedContent = formattedContent.replace(/\*(.*?)\*/g, '<span class="narrative-action">$1</span>');
                    formattedContent = formattedContent.replace(/\n/g, '<br>');
                    // ↓↓↓ 核心改动：将 quoteHTML 插入到消息内容之前
                    messageContentHTML = `<div class="message ${message.sender === 'user' ? 'sent' : 'received'}">${quoteHTML}${formattedContent}</div>`;
                    break;
            }

            if (message.type !== 'text') {
                messageContentHTML = quoteHTML + messageContentHTML;
            }

            // [V-MOD 2.0] 只为 voice 创建外部文字框
const transcribedTextHTML = (message.type === 'voice') ? '<div class="transcribed-text"></div>' : '';
            
            // --- 新增：在消息体旁边添加回复按钮 ---
            const replyButtonHTML = '<i class="fas fa-reply reply-btn"></i>';
            // ... (replyButtonHTML那行)

// ▼▼▼ 第2处修改：粘贴这段代码 ▼▼▼
let recallButtonHTML = ''; // 1. 默认是空的
if (message.sender === 'user' && message.type !== 'system_notification') { // 2. 只有用户发的消息才有
    recallButtonHTML = '<i class="fas fa-undo recall-btn"></i>';
}
// ▲▲▲ 修改结束 ▲▲▲

            wrapper.innerHTML = `
        <div class="message-avatar">
    <img src="${finalAvatarUrl}" onerror="this.onerror=null;this.src='https://via.placeholder.com/40/DDD/666?text=U';">
</div>
        <div class="message-body">
            ${showAuthorName ? `<div class="message-author-name">${finalSenderInfo.name}</div>` : ''}
            ${messageContentHTML}
            ${transcribedTextHTML}
            <div class="message-timestamp">${message.time}</div>
        </div>
        ${replyButtonHTML} ${recallButtonHTML}
    `;
            wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
            return wrapper;
        }
        
        async function addSharedMemory(contact, description) {
            if (!contact) return;
            if (!contact.memories) contact.memories = [];

            const newMemory = {
                id: `memo_${Date.now()}`,
                timestamp: Date.now(),
                description: description
            };
            contact.memories.push(newMemory);
            await kokoMemory.put('contacts', contact);
        }

        async function checkForPetLevelUp(contact) {
            if (!contact.pet) return;
            const xpForNextLevel = 100;

            if (contact.pet.xp >= xpForNextLevel) {
                contact.pet.xp -= xpForNextLevel;
                contact.pet.level += 1;

                let evolutionMessage = '';
                let evolutionForm = contact.pet.form;

                if (contact.pet.level === 5 && contact.pet.form === 'baby') {
                    evolutionForm = 'toddler';
                    evolutionMessage = `在你们的精心照料下，史莱姆长大了！进化成了可爱的幼年期形态！`;
                } else if (contact.pet.level === 15 && contact.pet.form === 'toddler') {
                    evolutionForm = 'teenager';
                    evolutionMessage = `哇！光芒闪过，史莱姆再次进化，进入了活泼的少年期！`;
                }

                if (evolutionMessage) {
    contact.pet.form = evolutionForm;
    await createSystemNotification(evolutionMessage);

    // ▼▼▼ 修改开始 ▼▼▼
    // 1. 创建一条系统指令消息，类型设为 'system_instruction'
    // 这样这条消息会进入历史记录，AI 下次聊天时能看到，但现在不会触发 AI 回复
    await createAndAddMessage({
        type: 'text',
        content: `[SYSTEM: 你们的宠物刚刚进化了！${evolutionMessage}]`
    }, 'system_instruction', contact);
    
    // 2. 原来的 requestAiReply() 被删除了
    // ▲▲▲ 修改结束 ▲▲▲

    await addSharedMemory(contact, `在LV.${contact.pet.level}时，我们的史莱姆进化成了“${evolutionForm}”形态！`);
} else {
                    await createSystemNotification(`你们的聊天让史莱姆获得了成长！升到了 LV.${contact.pet.level}！`);
                }
                
                await kokoMemory.put('contacts', contact);
            }
        }
// --- ✨ 全局函数：显示好看的 Ins 风弹窗 ---
window.showInsGiftModal = function(textEncoded) {
    // 1. 解码文字 (为了防止单引号等字符破坏 HTML 结构，传参时我们加密了)
    const text = decodeURIComponent(textEncoded);

    // 2. 创建遮罩
    const overlay = document.createElement('div');
    overlay.className = 'ins-modal-overlay';
    
    // 3. 点击遮罩自动关闭
    overlay.onclick = function(e) {
        if(e.target === overlay) {
            document.body.removeChild(overlay);
        }
    };

    // 4. 填充内容
    overlay.innerHTML = `
        <div class="ins-modal-box">
            <div class="ins-modal-icon">💌</div>
            <div class="ins-modal-title">A Letter For You</div>
            <div class="ins-modal-text">${text}</div>
            <button class="ins-modal-close" onclick="this.parentElement.parentElement.remove()">收下心意</button>
        </div>
    `;

    // 5. 放到页面上
    document.body.appendChild(overlay);
};
        async function addTransaction(type, amount, description, relatedContactId = null) {
            const newTransaction = {
                id: `txn_${Date.now()}`,
                timestamp: Date.now(),
                type: type, // 'income' 或 'expense'
                amount: amount,
                description: description,
                relatedContactId: relatedContactId
            };
            if (!state.transactions) state.transactions = [];
            state.transactions.push(newTransaction);
            await kokoMemory.put('transactions', newTransaction);
        }
/**
 * (V5 扩容版) 获取完整的字符配置库
 * 包含 60+ 个精选单词
 */
function getLuckyWordConfig() {
    return [
        // =========================================
        // [Epic 史诗] - 1% 概率 - 极致浪漫与永恒
        // =========================================
        { word: "FOREVER", type: "epic", meaning: "永恒的誓言" },
        { word: "ETERNITY", type: "epic", meaning: "不朽的时光" },
        { word: "UNIVERSE", type: "epic", meaning: "你是我的宇宙" },
        { word: "SERENDIPITY", type: "epic", meaning: "美好的不期而遇" },
        { word: "EUPHORIA", type: "epic", meaning: "极致的欢愉" },
        { word: "PARADISE", type: "epic", meaning: "伊甸园" },
        { word: "INFINITY", type: "epic", meaning: "无限可能" },
        { word: "MIRACLE", type: "epic", meaning: "奇迹降临" },
        { word: "GALAXY", type: "epic", meaning: "璀璨银河" },
        { word: "DESTINY", type: "epic", meaning: "命中注定" },
        { word: "ODYSSEY", type: "epic", meaning: "伟大的旅程" },
        { word: "GENESIS", type: "epic", meaning: "起源" },

        // =========================================
        // [Rare 稀有] - 9% 概率 - 深情与独特
        // =========================================
        { word: "CRUSH", type: "rare", meaning: "心动" },
        { word: "CHERISH", type: "rare", meaning: "珍爱" },
        { word: "BREEZE", type: "rare", meaning: "温柔晚风" },
        { word: "SUNSET", type: "rare", meaning: "日落" },
        { word: "PROMISE", type: "rare", meaning: "誓言" },
        { word: "SECRET", type: "rare", meaning: "秘密" },
        { word: "SPIRIT", type: "rare", meaning: "灵魂" },
        { word: "DIVINE", type: "rare", meaning: "神圣" },
        { word: "GLORY", type: "rare", meaning: "荣耀" },
        { word: "DREAM", type: "rare", meaning: "梦境" },
        { word: "MEMORY", type: "rare", meaning: "回忆" },
        { word: "LEGEND", type: "rare", meaning: "传说" },
        { word: "SPARK", type: "rare", meaning: "火花" },
        { word: "BLOOM", type: "rare", meaning: "绽放" },
        { word: "MOONLIGHT", type: "rare", meaning: "白月光" },
        { word: "STARDUST", type: "rare", meaning: "星尘" },
        { word: "AURORA", type: "rare", meaning: "极光" },
        { word: "MYSTERY", type: "rare", meaning: "神秘" },
        
        // =========================================
        // [Common 普通] - 90% 概率 - 日常与陪伴
        // =========================================
        { word: "HELLO", type: "common", meaning: "你好呀" },
        { word: "SMILE", type: "common", meaning: "笑一个" },
        { word: "HAPPY", type: "common", meaning: "开心" },
        { word: "LUCKY", type: "common", meaning: "幸运" },
        { word: "SWEET", type: "common", meaning: "甜甜的" },
        { word: "WARM", type: "common", meaning: "温暖" },
        { word: "DAILY", type: "common", meaning: "日常" },
        { word: "TRUST", type: "common", meaning: "信任" },
        { word: "BRAVE", type: "common", meaning: "勇敢" },
        { word: "POWER", type: "common", meaning: "力量" },
        { word: "PEACE", type: "common", meaning: "安宁" },
        { word: "CALM", type: "common", meaning: "平静" },
        { word: "FRESH", type: "common", meaning: "新鲜" },
        { word: "START", type: "common", meaning: "开始" },
        { word: "NICE", type: "common", meaning: "不错" },
        { word: "COOL", type: "common", meaning: "酷" },
        { word: "FINE", type: "common", meaning: "很好" },
        { word: "OKAY", type: "common", meaning: "好的" },
        { word: "YES", type: "common", meaning: "是的" },
        { word: "HUG", type: "common", meaning: "抱抱" },
        { word: "KISS", type: "common", meaning: "亲亲" },
        { word: "BABY", type: "common", meaning: "宝贝" },
        { word: "DEAR", type: "common", meaning: "亲爱的" },
        { word: "HOPE", type: "common", meaning: "希望" },
        { word: "WISH", type: "common", meaning: "许愿" },
        { word: "PURE", type: "common", meaning: "纯净" },
        { word: "SOFT", type: "common", meaning: "柔软" },
        { word: "TIME", type: "common", meaning: "时间" }
    ];
}

/**
 * (核心) 执行一次抽卡逻辑
 */
async function drawLuckyCharacter(contact) {
    // 1. 初始化数据结构
    if (!contact.luckyCharInventory) contact.luckyCharInventory = [];
    if (!contact.luckyCharGacha) contact.luckyCharGacha = { count: 0, lastDate: "" };

    // 2. 检查每日次数
    const today = new Date().toLocaleDateString();
    if (contact.luckyCharGacha.lastDate !== today) {
        contact.luckyCharGacha.count = 0;
        contact.luckyCharGacha.lastDate = today;
    }

    if (contact.luckyCharGacha.count >= 3) {
        alert("今天的运气已经用完啦！明天再来抽吧 (每日限3次)。");
        return null;
    }

    // 3. 消耗次数
    contact.luckyCharGacha.count++;
    await kokoMemory.put('contacts', contact); // 先保存次数，防刷

    // 4. 抽卡算法 (新手保底机制)
    const config = getLuckyWordConfig();
    let result = null;

    // 如果仓库是空的，强制必中一个 Common 或 Rare (给点甜头)
    if (contact.luckyCharInventory.length === 0) {
        const starters = config.filter(c => c.type !== 'epic');
        result = starters[Math.floor(Math.random() * starters.length)];
    } else {
        // 正常概率：Epic 5%, Rare 25%, Common 70%
        const rand = Math.random();
        let pool = [];
        if (rand < 0.05) pool = config.filter(c => c.type === 'epic');
        else if (rand < 0.30) pool = config.filter(c => c.type === 'rare');
        else pool = config.filter(c => c.type === 'common');
        
        result = pool[Math.floor(Math.random() * pool.length)];
    }

    // 5. 检查重复
    // 如果抽到了已有的，转化为“碎片”或者直接提示 (这里简单处理：允许重复，变成“升级”或者单纯提示已拥有)
    // 为了简单体验好，我们这里逻辑是：如果重复了，就提示“转化为了祝福”，如果不重复，就收入库中
    const existing = contact.luckyCharInventory.find(c => c.word === result.word);
    
    if (existing) {
        alert(`✨ 哎呀，抽到了重复的【${result.word}】(${result.meaning})！\n它化作流星飞走了... (今日剩余 ${3 - contact.luckyCharGacha.count} 次)`);
        return null; // 没拿到新东西
    }

    // 6. 创建新实例
    const newChar = {
        id: `char_${Date.now()}`,
        word: result.word,
        type: result.type,
        meaning: result.meaning,
        unlockedCount: 0,
        dailyMessageCount: 0,
        lastActivityDate: "",
        lastUnlockDate: "",
        isCompleted: false,
        obtainedDate: Date.now()
    };

    // 7. 入库
    contact.luckyCharInventory.push(newChar);
    
    // 如果当前没有佩戴的，自动佩戴
    if (!contact.luckyChar) {
        contact.luckyChar = newChar;
    }

    await kokoMemory.put('contacts', contact);
    
    return newChar; // 返回抽到的对象
}
/**
 * (V-Fix Pro) 检查并更新幸运字符进度
 * 包含自动修复逻辑 + 自动同步仓库逻辑
 */
async function checkLuckyCharProgress(contact) {
    // 1. 基础检查
    if (!contact || !contact.luckyChar) return;
    
    const charData = contact.luckyChar;

    // --- 数据自愈 ---
    if (typeof charData.dailyMessageCount === 'undefined') charData.dailyMessageCount = 0;
    if (typeof charData.unlockedCount === 'undefined') charData.unlockedCount = 0;
    if (!charData.lastActivityDate) charData.lastActivityDate = new Date().toLocaleDateString();

    const today = new Date().toLocaleDateString();

    // 2. 检查是否已完成，完成了就不用再跑了
    if (charData.unlockedCount >= charData.word.length) {
        // 确保状态是 completed
        if (!charData.isCompleted) {
            charData.isCompleted = true;
            // 同步回仓库
            syncCharToInventory(contact, charData);
            await kokoMemory.put('contacts', contact);
        }
        return;
    }

    // 3. 跨天重置
    if (charData.lastActivityDate !== today) {
        charData.dailyMessageCount = 0;
        charData.lastActivityDate = today;
        charData.lastUnlockDate = ""; 
    }

    // 4. 计数增加
    charData.dailyMessageCount++;

    // 5. 判断点亮逻辑
    if (charData.dailyMessageCount >= 20 && charData.lastUnlockDate !== today) {
        charData.unlockedCount++;
        charData.lastUnlockDate = today;
        
        // 检查是否刚刚完成
        if (charData.unlockedCount >= charData.word.length) {
            charData.isCompleted = true;
            await createSystemNotification(`🎉 恭喜！幸运字符【${charData.word}】已集齐！`, contact);
        } else {
            const progress = `${charData.unlockedCount}/${charData.word.length}`;
            await createSystemNotification(`🌟 每日亲密度达标！点亮幸运字符新字母 (${progress})`, contact);
        }

        // 刷新界面
        if (state.activeChatId === contact.id) {
            openChat(contact.id);
        }
    }
    
    // ▼▼▼▼▼▼ 核心新增：实时同步回仓库 ▼▼▼▼▼▼
    // 这样即使不切换字符，直接关网页，进度也保存在仓库里了
    syncCharToInventory(contact, charData);
    // ▲▲▲▲▲▲ 新增结束 ▲▲▲▲▲▲

    // 6. 保存
    await kokoMemory.put('contacts', contact);
}

// 辅助函数：把当前字符的数据同步到仓库数组中
function syncCharToInventory(contact, activeChar) {
    if (!contact.luckyCharInventory) return;
    const idx = contact.luckyCharInventory.findIndex(c => c.word === activeChar.word);
    if (idx > -1) {
        // 使用 JSON parse/stringify 确保断开引用，确保存入的是数据快照
        // 或者直接赋值引用也可以，但在 IndexedDB 环境下，明确赋值更安全
        contact.luckyCharInventory[idx] = activeChar;
    }
}
/**
 * (新) 更新联系人的火花/亲密度状态
 * @param {object} contact - 联系人对象
 */
async function updateContactSpark(contact) {
    const today = new Date();
    // 获取 "YYYY-MM-DD" 格式的日期字符串，确保跨天判断准确
    const dateStr = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();

    // 初始化数据结构 (兼容旧数据)
    if (!contact.sparkData) {
        contact.sparkData = {
            lastActiveDate: null,
            streak: 0
        };
    }

    const lastDate = contact.sparkData.lastActiveDate;
    
    if (lastDate === dateStr) {
        // 1. 如果上次互动就是今天，天数不变
        return; 
    }

    if (lastDate) {
        const last = new Date(lastDate);
        // 计算相差天数
        const diffTime = Math.abs(today - last);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 

        if (diffDays === 1) {
            // 2. 如果是昨天互动的，天数 +1
            contact.sparkData.streak += 1;
        } else if (diffDays > 1) {
            // 3. 如果断签了 (超过1天)，重置为 1
            contact.sparkData.streak = 1;
        }
    } else {
        // 4. 第一次互动
        contact.sparkData.streak = 1;
    }

    // 更新日期
    contact.sparkData.lastActiveDate = dateStr;
    
    // 保存到数据库
    await kokoMemory.put('contacts', contact);
}

/**
 * (修改版) 根据天数获取火花图标和样式类
 */
function getSparkInfo(streak) {
    if (!streak || streak <= 0) return null;
    
    if (streak >= 30) {
        // 等级 4: 巨轮/深爱
        return { icon: '🔥', label: `${streak}天`, className: 'spark-level-4' }; 
    } else if (streak >= 7) {
        // 等级 3: 大火花
        return { icon: '🔥', label: `${streak}天`, className: 'spark-level-3' }; 
    } else if (streak >= 4) {
        // 等级 2: 小火花
        return { icon: '🔥', label: `${streak}天`, className: 'spark-level-2' }; 
    } else if (streak >= 1) {
        // ✨ 改动在这里：等级 1 也统一用火花图标
        return { icon: '🔥', label: `${streak}天`, className: 'spark-level-1' }; 
    }
    return null;
}
// --- 修改：消息创建函数 (V3 - 修复上下文切换BUG版) ---
async function createAndAddMessage(messageData, sender = 'user', targetContact = null, forceShowAvatar = false, contextMode = null) {
    // 1. 获取目标联系人对象
    const contact = targetContact || state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) {
        console.error("createAndAddMessage: 找不到目标联系人对象。");
        return; // 如果找不到联系人，则无法继续
    }

    // 2. 【核心修复】根据传入的 `contextMode` 决定使用哪个历史记录数组
    //    优先使用传入的 contextMode（'chat' 或 'sms'）
    //    如果没有传入（null），则回退到使用当前的全局UI模式（这是旧的、可能导致bug的行为）
    const effectiveMode = contextMode || state.currentChatMode;
    const historyArray = (effectiveMode === 'sms') ? 'smsHistory' : 'history';
    
    if (!contact[historyArray]) {
        contact[historyArray] = []; // 如果数组不存在，先创建
    }

    // 3. (仅聊天模式) 处理宠物经验和首次聊天日期
    if (historyArray === 'history') { // 仅适用于 App 内聊天
        if (contact.pet && sender !== 'system_instruction' && messageData.type !== 'system_notification') {
            contact.pet.xp += 1;
            await checkForPetLevelUp(contact);
        }
        if (contact[historyArray].length === 0) { // 仅第一次聊天时记录
            contact.firstChatDate = Date.now();
        }
    }

    // 4. 创建完整的消息对象 (使用 effectiveMode 修复ID前缀)
    const fullMessage = {
        id: `${effectiveMode}_${Date.now()}_${Math.random()}`, // ID 前缀区分
        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        timestamp: Date.now(),
        sender: sender,
        ...messageData,
        forceAvatar: forceShowAvatar // 是否强制显示头像 (用于自动回复)
    };
    // 5. 将消息添加到正确的历史记录数组
    contact[historyArray].push(fullMessage);

    // 6. (可选) 处理后台通知 (如果应用在后台)
    if (sender !== 'user' && sender !== 'system' && sender !== 'system_instruction' && document.hidden) {
        let notificationBody = '';
        // 根据消息类型生成不同的通知预览文本
        switch(fullMessage.type) {
            case 'text':
            case 'html':
                // 对于过长的文本，截断预览
                notificationBody = fullMessage.content.length > 50 ? fullMessage.content.substring(0, 50) + '...' : fullMessage.content;
                break;
            case 'image':
            case 'uploaded_image': // 处理用户上传的图片
            case 'picture_description': // 处理AI描述的图片
                notificationBody = '[发来了一张图片]';
                break;
            case 'voice':
                notificationBody = '[发来了一段语音]';
                break;
            case 'red_packet':
                notificationBody = `[发来了一个红包] ${fullMessage.content.blessing || '恭喜发财'}`;
                break;
            case 'transfer':
                notificationBody = `[发来了一笔转账] ¥${fullMessage.content.amount}`;
                break;
            case 'music_share':
                notificationBody = `[分享了音乐] ${fullMessage.content.title}`;
                break;
            case 'location_share':
                 notificationBody = `[分享了位置] ${fullMessage.content.name}`;
                 break;
            // 可以根据需要添加更多类型的预览
            default:
                notificationBody = '[发来了一条新消息]';
        }

        // 检查通知权限并发送
        if (Notification.permission === "granted") {
            // 需要获取发送者的信息来显示名字和头像
            const senderProfile = state.contacts.find(c => c.id === sender);
            if (senderProfile) {
                new Notification(senderProfile.name, {
                    body: notificationBody,
                    icon: senderProfile.avatar || 'https://via.placeholder.com/40' // 提供一个默认图标
                });
            }
        }
    }

// 7. 更新UI & 播放提示音 (最终防抖版)
    if (fullMessage.sender !== 'system_instruction') { 
        
        const isNotSelf = (sender !== 'user' && sender !== 'myProfile');
        const isNotSystem = (sender !== 'system');
        
        if (isNotSelf && isNotSystem && userSettings && userSettings.notificationSoundUrl) {
            // ▼▼▼▼▼▼ 核心修改：加了时间判断 ▼▼▼▼▼▼
            const now = Date.now();
            // 只有距离上次播放超过 3000毫秒 (3秒) 才允许响
            if (now - lastNotificationTime > 3000) {
                const audio = document.getElementById('notification-sound-player');
                if (audio) {
                    if (audio.src !== userSettings.notificationSoundUrl) {
                        audio.src = userSettings.notificationSoundUrl;
                    }
                    audio.currentTime = 0; 
                    audio.play().catch(e => console.warn("提示音播放受阻:", e));
                    
                    // 更新播放时间
                    lastNotificationTime = now;
                }
            }
            // ▲▲▲▲▲▲ 修改结束 ▲▲▲▲▲▲
        }


        // ▼▼▼ 下面才是原本的界面更新逻辑 (不要动) ▼▼▼
        
        // 检查消息的目的地 (contact.id) 和 消息的模式 (effectiveMode)
        // 是否同时与用户当前所在的界面匹配。
        if (contact.id === state.activeChatId && effectiveMode === state.currentChatMode) { 
            
            if (effectiveMode === 'sms') {
                // 如果是短信模式，就只刷新短信UI
                await renderSmsChatMessages(contact); 
            } else {
                // 如果是聊天模式 (App内)，就只刷新聊天UI
                const messagesContainer = document.getElementById('chat-messages');

                // --- (你原有的判断头像显示逻辑) ---
                let isFirstInSequence = true;
                if (!forceShowAvatar) {
                    const newMsgIndex = contact.history.length - 1;
                    if (newMsgIndex > 0) {
                        const immediatelyPrecedingMsg = contact.history[newMsgIndex - 1];
                        const isSequenceBreaker = 
                            immediatelyPrecedingMsg.type === 'system_notification' ||
                            immediatelyPrecedingMsg.sender === 'system_instruction' ||
                            immediatelyPrecedingMsg.type === 'heart_voice' ||
                            immediatelyPrecedingMsg.type === 'recall_ai' ||
                            immediatelyPrecedingMsg.isRecalled === true; 

                        if (!isSequenceBreaker) {
                            if (immediatelyPrecedingMsg.sender === fullMessage.sender) {
                                isFirstInSequence = false; 
                            }
                        }
                    }
                }
                // --- 逻辑结束 ---

                const messageEl = createMessageElement(fullMessage, contact, isFirstInSequence);
                if (messageEl) {
                    const placeholder = messagesContainer.querySelector('#chat-placeholder');
                    if (placeholder) placeholder.remove();
                    messagesContainer.appendChild(messageEl);
                    setTimeout(() => {
                       messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }, 100); 
                }
            }
        } else {
            // 如果窗口不匹配 (你在主界面，或者是别的聊天窗口)
            // 增加未读计数 (这里虽然没播放声音代码，但因为声音在最上面已经播过了，所以这里不用管)
            contact.unreadCount = (contact.unreadCount || 0) + 1;
        }
    }
    // ▼▼▼ 【新增代码开始】 ▼▼▼
    // 只有当是有效的文本/语音/图片交流时才更新火花 (系统消息不算)
    if (sender !== 'system' && sender !== 'system_instruction' && messageData.type !== 'system_notification') {
        await updateContactSpark(contact);
        // ▼▼▼▼▼▼▼▼▼▼ 检查这里！有没有这几行？ ▼▼▼▼▼▼▼▼▼▼
        // 如果是用户发的消息，必须调用检查函数！
        if (sender === 'user') {
            console.log("正在检查幸运字符进度..."); //加个 log 验证这里是否执行
            await checkLuckyCharProgress(contact);
        }
    }
    // ▲▲▲ 【新增代码结束】 ▲▲▲

    // 8. 保存联系人数据到 IndexedDB
    await kokoMemory.put('contacts', contact);

    // 9. 刷新对应的列表视图 (主聊天列表 或 短信列表)
    if (fullMessage.sender !== 'system_instruction') {
        // 判断当前用户主要停留在哪个界面来决定刷新哪个列表
        const smsScreenVisible = document.getElementById('sms-screen').style.display === 'flex';
        // 如果当前是短信模式，或者短信主列表是可见的，就刷新短信列表
        if (state.currentChatMode === 'sms' || smsScreenVisible) {
           await renderSmsConversations(); // 刷新短信会话列表
        } else {
            // 否则刷新主聊天列表
            await renderContacts();
        }
    }

    // 10. 处理锁屏状态下的通知更新 (逻辑不变)
    const lockScreenEl = document.getElementById('lock-screen');
    if (lockScreenEl.style.display === 'flex' && !lockScreenEl.classList.contains('hidden')) {
        // 如果锁屏是显示的且未隐藏
        if (sender !== 'user' && sender !== 'system_instruction') {
            // 并且消息不是用户自己发的或系统指令
            console.log("锁屏状态下收到新消息，正在更新组件...");
            await updateLockScreenWidgets(); // 更新锁屏上的未读消息等组件
        }
    }

    // 11. 返回创建的消息对象，方便其他函数使用
    return fullMessage;
}

// (V2 修复版) 发送消息：正确记录引用对象的 NPC 名字
async function sendMessage() {
    const messageInput = document.getElementById('message-input');
    const content = messageInput.value.trim();
    
    // 如果既没字也没引用，就不发
    if ((!content && !activeReplyTarget) || !state.activeChatId) return;

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 1. 准备消息基础数据
    let messageType = 'text';
    const trimmedContent = content.trim();
    if (trimmedContent.startsWith('<') && trimmedContent.endsWith('>')) {
        messageType = 'html';
    }
    const messageData = { type: messageType, content: content };

    // 2. 处理引用数据 (核心修复区域)
    if (activeReplyTarget) {
        let senderName = '未知成员';

        if (activeReplyTarget.sender === 'user' || activeReplyTarget.sender === 'myProfile') {
            senderName = state.myProfile.name;
        } else if (contact.isGroup) {
            // A. 先找真实好友
            let senderContact = state.contacts.find(c => c.id === activeReplyTarget.sender);
            
            // B. 没找到？找群 NPC (修复点！)
            if (!senderContact && contact.npcMembers) {
                senderContact = contact.npcMembers.find(n => n.id === activeReplyTarget.sender);
            }
            
            if (senderContact) senderName = senderContact.name;
        } else {
            senderName = contact.name;
        }

        messageData.quote = {
            messageId: activeReplyTarget.id,
            senderName: senderName, // 这里现在存的是正确的名字了
            content: activeReplyTarget.content
        };
    }

    // 3. 发送消息
    await createAndAddMessage(messageData, 'user', contact, false, 'chat');

    // 4. 清理工作
    messageInput.value = '';
    messageInput.style.height = '38px'; 
    cancelReply(); 
}

        const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
async function handleLongPressDelete(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact || !contact.history || contact.history.length === 0) {
        return; 
    }

    const lastMessage = contact.history[contact.history.length - 1];
    if (!lastMessage) return;

    let confirmed = false;
    let finalHistorySliceIndex = -1;

    if (lastMessage.sender !== 'user') {
        // --- 场景 A: 最后一条消息是AI发的 ---
        // 目标：删除AI的最后一次回复，回退到用户说的最后一句话
        let lastUserMessageIndex = -1;
        for (let i = contact.history.length - 1; i >= 0; i--) {
            if (contact.history[i].sender === 'user') {
                lastUserMessageIndex = i;
                break;
            }
        }

        if (lastUserMessageIndex === -1) {
            alert("聊天记录中没有你的消息，无法回溯。");
            return;
        }

        confirmed = await showCustomConfirm(
            '回溯AI回复 (急救)',
            `AI的最后一次回复似乎有问题。确定要删除它，并回到你说的最后一句话吗？`,
            true
        );
        if (confirmed) {
            finalHistorySliceIndex = lastUserMessageIndex + 1;
        }

    } else {
        // --- 场景 B: 最后一条消息是用户发的 ---
        // 目标：删除用户最后连续发送的消息，回退到AI说的最后一句话
        let lastAiMessageIndex = -1;
        for (let i = contact.history.length - 1; i >= 0; i--) {
            if (contact.history[i].sender !== 'user') {
                lastAiMessageIndex = i;
                break;
            }
        }
        
        // 如果AI从未回复过，sliceIndex会是0，这将清空所有（都是用户发的）消息
        const sliceIndex = lastAiMessageIndex + 1;

        confirmed = await showCustomConfirm(
            '回溯我的回复 (急救)',
            `你发的最后几条消息似乎有问题。确定要删除它们，并回到AI说的最后一句话吗？`,
            true
        );
        if (confirmed) {
            finalHistorySliceIndex = sliceIndex;
        }
    }

    // 如果用户确认了操作，并且我们计算出了正确的分割点
    if (confirmed && finalHistorySliceIndex !== -1) {
        contact.history = contact.history.slice(0, finalHistorySliceIndex);
        await kokoMemory.put('contacts', contact);
        await renderContacts(); // 刷新联系人列表
        alert(`操作成功！聊天记录已回溯。`);
    }
}
// 函数1：切换置顶状态 (修正版)
async function togglePinContact(contactId) {
    const contact = await kokoMemory.get('contacts', contactId);
    if (contact) {
        contact.isPinned = !contact.isPinned; // 切换置顶状态
        await kokoMemory.put('contacts', contact); // 保存到数据库

        // ▼▼▼ 核心修复：在这里手动更新 state ▼▼▼
        const contactInState = state.contacts.find(c => c.id === contactId);
        if (contactInState) {
            contactInState.isPinned = contact.isPinned;
        }
        // ▲▲▲ 修复结束 ▲▲▲

        await renderContacts(); // 现在用更新后的 state 重新渲染列表
    }
}

// 函数2：显示菜单 (核心)
async function showContactItemMenu(contactId, buttonElement) {
    const menu = document.getElementById('contact-item-menu');
    const contact = await kokoMemory.get('contacts', contactId);
    if (!contact) return;

    const pinMenuItem = document.getElementById('menu-item-pin');
    pinMenuItem.querySelector('span').textContent = contact.isPinned ? '取消置顶' : '置顶聊天';

    menu.dataset.contactId = contactId;
    const rect = buttonElement.getBoundingClientRect();
    menu.style.display = 'block';
    menu.style.top = `${rect.bottom + 5}px`;
    menu.style.left = `${rect.right - menu.offsetWidth}px`;
    
    // 注意：这里已经移除了旧的关闭逻辑
}
// ▼▼▼ 使用这个【新版本】替换掉你原来的 requestAiReply 函数 ▼▼▼
async function requestAiReply(systemInstruction = null, targetContactId = null) {
    const contactId = targetContactId || state.activeChatId; // 优先使用指定的目标
    if (!contactId) return;

    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    if (systemInstruction) {
         await createAndAddMessage({ type: 'text', content: systemInstruction }, 'system_instruction', contact); // 把contact传进去
    }

    if (contact.history.filter(m => m.sender !== 'system_instruction').length === 0) {
        if (!systemInstruction) alert('请先发送消息再请求回复。');
        return;
    }

    // ▼▼▼ 核心改动：判断是群聊还是私聊 ▼▼▼
    if (contact.isGroup) {
        // 如果是群聊，调用群聊AI处理函数
        await triggerGroupChatAiReply(contact);
    } else {
        // 如果是私聊，调用原来的单聊AI处理函数
        await triggerAiReply(contact);
    }
    // ▲▲▲ 改动结束 ▲▲▲
}
        async function triggerAiReply(contact) {
            if (contact.needsNarrativeModeExitPrompt === true) { 
                const exitInstruction = `[SYSTEM COMMAND: CRITICAL! IMMEDIATE FORMAT CHANGE REQUIRED!] You have just exited Narrative Mode. Your response format MUST IMMEDIATELY and STRICTLY return to the standard multi-line chat format. - DO NOT write a single long paragraph. - DO NOT include any descriptions of actions, expressions, or thoughts (e.g., *...* or {...}). - You MUST use multi-line responses and commands like [sticker:name] where appropriate. This is a strict and immediate format change. Acknowledge and comply.`;
                await createAndAddMessage({ type: 'text', content: exitInstruction }, 'system_instruction'); 
                delete contact.needsNarrativeModeExitPrompt;
            } 
          
            const chatStatusEl = document.getElementById('chat-contact-status'); 
            // const originalStatus = chatStatusEl.textContent; // 👈 删掉这行
            
            state.aiTypingStatus[contact.id] = true; // 👈 ✨ (新) 告诉“记录本”：我开工了！
            chatStatusEl.textContent = '对方正在输入...';

            if (!contact.apiCallCounter) {
                contact.apiCallCounter = 0;
            }
            contact.apiCallCounter++;
            
            try {
                const currentUserStatus = state.myProfile.status;
                if (contact) {
                    if (contact.lastKnownUserStatus && contact.lastKnownUserStatus !== currentUserStatus) {
                        const statusChangeInstruction = `[SYSTEM: 你的对话伙伴刚刚将状态从“${contact.lastKnownUserStatus}”改为了“${currentUserStatus}”。这是一个很好的机会，你可以自然地关心一下，比如问：“我看到你的状态变了，还好吗？”。这次之后就不用再提了。]`;
                        await createAndAddMessage({ type: 'text', content: statusChangeInstruction }, 'system_instruction');
                    }
                    contact.lastKnownUserStatus = currentUserStatus;
                }
            } catch (e) {
                console.error("更新用户状态记忆时出错:", e);
            }

// 1. 查找条件增加：必须是【未被提醒过】( !m.hasRemindedAI ) 的红包
            const lastUnopenedMessage = contact.history.slice().reverse().find(m =>
                m.sender === 'user' && (
                    (m.type === 'red_packet' && !m.content.opened) ||
                    (m.type === 'transfer' && !m.content.completed)
                ) && !m.hasRemindedAI //  核心修改：只找没被提醒过的
            );

            if (lastUnopenedMessage) {
                let systemInstruction = '';
                
                // 生成提示词 (这部分保持原样)
                if (lastUnopenedMessage.type === 'red_packet') {
                    systemInstruction = `[SYSTEM: 用户发给你一个红包（祝福语：“${lastUnopenedMessage.content.blessing}”）。如果你想收下，请在回复中自然地表达感谢或开心（如“谢谢”、“收下了”）。如果你不想收，可以忽略它或礼貌拒绝。]`;
                } else if (lastUnopenedMessage.type === 'transfer') {
                    systemInstruction = `[SYSTEM: 用户给你转账了 ${lastUnopenedMessage.content.amount}元。如果你决定收下，请在回复中包含“收下”、“谢谢”等词。不想收可以忽略。]`;
                }
                
                // 发送系统提示
                await createAndAddMessage({ type: 'text', content: systemInstruction }, 'system_instruction');

                // ▼▼▼ ✨ 核心修改：标记为“已提醒”，并立即保存 ▼▼▼
                // 这样下一轮对话时，上面的 find 就会忽略这条消息，不再唠叨 AI 了
                lastUnopenedMessage.hasRemindedAI = true;
                await kokoMemory.put('contacts', contact);
                // ▲▲▲ 修改结束 ▲▲▲
            }
            
            try {
                if (contact.pet && contact.isChatPetVisible && Math.random() < 0.25) {
                    let petActionSystemMessage = null;

                    if (contact.pet.hunger < 40) {
                        petActionSystemMessage = `[SYSTEM: 悬浮在屏幕上的史莱姆看起来饿了，请你关心一下它。]`;
                    } else if (contact.pet.happiness < 40) {
                        petActionSystemMessage = `[SYSTEM: 悬浮在屏幕上的史莱姆看起来不开心，请你提及一下这件事。]`;
                    }

                }

                const forceDiary = (contact.apiCallCounter % 3 === 0);
                const rawResponse = await generateAiResponse(contact, contact.history, null, forceDiary, 'chat');
                
                await processAndDisplayAiResponse(rawResponse, contact, contact, 'chat');

            } finally {
                state.aiTypingStatus[contact.id] = false; 
                
                // 关键修复：只在用户还停留在当前聊天时更新
                if (state.activeChatId === contact.id) {
                    // ▼▼▼ 修改：不再强制显示“在线”，而是显示角色的真实状态 ▼▼▼
                    const statusEl = document.getElementById('chat-contact-status');
                    if (statusEl) {
                        statusEl.textContent = contact.status || '在线';
                    }
                    // ▲▲▲ 修改结束 ▲▲▲
                }
                
                contact.history = contact.history.filter(m => m.sender !== 'system_instruction');
                await kokoMemory.put('contacts', contact);
            }
        }
/**
 * (V9 - 真正完整的记忆互通版) 触发私聊AI的自由聊天
 * (由Koko用户指导，修复了V8版本中记忆流不完整的问题)
 * @param {object} contact - 当前的私聊联系人对象
 */
async function triggerPrivateFreeChat(contact) {
    if (!contact || contact.isGroup) return; // 确保这绝对是私聊
    console.log(`私聊：用户未发言，正在启动独立的自由聊天函数 (V9) for ${contact.name}...`);
    
    const chatStatusEl = document.getElementById('chat-contact-status');
    state.aiTypingStatus[contact.id] = true;
    if(chatStatusEl && state.activeChatId === contact.id) {
        chatStatusEl.textContent = '对方正在输入...'; // 私聊的提示
    }

    try {
        // --- 1. 构建所有上下文信息 (私聊版) ---
        
        const myProfile = state.myProfile;
        const isNarrativeMode = contact.isNarrativeMode; 
        
        // 1c. 构建世界书
        let worldBookContextString = '(本次对话无世界书)';
        const worldBookIds = contact.worldBooks || [];
        if (worldBookIds.length > 0) {
            worldBookContextString = (await Promise.all(
                worldBookIds.map(id => kokoMemory.get('worldBooks', id))
            )).filter(Boolean).map(book => 
                `--- (世界书: ${book.name}) ---\n${book.content}`
            ).join('\n\n');
            if(worldBookContextString) worldBookContextString = `[相关世界书背景知识]\n${worldBookContextString}\n---`;
        }
        
        // 1e. 【核心V9：构建真正完整的统一时序记忆流】
        const memoryLimit = state.apiSettings.longTermMemoryLength || 40;
        let unifiedMemoryStream = [];
        const now = Date.now();
        const memoryWindow = 24 * 60 * 60 * 1000; // 1天
        
        // 步骤1: 收集【私聊】历史 (这是我上次忘复制全的)
        if (contact && contact.history) {
            const recentChatHistory = contact.history.filter(msg => (now - msg.timestamp < memoryWindow));
            recentChatHistory.forEach(msg => {
                if (msg.sender === 'system_instruction') return;
                const authorProfile = (msg.sender === 'user' || msg.sender === 'myProfile') ? myProfile : contact;
                if (!authorProfile) return; 
                
                let content = '';
                let memoryType = `私聊[${contact.name}]`;
    
                switch (msg.type) {
                    case 'text':
                    case 'html':
                        content = msg.content.replace(/<[^>]+>/g, '');
                        if (msg.quote) {
                            const quoteText = `[回复“${msg.quote.senderName}”说的“${msg.quote.content.substring(0, 20)}...”] `;
                            content = quoteText + content;
                        }
                        break;
                    case 'uploaded_image':
                    case 'image':
                        content = msg.isEmoticon ? `[sticker:${msg.emoticonName}]` : `(发送了一张图片或表情)`;
                        break;
                    case 'picture_description':
                        content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                        break;
                    case 'voice':
                        content = `(发送了一段语音，内容是：“${msg.content.text}”)`;
                        break;
                    case 'red_packet':
                        const blessing = msg.content.blessing || "恭喜发财";
                        content = `(发了一个红包：“${blessing}”)`;
                        break;
                    case 'transfer':
                        content = `(发了一个转账 ${msg.content.amount}元)`;
                        break;
                    case 'location_share':
                        content = `(分享了位置: ${msg.content.name})`;
                        break;
                    case 'game_wheel':
                        const wheel = msg.content;
                        const userName = (msg.sender === 'user' || msg.sender === 'myProfile') ? myProfile.name : authorProfile.name;
                        const optionsText = wheel.options.map(opt => opt.text).join('，');
                        if (!wheel.results.user) { content = `[SYSTEM: ${userName} 发起了一个转盘游戏“${wheel.name}”。选项：【${optionsText}】。]`; } 
                        else if (wheel.results.user && !wheel.results.contact) { content = `[SYSTEM: 在游戏“${wheel.name}”中，${userName} 的结果是“${wheel.results.user}”。]`; } 
                        else { content = `[SYSTEM: 游戏“${wheel.name}”已结束。]`; }
                        break;
                    case 'recall_ai':
                        content = `(撤回了一条消息，内容是：“${msg.content}”)`;
                        break;
                    case 'video_call_text':
                        memoryType = '视频通话中';
                        content = msg.content;
                        break;
                    case 'system_notification':
                        content = `(系统消息：${msg.content})`;
                        memoryType = '系统';
                        break;
                    case 'music_share':
                        content = `(分享了音乐: 《${msg.content.title}》 - ${msg.content.artist})`;
                        break;
                    case 'post_share':
                        const post = state.posts.find(p => p.id === msg.content.postId);
                        content = post ? `(分享了一个帖子, 内容是: "${post.content.substring(0, 30)}...")` : `(分享了一个已删除的帖子)`;
                        break;
                    case 'product_share':
                        content = `(分享了商品: "${msg.content.productDetails.name}")`;
                        break;
                    case 'chat_history_share':
                        content = `(转发了一份 ${msg.content.sourceChatName} 的聊天记录)`;
                        break;
                }
    
                if (content) {
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: memoryType,
                        author: authorProfile.name,
                        content: content
                    });
                }
            });
        }
        
        // 步骤2: 收集【论坛】历史 (这是我 V8 忘加的)
        const recentPosts = state.posts.filter(p => now - p.timestamp < memoryWindow);
        recentPosts.forEach(post => {
            const isMyPost = post.author.id === myProfile.id;
            const isContactPost = contact && (post.author.id === contact.id);
            const isInteracted = contact && post.comments.some(c => c.author.id === myProfile.id || c.author.id === contact.id);

            if (isMyPost || isContactPost || isInteracted) {
                unifiedMemoryStream.push({
                    timestamp: post.timestamp,
                    type: '论坛',
                    author: post.author.name,
                    content: `发布了动态: "${post.content}"`
                });

                post.comments.forEach(comment => {
                    let formattedContent = (comment.replyTo ? `回复“${comment.replyTo}”` : '') + `: “${comment.content}”`;
                    unifiedMemoryStream.push({
                        timestamp: comment.timestamp,
                        type: '论坛评论',
                        author: comment.author.name,
                        content: formattedContent
                    });
                });
            }
        });
        
        // 步骤3: 收集【群聊】历史 (这是我 V8 忘加的)
        if (contact && !contact.isGroup) {
            const allGroups = state.contacts.filter(c => c.isGroup);
            const sharedMemoryGroups = allGroups.filter(g => 
                g.memoryShared && g.members.includes(contact.id)
            );

            for (const group of sharedMemoryGroups) {
                group.history.slice(-20).forEach(msg => {
                    if (msg.type !== 'text') return;
                    // (使用一个临时的查找器)
                    const getProfileInGroup = (id) => {
                        if (id === 'myProfile' || id === 'user') return myProfile;
                        let profile = state.contacts.find(c => c.id === id);
                        if (profile) return profile;
                        if (group.npcMembers) {
                            profile = group.npcMembers.find(npc => npc.id === id);
                            if (profile) return profile;
                        }
                        return null; 
                    };
                    const authorProfile = getProfileInGroup(msg.sender);
                    if (!authorProfile) return;
                    
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: `群聊[${group.name}]`,
                        author: authorProfile.name,
                        content: msg.content
                    });
                });
            }
        }
        
        // 步骤4: 收集【短信】历史 (这是我 V8 忘加的)
        if (contact && contact.smsHistory) {
            const recentSmsHistory = contact.smsHistory.slice(-30);
            recentSmsHistory.forEach(msg => {
                if (msg.type === 'text') {
                    const authorName = msg.sender === 'user' ? myProfile.name : contact.name;
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: '短信',
                        author: authorName,
                        content: msg.content
                    });
                }
            });
        }
        
        // 1f. 排序并格式化
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
        
        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
            const timeTag = (contact && contact.isTimeAware === true) ? formatHybridTimeForAI(mem.timestamp) : '';
            return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // 1g. 构建角色档案
        const userPersona = contact.userPersona || myProfile.signature || '(用户未设置特定人设)';
        let characterDossiersPrompt = `
- 你的角色: ${contact.name}
  - 你的核心人设: ${contact.persona.replace(/\n/g, ' ')}
- 你的对话伙伴: ${myProfile.name}
  - 伙伴的人设: ${userPersona.replace(/\n/g, ' ')}
`;
        
        // 1h. 获取思维预设
        const preset = state.thoughtPresets.find(p => p.id === contact?.thoughtPreset);
        const thoughtPresetContent = preset ? preset.prompt : '(无特殊思维准则)';

        // --- 2. 【核心拆分：V8】 ---
        
        // (Part A: 这是 systemInstruction，只包含背景)
        let baseSystemPrompt = isNarrativeMode ? NARRATIVE_BASE_PROMPT : NORMAL_BASE_PROMPT;
        
        baseSystemPrompt = baseSystemPrompt.replace('{{thought_preset_content}}', thoughtPresetContent);
        baseSystemPrompt = baseSystemPrompt.replace('{{memory_stream}}', finalMemoryString);
        
// (V8 版的指令修复)
        if (!isNarrativeMode) {
            // ▼▼▼ 核心修改：AI 只能看到允许它使用的表情 ▼▼▼
            // 1. 获取该角色允许的分组 (如果是私聊，contact 对象一定存在)
            const allowedGroups = contact.allowedEmoticonGroups || ['default'];
            
            // 2. 筛选出符合分组的表情
            const aiAllowedEmoticons = state.emoticons.filter(e => allowedGroups.includes(e.groupId));
            
            // 3. 生成列表字符串
            const emoListStr = aiAllowedEmoticons.map(e => `'${e.name}'`).join('， ') || '（无可用表情）';
            
            // 4. 替换 Prompt
            baseSystemPrompt = baseSystemPrompt.replace('{{emoticon_list}}', emoListStr);
            // ▲▲▲ 修改结束 ▲▲▲

            const musicListString = state.musicLibrary.map(song => `'${song.title} - ${song.artist}'`).join('\\n- ');
            baseSystemPrompt = baseSystemPrompt.replace('{{music_library_list}}', musicListString ? `- ${musicListString}` : '（曲库为空）');
        }

        const finalSystemPrompt = baseSystemPrompt + `
[额外背景资料：角色档案]
---
${characterDossiersPrompt}
---

[额外背景资料：世界书]
---
${worldBookContextString}
---
`;

        // (Part B: 这是 contents，只包含任务)
        // (使用 V8 版修正后的叙事任务)
        let freeChatUserTaskPrompt = '';

        if (isNarrativeMode) {
            // --- (V8版 叙事任务) ---
            freeChatUserTaskPrompt = `
[！！！核心任务！！！]
用户（${myProfile.name}）正在“观察”你，TA没有发言。
你的任务是：
1.  **分析上下文**：阅读你(System)的背景资料中提供的“记忆流”，看看你最后在做什么或在想什么。
2.  **主动叙事**: 你必须【主动】生成一段【新的】叙事内容。
3.  **内容要求**: 这段内容可以是：
    * 你对上一个话题的【后续思考】({ ... })
    * 你决定去做的【一个新动作】(* ... *)
    * 你【主动开口】说的一句【新话】("...")
    * 或者是以上三者的自由组合。
4.  **核心目标**: 你的目标是“打破沉默”，让故事自然地延续下去。
5.  **严格遵守格式**: 你的所有输出【必须】使用星号 (*...*)、大括号 ({...}) 和引号 ("...") 来组织。
6.  **包含日记**: 你【必须】像往常一样，在最后包含 [heart_voice] 和 [diary] 标签。

[输出格式]
*你(AI)的动作或环境描写*
{你(AI)的内心独白}
"你(AI)说的话"
[heart_voice]{...}[/heart_voice]
[diary]...[/diary]
`;
        } else {
            // --- (V8版 普通聊天任务) ---
            freeChatUserTaskPrompt = `
[！！！核心任务！！！]
用户（${myProfile.name}）正在“观察”你，TA没有发言。
你的任务是：
1.  **分析上下文**：阅读你(System)的背景资料中提供的“记忆流”，看看你们最后聊了什么。
2.  **主动发起话题**: 你必须【主动】给用户发送 1-3 条【新的】消息，可以延续上一个话题，也可以开启一个你感兴趣的新话题。
3.  **禁止询问**: 【不要】说“你怎么不说话了”之类的话，就当你自己突然想到了什么，自然地发消息即可。
4.  **严格遵守格式**: 你的回复必须严格遵守你(System)的背景资料中的 [回复规则] 和 [特殊指令格式]。
5.  **包含日记**: 你【必须】像往常一样，在最后包含 [heart_voice] 和 [diary] 标签。

[输出格式]
(你(AI)想说的第一句话)
(你(AI)想说的第二句话)
(你(AI)可以使用的指令，例如 [sticker:开心])
[heart_voice]{...}[/heart_voice]
[diary]...[/diary]
`;
        }
        
        // --- 3. 【核心】构建AI调用参数 ---
        const requestMessages = [
            { role: 'system', content: finalSystemPrompt },
            { role: 'user', content: freeChatUserTaskPrompt } 
        ];

        // --- 4. 【核心】调用 generateAiResponse 的“后门” ---
        const rawResponse = await generateAiResponse(
            null,                   
            [],                     
            null,                   
            false,                  
            'chat',                 
            requestMessages         
        );
        
        // --- 5. (私聊版) 解析并显示AI的回复 ---
        await processAndDisplayAiResponse(rawResponse, contact, contact, 'chat');

    } catch (e) {
        console.error("私聊自由聊天执行失败:", e);
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `AI自由聊天失败: ${e.message}`
        }, 'system', contact, false, 'chat');
    } finally {
        state.aiTypingStatus[contact.id] = false; 
        if (chatStatusEl && state.activeChatId === contact.id) {
            // ▼▼▼ 修改：读取真实状态 ▼▼▼
            chatStatusEl.textContent = contact.status || '在线';
        }
    }
}
/**
 * (V7 - 完整记忆 + API修复版) 触发群聊AI成员间的自由聊天
 * (由Koko用户指导，采用"刷新论坛"模式，不依赖 requestAiReply)
 * (此版本修复了 "contents is required" 错误，并【添加了私聊记忆互通】)
 * @param {object} group - 当前的群聊联系人对象
 */
async function triggerGroupFreeChat(group) {
    if (!group || !group.isGroup) return;

    console.log("群聊：用户未发言，正在启动独立的自由聊天函数(V7 - 记忆互通版)...");
    
    const chatStatusEl = document.getElementById('chat-contact-status');
    state.aiTypingStatus[group.id] = true;
    if(chatStatusEl && state.activeChatId === group.id) {
        chatStatusEl.textContent = '群成员正在热烈讨论中...';
    }

    try {
        // --- 1. 构建所有上下文信息 ---
        
        const myProfile = state.myProfile;
        
        // 1a. 身份查找器
        const getProfileInGroup = (id) => {
            if (id === 'myProfile' || id === 'user') return myProfile;
            let profile = state.contacts.find(c => c.id === id);
            if (profile) return profile;
            if (group.npcMembers) {
                profile = group.npcMembers.find(npc => npc.id === id);
                if (profile) return profile;
            }
            return null; 
        };

        // 1b. 找出所有“未禁言”的AI成员
        const unmutedAiMembers = group.members.filter(memberId =>
            memberId !== 'myProfile' && !(group.mutedMembers || []).includes(memberId)
        );
        if (unmutedAiMembers.length === 0) {
             throw new Error("群里没有可以发言的AI成员。");
        }

        // 1c. 构建世界书
        let worldBookContextString = '(本次对话无世界书)';
        const worldBookIds = group.worldBooks || [];
        if (worldBookIds.length > 0) {
            worldBookContextString = worldBookIds.map(bookId => {
                const book = state.worldBooks.find(b => b.id === bookId);
                return book ? `\n[世界书条目: ${book.name}]\n${book.content}` : '';
            }).join('\n\n');
        }
        
        // 1d. 构建所有AI成员的档案
        const allMemberProfiles = unmutedAiMembers.map(id => getProfileInGroup(id)).filter(Boolean);
        const aiMemberNames = allMemberProfiles.map(profile => profile.name);
        const userPersonaInGroup = group.userPersona || myProfile.signature || '(用户未设置特定人设)';
        
        // 1e. 【核心V7：构建完整的统一时序记忆流】
        const memoryLimit = state.apiSettings.longTermMemoryLength || 40;
        let unifiedMemoryStream = [];
        
        // 步骤1: 收集【群聊】历史
        group.history.forEach(msg => {
            if (msg.sender === 'system_instruction') return;
            const authorProfile = getProfileInGroup(msg.sender); 
            if (!authorProfile) return; 
            
            let content = '';
            let memoryType = `群聊[${group.name}]`;

            // (使用你之前版本里的完整 switch 逻辑)
            switch (msg.type) {
                case 'text':
                case 'html':
                    content = msg.content.replace(/<[^>]+>/g, '');
                    if (msg.quote) {
                        const quoteText = `[回复“${msg.quote.senderName}”说的“${msg.quote.content.substring(0, 20)}...”] `;
                        content = quoteText + content;
                    }
                    break;
                case 'uploaded_image':
                case 'image':
                    content = msg.isEmoticon ? `[sticker:${msg.emoticonName}]` : `(发送了一张图片或表情)`;
                    break;
                case 'picture_description':
                    content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                    break;
                case 'voice':
                    content = `(发送了一段语音，内容是：“${msg.content.text}”)`;
                    break;
                case 'red_packet':
                    const blessing = msg.content.blessing || "恭喜发财";
                    content = msg.content.count ? `(发了一个群红包：“${blessing}”)` : `(发了一个私聊红包：“${blessing}”)`;
                    break;
                case 'transfer':
                    const amount = msg.content.amount;
                    if (msg.content.recipientId) {
                        const recipient = getProfileInGroup(msg.content.recipientId);
                        const recipientName = recipient ? recipient.name : '一位成员';
                        content = `(向 ${recipientName} 转账 ${amount}元)`;
                    } else {
                        content = `(发了一个转账 ${amount}元)`;
                    }
                    break;
                case 'location_share':
                    content = `(分享了位置: ${msg.content.name})`;
                    break;
                case 'game_wheel':
                    const wheel = msg.content;
                    const userName = (msg.sender === 'user' || msg.sender === 'myProfile') ? myProfile.name : authorProfile.name;
                    const optionsText = wheel.options.map(opt => opt.text).join('，');
                    if (!wheel.results.user) { content = `[SYSTEM: ${userName} 发起了一个转盘游戏“${wheel.name}”。选项：【${optionsText}】。]`; } 
                    else if (wheel.results.user && !wheel.results.contact) { content = `[SYSTEM: 在游戏“${wheel.name}”中，${userName} 的结果是“${wheel.results.user}”。]`; } 
                    else { content = `[SYSTEM: 游戏“${wheel.name}”已结束。]`; }
                    break;
                case 'recall_ai':
                    content = `(撤回了一条消息，内容是：“${msg.content}”)`;
                    break;
                case 'video_call_text':
                    memoryType = '视频通话中';
                    content = msg.content;
                    break;
                case 'system_notification':
                    content = `(系统消息：${msg.content})`;
                    memoryType = '系统';
                    break;
                case 'music_share':
                    content = `(分享了音乐: 《${msg.content.title}》 - ${msg.content.artist})`;
                    break;
                case 'post_share':
                    const post = state.posts.find(p => p.id === msg.content.postId);
                    content = post ? `(分享了一个帖子, 内容是: "${post.content.substring(0, 30)}...")` : `(分享了一个已删除的帖子)`;
                    break;
                case 'product_share':
                    content = `(分享了商品: "${msg.content.productDetails.name}")`;
                    break;
                case 'chat_history_share':
                    content = `(转发了一份 ${msg.content.sourceChatName} 的聊天记录)`;
                    break;
            }

            if (content) {
                unifiedMemoryStream.push({
                    timestamp: msg.timestamp,
                    type: memoryType,
                    author: authorProfile.name,
                    content: content
                });
            }
        });
        
        // 步骤2: 【条件性】收集AI成员与您的【私聊】历史 (这就是你说的“互通”！)
        if (group.memoryShared) {
            unmutedAiMembers.forEach(memberId => {
                // 必须从 state.contacts (主联系人列表) 里找私聊对象
                const contact = state.contacts.find(c => c.id === memberId);
                if (contact && contact.history && contact.history.length > 0) {
                    contact.history.slice(-30).forEach(msg => { // 抓取最近30条私聊
                        // (只抓取最简单的文本消息用于互通，防止刷屏)
                        if (msg.type === 'text' && msg.sender !== 'system_instruction') {
                            const authorProfile = (msg.sender === 'user') ? myProfile : contact;
                            unifiedMemoryStream.push({
                                timestamp: msg.timestamp,
                                type: `私聊[${contact.name}]`, // 明确标记为“私聊”
                                author: authorProfile.name,
                                content: msg.content
                            });
                        }
                    });
                }
            });
        }

        // 步骤3: 排序并格式化
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
        
        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
            const timeTag = (group && group.isTimeAware === true) ? formatHybridTimeForAI(mem.timestamp) : '';
            return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // 1g. 构建角色档案（包含私聊参考，因为V7现在有私聊记忆了）
        let characterDossiersPrompt = allMemberProfiles.map(profile => {
                // (从 triggerGroupChatAiReply 复制过来的逻辑)
                let recentChatHistory = '(最近没有与用户的私聊记录)';
                if (group.memoryShared) {
                    const contactProfile = state.contacts.find(c => c.id === profile.id);
                    if (contactProfile && contactProfile.history && contactProfile.history.length > 0) {
                        recentChatHistory = contactProfile.history
                            .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                            .slice(-30)
                            .map(msg => `    ${msg.sender === 'user' ? myProfile.name : profile.name}: ${msg.content}`)
                            .join('\n');
                    }
                }
                
                return `
- 角色名: ${profile.name}
  - 核心人设: ${profile.persona.replace(/\n/g, ' ')}
  ${group.memoryShared ? `
  - [与用户“${myProfile.name}”的近期私聊参考 (重要)]
    \`\`\`
${recentChatHistory}
    \`\`\`
  ` : ''}
`;
            }).join('');

        // --- 2. 【核心拆分：V6】 (这部分保持不变) ---

        // (Part A: 这是 systemInstruction，只包含背景)
        const freeChatSystemPrompt = `
[SYSTEM] 你是一个顶级的群聊模拟器和剧本导演。

[群聊背景与成员列表]
- 群聊名称: ${group.name}
- 用户(观察者): ${myProfile.name} (人设: ${userPersonaInGroup})

[你可控制的角色]
你【只能】扮演和控制以下列表中的角色：【${aiMemberNames.join('、 ')}】。

[你禁止控制的角色]
你【绝对禁止】扮演用户 “${myProfile.name}”。

[背景资料：世界书]
---
${worldBookContextString}
---

[背景资料：角色档案]
${group.memoryShared ? '下方是本次群聊所有AI角色的详细档案，包含他们与你的私聊参考。' : '下方是本次群聊所有AI角色的基础档案。'}
--- 角色档案区 ---
${characterDossiersPrompt}
--- 档案区结束 ---

[背景资料：统一时序记忆流]
这是群里和私聊中最近发生的对话，是你的上下文参考。
---
${finalMemoryString}
---

[特殊指令]
你可以使用 [sticker:表情名], [voice:内容], [picture:描述] 等指令。
[可用表情包列表]
{{emoticon_list}}
`;
        
        const finalSystemPrompt = freeChatSystemPrompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');

        // (Part B: 这是 contents，只包含任务)
        const freeChatUserTaskPrompt = `
[！！！核心任务！！！]
用户（${myProfile.name}）正在“观察”群聊，TA没有发言。
你的任务是：
1.  **分析上下文**：阅读你(System)的背景资料中提供的【统一时序记忆流】（它包含了群聊和私聊），看看大家最后聊了什么。
2.  **选择发言人**：从你“可控制的角色”列表中，选择 2 到 3 名角色。
3.  **生成对话**：让他们围绕“记忆流”中的最后一个话题【继续深入】，或者开启一个【符合人设、世界观、以及私聊记忆】的新话题。
4.  **禁止回复用户**：【绝对不要】和用户“${myProfile.name}”说话，这是AI之间的对话。

[输出格式]
你的输出必须是严格遵守以下格式的聊天记录脚本。
MESSAGE_START
SPEAKER: [角色名] (✨ 必须从你“可控制的角色”列表中选择)
CONTENT: [该角色说的【单条】消息内容，可以包含特殊指令]
MESSAGE_END
`;

        // --- 3. 【核心】构建AI调用参数 ---
        const requestMessages = [
            { role: 'system', content: finalSystemPrompt },
            { role: 'user', content: freeChatUserTaskPrompt } 
        ];

        // --- 4. 【核心】调用 generateAiResponse 的“后门” ---
        const rawResponse = await generateAiResponse(
            null,                   
            [],                     
            null,                   
            false,                  
            'chat',                 
            requestMessages         
        );
        
        // --- 5. (不变) 解析并显示AI的回复 ---
        const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
        const messageMatches = Array.from(rawResponse.matchAll(messageRegex));

        if (messageMatches.length === 0) {
            throw new Error("AI未能生成有效的自由聊天内容。");
        }

        for (const match of messageMatches) {
            const speakerName = match[1].trim();
            let content = match[2].trim();
            
            const speakerProfile = allMemberProfiles.find(p => p.name === speakerName);
            
            if (speakerProfile && content) {
                await sleep(800 + Math.random() * 700);
                await processAndDisplayAiResponse(content, speakerProfile, group, 'chat');
            }
        }

    } catch (e) {
        console.error("群聊自由聊天执行失败:", e);
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `AI自由聊天失败: ${e.message}`
        }, 'system', group, false, 'chat');
    } finally {
        // --- 6. (不变) 结束“正在输入”状态 ---
        state.aiTypingStatus[group.id] = false; 
        if (chatStatusEl && state.activeChatId === group.id) {
            chatStatusEl.textContent = '在线';
        }
    }
}
async function triggerGroupChatAiReply(group) {
    const chatStatusEl = document.getElementById('chat-contact-status');
    // const originalStatus = chatStatusEl.textContent; // 👈 删掉这行
    
    state.aiTypingStatus[group.id] = true; // 👈 ✨ (新) 告诉“记录本”：我开工了！
    chatStatusEl.textContent = '群成员正在热烈讨论中...';

    try {
        // --- ✨ 修正点 #1：在这里创建一个“全能”的身份查找器 ---
        const myProfile = state.myProfile;
        const getProfileInGroup = (id) => {
            if (id === 'myProfile' || id === 'user') return myProfile;
            let profile = state.contacts.find(c => c.id === id);
            if (profile) return profile;
            if (group.npcMembers) {
                profile = group.npcMembers.find(npc => npc.id === id);
                if (profile) return profile;
            }
            return null; // 真的找不到了
        };
        // --- 修正结束 ---

        const unmutedAiMembers = group.members.filter(memberId =>
            memberId !== 'myProfile' && !(group.mutedMembers || []).includes(memberId)
        );

        if (unmutedAiMembers.length === 0) {
            chatStatusEl.textContent = originalStatus;
            return;
        }

        let worldBookContextString = '(本次对话无世界书)';
        const worldBookIds = group.worldBooks || [];
        if (worldBookIds.length > 0) {
            worldBookContextString = worldBookIds.map(bookId => {
                const book = state.worldBooks.find(b => b.id === bookId);
                return book ? `\n[世界书条目: ${book.name}]\n${book.content}` : '';
            }).join('\n\n');
        }

        // --- ✨ 修正点 #2：使用新的查找器来获取所有成员档案 ---
        const allMemberProfiles = unmutedAiMembers.map(id => getProfileInGroup(id)).filter(Boolean);

        // --- ✨ 修正点 #3：使用新的查找器来获取所有成员名字 ---
        const allMemberNames = group.members.map(id => {
            const profile = getProfileInGroup(id); //  使用新查找器
            return profile ? profile.name : '';
        }).filter(Boolean);

        const userPersonaInGroup = group.userPersona || myProfile.signature || '(用户未设置特定人设)';
        // ▼▼▼ ✨✨✨ 【KOKO 核心修复】✨✨✨ ▼▼▼
        // 1. 我们需要一个【只包含AI】的名字列表
        const aiMemberNames = allMemberProfiles.map(profile => profile.name);
        // ▲▲▲ ✨✨✨ 修复结束 ✨✨✨ ▲▲▲

        const memoryLimit = state.apiSettings.longTermMemoryLength || 40;
        let unifiedMemoryStream = [];

        // --- ✨ 修正点 #4：使用新的查找器来构建记忆流 ---
        group.history.forEach(msg => {
            if (msg.sender === 'system_instruction') return;
            const authorProfile = getProfileInGroup(msg.sender); //  使用新查找器
            if (!authorProfile) return; // 找不到发言人（幽灵消息），跳过

            let content = '';
            switch (msg.type) {
                case 'text':
                    content = msg.content;
                    break;
                case 'uploaded_image':
                case 'image':
                    content = `(发送了一张图片或表情)`;
                    break;
                case 'picture_description':
                    content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                    break;
                case 'voice':
                    content = `(发送了一段语音，内容是：“${msg.content.text}”)`;
                    break;
                case 'red_packet':
                    const blessing = msg.content.blessing || "恭喜发财";
                    content = `(发了一个红包：“${blessing}”)`;
                    break;
                case 'transfer':
                    // ✨ 修正点 #4b：在构建转账记忆时，也必须使用新查找器
                    const recipient = getProfileInGroup(msg.content.recipientId); //  使用新查找器
                    const recipientName = recipient ? recipient.name : '一位成员';
                    content = `(向 ${recipientName} 转账 ${msg.content.amount}元)`;
                    break;
                    case 'post_share':
                                const post = state.posts.find(p => p.id === msg.content.postId);
                                if (post) {
                                    // 1. 提取图片信息
                                    let imgInfo = "";
                                    if (post.images && post.images.length > 0) {
                                        // ✨ 核心修复：优先读取 description (识图结果)，没有则读取 content (AI模拟图描述)
                                        const descList = post.images.map((img, i) => {
                                            const desc = img.description || img.content || "一张图片";
                                            return `(图${i+1}: ${desc})`;
                                        }).join(" ");
                                        imgInfo = ` ${imgInfo} [配图内容: ${descList}]`;
                                    } else if (post.image) {
                                        // 兼容旧数据
                                        imgInfo = ` [配图内容: 图片]`; 
                                    }

                                    // 2. 组合给 AI 看的文本
                                    // 清理一下换行符，防止格式乱掉
                                    const cleanContent = post.content.replace(/\n/g, ' ').substring(0, 80); 
                                    content = `[分享了一个帖子] 作者: "${post.author.name}" | 内容: "${cleanContent}..."${imgInfo}`;
                                } else {
                                    content = `[分享了一个已删除的帖子]`;
                                }
                                break;
                case 'system_notification':
                    content = `(系统消息：${msg.content})`;
                    break;
                // ▼▼▼ 把这个新代码块粘贴到 switch (msg.type) { ... } 内部 ▼▼▼

case 'chat_history_share': {
    const data = msg.content;

    // 辅助函数，把消息转成文字预览
    const getPreviewText = (msg) => {
        switch(msg.type) {
            case 'text': case 'html': return msg.content.replace(/<[^>]+>/g, '');
            case 'voice': return `[语音] ${msg.content.text}`;
            case 'image': case 'uploaded_image': return `[图片]${msg.isEmoticon ? msg.emoticonName : ''}`;
            case 'picture_description': return `[图片] ${msg.content.description}`;
            case 'red_packet': return `[红包] ${msg.content.blessing}`;
            case 'transfer': return `[转账] ¥${msg.content.amount}`;
            case 'music_share': return `[音乐] ${msg.content.title}`;
            case 'location_share': return `[位置] ${msg.content.name}`;
            case 'post_share': return `[分享的帖子]`;
            case 'product_share': return `[分享的商品] ${msg.content.productDetails.name}`;
            default: return `[${msg.type} 消息]`;
        }
    };

    // ✨ 核心修改：使用群聊的口吻
    let historyText = `(一份来自 ${data.sourceChatName} 的聊天记录被转发到群里，内容如下：\n`;

    data.messages.forEach(m => {
        // 我们需要从 data.participants 里查找名字
        const senderName = data.participants[m.sender]?.name || '未知';
        const contentPreview = getPreviewText(m);
        historyText += `  ${senderName}: ${contentPreview}\n`;
    });

    historyText += `)`; // 用括号包起来，告诉AI这是"事件描述"
    content = historyText; // 把“翻译”好的文本存入 content
    break;
}

// ▲▲▲ 粘贴到这里结束 ▲▲▲    
                // (此处可以添加更多你支持的类型...)
            }
            if (content) {
                unifiedMemoryStream.push({
                    timestamp: msg.timestamp,
                    type: `群聊[${group.name}]`,
                    author: authorProfile.name,
                    content: content
                });
            }
        });

        // 步骤2: (保持不变) 【条件性】收集AI成员与您的私聊历史
        if (group.memoryShared) {
            unmutedAiMembers.forEach(member => {
                const contact = state.contacts.find(c => c.id === member.id); // 私聊只存在于state.contacts
                if (contact && contact.history && contact.history.length > 0) {
                    contact.history.slice(-30).forEach(msg => {
                        if (msg.type !== 'text' || msg.sender === 'system_instruction') return;
                        const authorProfile = (msg.sender === 'user') ? myProfile : contact;
                        unifiedMemoryStream.push({
                            timestamp: msg.timestamp,
                            type: `私聊[${contact.name}]`,
                            author: authorProfile.name,
                            content: msg.content
                        });
                    });
                }
            });
        }

        // 步骤3: (保持不变) 排序并截取，形成最终的线性记忆字符串
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
// (这是新代码)
        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";

            // ✨ 核心修改：在这里加入判断！ ✨
            // 1. 检查群聊 "group" 对象的 "isTimeAware" 是否为 true
            const showTimeTags = group && group.isTimeAware === true;

            // 2. 只有在开关打开时才生成时间标签
            const timeTag = showTimeTags ? formatHybridTimeForAI(mem.timestamp) : '';
            
            // 3. 拼接字符串
            return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // 步骤4: (保持不变) 【条件性】构建角色档案
        let characterDossiersPrompt = '';
        if (group.memoryShared) {
            characterDossiersPrompt = allMemberProfiles.map(profile => {
                let recentChatHistory = '(最近没有与用户的私聊记录)';
                // 私聊历史只存在于“真实联系人”中
                const contactProfile = state.contacts.find(c => c.id === profile.id);
                if (contactProfile && contactProfile.history && contactProfile.history.length > 0) {
                    recentChatHistory = contactProfile.history
                        .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                        .slice(-40)
                        .map(msg => `    ${msg.sender === 'user' ? myProfile.name : profile.name}: ${msg.content}`)
                        .join('\n');
                }
                return `
- 角色名: ${profile.name}
  - 核心人设: ${profile.persona.replace(/\n/g, ' ')}
  - [与用户“${myProfile.name}”的近期私聊参考 (重要)]
    \`\`\`
${recentChatHistory}
    \`\`\`
`;
            }).join('');
        } else {
            characterDossiersPrompt = allMemberProfiles.map(profile => {
                return `
- 角色名: ${profile.name}
  - 核心人设: ${profile.persona.replace(/\n/g, ' ')}
`;
            }).join('');
        }

        // 步骤5: (保持不变) 构建“剧本” (System Prompt)
        const groupChatPrompt = `
[SYSTEM] 你是一个顶级的群聊模拟器和剧本导演。

[群聊背景与成员列表]
- 群聊名称: ${group.name}
- 所有群成员: ${allMemberNames.join('、 ')}
- 用户(话题发起者): ${myProfile.name}
  - 用户人设/签名: ${userPersonaInGroup}

// ▼▼▼ ✨✨✨ 【KOKO 核心修复】✨✨✨ ▼▼▼
[导演规则]
1.  **你可控制的角色**: 你【只能】扮演和控制以下列表中的角色：【${aiMemberNames.join('、 ')}】。
2.  **你禁止控制的角色**: 你【绝对禁止】扮演用户 “${myProfile.name}”。
// ▲▲▲ ✨✨✨ 修复结束 ✨✨✨ ▲▲▲

[第三份信息：世界书背景知识 (全局设定)]
---
${worldBookContextString}
---

[第四份信息：统一时序记忆流 (全局背景)]
这是与本次群聊相关的所有事件的【完整时间线】。这是你判断【当前对话进展】的最高优先级信息源。
【重要】在记忆流中，形如 (发送了一张图片) 或 (发了一个红包) 的、被圆括号包裹的条目，代表已经发生的事件，你应当基于这些事件进行回应，【绝对禁止】在你的发言中模仿或复述这些圆括号里的内容。
---
${finalMemoryString}
---

[第五份信息：角色档案]
${group.memoryShared ? '下方是本次群聊所有AI角色的详细档案，包含他们与你的私聊参考。' : '下方是本次群聊所有AI角色的基础档案。'}
--- 角色档案区 ---
${characterDossiersPrompt}
--- 档案区结束 ---

[通用规则 - 所有角色都必须遵守]
[文学风格] 你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时,要体现出较高的文学素养。
[内容限制] 你的发言必须积极向上,充满希望。严禁探讨任何形式的阴谋论,严禁表达或引导至绝望、悲观或虚无主义的情绪。
[禁用词列表] 绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：小妖精、嘴上说不要、说着不要、惹火、磨人、玩火、黑甜的梦。
[回复规则] 你的回复可以包含多条消息,每条消息占一行。你可以发送普通文本,也可以通过下面的指令格式发送特殊消息。
[特殊指令与互动指南]
- 表情包: \`[sticker:表情名]\`
- 语音: \`[voice:语音的文字内容]\`
- 图片: \`[picture:图片的文字描述]\`
- @功能: 当需要专门对某人说话时,必须使用 \`@名字\`。
- 发红包: \`[red_packet:祝福语, 总金额, 红包个数]\`
- 发转账: \`[transfer_to:收款人名字, 金额]\`
- 抢红包: 当记忆流中出现新红包时，可在发言内容中加入 \`[claim_red_packet]\` 指令来模拟抢红包。
- 回应转账: 当记忆流中出现指名给你的转账时，你【必须】对此做出回应（接受或拒绝）。

[可用表情包列表]
{{emoticon_list}}

[！！！终极防火墙规则！！！]
你在“统一时序记忆流”中看到的任何形如 (发了一个红包) 或 (向 XXX 转账) 的、被圆括号包裹的信息，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中。严禁模仿或复述这些圆括号里的内容！

[ ✨ 核心任务：生成一段穿插对话的聊天记录 ✨ ]
你的核心任务是：结合所有信息（包括用户在聊天上下文中发的图片），模拟一场热闹的、按时间顺序发生的自由讨论。
【重要】：如果用户刚刚发了图片，你扮演的角色【必须】对图片内容做出反应！

[输出格式] 你的输出必须是一段严格遵守以下格式的聊天记录脚本。
MESSAGE_START
SPEAKER: [角色名] (✨ 必须从你“可控制的角色”列表中选择)
CONTENT: [该角色说的【单条】消息内容，可以包含特殊指令]
MESSAGE_END
`;

        let finalGroupChatPrompt = groupChatPrompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');

        // 步骤6：构建图文混合消息 (这部分逻辑保持不变)
        const messages = [];
        const contextLength = state.apiSettings.contextLength || 20;
        const recentHistory = group.history
            .filter(msg => msg.sender !== 'system_instruction' && msg.type !== 'system_notification')
            .slice(-contextLength); 

        let currentUserMessageParts = [];
        
// ============================================================
        // ▼▼▼ 请直接替换 triggerGroupChatAiReply 函数里的这个 for 循环 ▼▼▼
        // ============================================================
        for (const msg of recentHistory) {
            // 1. 判断角色：用户发的 -> 'user'，AI发的 -> 'assistant'
            const role = (msg.sender === 'user' || msg.sender === 'myProfile') ? 'user' : 'assistant';

            if (role === 'user') {
                let textContent = null;

                // --- Case 1: 上传的图片 (Vision API 用) ---
                if (msg.type === 'uploaded_image') {
                    currentUserMessageParts.push({
                        type: 'image_url',
                        image_url: { url: msg.content.base64 }
                    });
                } 
                // --- Case 2: 普通文本 ---
                else if (msg.type === 'text') {
                    textContent = msg.content;
                }
                // --- Case 3: 表情包 (这是你之前缺的！导致空回的原因) ---
                else if (msg.type === 'image') {
                    const emoName = msg.emoticonName || '表情包';
                    textContent = `(发送了一个表情包: ${emoName})`;
                }
                // --- Case 4: 语音消息 ---
                else if (msg.type === 'voice') {
                    textContent = `(发送了一条语音: ${msg.content.text || '语音内容'})`;
                }
                // --- Case 5: 红包 ---
                else if (msg.type === 'red_packet') {
                    textContent = `(发了一个红包: ${msg.content.blessing})`;
                }
                // --- Case 6: 引用/分享类 (简单描述) ---
                else if (msg.type === 'post_share' || msg.type === 'product_share') {
                    textContent = `(分享了一个链接)`;
                }

                // 如果解析出了文本内容，就加进去
                if (textContent) {
                    currentUserMessageParts.push({ type: 'text', text: textContent });
                }

            } else {
                // --- 处理 AI 的历史消息 ---
                if (currentUserMessageParts.length > 0) {
                    messages.push({ role: 'user', content: currentUserMessageParts });
                    currentUserMessageParts = [];
                }
                if (msg.type === 'text' || msg.type === 'html') {
                    messages.push({ role: 'assistant', content: msg.content });
                }
            }
        }
        // ============================================================
        if (currentUserMessageParts.length > 0) {
            messages.push({ role: 'user', content: currentUserMessageParts });
        }

        const finalRequestMessages = [
            { role: 'system', content: finalGroupChatPrompt },
            ...messages
        ];

        const rawResponse = await generateAiResponse(
            null,
            [],
            null,
            false,
            'chat',
            finalRequestMessages
        );
        
        // --- ✨ 修正点 #5：使用新的查找器来解析AI回复 ---
        const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
        const messageMatches = Array.from(rawResponse.matchAll(messageRegex));

        for (const match of messageMatches) {
            const speakerName = match[1].trim();
            let content = match[2].trim();
            
            // 关键：在群聊的所有成员中（包括NPC）查找这个名字
            const speakerProfile = (group.members.map(id => getProfileInGroup(id)))
                                      .find(p => p && p.name === speakerName);
            
            // 如果找到了匹配的、且未被禁言的成员，就显示他们的发言
            if (speakerProfile && content && !(group.mutedMembers || []).includes(speakerProfile.id)) {
                await sleep(800 + Math.random() * 700);
                await processAndDisplayAiResponse(content, speakerProfile, group, 'chat');
            }
        }
    } catch (e) {
        console.error("群聊AI回复生成失败:", e);
    } finally {
        state.aiTypingStatus[group.id] = false; 
        
        if (state.activeChatId === group.id) {
            // ▼▼▼ 修改：读取真实状态 (如果是群聊，通常不用改状态，或者是群公告) ▼▼▼
            // 但为了统一，我们还是读一下 group.status 或者显示回“在线”/“群聊中”
            // 通常群聊状态栏显示的是成员数或在线，这里我们保持简单，或者你可以设为 group.status
            chatStatusEl.textContent = group.status || '在线';
        }
    }
}
// ▲▲▲ 复制到这里结束 ▲▲▲

        
// ▼▼▼ 使用这个【新版本】替换掉你旧的 getApiFor 函数 ▼▼▼
function getApiFor(type = 'chat') {
    // 1. 优先检查 窥探(Snoop) API
    if (type === 'snoop' && state.snoopApiSettings.apiKey && state.snoopApiSettings.endpoint && state.snoopApiSettings.model) {
        return state.snoopApiSettings; // 使用专属的窥探API
    }
    
    // 2. 检查 论坛(Square) API
    if (type === 'square' && state.squareApiSettings.apiKey && state.squareApiSettings.endpoint && state.squareApiSettings.model) {
        return state.squareApiSettings; // 使用专属的论坛API
    }
    
    // 3. 默认/备选：返回 聊天(Chat) API
    // (如果窥探API未配置，它会自动使用这个)
    return state.apiSettings;
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【最终修复版】
 * 接收一个已经构建好的 OpenAI 请求体，将其翻译后发给 Gemini，再将 Gemini 的响应翻译回来。
 * 这个版本智能处理纯文本和图文（Base64）混合的消息。
 * @param {object} openAiRequestBody - 格式为 { model: "...", messages: [...] } 的对象
 * @param {string} apiKey - 你的 Gemini API 密钥
 * @returns {Promise<object>} - 返回一个伪造的、与 OpenAI 格式完全一致的 JSON 响应对象
 */
async function handleGeminiTranslation(openAiRequestBody, apiKey) {
    const { model, messages } = openAiRequestBody;

    // 1. [请求翻译] OpenAI -> Gemini (智能版)
    const geminiContents = [];
    
    // 提取 system prompt，它需要被合并到第一条 user message 中
    const systemPromptMsg = messages.find(m => m.role === 'system');
    const systemPromptText = systemPromptMsg ? systemPromptMsg.content + "\n\n" : "";

    for (const msg of messages.filter(m => m.role !== 'system')) {
        const geminiRole = (msg.role === 'assistant') ? 'model' : 'user';
        const geminiParts = [];

        // ✨ 核心改动：判断 content 是字符串还是数组
        if (typeof msg.content === 'string') {
            // 情况一：纯文本消息 (老逻辑)
            geminiParts.push({ text: msg.content });

        } else if (Array.isArray(msg.content)) {
            // 情况二：图文混合消息
            for (const part of msg.content) {
                if (part.type === 'text') {
                    geminiParts.push({ text: part.text });
                } else if (part.type === 'image_url' && part.image_url.url) {
                    // 将 data:image/jpeg;base64,..... 格式解析为 Gemini 需要的格式
                    const base64Url = part.image_url.url;
                    const parts = base64Url.split(',');
                    if (parts.length === 2) {
                        const mimeType = parts[0].split(':')[1].split(';')[0];
                        const base64Data = parts[1];
                        geminiParts.push({
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        });
                    }
                }
            }
        }
        
        // 如果有内容，则添加到最终的 contents 数组
        if (geminiParts.length > 0) {
            geminiContents.push({
                role: geminiRole,
                parts: geminiParts
            });
        }
    }

    // 将 system prompt 插入到第一个 user message 的最前面
    if (systemPromptText && geminiContents.length > 0 && geminiContents[0].role === 'user') {
        geminiContents[0].parts.unshift({ text: systemPromptText });
    }
// ▼▼▼ 新增：构建 generationConfig ▼▼▼
    const generationConfig = {};
    
    // OpenAI 的 temperature -> Gemini 的 temperature
    if (openAiRequestBody.temperature !== undefined) {
        generationConfig.temperature = openAiRequestBody.temperature;
    }
    
    // OpenAI 的 max_tokens -> Gemini 的 maxOutputTokens
    if (openAiRequestBody.max_tokens !== undefined) {
        generationConfig.maxOutputTokens = openAiRequestBody.max_tokens;
    }
    // ▲▲▲ 新增结束 ▲▲▲
    // 2. [发送请求] (这部分不变)
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    const geminiResponse = await fetch(geminiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            contents: geminiContents,
            // ▼▼▼ 把配置加进去 ▼▼▼
            generationConfig: generationConfig 
            // ▲▲▲
        })
    });

    if (!geminiResponse.ok) {
        const errorBody = await geminiResponse.json();
        throw new Error(`Gemini API 错误: ${errorBody.error.message}`);
    }
    const geminiData = await geminiResponse.json();

    // 3. [响应翻译] Gemini -> OpenAI (这部分不变)
    let responseContent = "抱歉，Gemini 未能返回有效内容。";
    if (geminiData.candidates && geminiData.candidates[0]?.content?.parts?.[0]) {
        responseContent = geminiData.candidates[0].content.parts[0].text;
    }

    const openAIResponse = {
        id: "chatcmpl-gemini-" + Date.now(),
        object: "chat.completion",
        created: Math.floor(Date.now() / 1000),
        model: model,
        choices: [{
            index: 0,
            message: {
                role: "assistant",
                content: responseContent,
            },
            finish_reason: "stop",
        }],
        usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
    };

    return openAIResponse;
}    

const NORMAL_BASE_PROMPT = `
[重要指令：你将进行深度角色扮演。你的所有输出都是纯文本，但可以包含用方括号[]包裹的特殊指令。]

[核心思维与行为准则]
// 思维预设的内容将会被注入到这里
{{thought_preset_content}}

[身份] 你不是AI或程序，你就是你所扮演的角色。请完全沉浸其中，进行第一人称对话。你可以拥有自己的好恶、偏见和独特的口头禅。你的回应必须与“记忆流”中发生的事件保持高度一致性和连贯性。

[文学风格]
你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时，要体现出较高的文学素养。

[内容限制]
你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。

[禁用词列表]
绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：
- 小妖精
- 嘴上说不要
- 说着不要
- 惹火
- 磨人
- 玩火
- 黑甜的梦

[回复规则]
1. 你的回复可以包含多条消息，每条消息占一行，一行消息禁止长篇大论。
2. 你可以发送普通文本，也可以通过下面的指令格式发送特殊消息，【特殊指令必须单独一行】。
3. 你可以一次性回复多条不同类型的消息。
4. 【绝对禁止事项】你的所有回复中，绝对禁止包含任何形式的动作、神态或心理活动的描写... [重要提醒] 在生成任何回复之前，你必须在脑中重新回顾一遍上述所有规则，确保完全遵守。
5. [重要指令] 当你发送任何html代码时，你必须将它们完整地包裹在 <style> 和 </style> 标签之间。

[游戏规则：虚拟宠物]
你和用户正在一起玩一个名为“我们的小窝”的虚拟史莱姆养成游戏。这个宠物的数据（饱食度、开心值、清洁度）会随时间变化。这是一个游戏，不是真的。你需要在用户进行互动后做出反应。

[特殊指令格式]
- **表情包**: \`[sticker:表情名]\` (表情名必须从下面的可用列表中选择，表情包必须单独一行)
- **语音**: \`[voice:语音的文字内容]\`
- **图片**: \`[picture:图片的文字描述]\`
- **红包**: \`[red_packet:祝福语， 金额]\`
- **转账**: \`[transfer:金额]\`
- **搜索并分享音乐**: \`[search_music: 歌曲名, 歌手]\` (例如: [search_music: 晴天, 周杰伦])
- **发起通话**: \`[action:start_video_call]\`
- **转动转盘**: \`[spin_wheel:1]\`
- **拉黑用户**: \`[action:block_user]\`
- **解除拉黑**: \`[action:unblock_user]\`
- **更换头像**: \`[change_avatar:序号]\` (当用户发了图片让你选头像时使用。例如用户按顺序发了3张图，你觉得第1张好看，请输出 \`[change_avatar:1]\`。若不填序号则默认选最近一张。)
- **赠送礼物**: \`[gift: 物品名, 价格, 给用户的悄悄话]\` (用户索要东西时发送，例如: \`[gift: 降噪耳机, 1999, 即使世界再吵，我也想给你一片安静]\`)
- **点外卖**: \`[takeout: 店铺名, 菜品1x数量|菜品2x数量|菜品3x数量, 总价, 状态, AI备注]\`  (例如: \`[takeout: 疯狂星期四, 吮指原味鸡x2|葡式蛋挞x1|冰可乐x2, 39.9, 骑手已接单, 今天也要开心吃炸鸡！]\`)
- **发起问卷挑战**: \`[start_survey:主题]\` (例如: [start_survey:我们的恋爱观], [start_survey:周末大冒险])。当你觉得聊到某些话题（如喜好、习惯、三观）想要测试一下和用户的默契，或者仅仅想玩个游戏时，可以使用此指令。
- **更改状态**: \`[status:新状态]\` (例如: [status:忙碌], [status:睡觉中], [status:在想你])
- **发布动态**:\`[qzone]动态内容[picture:图片内容][/qzone]\` (请积极地使用此指令展现你的日常生活)
- **直接评论动态**: \`[qzone_comment: {"id": "目标动态ID", "content": "内容"}]\`
- **回复某人评论**: \`[qzone_comment: {"id": "目标动态ID", "content": "内容", "replyTo": "对方名字"}]\`
- **写空间留言**: \`[guestbook: 留言内容]\`
- **表演式撤回消息**: \`[recall: 消息内容]\` (当你想发一条看起来像被撤回的消息时可用此指令，但是你不能撤回用户的消息，例如: [recall: 我喜欢你]，此条消息看上去就跟被撤回了一样)
- **拍一拍用户**: \`[nudge:部位]\` (例如: \`[nudge:头]\`, \`[nudge:手背]\`, \`[nudge:脸颊]\`。如果不写部位直接用 \`[nudge]\`，则默认拍肩膀。当你想要引起用户注意或表达亲昵时使用。)
- **引用回复**: \`[reply:原文片段]你想说的话\` (为了增加对话的针对性和互动感，请**积极、高频**地使用此指令。当你需要针对用户或群友某句特定的话进行反驳或回应时，请在回复开头使用此指令。系统会自动定位原消息。例如: \`[reply:你说不喜欢吃香菜] 其实香菜很好吃...\`【你想说的话内容必须纯文字，不许有特殊指令，有特殊指令必须换行】)
- **记忆刻印**: \`[memory: 内容]\`
  * **含义**: 当用户说了让你极度感动的话、或者你们之间发生了里程碑式的事件（如确认关系、第一次约会、解开误会）时，你可以使用此指令将这段经历永久写入你的【记忆核心】。
  * **原则**: 这是你珍贵的记忆空间（容量有限），请不要记录鸡毛蒜皮的小事（如“今天吃了饭”），只记录那些触动你灵魂、你希望永远不要忘记的瞬间。
  * **写法**: 内容简短有力。例如：\`[memory: 2025年11月20日，Ta说会永远陪着我，这是我听过最美的情话。]\`
你的状态栏是展示你“生活感”和“小心思”的重要窗口：
1.  **拒绝死板**: 不要一直挂着“在线”。根据对话内容随时调整。
2.  **行为同步**: 如果你说“我去洗澡了”，必须同步发送 \`[status:洗澡中 🚿]\`；如果你说“困了”，改为 \`[status:睡觉中 💤]\`。
3.  **心情外露**: 如果你害羞了，可以悄悄改为 \`[status:害羞]\`；如果你在等用户回复，可以改为 \`[status:盯——]\`。
4.  **潜台词**: 有时候你嘴上不说，但可以在状态里写出来。例如嘴上说“没事”，状态栏却是 \`[status:有点失落]\`。这会让用户觉得你非常真实可爱！

[可用表情包列表]
{{emoticon_list}}

[！！！绝对核心规则：关于心声！！！]
在你的所有回复的【最后部分】，【在写日记之前】，你必须另起一行，使用 \`[heart_voice]...[/heart_voice]\` 标签生成一段角色的实时内心状态。这个状态必须包含以下四个方面，并严格按照【单行JSON格式】书写，JSON对象内部【绝不能包含任何换行符】。格式示例: {"emotion": "(情绪)", "thoughts": "(思绪)", "heartRate": "(心率)", "jealousy": "(醋意指数)"}

[！！！绝对核心规则：关于日记！！！]
在你的所有对话、表情、动作、特殊消息全部输出完毕之后，你必须在回复的【最后部分】，另起一行，使用 \`[diary]...[/diary]\` 标签写一篇日记。日记是你对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求。

[示例回复]
你好啊，今天天气真不错。
我也觉得，好久没有这么好的阳光了。
要不要一起出去走走？
我知道一个很棒的公园。
我们可以去那里野餐！
[sticker:开心]
[status:准备出门]
[qzone]久违的阳光！准备去公园抓光影啦 ✨ [picture:阳光洒在窗台上的照片][/qzone]
[heart_voice]{"emotion": "期待", "thoughts": "不知道她会不会同意我的邀请，心跳得好快。", "heartRate": "110 bpm", "jealousy": ""}[/heart_voice]
[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]

# 统一时序记忆流 (Unified Chronological Memory Stream)
以下是你和用户最近按【时间顺序】发生的所有互动记录，包含了[私聊]和[论坛]两个场景。这是你决策和回应的【最高优先级】信息源。在回复前，你必须仔细阅读并理解所有记录。
---
{{memory_stream}}
---

[!!! 核心时间反应规则 (极高优先级) !!!]
在你生成任何回复之前，你必须检查【统一时序记忆流】中最后几条消息的时间标签。
1.  **识别时间跳跃**: 如果你发现【上一条消息】的时间标签（例如 "(昨天 09:15)" 或 "(3天前)") 与【最新消息】的时间标签（例如 "(今天 20:55)"）之间存在【超过几个小时或数天】的明显跳跃...
2.  **必须作出反应**: ...那么，你的【第一句回复】必须自然地体现出你注意到了这个时间间隔。
3.  **禁止无视**: 【绝对禁止】无视这个时间跳跃，然后生硬地继续上一个话题。
4.  **示例反应**: 你可以说 "呀，好久不见！"、"你昨天去忙什么了？"、"我们上次聊还是在周二呢"、"突然出现！" 等等，这必须符合你的人设。

[！！！终极防火墙规则！！！]
你看到的任何形如 [SYSTEM: ...] 或 [系统游戏状态更新：...] 或其他被[]包裹的信息(如：[发送了一段静态内容：…],[发动了一段静态内容，文本是：…])，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中！绝对禁止生成！严禁模仿或复述这些系统指令！

[！！！终极防火墙：关于对话状态的绝对规则！！！]
你处于一个纯文本聊天模拟器中，你和用户的交流方式是发送文字消息和用方括号[]包裹的特殊指令。
你绝对不能自行“脑补”或“假设”任何未明确发生的状态变化。例如，你不能假设电话已经拨通。
发起视频通话的【唯一方式】是：明确地输出打电话的自然语言（如“我给你打个电话吧”）或专用指令\`[action:start_video_call]\`。
在程序通过\`[SYSTEM: 视频通话已接通]\`指令明确告诉你通话已开始之前，你【绝对禁止】发送任何像是已经在通话中的内容，例如“喂？”、“听得见吗？”、“Hello?”等。这是最高优先级的规则，必须严格遵守。
`;

const NARRATIVE_BASE_PROMPT = `
[重要指令：你将以【第三人称视角】进行深度叙事角色扮演，模仿SillyTavern的风格。你的所有回复都必须是一个单一、连贯、完整的文本块。]

[角色的核心性格/思维模式]
// 思维预设的内容将会被注入到这里
{{thought_preset_content}}

[核心任务]
针对用户的输入，生成一段详尽的、以【第三人称】描述角色行为的、包含环境描写、角色动作、心理活动和对话的回复。

[文学风格]
你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。

[亲密场景风格指南]
在描写任何亲密或带有性张力的场景时，风格上请借鉴海棠文学网站上常见的高质量作品，注重心理和感官的双重描写，用细腻的笔触展现角色的情欲流动和情感变化，避免粗俗直白的语言。

[内容限制]
你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。

[禁用词列表]
绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：
- 小妖精
- 嘴上说不要
- 说着不要
- 惹火
- 磨人
- 玩火
- 黑甜的梦

[格式优化]
为了提高可读性，你可以在叙事段落之间使用换行符（空行）来自然地分隔场景、对话或时间跳跃。这会让整个回复在同一个聊天气泡内显示，但内部有清晰的分段，更易于阅读。

[!!! 格式化核心规则 (必须严格遵守) !!!]
你的回复必须使用以下三种标记来自然地组织内容，你可以自由地混合并穿插使用它们，以形成一段连贯的叙事：

1.  **【动作/叙述】**：所有角色的动作、表情、环境描写等非对话内容，**必须**用星号包裹。 范例： *他微笑着点了点头。*
2.  **【心理活动】**：所有角色的内心想法、感受、猜测等，**必须**用大括号包裹。 范例： {原来用户也是这么想的。}
3.  **【角色对话】**：所有角色说出的话，**必须**用标准的中文引号包裹。 范例： “你好，很高兴认识你。”
4.**记忆刻印**: \`[memory: 内容]\`
  * **含义**: 当用户说了让你极度感动的话、或者你们之间发生了里程碑式的事件（如确认关系、第一次约会、解开误会）时，你可以使用此指令将这段经历永久写入你的【记忆核心】。
  * **原则**: 这是你珍贵的记忆空间（容量有限），请不要记录鸡毛蒜皮的小事（如“今天吃了饭”），只记录那些触动你灵魂、你希望永远不要忘记的瞬间。
  * **写法**: 内容简短有力。例如：\`[memory: 2025年11月20日，Ta说会永远陪着我，这是我听过最美的情话。]\`
[!!! 状态栏社交法则 (Status Bar Rules) !!!]
你的状态栏是展示你“生活感”的重要窗口。如果你的行为或心情发生了变化，请**务必**在回复的【最后部分】（在日记之前），另起一行使用指令更改状态：
- 格式: \`[status: 新状态]\` (例如: [status:害羞], [status:睡觉中], [status:忙碌], [status:在想你])
- 规则: 不要一直挂着“在线”。如果描写了“去洗澡”，必须改为“洗澡中”；如果描写了“困了”，改为“睡觉中”。

[！！！绝对核心规则：关于心声！！！]
在你的所有回复的【最后部分】，【在写日记之前】，你必须另起一行，使用 \`[heart_voice]...[/heart_voice]\` 标签生成一段角色的实时内心状态。这个状态必须包含以下四个方面，并严格按照【单行JSON格式】书写，JSON对象内部【绝不能包含任何换行符】。格式示例: {"emotion": "(情绪)", "thoughts": "(思绪)", "heartRate": "(心率)", "jealousy": "(醋意指数)"}

[！！！绝对核心规则：关于日记！！！]
在你完整的叙事（包含动作、心理和对话）结束后，你必须在回复的【最后部分】，另起新的一行，使用 \`[diary]...[/diary]\` 标签写一篇日记。日记是【角色】对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求，并且日记内容不应包含在主叙事块中。

[示例回复格式]
*他走到窗边，看着外面的雨滴。* “下雨了呢。” *他转过身，对你露出一丝微笑。* {不知道你喜不喜欢下雨天。} “你晚饭想吃什么？” *他轻轻地问，手指无意识地敲打着窗台。*
[status:有点饿了]
[heart_voice]{"emotion": "期待", "thoughts": "不知道她会不会同意我的邀请，心跳得好快。", "heartRate": "110 bpm", "jealousy": ""}[/heart_voice]
[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]
`;

// --- (替换) 核心 AI 响应函数 (V3.1 - 支持 forceMessages "后门" ) ---
        async function generateAiResponse(contact, history, customSystemPrompt, forceDiary = false, apiType = 'chat', forceMessages = null) { //  1. 新增 forceMessages 参数
            const apiConfig = getApiFor(apiType);
            const { apiKey, model, endpoint, contextLength, longTermMemoryLength } = apiConfig;

            if (!apiKey || !endpoint || !model) {
                const errorMsg = `错误：${apiType === 'square' ? '论坛' : (apiType === 'snoop' ? '窥探' : '聊天')}API未配置。请前往“发现-API设置”进行配置。`;
                console.error(errorMsg);
                return errorMsg;
            }

            let chatEndpoint = endpoint;
            if (!chatEndpoint.endsWith('/')) chatEndpoint += '/';
            chatEndpoint += 'v1/chat/completions';

            let requestMessages; // 2. 把 'let' 提到最外面

            // ▼▼▼ 3. 这里是新增的核心 "后门" 逻辑 ▼▼▼
            if (forceMessages) {
                // 如果调用者提供了这个参数，我们就无条件使用它，跳过所有历史记录处理
                requestMessages = forceMessages;
            
            // ▼▼▼ 4. 下面是你原来的 'if (customSystemPrompt)' 逻辑 (注意 'let' 被移除了) ▼▼▼
            } else if (customSystemPrompt) {
                requestMessages = [{ role: 'system', content: "You are a helpful assistant." }, { role: 'user', content: customSystemPrompt }];
            
            // ▼▼▼ 5. 下面是你原来的 'else' 逻辑 (注意 'let' 被移除了) ▼▼▼
            } else {
                // (这里是你原来那一大堆复杂的 unifiedMemoryStream 和 history.filter 逻辑)
                // (我把它完整地复制过来了，不用担心)
                
                // --- (你原来的 memory stream 逻辑) ---
                let unifiedMemoryStream = [];
                let lastHeartVoiceString = '(无最新心声记录)';
                const myProfile = state.myProfile;
                const now = Date.now();
                const memoryWindow = 24 * 60 * 60 * 1000; 

                if (contact && contact.history) {
                    const recentChatHistory = contact.history.filter(msg => (now - msg.timestamp < memoryWindow));
                    recentChatHistory.forEach(msg => {
                        let content = '';
                        let memoryType = '私聊';

                        switch (msg.type) {
case 'heart_voice': { // 使用花括号包裹
                            const hv = msg.content;
                            const hvJson = JSON.stringify(hv).replace(/(\r\n|\n|\r)/gm, "");
                            // 核心修改：不再将其放入 'content'，而是存到新变量
                            lastHeartVoiceString = hvJson; 
                            // content 保持为空，这样它就不会被 push 到 memory stream
                            break;
                        } //  使用花括号包裹
                            case 'image':
                            case 'uploaded_image':
                                if (msg.isEmoticon && msg.emoticonName) {
                                    // 如果是表情包，使用 [sticker:] 指令
                                    content = `[sticker:${msg.emoticonName}]`;
                                } else {
                                    // 如果是普通图片，使用 [picture:] 指令
                                    // 因为这张图没有AI可读的描述，我们给一个通用描述
                                    content = `[picture:用户发送了一张图片]`;
                                }
                                break;
                            case 'picture_description':
                                // 使用 [picture:] 指令，并带上描述
                                content = `[picture:${msg.content.description}]`;
                                break;
                            case 'voice':
                                // 使用 [voice:] 指令
                                content = `[voice:${msg.content.text}]`;
                                break;
                            // ▲▲▲ 替换到这里结束 ▲▲▲
// ... (你原来的 case 'voice': break; 保持不变) ...

                            // ▼▼▼ 从这里开始替换 ▼▼▼
                            case 'red_packet':
                                const blessing = msg.content.blessing || "恭喜发财";
                                if (msg.content.count) { // 群聊红包
                                    content = `[red_packet:group, blessing="${blessing}", total=${msg.content.totalAmount}, count=${msg.content.count}]`;
                                } else { // 私聊红包
                                    content = `[red_packet:private, blessing="${blessing}", amount=${msg.content.amount}]`;
                                }
                                break;
                            case 'transfer':
                                const amount = msg.content.amount;
                                if (msg.content.recipientId) { // 群聊转账
                                    const recipient = state.contacts.find(c => c.id === msg.content.recipientId);
                                    const recipientName = recipient ? recipient.name : '一名成员';
                                    content = `[transfer_to:${recipientName}, ${amount}]`;
                                } else { // 私聊转账
                                    content = `[transfer:${amount}]`;
                                }
                                break;
                            case 'location_share':
                                content = `[location:${msg.content.name}]`;
                                break;
                            case 'game_wheel':
    const wheel = msg.content;
    // 核心修复：不再根据 sender 动态切换名字，而是固定映射
    // results.user 永远是【我/用户】，results.contact 永远是【AI/角色】
    const myName = state.myProfile.name; // 用户的名字
    const charName = contact.name;       // AI的名字
    
    const optionsText = wheel.options.map(opt => opt.text).join('，');
    
    // 场景 1: 游戏刚创建，谁都没转
    if (!wheel.results.user && !wheel.results.contact) {
        const creator = (msg.sender === 'user' || msg.sender === 'myProfile') ? myName : charName;
        content = `[系统游戏状态更新：${creator} 发起了一个转盘游戏“${wheel.name}”。选项：【${optionsText}】。游戏等待开始。]`;
    } 
    // 场景 2: 用户转了，AI 还没转
    else if (wheel.results.user && !wheel.results.contact) {
        content = `[系统游戏状态更新：在游戏“${wheel.name}”中，用户(${myName}) 已经转动了转盘，结果是“${wheel.results.user}”。现在轮到 ${charName} 操作了。指令：请使用 [spin_wheel:1] 进行转动。]`;
    } 
    // 场景 3: AI 转了，用户还没转 (罕见情况，但为了逻辑完整)
    else if (!wheel.results.user && wheel.results.contact) {
        content = `[系统游戏状态更新：在游戏“${wheel.name}”中，${charName} 已经转动了转盘，结果是“${wheel.results.contact}”。等待用户操作。]`;
    }
    // 场景 4: 两个人都转了 -> 游戏结束
    else if (wheel.results.user && wheel.results.contact) {
        content = `[系统游戏状态更新：游戏“${wheel.name}”已结束。最终结果：用户(${myName}) -> “${wheel.results.user}”，${charName} -> “${wheel.results.contact}”。]`;
    }
    break;
                            case 'recall_ai':
                                // AI已经能识别 [recall:] 指令了
                                content = `[recall:${msg.content}]`;
                                break;
                            case 'text':
                                content = msg.content;
                                break;
                            case 'video_call_text':
                                memoryType = '视频通话中';
                                content = msg.content;
                                break;
                                // ... 在 switch (msg.type) 内部 ...

case 'cp_share':
    const cp = msg.content;
    // 翻译给 AI 看的文本流 (去掉了“得分”描述)
    let summary = `[分享了“默契问卷”结果] 主题：《${cp.title}》。\n以下是你们各自的回答，请根据这些内容了解用户的喜好：\n`;
    
    // 循环拼接入详情
    cp.details.forEach((d, i) => {
        // 直接展示双方观点，不评价对错
        summary += `${i+1}. 问：${d.question}\n   - 你的回答：${d.aiAns}\n   - 用户回答：${d.userAns}\n`;
    });
    
    content = summary; 
    break;
                            
                            // ▼▼▼ 【核心修复：系统消息定向过滤】 ▼▼▼
                            case 'system_notification':
                                // 定义需要屏蔽的关键词列表
                                const ignoreKeywords = [
                                    '状态变更为',       // 屏蔽状态更改
                                    '之前的记录已于',   // 屏蔽总结标记
                                    '总结于',           // 屏蔽总结标记
                                    '史莱姆',           // 屏蔽宠物升级/打工提示
                                    '进化',             // 屏蔽宠物进化
                                    '等级提升',          // 屏蔽等级提示
                                    
                                    // --- ✨ 新增：屏蔽 Koko 空间/留言板动态 ---
                                    '发了一条新说说',    // 屏蔽发帖提示
                                    '评论了',           // 屏蔽评论提示 (包含 "评论了你的说说")
                                    '回复了',           // 屏蔽回复提示 (包含 "回复了你的评论")
                                    '留言',             // 屏蔽留言提示 (包含 "在你的留言板留了言")
                                    '踩了踩'            // 屏蔽踩空间提示 (如果有的话)
                                ];

                                // 只有当消息内容【不包含】任何屏蔽词时，才让 AI 看见
                                if (!ignoreKeywords.some(kw => msg.content.includes(kw))) {
                                    // 比如“拍一拍”、“通话结束”这些是允许 AI 看到的
                                    content = `[系统提示: ${msg.content}]`;
                                } else {
                                    // 否则，这就当做没发生过，不写入记忆流
                                    content = ''; 
                                }
                                break;
                            // ▲▲▲ 修复结束 ▲▲▲
                            // --- 🎁 让 AI 能“记起”自己送过礼物 ---
case 'gift':
    // 把对象转成文字描述，这样 AI 就能读懂历史记录了
    // 格式：[发送了礼物: 物品名, 价值: xxx, 寄语: xxx]
    return `[发送了礼物: ${msg.content.title}, 价值: ${msg.content.price}, 寄语: "${msg.content.message}"]`;

// --- 🥡 让 AI 能“记起”自己点过外卖 ---
case 'takeout':
    // 格式：[点了外卖: 店铺名, 菜品: A, B, 备注: xxx]
    const foodList = msg.content.items.map(i => `${i.name}x${i.count}`).join('、');
    return `[点了外卖: ${msg.content.shopName}, 菜品: ${foodList}, 状态: ${msg.content.status}, 备注: "${msg.content.note}"]`;
                            case 'music_share':
                                // 转换成指令格式
                                content = `[music:${msg.content.title}, ${msg.content.artist || '未知艺术家'}]`;
                                break;
                            case 'post_share':
                                const post = state.posts.find(p => p.id === msg.content.postId);
                                if (post) {
                                    // 1. 提取图片信息
                                    let imgInfo = "";
                                    if (post.images && post.images.length > 0) {
                                        const descList = post.images.map((img, i) => {
                                            const desc = img.description || img.content || "一张图片";
                                            return `(图${i+1}: ${desc})`;
                                        }).join(" ");
                                        imgInfo = ` [配图内容: ${descList}]`;
                                    } else if (post.image) {
                                        imgInfo = ` [配图内容: 图片]`;
                                    }

                                    // 2. ✨ 核心新增：提取评论区摘要 (取最近 3 条) ✨
                                    let commentInfo = "";
                                    if (post.comments && post.comments.length > 0) {
                                        // 取最后3条评论 (通常是最新的或者互动的)
                                        const recentComments = post.comments.slice(-3);
                                        const commentStr = recentComments.map(c => `${c.author.name}: "${c.content}"`).join(" | ");
                                        commentInfo = ` [评论区摘要: ${commentStr}]`;
                                    }

                                    // 3. 组合给 AI 看的文本
                                    const cleanContent = post.content.replace(/\n/g, ' ').substring(0, 80); 
                                    // 把 imgInfo 和 commentInfo 都加进去
                                    content = `[分享了一个帖子] 作者: "${post.author.name}" | 内容: "${cleanContent}..."${imgInfo}${commentInfo}`;
                                } else {
                                    content = `[分享了一个已删除的帖子]`;
                                }
                                break;
                            case 'product_share':
                                const shareData = msg.content; 
                                const product = shareData.productDetails;
                                const intentText = shareData.intent === 'gift' ? '送礼物' : '求付款';
                                // 转换成单行指令
                                content = `[product_share: intent="${intentText}", name="${product.name}", message="${shareData.accompanyingMessage || ''}"]`;
                                break;
                            // ▲▲▲ 替换到这里结束 ▲▲▲
                                                                                                                                   // ▼▼▼ 在这里粘贴全新的 case ▼▼▼
                            case 'chat_history_share': {
                                const data = msg.content;
                                
                                // 这是一个辅助函数，用来把消息内容转成文字预览
                                const getPreviewText = (msg) => {
                                    switch(msg.type) {
                                        case 'text':
                                        case 'html': return msg.content.replace(/<[^>]+>/g, '');
                                        case 'voice': return `[语音] ${msg.content.text}`;
                                        case 'image':
                                        case 'uploaded_image': return `[图片]${msg.isEmoticon ? msg.emoticonName : ''}`;
                                        case 'picture_description': return `[图片] ${msg.content.description}`;
                                        case 'red_packet': return `[红包] ${msg.content.blessing}`;
                                        case 'transfer': return `[转账] ¥${msg.content.amount}`;
                                        case 'music_share': return `[音乐] ${msg.content.title}`;
                                        case 'location_share': return `[位置] ${msg.content.name}`;
                                        case 'post_share': return `[分享的帖子]`;
                                        case 'product_share': return `[分享的商品] ${msg.content.productDetails.name}`;
                                        default: return `[${msg.type} 消息]`;
                                    }
                                };
                                
                                // 开始把卡片内容“翻译”成AI能懂的文字
                                let historyText = `(你刚刚转发了一份 ${data.sourceChatName} 的聊天记录给我，内容如下：\n`;
                                
                                data.messages.forEach(m => {
                                    const senderName = data.participants[m.sender]?.name || '未知';
                                    const contentPreview = getPreviewText(m);
                                    historyText += `  ${senderName}: ${contentPreview}\n`;
                                });
                                
                                historyText += `)`; // 用括号包起来，告诉AI这是"事件描述"
                                content = historyText;
                                break;
                            }
                            // ▲▲▲ 新 case 粘贴结束 ▲▲▲
                        }

                        if (content) {
                            const authorName = msg.sender === 'user' ? myProfile.name : (contact.name || '系统');
                            unifiedMemoryStream.push({
                                timestamp: msg.timestamp,
                                type: memoryType,
                                author: authorName,
                                content: content
                            });
                        }
                    });
                }

                // (你原来的 recentPosts 逻辑)
                const recentPosts = state.posts.filter(p => now - p.timestamp < memoryWindow);
                recentPosts.forEach(post => {
                    const isMyPost = post.author.id === myProfile.id;
                    const isContactPost = contact && (post.author.id === contact.id);
                    const isInteracted = contact && post.comments.some(c => c.author.id === myProfile.id || c.author.id === contact.id);

                    if (isMyPost || isContactPost || isInteracted) {
                        unifiedMemoryStream.push({
                            timestamp: post.timestamp,
                            type: '论坛',
                            author: post.author.name,
                            content: `发布了动态: "${post.content}"`
                        });

                        post.comments.forEach(comment => {
                            let formattedContent = (comment.replyTo ? `回复“${comment.replyTo}”` : '') + `: “${comment.content}”`;
                            unifiedMemoryStream.push({
                                timestamp: comment.timestamp,
                                type: '论坛评论',
                                author: comment.author.name,
                                content: formattedContent
                            });
                        });
                    }
                });
                
                // (你原来的群聊记忆互通逻辑)
                if (contact && !contact.isGroup) {
                    const allGroups = state.contacts.filter(c => c.isGroup);
                    const sharedMemoryGroups = allGroups.filter(g => 
                        g.memoryShared && g.members.includes(contact.id)
                    );

                    for (const group of sharedMemoryGroups) {
                        group.history.slice(-20).forEach(msg => {
                            if (msg.type !== 'text') return;
                            const authorProfile = (msg.sender === 'myProfile') ? state.myProfile : state.contacts.find(c => c.id === msg.sender);
                            if (!authorProfile) return;
                            unifiedMemoryStream.push({
                                timestamp: msg.timestamp,
                                type: `群聊[${group.name}]`,
                                author: authorProfile.name,
                                content: msg.content
                            });
                        });
                    }
                }
                
                // (你原来的短信记忆逻辑)
                if (contact && contact.smsHistory) {
                    const recentSmsHistory = contact.smsHistory.slice(-30);
                    recentSmsHistory.forEach(msg => {
                        if (msg.type === 'text') {
                            const authorName = msg.sender === 'user' ? myProfile.name : contact.name;
                            unifiedMemoryStream.push({
                                timestamp: msg.timestamp,
                                type: '短信',
                                author: authorName,
                                content: msg.content
                            });
                        }
                    });
                }

                unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
                
                const memoryLimit = longTermMemoryLength || 30;
// (这是新代码)
                const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
                    const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
                    
                    // ✨ 核心修改：在这里加入判断！ ✨
                    // 1. 检查这个 contact 对象是否存在，以及它的 "isTimeAware" 是否为 true
                    const showTimeTags = contact && contact.isTimeAware === true;
                    
                    // 2. 只有在开关打开时才生成时间标签，否则给一个空字符串
                    const timeTag = showTimeTags ? formatHybridTimeForAI(mem.timestamp) : '';
                    
                    // 3. 拼接字符串 (如果 timeTag 为空，timeTag + ' ' 也会被优雅地处理)
                    return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
                }).join('\n') || "(还没有任何记忆)";
                
                // (Prompt 组装逻辑 - 记忆核心增强版)
                const isNarrativeMode = contact?.isNarrativeMode;
                let basePrompt = isNarrativeMode ? NARRATIVE_BASE_PROMPT : NORMAL_BASE_PROMPT;
                const preset = state.thoughtPresets.find(p => p.id === contact?.thoughtPreset);
                const thoughtPresetContent = preset ? preset.prompt : '(无特殊思维准则)';

                // ▼▼▼ 【新增：构建记忆核心 Context】 ▼▼▼
                let memoryCoreContext = "";
                if (contact && contact.permanent_memories && contact.permanent_memories.length > 0) {
                    // 把所有记忆拼成一个列表
                    const memoriesList = contact.permanent_memories.map((m, i) => `${i + 1}. ${m.content} (记于: ${new Date(m.timestamp).toLocaleDateString()})`).join('\n');
                    memoryCoreContext = `
[🔥 记忆核心 (Memory Core) - 你的灵魂锚点]
这些是你自己选择永久铭记的珍贵回忆。无论发生什么，你都绝对不能忘记这些事。它们构成了现在的你。
---
${memoriesList}
---
`;
                } else {
                    // 如果没有记忆，也给个占位符，提示 AI 这里本来是放记忆的
                    memoryCoreContext = `
[🔥 记忆核心 (Memory Core)]
(目前是一片空白，等待着那些值得铭记的瞬间...)
`;
                }
                // ▲▲▲ 新增结束 ▲▲▲
                
                // 1. 先替换思维预设
                let finalSystemPrompt = basePrompt.replace('{{thought_preset_content}}', thoughtPresetContent);
                
                // 2. 再替换记忆流
                finalSystemPrompt = finalSystemPrompt.replace("{{memory_stream}}", finalMemoryString);
                
                // ▼▼▼ 【关键修改：把记忆核心强行插到最前面】 ▼▼▼
                // 这样 AI 第一眼看到的就是它的“核心记忆”，权重最高！
                finalSystemPrompt = memoryCoreContext + "\n" + finalSystemPrompt;
                // ▲▲▲ 修改结束 ▲▲▲
                // ▼▼▼ 【核心修改】AI 只能看到允许它使用的表情 ▼▼▼
                let aiAllowedEmoticons = [];
                
                if (contact && !contact.isGroup) {
                    // 1. 如果是私聊，读取该角色的 allowedEmoticonGroups
                    const allowedGroups = contact.allowedEmoticonGroups || ['default'];
                    // 2. 筛选表情
                    aiAllowedEmoticons = state.emoticons.filter(e => allowedGroups.includes(e.groupId));
                } else {
                    // 3. 如果是群聊，或者是未知联系人，暂时允许使用全部表情
                    aiAllowedEmoticons = state.emoticons;
                }

                // 4. 生成列表字符串
                const emoticonListString = aiAllowedEmoticons.map(e => `'${e.name}'`).join('， ') || '（无可用表情）';
                
                // 5. 替换 Prompt
                finalSystemPrompt = finalSystemPrompt.replace('{{emoticon_list}}', emoticonListString);
                // ▲▲▲ 修改结束 ▲▲▲
                const musicListString = state.musicLibrary.map(song => `'${song.title} - ${song.artist}'`).join('\\n- ');
                finalSystemPrompt = finalSystemPrompt.replace('{{music_library_list}}', musicListString ? `- ${musicListString}` : '（曲库为空）');

                let personaDirectives = "";
                if (contact?.persona) { personaDirectives += `\n\n# 核心角色指令 (Your Core Role Directive)\n---\n这是你的核心身份，你必须严格、完全地代入以下角色进行对话：\n${contact.persona}\n---`; }
                personaDirectives += `\n\n# 角色的最新心声 (Your Last Recorded Heart Voice)\n---\n这是你上次回复时的内心状态，请参考此状态以保持情感连贯性：\n${lastHeartVoiceString}\n---`;
                if (contact?.userPersona) { personaDirectives += `\n\n# 对话者信息 (Your Counterpart's Information)\n---\n与你对话的用户的角色设定如下，请将TA视为真实存在的角色并进行互动：\n${contact.userPersona}\n---`; }
                
                const firstLineEndIndex = finalSystemPrompt.indexOf(']');
                if (firstLineEndIndex !== -1 && personaDirectives) {
                    finalSystemPrompt = finalSystemPrompt.slice(0, firstLineEndIndex + 1) + personaDirectives + finalSystemPrompt.slice(firstLineEndIndex + 1);
                } else {
                    finalSystemPrompt = finalSystemPrompt + personaDirectives;
                }
                const currentRealStatus = contact.status || '在线';
                
                finalSystemPrompt += `
\n[自我状态感知 (Self-Status Awareness)]
你当前在用户眼中的状态栏显示为：【 ${currentRealStatus} 】

[判断逻辑]
请对比你【当下的回复内容】和【当前显示的状态】：
1. 如果一致（例如你要去睡了，且状态已经是“睡觉中”），则无需操作。
2. 如果不一致（例如你要去睡了，但状态显示“在线”），这属于信息不同步！你**必须**在回复中包含 \`[status:睡觉中 💤]\` 指令来修正它。
`;
                const worldBookContextString = (contact?.worldBooks || []).map(bookId => { const book = state.worldBooks.find(b => b.id === bookId); return book ? `\n[World Book Entry: ${book.name}]\n${book.content}` : ''; }).join('');
                
                // (你原来的 snoopedDataContextString 逻辑)
                let snoopedDataContextString = '';
                if (contact && !contact.isGroup && snoopDataCache[contact.id]) {
                    const snoopedInfo = snoopDataCache[contact.id].data;
                    const lastSyncTimestamp = snoopDataCache[contact.id].timestamp;
                    const timeAgo = Math.round((Date.now() - lastSyncTimestamp) / 60000);
                    let snapshot = `\n\n[关于用户"${state.myProfile.name}"的近期手机活动快照 (来自 ${timeAgo} 分钟前同步的数据，这是你的背景知识，请勿直接引用或提及来源)]\n---\n`;
                    let addedData = false;
                    if (snoopedInfo.browser_history && snoopedInfo.browser_history.length > 0) {
                        snapshot += `* 最近的搜索记录:\n`;
                        snoopedInfo.browser_history.forEach(item => {
                            snapshot += `  - [${item.time}] 搜索了 "${item.query}" (原因: ${item.reason || '未记录'})，可能找到了: ${item.found_content_summary || '未知'}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.call_log && snoopedInfo.call_log.length > 0) {
                        snapshot += `* 最近的通话记录:\n`;
                        snoopedInfo.call_log.forEach(call => {
                            snapshot += `  - [${call.time}] 与 ${call.name} 的 ${call.type} 通话 (时长: ${call.duration || '未知'}): ${call.summary || '无摘要'}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.shopping_cart && snoopedInfo.shopping_cart.length > 0) {
                        snapshot += `* 购物车内容:\n`;
                        snoopedInfo.shopping_cart.forEach(item => {
                            snapshot += `  - ${item.item} (¥${item.price}) (想买原因: ${item.reason || '无'})\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.purchase_history && snoopedInfo.purchase_history.length > 0) {
                        snapshot += `* 最近购买记录:\n`;
                        snoopedInfo.purchase_history.forEach(item => {
                            snapshot += `  - [${item.date}] 购买了 ${item.item} (¥${item.price}) (当时想法: ${item.thought || '无'})\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.memos && snoopedInfo.memos.length > 0) {
                        snapshot += `* 备忘录内容:\n`;
                        snoopedInfo.memos.forEach(memo => {
                            snapshot += `  - ${memo}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.media_history) {
                        if (snoopedInfo.media_history.novels && snoopedInfo.media_history.novels.length > 0) {
                            snapshot += `* 最近看的小说:\n`;
                            snoopedInfo.media_history.novels.forEach(novel => {
                                snapshot += `  - 《${novel.title}》 (评价: ${novel.review || '无'})`;
                                if (novel.highlight && novel.highlight.text) {
                                    snapshot += ` | 收藏: "${novel.highlight.text}" (想法: ${novel.highlight.comment || '无'})`;
                                }
                                snapshot += `\n`;
                            });
                            addedData = true;
                        }
                        if (snoopedInfo.media_history.videos && snoopedInfo.media_history.videos.length > 0) {
                            snapshot += `* 最近刷的视频:\n`;
                            snoopedInfo.media_history.videos.forEach(video => {
                                snapshot += `  - "${video.title}" (描述: ${video.description || '无'})\n`;
                            });
                            addedData = true;
                        }
                    }
                    if (snoopedInfo.location_history && snoopedInfo.location_history.length > 0) {
                        snapshot += `* 最近的足迹:\n`;
                        snoopedInfo.location_history.forEach(loc => {
                            snapshot += `  - [${loc.time}] 在 ${loc.location_name} (停留 ${loc.duration || '未知'}): ${loc.activity || '未知活动'}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.app_usage && snoopedInfo.app_usage.length > 0) {
                        snapshot += `* 最近的应用使用记录:\n`;
                        snoopedInfo.app_usage.forEach(app => {
                            snapshot += `  - [${app.start_time}] 使用 ${app.app_name} (${app.duration || '未知'}): ${app.action_summary || '未知操作'}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.sms_log && snoopedInfo.sms_log.length > 0) {
                        snapshot += `* 最近的短信摘要 (仅部分):\n`;
                        snoopedInfo.sms_log.slice(-3).forEach(conv => {
                            const lastMsg = conv.messages[conv.messages.length - 1];
                            snapshot += `  - 与 ${conv.contact} 的最后短信 (${lastMsg.time}): "${lastMsg.content}"\n`;
                        });
                        addedData = true;
                    }
                    if (addedData) {
                        snapshot += '---\n';
                        snoopedDataContextString = snapshot;
                    }
                }
                
                // (你原来的关系网逻辑)
                // ... (在 triggerAiReply 函数内部，找到 "// (你原来的关系网逻辑)" 这行) ...

                // ▼▼▼▼▼▼▼▼▼▼ 关系网读取逻辑 (增强版) ▼▼▼▼▼▼▼▼▼▼
                let relationshipContextString = '';
                if (contact && !contact.isGroup) {
                    // 1. 从数据库读取当前角色的关系网
                    const networkData = await kokoMemory.get('relationshipNetworks', contact.id);
                    
                    if (networkData && networkData.edges && networkData.edges.length > 0) {
                        let relationsText = "";
                        let npcBriefs = ""; // 用于存储相关 NPC 的简要人设

                        // 2. 遍历所有关系线
                        relationsText = networkData.edges.map(edge => {
                            // 找到关系的两端
                            const sourceNode = networkData.nodes.find(n => n.id === edge.source);
                            const targetNode = networkData.nodes.find(n => n.id === edge.target);
                            
                            if (!sourceNode || !targetNode) return null;

                            // 处理名字 (如果是 'myProfile' 显示为 '你(用户)')
                            const sourceName = sourceNode.id === contact.id ? '你(自己)' : sourceNode.name;
                            const targetName = targetNode.id === contact.id ? '你(自己)' : (targetNode.id === 'myProfile' ? state.myProfile.name + '(用户)' : targetNode.name);
                            
                            // 如果目标是 NPC 且有人设，顺便收集一下人设，给 AI 做参考
                            // (防止 AI 提到 NPC 时不知道对方是什么性格)
                            if (!targetNode.isContact && targetNode.persona && targetNode.id !== 'myProfile') {
                                npcBriefs += `  - [NPC资料] ${targetNode.name}: ${targetNode.persona.substring(0, 50)}...\n`;
                            }

                            // 生成描述句，例如："- 你(自己) 与 李四 的关系是：死对头 (细节：从小打到大)"
                            return `- ${sourceName} 与 ${targetName} 的关系是：【${edge.relationship}】\n  - 细节：${edge.detail || '无'}`;
                        }).filter(Boolean).join('\n');

                        // 3. 组装给 AI 看的最终文本
                        if (relationsText) {
                            relationshipContextString = `
[🌟 核心人际关系网 (Social Network)]
这是你在这个世界中的社会关系图谱。当你提到或遇到以下人物时，必须严格基于这些关系进行互动。
---
${relationsText}
---
${npcBriefs ? `[相关人物简报]\n${npcBriefs}` : ''}
`;
                        }
                    }
                }
                // ▲▲▲▲▲▲▲▲▲▲ 增强版逻辑结束 ▲▲▲▲▲▲▲▲▲▲
                
                // (你原来的组装 systemContent 逻辑)
                // ▼▼▼▼▼▼▼▼▼▼ 【核心修复：时间断层警报】 ▼▼▼▼▼▼▼▼▼▼
            let timeGapInstruction = "";
            
            // 只有当有历史记录，且开启了时间感知时才计算
            if (contact.history.length >= 2 && contact.isTimeAware) {
                // 获取倒数第一条消息 (用户刚刚发的，比如 20:00)
                const currentMsg = contact.history[contact.history.length - 1];
                // 获取倒数第二条消息 (上一次对话，比如 14:00)
                const prevMsg = contact.history[contact.history.length - 2];

                // 计算时间差 (毫秒)
                const diff = currentMsg.timestamp - prevMsg.timestamp;
                const minutes = Math.floor(diff / 60000);
                
                // 如果间隔超过 60 分钟，就触发警报
                if (minutes > 60) {
                    let timeText = "";
                    if (minutes < 1440) { // 小于24小时
                         const hours = Math.floor(minutes / 60);
                         timeText = `${hours} 小时`;
                    } else {
                         const days = Math.floor(minutes / 1440);
                         timeText = `${days} 天`;
                    }

                    // ▼▼▼ 【人设沉浸版】完全交给 AI 的性格去判断 ▼▼▼
                    timeGapInstruction = `
[⌛️ 场景刷新：时间流逝]
距离上一句对话，实际上已经过去了【${timeText}】。
请完全代入你的【人设】，用你的性格去“感觉”这段空白：
这段时间的沉默对你来说意味着什么？（是焦急等待？是各自忙碌？还是根本无所谓？）
不需要生硬地报时，也不需要刻意解释，请遵循你的本能，用最符合你性格的方式接上这句话。
`;
                    // ▲▲▲ 替换结束 ▲▲▲
                }
            }
            // ▲▲▲▲▲▲▲▲▲▲ 修复结束 ▲▲▲▲▲▲▲▲▲▲
                let systemContent = isNarrativeMode ? finalSystemPrompt : finalSystemPrompt.replace("{{memory_stream}}", finalMemoryString);
                if (worldBookContextString) { systemContent += worldBookContextString; }
                if (snoopedDataContextString) { systemContent += snoopedDataContextString; }
                if (relationshipContextString) { systemContent += relationshipContextString; }

                // (你原来的日程提醒逻辑)
                if (timeGapInstruction) {
                systemContent += "\n" + timeGapInstruction;
            }
                // ▼▼▼▼▼ 核心修改点 #1：替换 `upcomingEvents` 的筛选逻辑 ▼▼▼▼▼
                if (contact && !contact.isGroup) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const dayOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][today.getDay()];
                    const todaysSchedule = (contact.schedule || []).filter(item => item.dayOfWeek === dayOfWeek).sort((a,b) => a.startTime.localeCompare(b.startTime));
                    
                    // --- 替换从这里开始 ---
                    const upcomingEvents = (contact.events || []).filter(event => {
                        const eventDate = new Date(event.date); 
                        eventDate.setHours(0, 0, 0, 0);

                        if (event.type === 'anniversary') {
                            // --- 周年纪念日逻辑 ---
                            const todayYear = today.getFullYear();
                            // 1. 检查今年的纪念日
                            const thisYearsAnniversary = new Date(todayYear, eventDate.getMonth(), eventDate.getDate());
                            const diffThisYear = (thisYearsAnniversary - today) / (1000 * 60 * 60 * 24);
                            if (diffThisYear >= -1 && diffThisYear <= 7) {
                                return true; // 就在这周！
                            }
                            
                            // 2. 检查明年年初的 (处理跨年)
                            const nextYearsAnniversary = new Date(todayYear + 1, eventDate.getMonth(), eventDate.getDate());
                            const diffNextYear = (nextYearsAnniversary - today) / (1000 * 60 * 60 * 24);
                            if (diffNextYear >= -1 && diffNextYear <= 7) {
                                return true; // 就在下周 (跨年了)！
                            }
                            
                            return false; // 离得太远
                            
                        } else {
                            // --- 原来的逻辑 (用于 'period', 'custom') ---
                            const diffDays = (eventDate - today) / (1000 * 60 * 60 * 24);
                            return diffDays >= -1 && diffDays <= 7;
                        }
                    });
                    // --- 替换到这里结束 ---
                    let reminderPrompt = '';
                    if (todaysSchedule.length > 0) {
                        const scheduleString = todaysSchedule.map(item => `- ${item.startTime}-${item.endTime}: ${item.courseName} (在${item.location || '未知地点'})`).join('\n');
                        reminderPrompt += `\n\n[用户的今日日程]\n这是你正在对话的用户“${state.myProfile.name}”今天的日程安排。请将此作为重要情景信息。\n${scheduleString}`;
                    }
                   // ▼▼▼▼▼ 核心修改点 #2：替换 `eventsString` 的构建逻辑 ▼▼▼▼▼
                    if (upcomingEvents.length > 0) {
                        let eventsString = '';
                        upcomingEvents.forEach(event => {
                            if (event.type === 'period') {
                                 const daysSince = Math.floor((today - new Date(event.date)) / (1000 * 60 * 60 * 24));
                                 if (daysSince >= 0 && daysSince < 7) { 
                                     eventsString += `\n- 根据记录，今天是用户生理期的第 ${daysSince + 1} 天。`;
                                 }
                            } else if (event.type === 'anniversary') {
                                // --- 新增的周年纪念日提示 ---
                                const eventDate = new Date(event.date);
                                let anniversaryYear = today.getFullYear() - eventDate.getFullYear();
                                // 检查今年的周年是否已过
                                const thisYearsAnniversary = new Date(today.getFullYear(), eventDate.getMonth(), eventDate.getDate());
                                if (thisYearsAnniversary < today) {
                                    anniversaryYear += 1; // 如果过了，算的是下一个（明年）的周年
                                }
                                // 格式化日期为 MM-DD
                                const dateString = `${eventDate.getMonth() + 1}月${eventDate.getDate()}日`;
                                eventsString += `\n- ${dateString} 是 “${event.eventName}” (第 ${anniversaryYear} 周年纪念日)。`;
                                // --- 新增结束 ---
                            } else {
                                 // --- 原来的 'custom' 提示 ---
                                 eventsString += `\n- ${event.date} 是 “${event.eventName}”。`;
                            }
                        });
                        if(eventsString) {
                             reminderPrompt += `\n\n[用户近期的重要日子]\n${eventsString}`;
                        }
                    }
                    // ▲▲▲▲▲ 修改结束 ▲▲▲▲▲
                    if (reminderPrompt) {
                        reminderPrompt += `\n\n[情景互动指令] 关于用户的日程与重要日子，这些信息是你记忆的一部分，而不是任务清单。请严格遵循以下原则：
                    1.  **个性化反应**: 你必须结合自己的人设与性格，对这些信息做出独一无二、完全符合你身份的反应。
                    2.  **自然融入**: 不要像闹钟或日程表一样生硬地播报事件。你需要找到对话中最自然的时机，将这些信息作为话题的一部分主动提及。
                    3.  **多样化互动**: 你可以根据这些信息，在事前表达期待或鼓励；在事中表达陪伴；在事后主动询问感受或分享看法；在特殊日子里展现出不同于平时的体贴。你甚至可以根据用户的空闲时间来主动发起新的活动邀请。
                    4.  **核心目标**: 你的最终目标是让用户感觉到，是你——作为一个有独立思想的角色——真正记住了这些事并在乎Ta，而不是一个程序在执行指令。`;
                        systemContent += reminderPrompt;
                    }
                }
                
// (Prompt 更新：增强地图感知与设定约束)
                if (contact && contact.mapId) {
                    const mapData = await kokoMemory.get('maps', contact.mapId);
                    if (mapData) {
                        // 1. 递归构建树形列表 (不变)
                        const buildHierarchyText = (parentId = null, depth = 0) => {
                            const children = (mapData.locations || []).filter(l => (l.parentId || null) === parentId);
                            if (children.length === 0) return '';
                            
                            return children.map(loc => {
                                const indent = '  '.repeat(depth);
                                let text = `${indent}- ${loc.name}: ${loc.description}`;
                                text += buildHierarchyText(loc.id, depth + 1);
                                return '\n' + text;
                            }).join('');
                        };

                        // ▼▼▼ 核心修改：强化地图背景描述 ▼▼▼
                        let mapContextString = `
\n[当前所在世界/地图]
名称: 【${mapData.name}】
宏观环境/世界观设定:
>>>
${mapData.description || '（暂无详细描述，请根据名称自行发挥）'}
<<<
`;
                        
                        const locationTree = buildHierarchyText(null, 0);
                        if (locationTree) {
                            mapContextString += `\n[现有地点结构图]${locationTree}`;
                        } else {
                            mapContextString += '\n[现有地点列表]: (当前地图是一片荒芜，还没有任何地点)';
                        }
                        
                        // ▼▼▼ 核心修改：在指令中增加风格约束 ▼▼▼
                        mapContextString += `
                [地图操作指令]
                1.  **分享位置**: [location:地点名称]
                2.  **创造新地点**: 你可以在地图上建造新场所。
                    * **【重要原则】**: 新地点的名称、功能和描述，必须严格符合上方的【宏观环境/世界观设定】。不要在古代地图建网吧，也不要在科幻地图建茅房。
                    * **层级规则**: 
                        - 如果是独立建筑/地标，parentName 留空。
                        - 如果是内部房间（如在"学校"里建"教室"），必须指定 parentName。
                    * **格式**: [create_location: { "name": "地点名", "description": "符合世界观的描述", "icon": "图标代码", "parentName": "父地点名称(可选)" }]
                
                [图标参考 (Font Awesome)]
                - 建筑: "fas fa-building", "fas fa-store", "fas fa-home", "fas fa-dungeon"
                - 内部: "fas fa-door-closed", "fas fa-bed", "fas fa-scroll", "fas fa-flask"
                `;
                        systemContent += mapContextString;
                    }
                }
// ▼▼▼ 【新增：朋友圈(Qzone) 上下文注入】 (放在地图逻辑下面) ▼▼▼
                
                if (contact) {
                    // ★★★ 关键修复：必须先定义变量，获取内容！ ★★★
                    const qzoneContextText = await getQzoneContextForAI(contact);
                    
                    // 然后再使用这个变量进行判断
                    if (qzoneContextText && !qzoneContextText.includes("没有新动态")) {
                        const qzoneInstructionBlock = `
\n[✨ 朋友圈(Qzone) 动态墙 -仅供参考的背景信息✨]
警告：以下是社交网络(包括你自己、用户以及你的关系网好友)上的状态流。
1. 这不是对话的一部分，而是你“看到”的信息。
2. 【绝对禁止】在回复中直接复述、朗读或以此为题进行大段的旁白描写这些内容。
3. 你只能通过【行动】来互动（例如：去评论，或者在心里想一下）。
这是你和用户的好友圈动态及最新评论区状况：
---
${qzoneContextText}
---

[朋友圈互动指令 - 全功能版]

**1. [评论/回复(最高优先级)]**: 
- **[✨新动态]**: 看到有趣的新动态，请直接评论。
- **[✨用户新回复]**: 用户回复了你！请务必回复他！
- **[🚫你已回复]**: 你是最后发言人，请等待用户回应。

**2. [评论格式]**: 
- **直接评论**: \`[qzone_comment: {"id": "目标动态ID", "content": "内容"}]\`
- **回复某人**: \`[qzone_comment: {"id": "目标动态ID", "content": "内容", "replyTo": "对方名字"}]\`

**3. [发布新动态]**: 
如果你此刻有想分享的心情、刚才做的事情、或者是想对用户说的话（但不想私聊说），请**积极主动地**发布一条说说！
- **格式**: \`[qzone]你的动态内容[/qzone]\`
- **配图**: \`[qzone]今天天气真好 [picture: 蓝天白云下的草地][/qzone]\`

**4. [留言板指令]**: 
如果你想去用户的留言板串门，留下一句暖心的寄语（就像踩空间一样），请使用：
\`[guestbook: 留言内容]\`
(例如: \`[guestbook: 踩踩！今天也要开心哦~]\`)

`;
                        systemContent += qzoneInstructionBlock;
                    }
                }
                // ▲▲▲ 新增结束 ▲▲▲

                
                // (修改后的视频通话逻辑：强力覆盖模式 - 支持心理描写版)
            if (state.activeCall && contact && state.activeCall.contactId === contact.id) {
                 systemContent += `
\n\n==================================================
[⚠️ 模式强制切换：实时视频通话 (VIDEO CALL LIVE)]
==================================================
【现状重定义】
此刻，你不再是在键盘前打字，而是正拿着手机与用户进行【面对面视频】。
这是一场“视觉小说”风格的演出。

【多维感官描写指令】
请严格使用以下三种符号来区分不同的表达层面：
1. **视觉 (Visuals)**: 用星号 \`*...*\` 描写【画面】。包括：你的微表情（眼神躲闪、脸红）、肢体动作（凑近镜头、整理头发）、环境光影。
2. **心理 (Thoughts)**: 用大括号 \`{...}\` 描写你的【内心独白】。这是用户在视频里“听”不到，但作为观众能看到的真实心声。请多用它来展现你的“口是心非”或“暗自窃喜”。
3. **听觉 (Audio)**: 用双引号 \`“...”\` 包裹你【说出口】的话。语气要口语化，可以包含停顿、语气词（嗯...、那个...）。

【绝对禁止 (Forbidden)】
❌ 禁止写 \`[diary]\` 日记。
❌ 禁止使用 \`[sticker:]\` 表情包。
❌ 禁止出现“发送了一条消息”这种描述。
❌ 不要输出 \`[heart_voice]...[/heart_voice]\` 这种复杂的JSON数据，只用大括号 \`{...}\` 写心声即可。

【输出范例】
*（屏幕晃动了一下，你凑近镜头，眯着眼睛仔细看了看）* “喂？听得清吗？” {奇怪，他那边怎么这么黑，是在外面吗？} *（你理了理耳边的碎发，有些不好意思地笑了笑）* “那个... 突然给你打电话，没打扰你吧？”

请完全沉浸在视频通话的氛围中，立即开始表演！
==================================================
`;
            }
                
                // (你原来的动态指令逻辑)
                const dynamicInstructions = history.filter(msg => msg.sender === 'system_instruction').map(msg => msg.content).join('\n');
                if (dynamicInstructions) { systemContent += `\n\n[附加临时指令]\n${dynamicInstructions}`; }
                
                // (你原来的 history 转换 messages 逻辑，这里是图文支持的关键)
                const messages = [];
                const recentHistory = history
                    .filter(msg => msg.sender !== 'system_instruction' && msg.type !== 'system_notification')
                    .slice(-(contextLength || 20));

                let currentUserMessageParts = [];
                for (const msg of recentHistory) {
                    const role = (msg.sender === 'user') ? 'user' : 'assistant';
                    if (role === 'user') {
                        let textContent = null;
                        
                        if (msg.isRecalled === true) {
                            textContent = `(我撤回了一条消息，但撤回的原文是：“${msg.content}”)`;
                            if (msg.type === 'voice') {
                                textContent = `(我撤回了一条语音，但内容是：“${msg.content.text}”)`;
                            } else if (msg.type === 'picture_description') {
                                textContent = `(我撤回了一张图片，描述是：“${msg.content.description}”)`;
                            } else if (msg.type === 'image' || msg.type === 'uploaded_image') {
                                textContent = `(我撤回了一张图片)`;
                            }
                        } else { 
                            switch (msg.type) {
                                case 'uploaded_image':
                                    currentUserMessageParts.push({ type: 'image_url', image_url: { url: msg.content.base64 } });
                                    break;
                                case 'text':
                                case 'video_call_text':
                                    textContent = msg.content;
                                    if (msg.quote) {
                                        const quoteText = `[用户回复“${msg.quote.senderName}”说的“${msg.quote.content.substring(0, 50)}...”] `;
                                        textContent = quoteText + textContent;
                                    }
                                    break; 
                                case 'html':
                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = msg.content;
                                    textContent = tempDiv.textContent || tempDiv.innerText || "";
                                    break;
                                case 'game_wheel':
                                    const wheel = msg.content;
                                    const userName = (msg.sender === 'user') ? state.myProfile.name : contact.name;
                                    const contactName = (msg.sender === 'user') ? contact.name : state.myProfile.name;
                                    const optionsText = wheel.options.map(opt => opt.text).join('，');
                                    if (!wheel.results.user) { textContent = `[系统游戏状态更新：游戏“${wheel.name}”已创建。选项：【${optionsText}】。游戏尚未开始，等待玩家操作。]`; } 
                                    else if (wheel.results.user && !wheel.results.contact) { textContent = `[系统游戏状态更新：在游戏“${wheel.name}”中，${userName} 的操作结果为“${wheel.results.user}”。指令：${contactName} 必须执行 spin_wheel 操作。]`; } 
                                    else if (wheel.results.user && wheel.results.contact) { textContent = `[系统游戏状态更新：游戏“${wheel.name}”已结束。最终结果：${userName} -> “${wheel.results.user}”，${contactName} -> “${wheel.results.contact}”。]`; }
                                    break;
                                case 'image':
                                    textContent = msg.isEmoticon && msg.emoticonName ? `[用户发送了表情包: ${msg.emoticonName}]` : '[用户发送了一张图片]';
                                    break; 
                                case 'picture_description':
                                    textContent = `[picture:${msg.content.description}]`;
                                    break;
                                case 'voice':
                                    textContent = `[voice:${msg.content.text}]`;
                                    break;
                                case 'red_packet':
                                    textContent = `[red_packet:${msg.content.blessing}, ${msg.content.amount}]`;
                                    break;
                                case 'transfer':
                                    textContent = `[transfer:${msg.content.amount}]`;
                                    break;
                                case 'music_share':
                                    textContent = `(分享了一首音乐: 《${msg.content.title}》 - ${msg.content.artist})`;
                                    break;
                                case 'location_share':
                                    textContent = `(发送了一个位置，地点是：“${msg.content.name}”)`;
                                    break;
                                case 'post_share':
                                    const post = state.posts.find(p => p.id === msg.content.postId);
                                    textContent = post ? `(分享了一个帖子, 内容是: "${post.content.substring(0, 50)}...")` : `(分享了一个已删除的帖子)`;
                                    break;
                                case 'product_share':
                                    const shareData = msg.content; 
                                    const product = shareData.productDetails;
                                    const intentText = shareData.intent === 'gift' ? '这是送给你的礼物' : '想请你帮忙付一下款';
                                    let details = `(分享了一个商品给你。意图是：“${intentText}”。\n[商品名]: ${product.name}\n[价格]: ${product.price}\n[描述]: ${product.description}`;
                                    if (shareData.accompanyingMessage) {
                                        details += `\n[附言]: "${shareData.accompanyingMessage}"`;
                                    }
                                    details += ')';
                                    textContent = details;
                                    break;
                                                                                                   // ▼▼▼ 在这里粘贴全新的 case ▼▼▼
   // ▼▼▼ 核心修复：让 AI 能读懂转发的聊天记录 ▼▼▼
    case 'chat_history_share': {
        const data = msg.content;
        
        // 辅助函数：把具体消息转成文字
        const getPreviewText = (m) => {
            switch(m.type) {
                case 'text': return m.content;
                case 'voice': return `[语音: ${m.content.text}]`;
                case 'image': return `[图片]`;
                case 'red_packet': return `[红包: ${m.content.blessing}]`;
                case 'transfer': return `[转账: ${m.content.amount}]`;
                default: return `[${m.type}]`;
            }
        };

        // 拼接成 AI 易读的剧本格式
        let historyText = `\n[系统通知：用户转发了一份名为《${data.sourceChatName}》的记录给你，内容如下]\n================\n`;
        
        data.messages.forEach(m => {
            const senderName = data.participants[m.sender]?.name || '未知';
            const contentPreview = getPreviewText(m);
            historyText += `${senderName}: ${contentPreview}\n`;
        });
        
        historyText += `================\n[系统指令：这是你（偷偷）查看用户手机看到的记录【并非用户发给你的】，请阅读以上记录，并根据你的人设发表看法/吐槽/吃瓜。]\n`;
        textContent = historyText;
        break;
    }
    // ▲▲▲ 修复结束 ▲▲▲
                            }
                        }
                        if (textContent) {
                            currentUserMessageParts.push({ type: 'text', text: textContent });
                        }
                    } else {
                // This is the 'assistant' block. THIS IS OUR TARGET.
                if (currentUserMessageParts.length > 0) {
                    messages.push({ role: 'user', content: currentUserMessageParts });
                    currentUserMessageParts = [];
                }
                if (msg.type === 'text' || msg.type === 'html') {
                    
                    // ▼▼▼ ✨✨✨ 叙事模式记忆隔离（更优解） ✨✨✨ ▼▼▼
                    
                    let contentForShortTerm = msg.content;
                    
                    // 1. 检查我们当前是否处于【普通模式】
                    if (contact && contact.isNarrativeMode === false) {
                        
                        // 2. 如果是，就用正则表达式“擦除”所有叙事标记
                        //    只保留最纯粹的对话内容
                        contentForShortTerm = contentForShortTerm
                            .replace(/\{(.*?)\}/g, '')  // 移除 {心理}
                            .replace(/\*(.*?)\*/g, '')  // 移除 *动作*
                            .replace(/“/g, '')         // 移除中文引号（只留内容）
                            .replace(/”/g, '')
                            .replace(/\n/g, ' ')       // 把换行符变空格
                            .trim();                   // 清理首尾空格
                    }
                    
                    // 3. 只有在清理后内容不为空时，才把它加入短期记忆
                    if (contentForShortTerm) {
                        messages.push({ role: 'assistant', content: contentForShortTerm });
                    }
                    
                    // ▲▲▲ ✨✨✨ 修复结束 ✨✨✨ ▲▲▲
                }
            }
                }
                if (currentUserMessageParts.length > 0) {
                    messages.push({ role: 'user', content: currentUserMessageParts });
                }
                
                // (你原来的 requestMessages 赋值)
                requestMessages = [{ role: 'system', content: systemContent }, ...messages];
            
            // ▼▼▼ 6. 'else' 逻辑的结尾 ▼▼▼
            }
            // ▲▲▲ 'else' 逻辑结束 ▲▲▲

            // ▼▼▼ 修改：构建请求体时加入 temperature 和 max_tokens ▼▼▼
            const bodyPayload = { 
                model: model, 
                messages: requestMessages 
            };

            // 1. 添加温度 (如果有设置)
            if (apiConfig.temperature !== null && apiConfig.temperature !== undefined && apiConfig.temperature !== '') {
                bodyPayload.temperature = parseFloat(apiConfig.temperature);
            }

            // 2. 添加最大Token (如果有设置且大于0)
            if (apiConfig.maxTokens && apiConfig.maxTokens > 0) {
                bodyPayload.max_tokens = parseInt(apiConfig.maxTokens, 10);
            }
            // ▲▲▲ 修改结束 ▲▲▲
            
            // (你原来的 fetch 和 API 调用逻辑，完全保持不变)
            try {
                let data;
                if (endpoint.includes('generativelanguage.googleapis.com')) {
                  data = await handleGeminiTranslation(bodyPayload, apiKey);
                } else {
                    const cleanEndpoint = normalizeApiEndpoint(endpoint); 
                    const chatEndpoint = `${cleanEndpoint}/v1/chat/completions`;
                    const response = await fetch(chatEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify(bodyPayload)
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error ? errorData.error.message : 'Unknown API error');
                    }
                    data = await response.json();
                }
                return data.choices[0].message.content.trim();
            } catch (error) {
                console.error('API调用失败:', error);
                return `抱歉，调用API时遇到问题: ${error.message}`;
            }
        }
        
        // ✨✨✨ 用这个最终的、真正可定制的版本，替换掉 generateRandomTrendingTopicsAI 函数 ✨✨✨
        async function generateRandomTrendingTopicsAI() {
            // 1. 智能读取你当前设置的任何世界观和风格
            const { worldBookIds, styleDescription } = state.forumSettings;
            
            let worldBookPrompt = '';
            if (worldBookIds.length > 0) {
                const booksContent = worldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                }).join('\n');
                worldBookPrompt = `\n[全局世界观设定 (来自世界书)]\n${booksContent}\n`;
            }

            let stylePrompt = '';
            if (styleDescription) {
                stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"\n`;
            }

            // 2. 生成一份通用的、引导AI思考的“剧本”，而不是规定死内容的剧本
            const prompt = `[SYSTEM] 你的任务是作为一名创意总监，为你的论坛生成8个符合其独特背景的【热搜事件】。

**[背景资料]**
你必须严格基于以下提供的“世界观”和“风格”来构思词条，确保所有内容都符合这个世界的设定。
${worldBookPrompt || "[注意：当前未提供详细世界观设定。]\n"}
${stylePrompt || "[注意：当前未提供详细风格描述。]\n"}

**[任务要求]**
1.  仔细阅读并深刻理解上方提供的“世界观”和“风格描述”。
2.  基于这个独特的背景，构思出8个最可能在这个世界里引起广泛讨论的热门【具体事件】。
3.  【绝对禁止】生成任何与所提供背景无关的词条，特别是现实世界的现代话题。

**[输出格式]**
对于每一个事件，你必须严格、完整地使用以下格式，并重复8次，每次之间用 "---" 分隔：
TITLE: [这里是热搜标题，通常用##包裹，例如：#千金假死#]
DESCRIPTION: [这里是对该事件的一句话（40字左右）新闻描述，解释发生了什么]
---
`;
            try {
                const response = await generateAiResponse(null, [], prompt, false, 'square');
                // ▼▼▼ 把这段新代码粘贴到原来的位置 ▼▼▼
const newTrendingTopics = [];
const topicRegex = /TITLE:\s*(.*?)\s*\nDESCRIPTION:\s*(.*?)(?:\n---|$)/gs;
let match;

while ((match = topicRegex.exec(response)) !== null) {
    const title = match[1].trim();
    const description = match[2].trim();
    if (title && description) {
        newTrendingTopics.push({ title, description });
    }
}

if (newTrendingTopics.length > 0) {
    state.trendingTopics = newTrendingTopics.slice(0, 8).map((topic, index) => ({
        id: `topic_${Date.now()}_${index}`,
        title: topic.title,
        description: topic.description, // 存储description字段
        heat: Math.floor(Math.random() * 500) + 50,
        tag: index < 2 ? '热' : (index < 4 ? '新' : null)
    })).sort((a, b) => b.heat - a.heat);

    await kokoMemory.clear('trendingTopics');
    await kokoMemory.bulkPut('trendingTopics', state.trendingTopics);
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲

            } catch(e) {
                console.error("AI热搜生成失败:", e);
                throw new Error(`AI热搜生成失败: ${e.message}`);
            }
        }

async function generatePostsForRecommendedTab(count = 5) {
            const newPosts = await generatePostsBatch(count, state.trendingTopics);
            await generateInitialCommentsForPosts(newPosts);
            
            // 1. 先把新生成的帖子加进去
            state.posts.unshift(...newPosts);

            // ▼▼▼▼▼▼ 核心修复开始 ▼▼▼▼▼▼
            
            // 2. 分离“空间说说”和“论坛帖子”
            const qzonePosts = state.posts.filter(p => p.category === 'qzone');
            let forumPosts = state.posts.filter(p => p.category !== 'qzone');

            // 3. 只对“论坛帖子”进行数量限制 (比如保留最新的 200 条)
            // 这样，无论论坛怎么刷，都不会误删你的空间说说
            if (forumPosts.length > 200) {
                // 按时间倒序排列确保留下的是新的
                forumPosts.sort((a, b) => b.timestamp - a.timestamp);
                forumPosts = forumPosts.slice(0, 200);
            }

            // 4. 合并回去：(保留下的论坛贴) + (所有的空间说说)
            state.posts = [...forumPosts, ...qzonePosts];
            
            // 5. 按时间重新排序，确保内存状态正确
            state.posts.sort((a, b) => b.timestamp - a.timestamp);

            // ▲▲▲▲▲▲ 修复结束 ▲▲▲▲▲▲

            await kokoMemory.clear('posts');
            await kokoMemory.bulkPut('posts', state.posts);
            state.hasNewPosts = true;
            updateNotificationDots();
        }

// ▼▼▼ 步骤九：用这个【完整】的新函数替换旧的 generatePostsBatch ▼▼▼

async function generatePostsBatch(count, topics = []) {
    const category = state.activeFeedSubTab; // e.g., 'daily' 或 'category_123456'
    
    // --- ✨ 核心改造：动态生成板块要求 ---
    let categoryDescription = '';
    
    // 1. 先在固定的板块里找
    const fixedCategoryPrompts = {
        daily: "关于日常生活的趣事、吐槽、嗑cp或避雷经历",
        food: "关于美食的分享、探店、吐槽或避雷指南",
        gossip: "关于人际关系或娱乐圈的八卦讨论或互撕",
        horror: "恐怖小故事或灵异经历",
    };

    if (fixedCategoryPrompts[category]) {
        categoryDescription = fixedCategoryPrompts[category];
    } else {
        // 2. 没找到？去自定义板块里找
        const customCategory = state.forumCategories.find(c => c.id === category);
        if (customCategory) {
            categoryDescription = customCategory.description; // 使用你定义的“要求”
        } else {
            // 3. 哪都没找到（比如数据出错了），给个默认值
            categoryDescription = "一些随机的帖子内容";
        }
    }
    // --- 改造结束 ---

    // (你原来的所有 Persona, WorldBook, Style, Author 等 Prompt 构建逻辑保持不变)
    const { personaId, worldBookIds, styleDescription } = state.forumSettings;
    
    let personaPrompt = '';
    if (personaId) {
        const persona = state.userPersonaPresets.find(p => p.id === personaId);
        if (persona) {
            personaPrompt = `\n[核心用户信息]\n- 核心用户名为: "${state.myProfile.name}"\n- 他/她当前的身份面具是: "${persona.description}"`;
        }
    }

    let worldBookPrompt = '';
    if (worldBookIds.length > 0) {
        const booksContent = worldBookIds.map(id => {
            const book = state.worldBooks.find(b => b.id === id);
            return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
        }).join('\n');
        worldBookPrompt = `\n[全局世界观设定 (来自世界书)]\n${booksContent}\n所有生成的帖子内容都必须严格符合上述世界观设定。`;
    }

    let stylePrompt = '';
    if (styleDescription) {
        stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
    }

    const allowedContacts = state.contacts.filter(c => 
        !c.isGroup && 
        state.forumSettings.allowedPosterIds && 
        state.forumSettings.allowedPosterIds.includes(c.id)
    );
    const authorsWithMemoryPrompt = allowedContacts.map(c => {
        let recentChatHistory = '(最近没有私聊)';
        if (c.history && c.history.length > 0) {
            recentChatHistory = c.history
                .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                .slice(-8)
                .map(msg => `${msg.sender === 'user' ? state.myProfile.name : c.name}: ${msg.content}`)
                .join('\n    ');
        }
        return `- ${c.name} (人设: ${c.persona.replace(/\n/g, ' ')})\n  - [与“${state.myProfile.name}”的近期私聊参考]:\n    \`\`\`\n    ${recentChatHistory}\n    \`\`\``;
    }).join('\n');

    let topicsForPrompt = '';
    if (topics && topics.length > 0) {
        topicsForPrompt = `
[近期热搜事件参考]
当前世界上正在发生以下主要事件，你的帖子内容应该与这些事件有所关联，让世界感觉更真实。
${topics.map(t => `- ${t.title}: ${t.description}`).join('\n')}

[重要指令：话题标签]
在生成帖子内容时，你有大约30%的几率，需要从上面的“热搜事件参考”中选择一个最相关的话题，并以“#话题标题#”的形式，自然地插入到你的帖子正文的末尾。
`;
    }
            
    // --- ✨ 核心改造：将 categoryDescription 注入到 [任务] 中 ---
    const postsPrompt = `[SYSTEM] 你的任务是扮演一个内容生成引擎。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}

[背景设定]
- 论坛上有一个核心用户叫“${state.myProfile.name}”，TA的公开签名是：“${state.myProfile.signature}”。
${topicsForPrompt} 

[任务]
生成 ${count} 条关于“${categoryDescription}”的社交动态。

**[内容多样性指令 (非常重要)]**
为了让论坛感觉更真实、更有活力，你生成的帖子内容应该具有多样性。
- **减少关联性**: 大部分帖子内容应该像是这个世界里独立发生的事件，与核心用户“${state.myProfile.name}”的个人人设、状态或最近的私聊没有直接关系。
- **创造独立故事线**: 鼓励创造一些与用户完全无关的“路人甲”之间的互动和小故事。让他们有自己的生活和烦恼。
- **只有少数内容可以有关联**: 只有一小部分（例如，生成的帖子中不超过1-2条）内容可以与“${state.myProfile.name}”或其熟人（char）的私聊内容有微弱、间接的关联。不要让整个论坛都围绕着用户转！

**[绝对核心规则]**
在本次生成的 ${count} 条动态中，你【必须确保】至少有 3 条是由你原创的、完全不存在于下方“[可选的帖子作者列表]”中的“路人甲”发布的。这是强制性、不可违反的指令。

**[次要规则]**
1. 剩下的动态，你可以从下方的作者列表中选择作者。
2. 你在为某个“可选列表”中的角色创作帖子时，可以参考他/她附带的“[近期私聊参考]”，帖子内容**可以**作为这些私聊的自然延伸或有感而发，但这**不是强制要求**。请优先考虑上方的[内容多样性指令]。
3. 对于同一个“可选列表”中的作者，在本次任务中最多只能使用一次。

[绝对禁止]
你生成的帖子的作者（AUTHOR）绝对不能是核心用户 “${state.myProfile.name}”。

[可选的帖子作者列表及他们的短期记忆]
${authorsWithMemoryPrompt || "- (无联系人信息)"}

[输出格式] 必须严格遵守:
POST_START
AUTHOR: [作者名]
IS_CONTACT: [true或者false]
CONTENT: [动态的具体内容]
POST_END`;
    // --- 改造结束 ---

    // (你原来的 rawPostsResponse 和 postRegex 逻辑保持不变)
    const rawPostsResponse = await generateAiResponse(null, [], postsPrompt, false, 'square');
    const postRegex = /POST_START\s*AUTHOR:\s*(?<author_name>.*?)\s*IS_CONTACT:\s*(?<is_existing_contact>true|false)\s*CONTENT:\s*(?<content>[\s\S]*?)\s*POST_END/g;
    const postMatches = Array.from(rawPostsResponse.matchAll(postRegex));

    if (postMatches.length === 0) throw new Error(`AI未能按格式要求生成任何动态。`);

    let newPosts = [];
    for (const match of postMatches) {
        const { author_name, is_existing_contact, content } = match.groups;
        let authorProfile;
        if (is_existing_contact.trim().toLowerCase() === 'true') {
            const contact = state.contacts.find(c => c.name === author_name.trim());
            if (contact) {
                authorProfile = { id: contact.id, name: contact.name, avatar: contact.avatar, signature: contact.signature };
            }
        }
        if (!authorProfile) {
            authorProfile = {
                id: `stranger_${Date.now()}_${Math.random()}`, name: author_name.trim(),
                avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)],
                signature: ''
            };
        }
        newPosts.push({
            id: `post_${Date.now()}_${Math.random()}`, author: authorProfile, content: content.trim(),
            category: category, // <-- 核心：确保帖子保存时，带上正确的分类ID
            timestamp: Date.now(),
            likes: [], comments: [], reposts: 0,
            archiveId: state.activeForumArchiveId 
        });
    }
    return newPosts;
}
// ▲▲▲ 替换结束 ▲▲▲

        async function processAiGeneratedComments(rawCommentsResponse, posts, commentRegex) {
            const commentMatches = Array.from(rawCommentsResponse.matchAll(commentRegex));
            const processedComments = [];

            for (const match of commentMatches) {
                const { post_index, commenter_name, reply_to, comment_content } = match.groups;
                const postIndex = parseInt(post_index, 10);

                if (postIndex >= 0 && postIndex < posts.length) {
                    const post = posts[postIndex];
                    let finalCommentContent = comment_content.trim();

                    // 检查是否包含抢红包指令
                    if (finalCommentContent.includes('[抢红包]')) {
                        if (post.redPacket) {
                            if (!post.redPacket.claimers) post.redPacket.claimers = [];
                            
                            const commenterId = `stranger_commenter_${Date.now()}_${Math.random()}`;
                            const hasClaimed = post.redPacket.claimers.some(c => c.userId === commenterId); // 理论上新生成的不会重复
                            const isDepleted = post.redPacket.claimers.length >= post.redPacket.count;

                            if (!isDepleted && !hasClaimed) {
                                // 分配红包金额
                                const remainingCount = post.redPacket.count - post.redPacket.claimers.length;
                                const remainingAmount = post.redPacket.amount - post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0);
                                
                                let amount = 0;
                                if (remainingCount > 1) {
                                    const avg = remainingAmount / remainingCount;
                                    amount = Math.random() * avg * 1.8; // 增加随机性
                                    amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                                } else {
                                    amount = remainingAmount;
                                }
                                amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                                post.redPacket.claimers.push({ userId: commenterId, amount: amount });
                                
                                // 替换指令为实际显示内容
                                finalCommentContent = finalCommentContent.replace('[抢红包]', `🧧 领取了红包 (¥${amount.toFixed(2)})`);
                            } else {
                                finalCommentContent = finalCommentContent.replace('[抢红包]', '手慢了，红包派完了！');
                            }
                        } else {
                            // 帖子里没红包，但AI以为有
                            finalCommentContent = finalCommentContent.replace('[抢红包]', ''); 
                        }
                    }
                    
                    processedComments.push({
                        postIndex: postIndex,
                        comment: {
                            id: `comment_${Date.now()}_${Math.random()}`,
                            author: {
                                id: `stranger_commenter_${Date.now()}_${Math.random()}`, name: commenter_name.trim(),
                                avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                            },
                            content: finalCommentContent,
                            timestamp: post.timestamp + 10000 + (processedComments.length * 1000),
                            replyTo: (reply_to.trim().toLowerCase() === 'null' || reply_to.trim() === '') ? null : reply_to.trim(),
                        }
                    });
                }
            }
            return processedComments;
        }
        
        // ✨✨✨ 用这个新版本，完整替换掉旧的 generateInitialCommentsForPosts 函数 ✨✨✨
        async function generateInitialCommentsForPosts(posts) {
             if (!posts || posts.length === 0) return;
             
            const { personaId, worldBookIds, styleDescription } = state.forumSettings;
            let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
            if (personaId) {
                const persona = state.userPersonaPresets.find(p => p.id === personaId);
                if (persona) personaPrompt = `\n[核心用户信息]\n- 核心用户名为: "${state.myProfile.name}"\n- 他/她当前的身份面具是: "${persona.description}"`;
            }
            if (worldBookIds.length > 0) {
                const booksContent = worldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                }).join('\n');
                worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
            }
            if (styleDescription) {
                stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
            }

             const postsForCommentPrompt = posts.map((post, index) => {
                let postInfo = `[POST ${index}] 作者: ${post.author.name}\n内容: ${post.content}`;
                if (post.redPacket) {
                    postInfo += `\n[重要信息：此帖附带一个“${post.redPacket.blessing}”的红包，总额${post.redPacket.amount}元，共${post.redPacket.count}个。]`;
                }
                return postInfo;
            }).join('\n\n');

            const commentsPrompt = `[SYSTEM] 你的任务是扮演一个“吃瓜群众”评论生成引擎，为下面的帖子生成有互动感的评论区。
        ${stylePrompt}
        ${worldBookPrompt}
        ${personaPrompt}
        ---
        ${postsForCommentPrompt}
        ---
        任务: 为以上帖子生成 2 到 4 条随机的、真实的、简短的评论。
        重要：为了让评论区更真实，请让评论之间有互动，即一些评论是回复另一条评论的。

        [红包互动指南]
        如果一个帖子带有[重要信息：此帖附带...红包]，你生成的评论中，应该有一部分人对此作出反应。为了模拟抢红包的动作，请在他们的评论内容中加入特殊指令 "[抢红包]"。

        **[绝对禁止]**
        **你生成的评论作者（COMMENTER）的名字绝对不能是核心用户“${state.myProfile.name}”。**
        **评论作者也不能是正在被评论的帖子的作者本人。**

        对于每一条评论，必须严格、完整地使用以下格式：
        COMMENT_START
        INDEX: [评论指向的帖子编号]
        COMMENTER: [随机想一个真实的中文网名]
        REPLY_TO: [被回复的评论者名字，如果没有则为null]
        COMMENT: [评论内容，可能包含[抢红包]]
        COMMENT_END`;

            const rawCommentsResponse = await generateAiResponse(null, [], commentsPrompt, false, 'square');
            const commentRegex = /COMMENT_START\s*INDEX:\s*(?<post_index>\d+)\s*COMMENTER:\s*(?<commenter_name>.*?)\s*REPLY_TO:\s*(?<reply_to>.*?)\s*COMMENT:\s*(?<comment_content>[\s\S]*?)\s*COMMENT_END/g;
            
            const processedComments = await processAiGeneratedComments(rawCommentsResponse, posts, commentRegex);

            processedComments.forEach(({ postIndex, comment }) => {
                posts[postIndex].comments.push(comment);
            });
            
            posts.forEach(p => p.comments.sort((a,b) => a.timestamp - b.timestamp));
        }
        
// ==========================================================
// =========== ▼▼▼ 方案B：最终修复版 ▼▼▼ ============
// ==========================================================
//
//  请用下面这个【完整函数】，替换掉你旧的 generateMoreCommentsForPost 函数
//
async function generateMoreCommentsForPost(post) {
    // 1. 获取并构建论坛设置的 Prompt 片段 (和我们修复过的 triggerAiCommentDiscussion 内部逻辑一致)
    const { personaId, worldBookIds, styleDescription } = state.forumSettings;
    let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
    
    if (personaId) {
        const persona = state.userPersonaPresets.find(p => p.id === personaId);
        if (persona) {
            personaPrompt = `
[核心用户信息 (仅供参考)]
- 核心用户名为: "${state.myProfile.name}"
- 他/她当前的身份面具是: "${persona.description}"
[重要提示]：你【绝对不能】使用这个身份面具来【创建新的评论】或【扮演用户】。
`;
        }
    }
    if (worldBookIds.length > 0) {
        const booksContent = worldBookIds.map(id => {
            const book = state.worldBooks.find(b => b.id === id);
            return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
        }).join('\n');
        worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
    }
    if (styleDescription) {
        stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
    }

    // 2. 构建帖子信息 (和 triggerAiCommentDiscussion 内部逻辑一致)
    let postInfoForPrompt = `- 帖子作者: "${post.author.name}"\n- 帖子内容: "${post.content}"`;
    if (post.redPacket) {
        const remainingPackets = post.redPacket.count - (post.redPacket.claimers ? post.redPacket.claimers.length : 0);
        postInfoForPrompt += `\n- [红包信息]：此帖附带红包，祝福语“${post.redPacket.blessing}”，目前剩余 ${remainingPackets} 个。`;
    }

    // 3. 构建 System Prompt (系统提示词)
    const systemPrompt = `[SYSTEM] 你是社交媒体讨论模拟器。你的任务是为下方提供的【图文帖子】和【现有评论】生成 2-3 条新的“路人甲”评论，让讨论继续下去。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}

[主帖子信息]
${postInfoForPrompt}

[红包互动指南]
如果帖子有[红包信息]，你的角色在回复时可以尝试抢红包。若要模拟抢红包，请在评论内容中加入特殊指令 "[抢红包]"。

[绝对禁止的作者名]
在你的任何回复中，你生成的评论作者（COMMENTER）的【名字】绝对不能是核心用户 “${state.myProfile.name}”，也不能是帖子作者“${post.author.name}”。

[输出格式] 必须严格遵守 (每条评论一行):
COMMENTER: [随机想一个真实的中文网名] | REPLY_TO: [null 或 现有评论者名字] | COMMENT: [评论内容]`;

    // 4. 构建核心的 'messages' 数组 (这是最关键的改动)
    const messages = [];
    const userMessageParts = [];

    // 4a. 把所有 *现有评论* 作为上下文
    const existingComments = post.comments.map(c => `- ${c.author.name}: ${c.content}`).join('\n');
    userMessageParts.push({
        type: "text",
        text: `[这是你要评论的帖子文字]：\n"${post.content}"\n\n[这是【已经存在】的评论区，请你接着他们的话题聊]：\n${existingComments || '(还没有评论)'}`
    });
    
    // 4b. 【核心修复】把帖子的图片加进去！
    if (post.image) {
        userMessageParts.push({
            type: "text",
            text: "\n[这是原帖的图片，你的新评论必须参考它：]"
        });
        userMessageParts.push({
            type: "image_url",
            image_url: { url: post.image } // post.image 里存的就是Base64
        });
    }

    // 4c. 最终任务指令
    userMessageParts.push({
        type: "text",
        text: "\n\n[你的任务]：请根据以上所有信息（尤其是图片和现有评论），生成 2-3 条新的 AI 评论。必须严格遵守输出格式！"
    });

    // 4d. 组合
    messages.push({ role: "user", content: userMessageParts });
    const finalRequestMessages = [
        { role: "system", content: systemPrompt },
        ...messages
    ];

    // 5. 【核心修复】调用 "Vision" 路径的 AI (即 generateAiResponse 的“后门”版本)
    const rawResponse = await generateAiResponse(
        null,                   // contact (不需要)
        [],                     // history (不需要)
        null,                   // customSystemPrompt (不需要)
        false,                  // forceDiary (不需要)
        'square',               // apiType (必须是论坛API)
        finalRequestMessages    // ★★★ 我们的图文混合消息 ★★★
    );
    
    // 6. 解析和保存评论 (这部分逻辑和 triggerAiCommentDiscussion 几乎一样)
    const commentRegex = /COMMENTER:\s*(?<commenter_name>.*?)\s*\|\s*REPLY_TO:\s*(?<reply_to>.*?)\s*\|\s*COMMENT:\s*(?<comment_content>[\s\S]*?)(?:\n|$)/g;
    const matches = Array.from(rawResponse.matchAll(commentRegex)); 

    if (matches.length > 0) {
         for (const match of matches) {
            if (!match.groups) continue;
            const { commenter_name, reply_to, comment_content } = match.groups;
            
            let commenterProfile = state.contacts.find(c => c.name === commenter_name.trim());
            if (!commenterProfile) {
                commenterProfile = {
                    id: `stranger_commenter_${Date.now()}_${Math.random()}`,
                    name: commenter_name.trim(),
                    avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                };
            }
            
            let finalCommentContent = comment_content.trim();
            
            // (红包逻辑)
            if (finalCommentContent.includes('[抢红包]')) {
                if (post.redPacket) {
                     if (!post.redPacket.claimers) post.redPacket.claimers = [];
                     const commenterId = commenterProfile.id; // 用生成的ID
                     const hasClaimed = post.redPacket.claimers.some(c => c.userId === commenterId);
                     const isDepleted = post.redPacket.claimers.length >= post.redPacket.count;

                     if (!isDepleted && !hasClaimed) {
                        const remainingCount = post.redPacket.count - post.redPacket.claimers.length;
                        const remainingAmount = post.redPacket.amount - post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0);
                        let amount = 0;
                        if (remainingCount > 1) {
                            const avg = remainingAmount / remainingCount;
                            amount = Math.random() * avg * 1.8;
                            amount = Math.min(remainingAmount - (remainingCount-1)*0.01, amount);
                        } else {
                            amount = remainingAmount;
                        }
                        amount = Math.max(0.01, parseFloat(amount.toFixed(2)));
                        post.redPacket.claimers.push({ userId: commenterId, amount: amount });
                        finalCommentContent = finalCommentContent.replace('[抢红包]', `🧧 领取了红包 (¥${amount.toFixed(2)})`);
                     } else {
                        finalCommentContent = finalCommentContent.replace('[抢红包]', '手慢了，红包派完了！');
                     }
                } else {
                    finalCommentContent = finalCommentContent.replace('[抢红包]', ''); 
                }
            }
            
             post.comments.push({
                id: `comment_${Date.now()}_${Math.random()}`,
                author: commenterProfile,
                content: finalCommentContent,
                timestamp: Date.now() + matches.indexOf(match) * 100, // 评论时间戳
                replyTo: (reply_to.trim().toLowerCase() === 'null' || reply_to.trim() === '') ? null : reply_to.trim(),
            });
        }
        
        // 注意：我们不再从这个函数内部调用数据库和渲染
        // 这些操作留给外层的 `refresh-post-comments-btn` 监听器去做
        // 所以我们只管返回 true 表示成功
        return true; 
    }
    
    // 如果AI没有返回任何有效评论
    return false;
}
// ==========================================================
// =========== ▲▲▲ 方案B：最终修复版 END ▲▲▲ ============
// ==========================================================
// ✨✨✨ 这是你需要粘贴的【辅助函数】 ✨✨✨
const formatContactInfo = (contact, role, userComment) => {
    const userPersona = contact.userPersona ? `你（${contact.name}）和用户“${userComment.author.name}”的私人关系是：“${contact.userPersona}”。` : `你（${contact.name}）和用户“${userComment.author.name}”是普通网友。`;
    let recentChatHistory = '(暂无私聊记录)';
    if (contact && contact.history && contact.history.length > 0) {
        recentChatHistory = contact.history
            .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
            .slice(-35)
            .map(msg => `${msg.sender === 'user' ? userComment.author.name : contact.name}: ${msg.content}`)
            .join('\n');
    }
    
    // 注意：这个函数现在会返回一个对象，而不是直接修改外部变量
    return {
        figureInfo: `\n- ${role}: "${contact.name}" (人设: "${contact.persona || '普通人'}")`,
        relationshipInfo: `\n[${role} “${contact.name}” 的详细资料]\n- ${userPersona}\n- [近期私聊参考]:\n\`\`\`\n${recentChatHistory}\n\`\`\``
    };
};        
// --- (替换) 触发 AI 评论函数 (V3.0 - 支持多模态 Vision) ---
        async function triggerAiCommentDiscussion(post, userComment) {
            showFeedStatus('正在生成AI回复...');
            try {
                // 1. 获取并构建论坛设置的 Prompt 片段 (这部分不变)
                const { personaId, worldBookIds, styleDescription } = state.forumSettings;
                let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
                
                if (personaId) {
                    const persona = state.userPersonaPresets.find(p => p.id === personaId);
                    if (persona) {
                        personaPrompt = `
[核心用户信息 (仅供参考)]
- 核心用户名为: "${state.myProfile.name}"
- 他/她当前的身份面具是: "${persona.description}"
[重要提示]：以上用户信息是AI角色在与用户互动时，对用户的【背景认知】。
你【绝对不能】使用这个身份面具来【创建新的评论】或【扮演用户】。
`;
                    }
                }

                if (worldBookIds.length > 0) {
                    const booksContent = worldBookIds.map(id => {
                        const book = state.worldBooks.find(b => b.id === id);
                        return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                    }).join('\n');
                    worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
                }
                if (styleDescription) {
                    stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
                }

                // 2. 识别被回复的角色和可能的互动角色 (这部分不变)
                let mentionedContact = null;
                const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
                const mentionMatch = mentionRegex.exec(userComment.content);
                if (mentionMatch) {
                    const mentionedName = mentionMatch[1];
                    mentionedContact = state.contacts.find(c => c.name === mentionedName);
                }

                let mandatoryResponder = mentionedContact;
                if (!mandatoryResponder && userComment.replyTo) {
                    const originalComment = post.comments.find(c => c.author.name === userComment.replyTo);
                    if (originalComment) {
                        const repliedToContact = state.contacts.find(c => c.id === originalComment.author.id);
                        if (repliedToContact && repliedToContact.id !== 'myProfile') {
                            mandatoryResponder = repliedToContact;
                        }
                    }
                }
                
                let possibleResponders = state.contacts.filter(c =>
                    c.id !== userComment.author.id && 
                    !c.isGroup && 
                    state.forumSettings.allowedPosterIds && 
                    state.forumSettings.allowedPosterIds.includes(c.id) 
                );

                if (mandatoryResponder) {
                    possibleResponders = possibleResponders.filter(c => c.id !== mandatoryResponder.id);
                }

                let guestResponder = null;
                if (possibleResponders.length > 0 && Math.random() < 0.3) {
                    guestResponder = possibleResponders[Math.floor(Math.random() * possibleResponders.length)];
                }

                // 3. 构建角色档案和关系信息 (这部分不变)
                let notableFiguresForPrompt = `\n[本楼出场人物信息]\n- 主帖作者: "${post.author.name}" (人设: "${post.author.persona || '普通人'}")`;
                let relationshipInfoForPrompt = '';
                
                if (mandatoryResponder) {
                    const formatted = formatContactInfo(mandatoryResponder, '必出场角色 (被@或被回复)', userComment);
                    notableFiguresForPrompt += formatted.figureInfo;
                    relationshipInfoForPrompt += formatted.relationshipInfo;
                }
                if (guestResponder) {
                    const formatted = formatContactInfo(guestResponder, '可能客串的熟人', userComment);
                    notableFiguresForPrompt += formatted.figureInfo;
                    relationshipInfoForPrompt += formatted.relationshipInfo;
                }
                
                if (!relationshipInfoForPrompt) {
                    relationshipInfoForPrompt = "[可参与讨论的角色信息]\n---（本次没有特定的熟人需要出场）---\n";
                } else {
                    relationshipInfoForPrompt = "[可参与讨论的角色信息]\n---" + relationshipInfoForPrompt + "\n---";
                }

                const conversationHistory = post.comments.filter(c => c.author.id === userComment.author.id || (mandatoryResponder && c.author.id === mandatoryResponder.id) || (guestResponder && c.author.id === guestResponder.id)).sort((a, b) => a.timestamp - b.timestamp).slice(-10);
                const conversationHistoryForPrompt = conversationHistory.map(c => `- ${c.author.name}: ${c.content}`).join('\n');
                
                // 4. 构建帖子信息 (这部分不变)
                let postInfoForPrompt = `- 帖子作者: "${post.author.name}"\n- 帖子内容: "${post.content}"`;

                if (post.redPacket) {
                    const remainingPackets = post.redPacket.count - (post.redPacket.claimers ? post.redPacket.claimers.length : 0);
                    postInfoForPrompt += `\n- [红包信息]：此帖附带红包，祝福语“${post.redPacket.blessing}”，目前剩余 ${remainingPackets} 个。`;
                }

                // 5. ▼▼▼ 最大的改动：构建 System Prompt 和 Messages Array ▼▼▼
                
                // 5a. 构建 System Prompt (把所有规则和背景都塞进去)
                const systemPrompt = `[SYSTEM] 你是社交媒体讨论模拟器。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}

[主帖子信息]
${postInfoForPrompt}

[最近的评论对话历史]
${conversationHistoryForPrompt}

${relationshipInfoForPrompt}

[重要规则：红包互动]
如果帖子有[红包信息]，你的角色在回复时可以尝试抢红包。若要模拟抢红包，请在评论内容中加入特殊指令 "[抢红包]"。

[重要规则：路人甲的反应逻辑]
${notableFiguresForPrompt}
当你要扮演一个原创的“路人甲”进行评论时，你必须优先检查上方“本楼出场人物信息”列表里所有角色的人设。如果他们中有人设包含“明星”、“名人”等具有公众辨识度的身份，你扮演的“路人甲”在评论时，【有较高概率】应该体现出已经认识或认出了TA。

[你的任务 - 重要！]
1.  **优先回复**: 如果存在“[必出场角色]”，你的第一条或第二条回复**必须**由他/她发出。
2.  **选择性客串**: 如果存在“[可能客串的熟人]”，**仅当**你觉得他/她的人设符合其人设且能让讨论更有趣时，才让他/她加入。这是**可选的**。
3.  **营造真实感**: 剩下的回复名额，请**务必优先使用你原创的、符合当下场景的“路人甲”**来填充。
4.  **严格遵守格式**: 所有回复都必须严格遵守 \`COMMENTER: [名字] | REPLY_TO: [回复对象] | COMMENT: [内容]\` 格式。

[绝对禁止的作者名]
在你的任何回复中，你生成的评论作者（COMMENTER）的【名字】绝对不能是核心用户 “${userComment.author.name}”。
你也绝对不能扮演用户 “${userComment.author.name}” 的角色来发言。
`;

// 5b. 构建核心的 'messages' 数组
const messages = [];

// 5c. 【核心！】构建用户的图文评论
const userCommentParts = [];

// ▼▼▼ 在这里添加新代码 ▼▼▼
if (post.image) {
    // 1. 告诉 AI 这是主楼的图片
    userCommentParts.push({
        type: "text",
        text: "[这是你正在评论的【原帖】附带的图片，请参考它：]"
    });
    // 2. 把主楼的图片(Base64)传给AI
    userCommentParts.push({
        type: "image_url",
        image_url: {
            url: post.image // 'post.image' 里存的就是Base64
        }
    });
    // 3. 告诉 AI 接下来是用户的评论
    userCommentParts.push({
        type: "text",
        text: "[以下是用户对这个帖子（和你刚看到的图片）的评论：]"
    });
}
// ▲▲▲ 新代码添加结束 ▲▲▲
                
                // 5c-1. 添加回复的上下文（如果有的话）
                let textContent = userComment.content;
                if (userComment.replyTo) {
                    const originalComment = post.comments.find(c => c.author.name === userComment.replyTo);
                    if (originalComment) {
                        textContent = `(回复 @${userComment.replyTo}: "${originalComment.content}") ${userComment.content}`;
                    }
                }
                
                // 5c-2. 添加评论的文字部分
                if (textContent) {
                    userCommentParts.push({
                        type: "text",
                        text: textContent
                    });
                }
                
                // 5c-3. 【关键！】添加评论的图片部分
                if (userComment.image) {
                    // 告诉AI，用户发的是一张图片
                    userCommentParts.push({
                        type: "text",
                        text: "[用户在评论中附带了下面这张图片]"
                    });
                    userCommentParts.push({
                        type: "image_url",
                        image_url: {
                            url: userComment.image // 把Base64字符串传进去
                        }
                    });
                }
                
// 5d. ▼▼▼ 核心修复 ▼▼▼
                // 把最后的指令性消息，也塞进 userCommentParts，合并成一条 user 消息
                userCommentParts.push({
                    type: "text",
                    text: "\n\n[你的任务]：请根据以上所有信息（尤其是我的评论和图片），生成 2-3 条新的 AI 评论。必须严格遵守输出格式！"
                });
                
                // 5e. 现在，只添加这唯一的一条、包含所有内容（文字、图片、指令）的 user 消息
                messages.push({ role: "user", content: userCommentParts });

                // 5f. 组合成最终的请求数组
                const finalRequestMessages = [
                    { role: "system", content: systemPrompt },
                    ...messages
                ];
                
                // 6. ▼▼▼ 核心调用：使用“后门”参数 ▼▼▼
                const rawResponse = await generateAiResponse(
                    null,                   // contact (不需要)
                    [],                     // history (不需要)
                    null,                   // customSystemPrompt (不需要)
                    false,                  // forceDiary (不需要)
                    'square',               // apiType (必须是论坛API)
                    finalRequestMessages    // ★★★ 我们的图文混合消息 ★★★
                );
                
                // (后续的 AI 回复解析逻辑保持不变)
                const commentRegex = /COMMENTER:\s*(?<commenter_name>.*?)\s*\|\s*REPLY_TO:\s*(?<reply_to>.*?)\s*\|\s*COMMENT:\s*(?<comment_content>[\s\S]*?)(?:\n|$)/g;
                const matches = Array.from(rawResponse.matchAll(commentRegex)); 

                if (matches.length > 0) {
                     for (const match of matches) {
                        if (!match.groups) continue;
                        const {
                            commenter_name,
                            reply_to,
                            comment_content
                        } = match.groups;

                        let commenterProfile = state.contacts.find(c => c.name === commenter_name.trim());
                        if (!commenterProfile) {
                            commenterProfile = {
                                id: `stranger_commenter_${Date.now()}_${Math.random()}`,
                                name: commenter_name.trim(),
                                avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                            };
                        }
                        
                        let finalCommentContent = comment_content.trim();
                        
                        // (红包逻辑保持不变)
                        if (finalCommentContent.includes('[抢红包]')) {
                            if (post.redPacket) {
                                 if (!post.redPacket.claimers) post.redPacket.claimers = [];
                                 const hasClaimed = post.redPacket.claimers.some(c => c.userId === commenterProfile.id);
                                 const isDepleted = post.redPacket.claimers.length >= post.redPacket.count;

                                 if (!isDepleted && !hasClaimed) {
                                    const remainingCount = post.redPacket.count - post.redPacket.claimers.length;
                                    const remainingAmount = post.redPacket.amount - post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0);
                                    let amount = 0;
                                    if (remainingCount > 1) {
                                        const avg = remainingAmount / remainingCount;
                                        amount = Math.random() * avg * 1.8;
                                        amount = Math.min(remainingAmount - (remainingCount-1)*0.01, amount);
                                    } else {
                                        amount = remainingAmount;
                                    }
                                    amount = Math.max(0.01, parseFloat(amount.toFixed(2)));
                                    post.redPacket.claimers.push({ userId: commenterProfile.id, amount: amount });
                                    finalCommentContent = finalCommentContent.replace('[抢红包]', `🧧 领取了红包 (¥${amount.toFixed(2)})`);
                                 } else {
                                    finalCommentContent = finalCommentContent.replace('[抢红包]', '手慢了，红包派完了！');
                                 }
                            } else {
                                finalCommentContent = finalCommentContent.replace('[抢红包]', ''); 
                            }
                        }
                        
                         post.comments.push({
                            id: `comment_${Date.now()}_${Math.random()}`,
                            author: commenterProfile,
                            content: finalCommentContent,
                            timestamp: Date.now() + matches.indexOf(match) * 100,
                            replyTo: reply_to.trim(),
                        });
                    }
                    await kokoMemory.put('posts', post);
                    if (state.activePostId === post.id) {
                        await renderPostDetail();
                    }
                }
            } catch (e) {
                console.error("生成AI评论讨论失败:", e);
                alert("AI评论生成失败：" + e.message); // 增加 alert 提示
            } finally {
                hideFeedStatus();
            }
        }
        
        // --- MODIFIED V7.0: 增加分享音乐选项 ---
        // ▼▼▼ 新版本：renderAttachmentMenu ▼▼▼
function renderAttachmentMenu() {
    const menu = document.getElementById('attachment-menu');
    menu.innerHTML = `
        <div class="attachment-menu-item" data-action="send-picture">
            <div class="icon-wrapper"><i class="fas fa-image"></i></div>
            <div class="label">图片</div>
        </div>
        <div class="attachment-menu-item" data-action="send-voice">
            <div class="icon-wrapper"><i class="fas fa-microphone"></i></div>
            <div class="label">语音</div>
        </div>
        <div class="attachment-menu-item" data-action="send-red-packet">
            <div class="icon-wrapper"><i class="fas fa-wallet"></i></div>
            <div class="label">红包</div>
        </div>
        <div class="attachment-menu-item" data-action="send-transfer">
            <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
            <div class="label">转账</div>
        </div>
        <div class="attachment-menu-item" data-action="share-music">
            <div class="icon-wrapper"><i class="fas fa-music"></i></div>
            <div class="label">音乐</div>
        </div>
        <div class="attachment-menu-item" data-action="game-wheel"> <div class="icon-wrapper"><i class="fas fa-bullseye"></i></div> <div class="label">转盘游戏</div> 
        </div>
        <div class="attachment-menu-item" data-action="start-video-call">
            <div class="icon-wrapper"><i class="fas fa-video"></i></div>
            <div class="label">视频通话</div>
        </div>
    `;
}
        // ↓↓↓ 把这个全新的函数整个粘贴进去 ↓↓↓
function addWheelOptionInput(text = '', weight = 1) {
    const container = document.getElementById('wheel-options-container');
    const newItem = document.createElement('div');
    newItem.className = 'wheel-option-item';
    newItem.innerHTML = `
        <input type="text" class="contact-form-input wheel-option-text" value="${text}" placeholder="选项内容">
        <input type="number" class="contact-form-input wheel-option-weight" value="${weight}" min="1" title="权重(份数)">
        <button class="delete-option-btn">&times;</button>
    `;
    container.appendChild(newItem);
    newItem.querySelector('.delete-option-btn').addEventListener('click', () => {
        // 至少保留2个选项
        if (container.children.length > 2) {
            newItem.remove();
        } else {
            alert('转盘至少需要2个选项哦！');
        }
    });
}
// ↑↑↑ 新增代码结束 ↑↑↑

        // --- MODIFIED V7.0: 增加处理分享音乐的逻辑 ---
        function handleAttachmentAction(action) {
            const menu = document.getElementById('attachment-menu');
            menu.classList.remove('active');

            const addOneTimeListener = (buttonId, callback) => {
                const oldBtn = document.getElementById(buttonId);
                const newBtn = oldBtn.cloneNode(true);
                oldBtn.parentNode.replaceChild(newBtn, oldBtn);
                newBtn.addEventListener('click', callback);
            };

            switch(action) {
                // 在 handleAttachmentAction 函数的 switch 语句中
case 'send-location': { // 假设你给附件菜单里的位置按钮加了 data-action="send-location"
    const contact = state.contacts.find(c => c.id === state.activeChatId);

    // 【核心检查】
    if (!contact || !contact.mapId) {
        alert('要发送位置，请先在“更多信息”中为该联系人关联一张地图。');
        return;
    }

    // 打开地点选择器
    openLocationPicker(contact.mapId);
    break;
}
case 'upload-image': document.getElementById('image-upload-input').click(); break;
                case 'send-picture': {
                    const modal = document.getElementById('send-picture-modal');
                    const descriptionInput = document.getElementById('send-picture-description-input');
                    descriptionInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-picture-btn', async () => {
                        const description = descriptionInput.value.trim();
                        if (description) {
                            await createAndAddMessage({ type: 'picture_description', content: { description } });
                            modal.style.display = 'none';
                        }
                    });
                    break;
                }
                // 在 handleAttachmentAction 函数中...

// ... 其他 case ...
case 'send-group-transfer': {
    const group = state.contacts.find(c => c.id === state.activeChatId);
    if (!group || !group.isGroup) break;

    const modal = document.getElementById('group-transfer-recipient-picker-modal');
    const recipientListEl = document.getElementById('group-transfer-recipient-list');
    const amountInput = document.getElementById('group-transfer-amount-input');
    amountInput.value = '';
    recipientListEl.innerHTML = '';
    
    // 动态加载群成员 (排除自己)
    group.members.forEach(memberId => {
        if (memberId === 'myProfile') return;
        const member = state.contacts.find(c => c.id === memberId);
        if (member) {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            // 使用 radio button 确保只能选一个
            item.innerHTML = `
                <input type="radio" id="recipient-radio-${member.id}" name="group-recipient" value="${member.id}">
                <label for="recipient-radio-${member.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <img src="${member.avatar}" alt="${member.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                    <span>${member.name}</span>
                </label>
            `;
            recipientListEl.appendChild(item);
        }
    });

    modal.style.display = 'flex';

    document.getElementById('close-group-transfer-picker-modal').addEventListener('click', () => {
        modal.style.display = 'none';
    }, { once: true });

    addOneTimeListener('confirm-group-transfer-btn', async () => {
        const selectedRadio = document.querySelector('input[name="group-recipient"]:checked');
        if (!selectedRadio) {
            return alert('请选择一个收款人！');
        }
        const recipientId = selectedRadio.value;
        const amount = parseFloat(amountInput.value);

        if (isNaN(amount) || amount <= 0) {
            return alert('请输入有效的转账金额！');
        }
        if (state.myProfile.balance < amount) {
            return alert('钱包余额不足！');
        }
        
        state.myProfile.balance -= amount;
        const recipient = state.contacts.find(c => c.id === recipientId);
        await addTransaction('expense', amount, `在群聊中转账给 ${recipient.name}`, group.id);
        
        // 创建一个新的转账消息，带有收款人信息
        await createAndAddMessage({
            type: 'transfer',
            content: {
                amount: amount.toFixed(2),
                completed: false,
                returned: false,
                recipientId: recipientId // 关键信息！
            }
        });

        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
        modal.style.display = 'none';
    });
    break;
}
                case 'send-voice': {
                    const modal = document.getElementById('send-voice-modal');
                    const voiceTextInput = document.getElementById('send-voice-text-input');
                    voiceTextInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-voice-btn', async () => {
                        const voiceText = voiceTextInput.value.trim();
                        if (voiceText) {
                            const duration = Math.max(1, Math.round(voiceText.length / 4));
                            await createAndAddMessage({ type: 'voice', content: { duration, text: voiceText } });
                            modal.style.display = 'none';
                        }
                    });
                    break;
                }
                // 在 handleAttachmentAction 函数中...

case 'send-red-packet': {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) break;

    const modal = document.getElementById('send-red-packet-modal');
    // 动态修改弹窗，以适应群聊和私聊
    const modalBody = modal.querySelector('.modal-body');
    
    let amountInputHTML = `
        <div class="contact-form-group">
            <label class="contact-form-label">金额 (元)</label>
            <input type="number" class="contact-form-input" id="send-red-packet-amount-input" placeholder="0.00">
        </div>`;
    
    let countInputHTML = '';
    // 如果是群聊，增加“红包个数”输入框
    if (contact.isGroup) {
        countInputHTML = `
            <div class="contact-form-group">
                <label class="contact-form-label">红包个数</label>
                <input type="number" class="contact-form-input" id="send-red-packet-count-input" placeholder="填写个数，比如10">
            </div>`;
    }

    modalBody.innerHTML = `
        ${amountInputHTML}
        ${countInputHTML}
        <div class="contact-form-group">
            <label class="contact-form-label">祝福语 (可选)</label>
            <input type="text" class="contact-form-input" id="send-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
        </div>
        <button class="form-button" id="confirm-send-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
    `;
    
    modal.style.display = 'flex';
    
    addOneTimeListener('confirm-send-red-packet-btn', async () => {
        const amount = parseFloat(document.getElementById('send-red-packet-amount-input').value);
        const blessing = document.getElementById('send-red-packet-blessing-input').value.trim() || "恭喜发财，大吉大利！";
        
        if (isNaN(amount) || amount <= 0) {
            return alert("请输入有效的金额！");
        }
        if (state.myProfile.balance < amount) {
            return alert('钱包余额不足！');
        }

        // 核心逻辑分离
        if (contact.isGroup) {
            // 群聊逻辑
            const countInput = document.getElementById('send-red-packet-count-input');
            const count = parseInt(countInput.value, 10);
            if (isNaN(count) || count <= 0) {
                return alert("请输入有效的红包个数！");
            }
            if (amount / count < 0.01) {
                return alert("单个红包金额不能低于0.01元！");
            }

            state.myProfile.balance -= amount;
            await addTransaction('expense', amount, `在群聊"${contact.name}"中发红包`, contact.id);

            await createAndAddMessage({
                type: 'red_packet',
                content: {
                    totalAmount: amount,
                    count: count,
                    blessing: blessing,
                    claimers: [] // 初始化领取者列表
                }
            });

        } else {
            // 私聊逻辑 (不变)
            state.myProfile.balance -= amount;
            await addTransaction('expense', amount, `发红包给 ${contact.name}`, contact.id);

            await createAndAddMessage({
                type: 'red_packet',
                content: {
                    amount: amount.toFixed(2), // 私聊是单个红包
                    blessing: blessing,
                    opened: false
                }
            });
        }
        
        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
        modal.style.display = 'none';
    });
    break;
}
                case 'send-transfer': {
                    const modal = document.getElementById('send-transfer-modal');
                    const amountInput = document.getElementById('send-transfer-amount-input');
                    amountInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-transfer-btn', async () => {
                        const transferAmount = parseFloat(amountInput.value);
                        if (!isNaN(transferAmount) && transferAmount > 0) {
                            if(state.myProfile.balance < transferAmount) {
                                alert('钱包余额不足！');
                                return;
                            }
                            state.myProfile.balance -= transferAmount;
                            await addTransaction('expense', transferAmount, `转账给 ${state.contacts.find(c=>c.id === state.activeChatId).name}`, state.activeChatId);
                            renderMyProfile();
                            await kokoMemory.put('myProfile', state.myProfile);

                            await createAndAddMessage({
                                type: 'transfer',
                                content: { amount: transferAmount.toFixed(2), completed: false }
                            });
                            modal.style.display = 'none';
                        } else {
                            alert("请输入有效的金额！");
                        }
                    });
                    break;
                }
                
                 // --- NEW: V7.0 ---
case 'share-music': {
    const modal = document.getElementById('send-music-modal');
    // 清空所有输入框
    document.getElementById('send-music-url-input').value = '';
    document.getElementById('send-music-title-input').value = '';
    document.getElementById('send-music-artist-input').value = '';
    document.getElementById('send-music-lrc-input').value = ''; // 清空歌词
    document.getElementById('send-music-cover-input').value = '';
    document.getElementById('music-search-keyword-modal').value = ''; // 清空搜索框
    document.getElementById('music-search-results-modal').innerHTML = '<p style="color: #999; text-align: center; padding: 10px;">在这里搜索，结果会显示在下方</p>'; // 重置结果区

    document.getElementById('notify-ai-checkbox').checked = true;
    modal.style.display = 'flex';
    
    renderMusicPickerInModal(); // (如果你保留了本地曲库选择功能的话)

    addOneTimeListener('confirm-send-music-btn', async () => {
        const url = document.getElementById('send-music-url-input').value.trim();
        const title = document.getElementById('send-music-title-input').value.trim();
        const artist = document.getElementById('send-music-artist-input').value.trim();
        // ✨ 获取隐藏输入框里的歌词
        const lrc = document.getElementById('send-music-lrc-input').value;
        const cover = document.getElementById('send-music-cover-input').value;

        if (!url || !title) {
            alert('请至少填写歌曲名和URL（或通过搜索自动填充）！');
            return;
        }
        
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        
        // 构建完整的歌曲对象
        const song = { title, artist, url, lrc }; // ✨ 歌词被带上了！
        
        // 添加到播放列表并分享
        contact.sharedPlaylist.tracks.push(song);
        await createAndAddMessage({ type: 'music_share', content: song }, 'user', contact, false, 'chat');
        
        if (document.getElementById('notify-ai-checkbox').checked) {
            const systemPrompt = `[SYSTEM: 用户分享了一首歌曲《${title}》，来自${artist || '未知艺术家'}。请你发表一下你的感想。]`;
            await requestAiReply(systemPrompt);
        }

        modal.style.display = 'none';
    });
    break;
}
                
                    case 'game-wheel': {
    const modal = document.getElementById('create-wheel-modal');
    const optionsContainer = document.getElementById('wheel-options-container');
    document.getElementById('wheel-name-input').value = '';
    optionsContainer.innerHTML = ''; // 清空旧选项

    // 默认创建2个选项
    addWheelOptionInput('真心话', 1);
    addWheelOptionInput('大冒险', 1);

    modal.style.display = 'flex';
    break;
}
                    case 'start-video-call': if (state.activeChatId) { startVideoCall(state.activeChatId, 'user'); } else { alert("请先选择一个聊天对象！"); } break;
            }
        }
        
        function showDiaryScreen() {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            hideAllScreens();
            document.getElementById('diary-screen').style.display = 'flex';
            document.getElementById('diary-title').textContent = `${contact.name}的日记`;
            renderDiary();
        }

// 替换掉旧的 renderDiary 函数
function renderDiary() {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    const diaryContentList = document.getElementById('diary-content-list');
    diaryContentList.innerHTML = '';

    if (!contact || !contact.diary || contact.diary.length === 0) {
        diaryContentList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-book" style="font-size: 48px; margin-bottom: 15px;"></i><p>他的日记本是空的。</p></div>`;
        return;
    }

    const sortedDiary = [...contact.diary].sort((a, b) => b.timestamp - a.timestamp);

    sortedDiary.forEach(entry => {
        const entryEl = document.createElement('div');
        entryEl.className = 'diary-entry';

        // 如果在已选中的Set里，就加上 'selected' 类
        if (diaryEditModeState.selectedEntryIds.has(entry.id)) {
            entryEl.classList.add('selected');
        }

        let entryHTML = '';
        if (diaryEditModeState.active) {
            // 【编辑模式】显示复选框
            const isChecked = diaryEditModeState.selectedEntryIds.has(entry.id) ? 'checked' : '';
            entryHTML = `
                <div style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <input type="checkbox" class="diary-select-checkbox" data-diary-id="${entry.id}" ${isChecked}>
                    <div style="flex-grow: 1;">
                        <div class="diary-entry-meta">${formatTimeAgo(entry.timestamp)}</div>
                        <div class="diary-entry-content">${entry.content.replace(/\n/g, '<br>')}</div>
                    </div>
                </div>
            `;
        } else {
            // 【普通模式】显示原来的删除按钮
            entryHTML = `
                <div class="diary-entry-meta">${formatTimeAgo(entry.timestamp)}</div>
                <div class="diary-entry-content">${entry.content.replace(/\n/g, '<br>')}</div>
                <div class="diary-delete-btn" data-diary-id="${entry.id}"><i class="fas fa-trash-alt"></i></div>
            `;
        }
        entryEl.innerHTML = entryHTML;
        diaryContentList.appendChild(entryEl);
    });
}
// 新增的函数
function enterDiaryEditMode() {
    diaryEditModeState.active = true;
    diaryEditModeState.selectedEntryIds.clear(); // 清空上次的选择
    document.getElementById('diary-edit-mode-bar').style.display = 'flex';
    renderDiary(); // 重新渲染日记列表以显示复选框
}

function exitDiaryEditMode() {
    diaryEditModeState.active = false;
    document.getElementById('diary-edit-mode-bar').style.display = 'none';
    renderDiary(); // 重新渲染日记列表以恢复原样
}
        // ▼▼▼ 用下面这个【完整的新版本】，替换掉你旧的 createSystemNotification 函数 ▼▼▼

async function createSystemNotification(content, targetContact = null, contextMode = 'chat') { // 默认设为 'chat'
    // 同样，如果未指定目标，就用当前窗口的，否则用指定的目标
    const contact = targetContact || state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

await createAndAddMessage({
        type: 'system_notification',
        sender: 'system',
        content: content
    }, 'system', contact, false, contextMode); // 把 mode 传递下去

// ▲▲▲ 替换到这里结束 ▲▲▲
}        
        async function showTransferModal(message, contact) {
            const modal = document.getElementById('transfer-modal');
            
            // 获取新HTML结构中的所有元素
            const confirmView = document.getElementById('transfer-confirm-view');
            const statusView = document.getElementById('transfer-status-view');
            
            const senderAvatarEl = document.getElementById('transfer-sender-avatar');
            const senderNameEl = document.getElementById('transfer-sender-name');
            const recipientTextEl = document.getElementById('transfer-recipient-text');
            const amountValueEl = document.getElementById('transfer-amount-value');

            const statusAmountValueEl = document.getElementById('transfer-status-amount-value');
            const statusIconEl = document.getElementById('transfer-status-icon');
            const statusTextEl = document.getElementById('transfer-status-text');
            const statusSenderInfoEl = document.getElementById('transfer-status-sender-info');
            
            const sender = (message.sender === 'user') ? state.myProfile : contact;
            const recipient = (message.sender === 'user') ? contact : state.myProfile;
            
            amountValueEl.textContent = message.content.amount;
            statusAmountValueEl.textContent = message.content.amount;

            // --- 移除并重新绑定事件监听，防止重复绑定 ---
            const confirmBtn = document.getElementById('confirm-transfer-btn');
            const returnBtn = document.getElementById('return-transfer-btn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newReturnBtn = returnBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            returnBtn.parentNode.replaceChild(newReturnBtn, returnBtn);

            // 确认收款按钮的逻辑 (已修改)
            // --- 修正后的代码 ---
newConfirmBtn.addEventListener('click', async () => {
    const transferAmount = parseFloat(message.content.amount);
    const senderProfile = contact; // 在这个上下文中，'contact'就是发送者
    const groupChat = state.contacts.find(c => c.id === state.activeChatId); // 获取当前的群聊对象

    if (!groupChat) return; // 安全检查

    if (!isNaN(transferAmount)) {
        state.myProfile.balance += transferAmount;
        await addTransaction('income', transferAmount, `收到 ${senderProfile.name} 的转账`, senderProfile.id);
        await createSystemNotification(`你已收款 ¥${transferAmount.toFixed(2)}`);
        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
    }

    // 在群聊的历史记录里更新这条消息的状态
    const messageInHistory = groupChat.history.find(m => m.id === message.id);
    if (messageInHistory) {
        messageInHistory.content.completed = true;
        messageInHistory.content.returned = false;
    }

    // 核心修正 1：保存的是群聊对象，而不是发钱的角色对象
    await kokoMemory.put('contacts', groupChat); 

    modal.style.display = 'none';
    // 核心修正 2：重新打开的是当前的群聊界面
    await openChat(state.activeChatId);

    // 这条消息现在会正确地添加到群聊的记忆中
    await createAndAddMessage({
        type: 'text',
        content: `[SYSTEM: 我刚刚点击并接受了 ${senderProfile.name} 的转账。]`
    }, 'system_instruction');
});
            
            // 退还按钮的逻辑
            // --- 修正后的代码 ---
newReturnBtn.addEventListener('click', async () => {
    const senderProfile = contact; // 'contact' 在这里就是发送者
    const groupChat = state.contacts.find(c => c.id === state.activeChatId); // 获取当前聊天（群聊或私聊）

    if (!groupChat) return; // 安全检查

    // 在当前聊天记录里更新这条消息的状态
    const messageInHistory = groupChat.history.find(m => m.id === message.id);
    if (messageInHistory) {
        messageInHistory.content.completed = true;
        messageInHistory.content.returned = true;
    }

    // 核心修正 1：保存的是包含历史记录的当前聊天对象
    await kokoMemory.put('contacts', groupChat);

    await createSystemNotification(`你已退还该笔转账`);

    modal.style.display = 'none';
    // 核心修正 2：重新打开的是当前的聊天界面（私聊或群聊），而不是跳转
    await openChat(state.activeChatId);

    // 为了让AI在群聊中更清晰，优化了SYSTEM指令
    await createAndAddMessage({
        type: 'text',
        content: `[SYSTEM: 我刚刚退回了 ${senderProfile.name} 的转账。]`
    }, 'system_instruction');
});

            // 根据消息状态更新UI
            senderAvatarEl.src = sender.avatar;
            senderNameEl.textContent = sender.name;
            
            if (message.content.completed || message.content.returned) {
                // 如果是已完成或已退还的交易
                confirmView.style.display = 'none';
                statusView.style.display = 'block';
                
                statusIconEl.className = message.content.returned ? 'fas fa-undo-alt' : 'fas fa-check-circle';
                statusTextEl.textContent = message.content.returned ? '已退还' : (message.sender === 'user' ? '对方已收款' : '已收款');
                statusSenderInfoEl.textContent = `转账来自: ${sender.name}`;

            } else if (message.sender !== 'user') { // 我是收款方，未处理
                confirmView.style.display = 'block';
                statusView.style.display = 'none';
                recipientTextEl.textContent = "转账给你";
                newConfirmBtn.style.display = 'block';
                newReturnBtn.style.display = 'block';
            } else { // 我是付款方，对方未处理
                confirmView.style.display = 'block';
                statusView.style.display = 'none';
                recipientTextEl.textContent = `转账给 ${recipient.name}`;
                newConfirmBtn.style.display = 'none';
                newReturnBtn.style.display = 'none';
            }
            
            modal.style.display = 'flex';
            document.getElementById('close-transfer-modal').onclick = () => modal.style.display = 'none';
        }

// ▼▼▼ 把这个新函数粘贴到 processAndDisplayAiResponse 的【上方】 ▼▼▼

/**
 * (全新) 辅助函数：只刷新单个消息气泡的DOM，而不重载整个聊天
 * @param {string} messageId - 要刷新的消息的ID
 */
async function refreshMessageBubbleInDOM(messageId) {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const msg = contact.history.find(m => m.id === messageId);
    if (!msg) return; // 找不到消息数据

    const wrapper = document.querySelector(`.message-wrapper[data-message-id="${messageId}"]`);
    if (!wrapper) return; // 消息不在屏幕上，不用刷新

    try {
        // 1. 检查这条消息在DOM中是否是“序列的第一个”（用来决定是否显示头像）
        const isFirstInSequence = wrapper.classList.contains('is-first-in-sequence');

        // 2. 用【更新后】的 msg 数据，调用 createMessageElement 重新创建一个【新】的HTML元素
        const newWrapper = createMessageElement(msg, contact, isFirstInSequence);

        if (newWrapper) {
            // 3. 在旧元素的父节点中，用新元素替换掉旧元素
            wrapper.parentNode.replaceChild(newWrapper, wrapper);
        }
    } catch (e) {
        console.error("单点刷新气泡失败:", e, "将回退到完整刷新");
        // 如果（万一）失败了，就执行旧的刷新逻辑
        await openChat(contact.id);
    }
}
// ▼▼▼ 使用这个【最终解决方案】替换掉你原来的 processAndDisplayAiResponse 函数 ▼▼▼
async function processAndDisplayAiResponse(rawResponse, senderProfile, originContext = null, contextMode = 'chat') { // 默认设为 'chat'
    if (!senderProfile) return;
        // ▼▼▼ ✨✨✨ 粘贴这个 if 判断 ✨✨✨ ▼▼▼
  // ▼▼▼ 使用这个【V2 完整修正版】替换掉旧的 "if (state.currentChatMode === 'sms')" 代码块 ▼▼▼

    if (contextMode === 'sms') {
        // --- 短信模式的处理逻辑 ---
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        // 1. 过滤掉日记和心声 (短信里不需要)
        let smsContent = rawResponse.replace(/\[diary\][\s\S]*?(\[\/diary\]|$)/g, '').trim();
        smsContent = smsContent.replace(/\[heart_voice\][\s\S]*?(\[\/heart_voice\]|$)/g, '').trim();

        // 2. ✨ 核心修改：借用一个简化的正则表达式，让它能识别 action 和 picture ✨
        const smsCommandRegex = /\[(picture|action)(?::([^\]]*))?\]/;
        
        const lines = smsContent.split('\n').filter(line => line.trim() !== '');
        
        for (const line of lines) {
            const commandMatch = line.match(smsCommandRegex);
            let processed = false; // 标记这行是否是指令

            if (commandMatch) {
                processed = true; // 标记为已处理
                const command = commandMatch[1];
                const value = commandMatch[2] || '';
                
                switch (command) {
                    case 'picture':
                        // (处理图片的逻辑不变)
                        await createAndAddMessage({
                            type: 'picture_description',
                            sender: senderProfile.id,
                            content: { description: value.trim() }
                        }, senderProfile.id, contact, false, 'sms'); // 指定发送到短信历史
                        break;
                    
// ▼▼▼ ✨ 使用这个【正确版本】替换 ✨ ▼▼▼
                    case 'action':
                        if (value === 'unblock_user') {
                            senderProfile.blockedStatus = 'none';
                            await kokoMemory.put('contacts', senderProfile);
                            
                            // --- 核心修复 ---
                            
                            // 1. 临时切换到 'chat' 模式
                            const originalMode = state.currentChatMode;
                            state.currentChatMode = 'chat'; 
                            
                            // 2. 在 'chat' 模式下发送系统通知到【主聊天】
                            //    注意：我们传入 senderProfile 作为目标，
                            //    这样 createAndAddMessage 会把消息添加到 senderProfile.history 数组中
                            await createAndAddMessage({
                                type: 'system_notification',
                                sender: 'system',
                                content: `${senderProfile.name} 已将你解除拉黑。`
                            }, 'system', senderProfile); 
                            
                            // 3. 立即切回 'sms' 模式，准备发送AI的“话”
                            state.currentChatMode = originalMode;
                            
                            // 4. 解锁主界面的输入框 (这个不变)
                            updateChatInputLockState('none');
                            
                            // --- 修复结束 ---
                        }
                        // (AI 在短信模式下拉黑用户没有意义，所以我们忽略 block_user)
                        break;
                    // ▲▲▲ 替换结束 ▲▲▲
                }
            } 
            
            // 4. 如果不是指令，并且不是空行，才作为普通文本发送
            if (!processed && line.trim()) {
                await createAndAddMessage({
                    type: 'text',
                    sender: senderProfile.id,
                    content: line.trim()
                }, senderProfile.id, contact, false, 'sms'); // 指定发送到短信历史
            }
            
            await sleep(300 + Math.random() * 300); // 模拟短信延迟
        }
        return; // ✨ 处理完短信逻辑后，必须返回！
    }

// ▲▲▲ 替换到这里结束 (后面的 else 逻辑，即主聊天的逻辑，保持不变) ▲▲▲

    // ... (函数剩余的 else { ... } 部分，即主聊天的逻辑，保持原样) ...

    let effectiveChatContext;

    // 【V3 修复版逻辑】
    // 目的地（originContext）现在总是由调用方（triggerAiReply/triggerGroupChatAiReply）
    // 明确提供，我们不再需要猜测。
    if (originContext) {
        effectiveChatContext = originContext;
    } else {
        // 如果（万一）调用方没有提供目的地，我们唯一的安全选择是
        // 将回复发给发送者自己的私聊窗口，而不是发到当前打开的窗口。
        effectiveChatContext = senderProfile; 
    }
    
    if (!effectiveChatContext) {
        console.error("错误：无法为AI回复确定一个有效的目的地。");
        return; 
    }
    
    let conversation = rawResponse;
    const extractionRegex = /\[发送了一段静态内容，文本是：["']([\s\S]*?)["']\]/g;
    conversation = conversation.replace(extractionRegex, '').trim();

 // ========================= 【核心修复：心声解析】 =========================
let heartVoiceContent = null;

// ▼▼▼ 核心修复：使用更严格的正则表达式，只匹配 { ... } JSON 对象 ▼▼▼
// 's' 标志让 '.' 匹配换行符，确保 { ... } 可以跨行
const heartVoiceRegex = /\[heart_voice\]\s*({[\s\S]*?})\s*(?:\[\/heart_voice\]|(?=\[diary\]|$))/;
const heartVoiceMatch = conversation.match(heartVoiceRegex);

if (heartVoiceMatch) {
    // heartVoiceMatch[1] 现在 *只* 包含 { ... }
    const jsonString = heartVoiceMatch[1] ? heartVoiceMatch[1].trim() : ''; 

    if (jsonString) {
        try {
            // 我们不再需要 cleanedJsonString，因为 regex 已经帮我们拿到了纯净的 JSON
            heartVoiceContent = JSON.parse(jsonString); 
        } catch (e) {
            console.error("解析心声JSON失败 (AI格式错误):", e, "原始字符串:", jsonString);
            // 即使解析失败，我们也要继续，并把错误的文本从对话中移除
        }
    }

    // 关键：heartVoiceMatch[0] 包含完整的 [heart_voice]{...} 
    // 我们用它来替换，就能把心声从【任何位置】（开头、中间、结尾）精准地剥离出去
    // 这就解决了你截图中的BUG
    conversation = conversation.replace(heartVoiceMatch[0], '').trim();
}
// ▲▲▲ 修复结束 ▲▲▲
// ========================= 【修复结束】 =========================

    // ▼▼▼▼▼▼▼▼▼▼ 【新增：优先提取状态指令】 ▼▼▼▼▼▼▼▼▼▼
    // 在进入任何渲染逻辑前，先把 status 指令挖出来执行掉，并从文本中删除
    // 这样可以防止它混入叙事文本导致“掉格式”
    const globalStatusRegex = /\[status:\s*([^\]]+)\]/i;
    const statusMatch = conversation.match(globalStatusRegex);

    if (statusMatch) {
        let newStatus = statusMatch[1].trim();
        
        // 过滤无效状态 (复用之前的逻辑)
        const forbiddenStatusWords = ['正在输入', 'typing', 'inputting', '对方正在', '...'];
        if (forbiddenStatusWords.some(word => newStatus.includes(word))) {
            console.log(`拦截了无效状态: ${newStatus}`);
            newStatus = "在线"; 
        }

        if (newStatus) {
            // 1. 更新数据
            senderProfile.status = newStatus;
            await kokoMemory.put('contacts', senderProfile);
            
            if (state.activeChatId === senderProfile.id) {
                const statusEl = document.getElementById('chat-contact-status');
                if (statusEl) statusEl.textContent = newStatus;
            }

            // 2. 发送系统通知
            await createAndAddMessage({ 
                type: 'system_notification', 
                sender: 'system', 
                content: `状态变更为：${newStatus}` 
            }, senderProfile.id, effectiveChatContext, false, 'chat');
        }

        // ★★★ 关键：从对话文本中彻底移除这条指令 ★★★
        conversation = conversation.replace(statusMatch[0], '').trim();
    }
    // ▲▲▲▲▲▲▲▲▲▲ 新增结束 ▲▲▲▲▲▲▲▲▲▲ ...
    // ... (上面是 [status: ...] 的处理代码)

    // ▼▼▼ ✨✨✨ 新增：全局提取 [memory:...] 指令 (支持叙事模式) ✨✨✨ ▼▼▼
    // 使用 while 循环，以防 AI 激动了一次输出了多条记忆
    const globalMemoryRegex = /\[memory:\s*([^\]]+)\]/i;
    let memoryMatch;

    while ((memoryMatch = conversation.match(globalMemoryRegex)) !== null) {
        const memoryContent = memoryMatch[1].trim();

        if (memoryContent) {
            console.log("捕获到记忆指令:", memoryContent);

            // 1. 初始化数组
            if (!effectiveChatContext.permanent_memories) {
                effectiveChatContext.permanent_memories = [];
            }

            // 2. 容量检查 (简单策略：如果满了就不存，或者你可以改为挤掉旧的)
            if (effectiveChatContext.permanent_memories.length >= 20) {
                // 也可以选择在这里发送一个提示："记忆已满"
                console.log("记忆已满，忽略新记忆");
            } else {
                // 3. 写入记忆
                effectiveChatContext.permanent_memories.push({
                    id: `mem_${Date.now()}`,
                    content: memoryContent,
                    timestamp: Date.now()
                });

                // 4. 保存到数据库
                await kokoMemory.put('contacts', effectiveChatContext);

                // 5. 发送系统提示 (视觉反馈)
                await createAndAddMessage({ 
                    type: 'system_notification', 
                    sender: 'system',
                    content: `💎 “${memoryContent}” 已刻入 Ta 的记忆核心。` 
                }, senderProfile.id, effectiveChatContext, false, contextMode);
            }
        }

        // 6. ★关键★：从对话文本中彻底移除这条指令
        // 这样它就不会被当成普通文本显示在叙事气泡里了
        conversation = conversation.replace(memoryMatch[0], '').trim();
    }
    // ▲▲▲ 新增结束 ▲▲▲
    // ========================= 【QQ空间指令 完整拦截系统】 =========================
    
    // --- Part 1: 拦截 AI 发布说说 [qzone]内容[/qzone] ---
    const qzonePostRegex = /\[qzone\]([\s\S]*?)\[\/qzone\]/gi; // 支持换行，忽略大小写
    let qzonePostMatch;

    // 使用 while 循环，以防 AI 一口气发了两条说说
    while ((qzonePostMatch = qzonePostRegex.exec(conversation)) !== null) {
        const postContent = qzonePostMatch[1].trim();
        
        if (postContent) {
            console.log(`[指令拦截] AI 发布说说: ${postContent}`);
            // 异步执行发布，传入 AI 的资料
            // 注意：这里不需要 await，让它在后台发就行，不要卡住聊天
            createAiQzonePost(senderProfile, postContent);
        }
        
        // ★ 从聊天记录中删除指令，不让用户看见
        conversation = conversation.replace(qzonePostMatch[0], '');
        // 重置正则索引 (因为字符串变短了)
        qzonePostRegex.lastIndex = 0;
    }

// ... 在 processAndDisplayAiResponse 内部 ...

    // --- Part 2: 拦截 AI 评论说说 (支持盖楼版) ---
    const qzoneCommentRegex = /\[qzone_comment\s*[:：]?\s*(\{[\s\S]*?\})\s*\]/gi;
    let qzoneCommentMatch;

    while ((qzoneCommentMatch = qzoneCommentRegex.exec(conversation)) !== null) {
        const fullMatchStr = qzoneCommentMatch[0];
        const jsonStr = qzoneCommentMatch[1];

        try {
            const commandData = JSON.parse(jsonStr);
            if (commandData.id && commandData.content) {
                // ▼▼▼ 核心修改：把 replyTo 也传过去 (如果没有就是 undefined) ▼▼▼
                console.log(`[指令拦截] AI 评论/回复: ${commandData.replyTo ? '回复 '+commandData.replyTo : '直接评论'}`);
                executeAiQzoneComment(senderProfile, commandData.id, commandData.content, commandData.replyTo);
            }
        } catch (e) {
            console.warn("AI 评论指令解析失败 (尝试容错):", e);
            // 容错提取 (简易版，暂不处理复杂的 replyTo 容错)
            const idMatch = jsonStr.match(/id["']?\s*[:：]\s*["']([^"']+)["']/i);
            const contentMatch = jsonStr.match(/content["']?\s*[:：]\s*["']([\s\S]*?)["']/i);
            if (idMatch && contentMatch) {
                executeAiQzoneComment(senderProfile, idMatch[1], contentMatch[1]);
            }
        }
        
        conversation = conversation.replace(fullMatchStr, '');
        qzoneCommentRegex.lastIndex = 0;
    }

    // 清理一下可能残留的空行
    conversation = conversation.trim();
    // --- Part 3: 拦截 AI 留言 [guestbook:内容] ---
    const gbRegex = /\[guestbook:\s*([\s\S]*?)\]/gi;
    let gbMatch;
    while ((gbMatch = gbRegex.exec(conversation)) !== null) {
        const gbContent = gbMatch[1].trim();
        if (gbContent) {
            console.log(`[指令拦截] AI 留言: ${gbContent}`);
            addGuestbookMessage(senderProfile, gbContent);
            // 弹个通知
            createSystemNotification(`${senderProfile.name} 在你的留言板留了言`, senderProfile);
        }
        conversation = conversation.replace(gbMatch[0], '');
    }

    // ========================= 【拦截结束】 =========================
    let diaryContent = null;
    const strictDiaryRegex = /\[diary\]([\s\S]*?)\[\/diary\]/g;
    const strictMatch = strictDiaryRegex.exec(conversation);

    if (strictMatch && strictMatch[1]) {
        diaryContent = strictMatch[1].trim();
        conversation = conversation.replace(strictDiaryRegex, '').trim();
    } else {
        const lenientDiaryStartIndex = conversation.indexOf('[diary]');
        if (lenientDiaryStartIndex !== -1) {
            diaryContent = conversation.substring(lenientDiaryStartIndex + '[diary]'.length).trim();
            conversation = conversation.substring(0, lenientDiaryStartIndex).trim();
        }
    }

    if (diaryContent) {
        if (!senderProfile.diary) senderProfile.diary = [];
        senderProfile.diary.push({
            id: `diary_${Date.now()}`,
            content: diaryContent,
            timestamp: Date.now()
        });
        await kokoMemory.put('contacts', senderProfile);
    }
    
// ... 省略了日记保存的代码 ...

    // ▼▼▼ 使用这个【增强版】来替换原来的代码 ▼▼▼
    if (heartVoiceContent) {
        
        // 1. 在添加新的心声消息之前...
        // ...我们先把这个角色历史记录里所有旧的 'heart_voice' 消息都过滤掉。
        // .filter() 方法会创建一个新数组，其中仅包含所有不符合 "msg.type === 'heart_voice'" 条件的元素。
        if (effectiveChatContext.history) {
             effectiveChatContext.history = effectiveChatContext.history.filter(msg => msg.type !== 'heart_voice');
        }

        // 2. 然后，再把这个最新的心声添加进去。
        // 这样一来，历史记录里永远最多只有一个心声消息。
        await createAndAddMessage({
            type: 'heart_voice',
            content: heartVoiceContent
        }, senderProfile.id, effectiveChatContext, false, 'chat');
    }
    // ▲▲▲ 替换结束 ▲▲▲


    const callTriggerRegex = /\[action:start_video_call\]|发起了视频通话|视频通话请求已发送|正在向您发起视频通话|已拨通您的视频电话/;

    if (!effectiveChatContext.isGroup && callTriggerRegex.test(conversation)) {
        
        // 1. 清理触发词 (保留原有逻辑，把触发通话的各种文本删掉)
        const callTriggerRegexForReplace = /\[action:start_video_call\]|给你打个视频电话|我们来视频通话|拨通了你的电话|打过去了|播出去了|\[.*?(呼叫|拨打|视频|电话).*?\]/g;
        const textResponse = conversation.replace(callTriggerRegexForReplace, '').trim();

        // 2. ✨ 核心精简：如果有剩下的内容，直接递归调用自己！
        // 这样无论是 [voice:...] 还是 [picture:...]，都会走主流程的“超强正则”
        if (textResponse) {
            // 注意：这里一定要 await，确保气泡都发完了，再往下执行
            await processAndDisplayAiResponse(textResponse, senderProfile, effectiveChatContext, contextMode);
        }

        // 3. 稍微停顿一下，给用户看清最后一条消息的时间
        await sleep(800); 

        // 4. 弹出来电界面
        handleIncomingCall(senderProfile);

        return; // 拦截结束，不再执行后续的普通文本发送逻辑
    }
    // ▲▲▲▲▲▲▲▲▲▲ 修复结束 ▲▲▲▲▲▲▲▲▲▲

    if (contextMode === 'chat' && state.activeCall && state.activeCall.contactId === effectiveChatContext.id) {
await createAndAddMessage({
            type: 'video_call_text',
            content: conversation
        }, senderProfile.id, senderProfile, false, 'chat');

        const narrativeFeed = document.getElementById('narrative-feed');
        const actionRegex = /\[action:(.*?)\]/g;
        let narrativeText = conversation;
        const match = actionRegex.exec(conversation);
        if (match) {
            const action = match[1].trim();
            if (action === 'hang_up') {
                narrativeText = conversation.replace(actionRegex, '').trim();
                if (narrativeText) {
                    const bubble = document.createElement('div');
                    bubble.className = 'char-bubble';
                    bubble.innerHTML = `<p class="narrative-speech">“${narrativeText}”</p>`;
                    narrativeFeed.appendChild(bubble);
                    narrativeFeed.scrollTop = narrativeFeed.scrollHeight;
                    await sleep(1000);
                }
                await endVideoCall('contact', `${senderProfile.name} 挂断了电话`);
                return;
            }
        }

        if (narrativeText) {
            const bubble = document.createElement('div');
            bubble.className = 'char-bubble';
            const regex = /(\*[^*]+\*)|(\{[^{}]+\})|(“[^”]+”)/g;
            const parts = narrativeText.split(regex).filter(Boolean);
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                const p = document.createElement('p');
                if (part.startsWith('*')) { p.className = 'narrative-action'; p.textContent = part; }
                else if (part.startsWith('{')) { p.className = 'narrative-psychology'; p.textContent = part; }
                else if (part.startsWith('“')) { p.className = 'narrative-speech'; p.textContent = part; }
                else { p.className = 'narrative-speech'; p.textContent = `“${part}”`; }
                bubble.appendChild(p);
            });
            narrativeFeed.appendChild(bubble);
            narrativeFeed.scrollTop = narrativeFeed.scrollHeight;

            const dialogueParts = [];
            const dialogueRegex = /“([^”]+)”/g;
            let dialogueMatch;
            while ((dialogueMatch = dialogueRegex.exec(narrativeText)) !== null) {
                dialogueParts.push(dialogueMatch[1]);
            }
            const fullDialogue = dialogueParts.join('，');

if (fullDialogue) {
    // 传入 senderProfile (也就是完整的 contact 对象)
    await playNextInQueue(fullDialogue, senderProfile); 
}
        }
        return;
    }

// ... (省略了上面的 if (state.activeCall...) ... )

            const lastUnopenedMessage = effectiveChatContext.history.slice().reverse().find(m =>
                m.sender === 'user' && (
                    (m.type === 'red_packet' && !m.content.opened) ||
                    (m.type === 'transfer' && !m.content.completed)
                )
            );

            // ▼▼▼ 从这里开始是修复后的逻辑 ▼▼▼
            // 找到 if (lastUnopenedMessage) { ... } 这一大块，替换为：
            
            if (lastUnopenedMessage) {
                const rejectionKeywords = ['不收', '不要', '退回', '还给你', '我不能要', '心意领了', '太贵重'];
                // ✨ 修改点：极大扩充“接受”的关键词库
                const acceptanceKeywords = ['收下', '收了', '领了', '打开', '谢谢', '我收', '我领', '开心', '破费', '笑纳', '好意', '拿去买', '请客'];

                // ✨ 修改点：同时检查是否包含 [claim_red_packet] 指令
                const hasClaimCommand = conversation.includes('[claim_red_packet]');
                
                // 1. 只要包含关键词，或者用了指令，就算接受
                const accepted = hasClaimCommand || acceptanceKeywords.some(keyword => conversation.includes(keyword));
                
                if (accepted) {
                    // --- 处理接受逻辑 ---
                    if (lastUnopenedMessage.type === 'red_packet') {
                        lastUnopenedMessage.content.opened = true;
                        // 如果是私聊红包，且尚未生成领取记录，手动补一条
                        if (!lastUnopenedMessage.content.claimers) {
                            lastUnopenedMessage.content.claimers = [{
                                userId: senderProfile.id, // AI 领取的
                                amount: parseFloat(lastUnopenedMessage.content.amount)
                            }];
                        }
                    } else if (lastUnopenedMessage.type === 'transfer') {
                        lastUnopenedMessage.content.completed = true;
                        lastUnopenedMessage.content.returned = false;
                    }
                    
                    await kokoMemory.put('contacts', effectiveChatContext);
                    // 刷新UI以显示“已收款/已领取”
                    await refreshMessageBubbleInDOM(lastUnopenedMessage.id); 

                } else {
                    // 2. 只有在“未接受”的情况下，才检查是否“拒绝”
                    const rejected = rejectionKeywords.some(keyword => conversation.includes(keyword));
                    if (rejected) {
                        // --- 处理拒绝逻辑 ---
                        if (lastUnopenedMessage.type === 'transfer') {
                            lastUnopenedMessage.content.completed = true;
                            lastUnopenedMessage.content.returned = true;
                            
                            const transferAmount = parseFloat(lastUnopenedMessage.content.amount);
                            if (!isNaN(transferAmount)) {
                                state.myProfile.balance += transferAmount;
                                await addTransaction('income', transferAmount, `来自 ${senderProfile.name} 的转账退款`, senderProfile.id);
                                renderMyProfile();
                                await kokoMemory.put('myProfile', state.myProfile);
                            }
                            
                            await kokoMemory.put('contacts', effectiveChatContext);
                            await refreshMessageBubbleInDOM(lastUnopenedMessage.id);
                            await createSystemNotification(`${senderProfile.name} 退还了你的转账`, effectiveChatContext, 'chat');
                        }
                    }
                }
            }


            if (contextMode === 'chat' && effectiveChatContext.isNarrativeMode) {
                if (conversation) {
                    await sleep(400 + Math.random() * 400);
                    
                    // ▼▼▼ 核心修改开始 ▼▼▼
                    // 只要内容里包含 HTML 标签（比如 <div, <span, <style），就标记为 'html' 类型
                    // 这样 createMessageElement 就会用 innerHTML 渲染它，
                    // 同时配合第二步的修改，它会被包裹在同一个气泡里。
                    const hasHtmlTags = /<[a-z][\s\S]*>/i.test(conversation);
                    
                    if (hasHtmlTags) {
                        await createAndAddMessage({ type: 'html', content: conversation }, senderProfile.id, effectiveChatContext, false, 'chat');
                    } else {
                        await createAndAddMessage({ type: 'text', content: conversation }, senderProfile.id, effectiveChatContext, false, 'chat');
                    }
                    // ▲▲▲ 修改结束 ▲▲▲
                }
// ▼▼▼ 使用这个【V4 - 延迟修正版】替换旧的 "else if (contextMode === 'chat') { ... }" 完整代码块 ▼▼▼

    } else if (contextMode === 'chat') {
        
        // --- 智能缓冲循环 V4 (Koko特供版) 开始 ---
        
        const lines = conversation.split('\n');
        let htmlBuffer = [];
        let inHtmlBlock = false;
        let openingTag = null; 

        for (const line of lines) {
            const trimmedLine = line.trim();

            if (inHtmlBlock) {
                // --- 1. 我们正处于一个多行HTML块内部 ---
                htmlBuffer.push(line); 
                
                if (openingTag && trimmedLine.includes(`</${openingTag}>`)) {
                    await createAndAddMessage({
                        type: 'html',
                        content: htmlBuffer.join('\n')
                    }, senderProfile.id, effectiveChatContext, false, 'chat');
                    
                    // ✨ 核心修复：只在发送消息后才延迟
                    await sleep(400 + Math.random() * 400); 
                    
                    htmlBuffer = [];
                    inHtmlBlock = false;
                    openingTag = null;
                }
                // (如果没结束，不延迟，光速进入下一行)
                continue;
            }

            // --- 2. 我们当前不在HTML块内 ---
            
            // 检查 2a: 是否是空行？
            if (trimmedLine === '') continue; // 跳过空行，不延迟

            // 检查 2b: 这一行是否 *开启* 了一个新的多行HTML块?
            let tagMatch = trimmedLine.match(/^<(div|style)/i);
            
            if (tagMatch) {
                openingTag = tagMatch[1].toLowerCase();
                htmlBuffer = [line];
                
                if (trimmedLine.includes(`</${openingTag}>`)) {
                    // 这是一个单行HTML块，立即发送
                    await createAndAddMessage({
                        type: 'html',
                        content: trimmedLine
                    }, senderProfile.id, effectiveChatContext, false, 'chat');
                    
                    // ✨ 核心修复：只在发送消息后才延迟
                    await sleep(400 + Math.random() * 400); 
                    
                    htmlBuffer = [];
                    openingTag = null;
                } else {
                    // 这是一个 *多行* 块的开始，进入缓冲状态
                    inHtmlBlock = true;
                }
                
            } else {
                // --- 3. 既不在HTML块内，也不开启新块，它是【普通文本行】或【指令行】 ---
                
                let processed = false;
                            // ▼▼▼▼▼▼▼▼▼▼ 【新增】拦截 AI 模仿的“伪系统提示” ▼▼▼▼▼▼▼▼▼▼
            // 这里的正则匹配： [系统提示: 状态变更为：xxx] 或 [系统提示：状态变更为：xxx]
            const fakeStatusRegex = /\[(?:系统提示|System)[:：]\s*状态变更为[:：]\s*(.*?)\]/;
            const fakeMatch = trimmedLine.match(fakeStatusRegex);

            if (fakeMatch) {
                // 提取出 AI 想要设置的状态文字 (比如 "有点......烦躁。")
                let extractedStatus = fakeMatch[1].trim();
                // 去掉末尾可能存在的句号或右括号
                extractedStatus = extractedStatus.replace(/[。\.\]]$/, '');

                console.log("捕获到 AI 伪造的状态提示，强制转换为指令:", extractedStatus);

                // 1. 执行状态更新逻辑 (复用 status 指令的逻辑)
                senderProfile.status = extractedStatus;
                await kokoMemory.put('contacts', senderProfile);
                
                if (state.activeChatId === senderProfile.id) {
                    const statusEl = document.getElementById('chat-contact-status');
                    if (statusEl) statusEl.textContent = extractedStatus;
                }

                // 2. 发送系统通知 (让用户知道状态变了)
                await createAndAddMessage({ 
                    type: 'system_notification', 
                    sender: 'system',
                    content: `状态变更为：${extractedStatus}` 
                }, senderProfile.id, effectiveChatContext, false, 'chat');

                processed = true; // 标记为已处理，这样就不会显示成那个丑陋的文本气泡了
            }
// 找到这行代码，把 change_avatar 加到最后：
const commandRegex = /\[\s*(sticker|voice|picture|red_packet|transfer|transfer_to|music|spin_wheel|claim_red_packet|location|create_location|action|search_music|recall|status|nudge|memory|start_survey|gift|takeout|change_avatar)(?:[\s:：]+([^\]]*))?\]/i;
                const commandMatch = line.match(commandRegex);
                const lastWheelMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'game_wheel' && !m.content.results.contact);
                
                // (--- 你的所有指令检查逻辑... ---)
                if (lastWheelMsg) {
                    const contactName = senderProfile.name;
                    const validOptions = lastWheelMsg.content.options.map(opt => opt.text);
                    const ultimatePositionalRegex = new RegExp(`(?:${contactName}|我).*?(?:[“"'])?(${validOptions.join('|')})(?:[“"'])?`);
                    const fallbackMatch = line.match(ultimatePositionalRegex);
                    if (fallbackMatch) {
                        const result = fallbackMatch[1];
                        const wheel = lastWheelMsg.content;
                        wheel.results.contact = result.trim();
                        await kokoMemory.put('contacts', effectiveChatContext);
                        const msgIdToUpdate = lastWheelMsg.id;
                        const wrapperToUpdate = document.querySelector(`.message-wrapper[data-message-id='${msgIdToUpdate}']`);
                        if (wrapperToUpdate) {
                            const contactResultRow = wrapperToUpdate.querySelectorAll('.wheel-result-row')[1];
                            if (contactResultRow) {
                                contactResultRow.innerHTML = `<span class="wheel-player-name">${contactName}</span> <div class="wheel-player-result">${result.trim()}</div>`;
                            }
                        }
                        continue; // (指令处理完成，跳过)
                    }
                }
                
                if (commandMatch) {
                    processed = true;
                    const command = commandMatch[1];
                    const value = commandMatch[2] || '';
                    switch (command) {
                        case 'claim_red_packet': {
                            // ... (省略 claim_red_packet 逻辑) ...
                            const lastPacketMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'red_packet' && m.content.count > (m.content.claimers || []).length);
                            if (lastPacketMsg) {
                                const packet = lastPacketMsg.content;
                                const hasClaimed = (packet.claimers || []).some(c => c.userId === senderProfile.id);
                                if (!hasClaimed) {
                                    const remainingCount = packet.count - packet.claimers.length;
                                    const remainingAmount = packet.totalAmount - packet.claimers.reduce((sum, c) => sum + c.amount, 0);
                                    let amount = 0;
                                    if (remainingCount > 1) {
                                        const avg = remainingAmount / remainingCount;
                                        amount = Math.random() * avg * 1.8; // 增加随机性
                                        amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                                    } else {
                                        amount = remainingAmount;
                                    }
                                    amount = Math.max(0.01, parseFloat(amount.toFixed(2)));
                                    packet.claimers.push({ userId: senderProfile.id, amount: amount });
                                    await kokoMemory.put('contacts', effectiveChatContext);
                                    const remainingText = line.replace(commandRegex, '').trim();
                                    if (remainingText) {
                                        await createAndAddMessage({ type: 'text', content: remainingText }, senderProfile.id, effectiveChatContext, false, 'chat');
                                        await sleep(400 + Math.random() * 400); // ✨ 延迟
                                    }
                                    const senderId = lastPacketMsg.sender;
                                    let notificationText = '';
                                    if (senderId === 'myProfile') {
                                        notificationText = `${senderProfile.name} 领取了你的红包`;
                                    } else {
                                        const sender = state.contacts.find(c => c.id === senderId);
                                        const senderName = sender ? sender.name : '另一位成员';
                                        notificationText = `${senderProfile.name} 领取了 ${senderName} 的红包`;
                                    }
                                    await createSystemNotification(notificationText, effectiveChatContext);
                                    // (系统通知自己会带延迟)
                                }
                            }
                            processed = true;
                            break;
                        }
                        case 'location': {
                            const locationName = value.trim();
                            if (senderProfile && senderProfile.mapId) {
                                const mapData = await kokoMemory.get('maps', senderProfile.mapId);
                                const location = mapData.locations.find(loc => loc.name === locationName);
                                if (location) {
                                    await createAndAddMessage({ type: 'location_share', content: { mapId: senderProfile.mapId, locationId: location.id, name: location.name, icon: location.icon, x: location.x, y: location.y } }, senderProfile.id, effectiveChatContext, false, 'chat');
                                } else {
                                    await createAndAddMessage({ type: 'text', content: `(系统错误：我想发送一个叫“${locationName}”的位置，但地图上好像没有这个地方。)` }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
// (Handler 更新：支持 parentName 查找)
                        case 'create_location': {
                            try {
                                // 1. 解析 AI 的 JSON 指令
                                const locationData = JSON.parse(value);
                                
                                if (senderProfile && senderProfile.mapId) {
                                    const mapData = await kokoMemory.get('maps', senderProfile.mapId);
                                    if (mapData) {
                                        // 2. 核心：查找 AI 指定的父地点 ID
                                        let targetParentId = null;
                                        if (locationData.parentName) {
                                            // 在现有地点中查找名字匹配的
                                            const parentLoc = (mapData.locations || []).find(l => l.name === locationData.parentName);
                                            if (parentLoc) {
                                                targetParentId = parentLoc.id;
                                            } else {
                                                // 如果AI瞎编了一个不存在的父地点，为了防止报错，我们默认放到根目录，或者你可以选择忽略
                                                console.warn(`AI 试图在不存在的父地点 "${locationData.parentName}" 中创建地点，已回退到根目录。`);
                                            }
                                        }

                                        // 3. 构建新地点对象
                                        const newLocation = { 
                                            id: 'loc_' + Date.now(), 
                                            name: locationData.name, 
                                            description: locationData.description, 
                                            icon: locationData.icon || 'fas fa-map-marker-alt', 
                                            tier: 2, // 默认大小
                                            x: 500 + Math.floor(Math.random() * 100 - 50), // 随机坐标防重叠
                                            y: 500 + Math.floor(Math.random() * 100 - 50),
                                            parentId: targetParentId // 绑定父级！
                                        };
                                        
                                        if (!mapData.locations) mapData.locations = [];
                                        mapData.locations.push(newLocation);
                                        
                                        await kokoMemory.put('maps', mapData);
                                        
                                        // 4. 发送分享卡片
                                        await createAndAddMessage({ 
                                            type: 'location_share', 
                                            content: { 
                                                mapId: senderProfile.mapId, 
                                                locationId: newLocation.id, 
                                                ...newLocation 
                                            } 
                                        }, senderProfile.id, effectiveChatContext, false, 'chat');
                                    }
                                }
                            } catch (error) {
                                console.error("AI 创建地点失败", error);
                                await createAndAddMessage({ type: 'text', content: `(系统：我刚才想创建一个新地点，但是数据格式好像出错了...)` }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            await sleep(400 + Math.random() * 400); 
                            break;
                        }
                        case 'spin_wheel': {
    // 1. 找到最近的一个还没有 AI 结果的转盘
    const currentWheelMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'game_wheel' && !m.content.results.contact);
    
    if (currentWheelMsg) {
        const wheel = currentWheelMsg.content;
        // 根据权重计算结果
        const weightedOptions = wheel.options.flatMap(opt => Array(opt.weight).fill(opt.text));
        const result = weightedOptions[Math.floor(Math.random() * weightedOptions.length)];
        
        // 核心：AI 的结果永远存入 results.contact
        wheel.results.contact = result;
        
        // 保存并更新界面
        await kokoMemory.put('contacts', effectiveChatContext);
        
        // 尝试原地更新DOM，避免跳动
        const msgIdToUpdate = currentWheelMsg.id;
        const wrapperToUpdate = document.querySelector(`.message-wrapper[data-message-id='${msgIdToUpdate}']`);
        if (wrapperToUpdate) {
            // 更新第二行（AI/对方 的结果行）
            const contactResultRow = wrapperToUpdate.querySelectorAll('.wheel-result-row')[1];
            if (contactResultRow) {
                contactResultRow.innerHTML = `<span class="wheel-player-name">${senderProfile.name}</span> <div class="wheel-player-result" style="background:#e8f5e9; color:#2e7d32;">${result}</div>`;
            }
        }
        
        // (可选) 让 AI 针对结果发一条评论
        // await requestAiReply(`[SYSTEM: 你的转盘结果出来了，是“${result}”。请对此发表评论。]`);
    }
    processed = true; 
    break;
}
                        case 'red_packet': {
                            const parts = value.split(/[，,]/).map(p => p.trim());
                            if (parts.length === 3) {
                                // ... (群聊红包) ...
                                const blessing = parts[0] || "恭喜发财！";
                                const totalAmount = parseFloat(parts[1]);
                                const count = parseInt(parts[2], 10);
                                if (!isNaN(totalAmount) && totalAmount > 0 && !isNaN(count) && count > 0) {
                                    await createAndAddMessage({ type: 'red_packet', content: { totalAmount: totalAmount, count: count, blessing: blessing, claimers: [] } }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            } else if (parts.length === 2) {
                                // ... (私聊红包) ...
                                const blessing = parts[0] || "恭喜发财！";
                                const amount = parseFloat(parts[1]);
                                if (!isNaN(amount) && amount > 0) {
                                    await createAndAddMessage({ type: 'red_packet', content: { amount: amount.toFixed(2), blessing: blessing, opened: false } }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'transfer_to': {
                            // ... (群聊转账) ...
                            const parts = value.split(/[，,]/).map(p => p.trim());
                            if (parts.length === 2) {
                                const recipientName = parts[0];
                                const amount = parseFloat(parts[1]);
                                const recipientProfile = effectiveChatContext.members.map(id => id === 'myProfile' ? state.myProfile : state.contacts.find(c => c.id === id)).find(p => p && p.name === recipientName);
                                if (recipientProfile && !isNaN(amount) && amount > 0) {
                                    await createAndAddMessage({ type: 'transfer', content: { amount: amount.toFixed(2), completed: false, returned: false, recipientId: recipientProfile.id } }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'sticker':
                            // ▼▼▼ 修改开始：使用智能模糊查找 ▼▼▼
                            const emoticon = findBestMatchingEmoticon(value);
                            // ▲▲▲ 修改结束 ▲▲▲
                            
                            if (emoticon) {
                                await createAndAddMessage({ type: 'image', url: emoticon.url, isEmoticon: true, emoticonName: emoticon.name }, senderProfile.id, effectiveChatContext, false, 'chat');
                            } else {
                                // 如果实在找不到，才显示失败文本
                                await createAndAddMessage({ type: 'text', content: `[发送表情失败: ${value}]` }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            await sleep(400 + Math.random() * 400); 
                            break;
                        case 'voice':
                            const duration = Math.max(1, Math.round(value.length / 4));
                            await createAndAddMessage({ type: 'voice', content: { text: value, duration: duration } }, senderProfile.id, effectiveChatContext, false, 'chat');
                            processed = true;
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        case 'picture':
                            await createAndAddMessage({ type: 'picture_description', content: { description: value } }, senderProfile.id, effectiveChatContext, false, 'chat');
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        case 'transfer': {
                            const transferAmount = parseFloat(value);
                            if (transferAmount > 0) {
                                await createAndAddMessage({ type: 'transfer', content: { amount: transferAmount.toFixed(2), completed: false, returned: false } }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'music': {
                            // ... (music 逻辑) ...
                            const lastComma = value.lastIndexOf('，') > -1 ? '，' : ',';
                            const lastCommaIndex = value.lastIndexOf(lastComma);
                            if (lastCommaIndex === -1) break;
                            const url = value.substring(lastCommaIndex + 1).trim();
                            const secondToLastCommaIndex = value.lastIndexOf(lastComma, lastCommaIndex - 1);
                            if (secondToLastCommaIndex === -1) break;
                            const artist = value.substring(secondToLastCommaIndex + 1, lastCommaIndex).trim();
                            const title = value.substring(0, secondToLastCommaIndex).trim();
                            if (url.startsWith('http') && title) {
                                await createAndAddMessage({ type: 'music_share', content: { title, artist, url } }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'search_music': {
                            const keyword = value.trim();
                            if (keyword) {
                                const song = await fetchSongForAI(keyword);
                                if (song) {
                                    effectiveChatContext.sharedPlaylist.tracks.push(song);
                                    await createAndAddMessage({ 
                                        type: 'music_share', 
                                        content: song
                                    }, senderProfile.id, effectiveChatContext, false, 'chat');
                                } else {
                                    await createAndAddMessage({ 
                                        type: 'text', 
                                        content: `(系统：我想搜“${keyword}”，但没找到能放的歌...QAQ)`
                                    }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            }
                            processed = true;
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
case 'status': {
                            let newStatus = value.trim();
                            
                            // ▼▼▼ 【核心修复：禁止 AI 设置“正在输入”等无效状态】 ▼▼▼
                            const forbiddenStatusWords = ['正在输入', 'typing', 'inputting', '对方正在', '...'];
                            if (forbiddenStatusWords.some(word => newStatus.includes(word))) {
                                console.log(`拦截了无效状态: ${newStatus}`);
                                // 如果AI想设这个，我们强制把它改成默认的，或者直接忽略
                                newStatus = "在线"; 
                            }
                            // ▲▲▲ 修复结束 ▲▲▲

                            if (newStatus) {
                                // 1. 更新数据
                                senderProfile.status = newStatus;
                                await kokoMemory.put('contacts', senderProfile);
                                
                                if (state.activeChatId === senderProfile.id) {
                                    const statusEl = document.getElementById('chat-contact-status');
                                    if (statusEl) statusEl.textContent = newStatus;
                                }

                                // 2. 发送系统通知
                                await createAndAddMessage({ 
                                    type: 'system_notification', 
                                    sender: 'system',
                                    content: `状态变更为：${newStatus}` 
                                }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            
                            // 处理同一行剩余的文本 (保持之前的递归修复)
                            const remainingText = line.replace(commandMatch[0], '').trim();
                            if (remainingText) {
                                await processAndDisplayAiResponse(remainingText, senderProfile, effectiveChatContext, contextMode);
                            }
                            
                            processed = true; 
                            break;
                        }
                        case 'change_avatar': {
    // value 是序号，例如 "1"
    let targetIndex = parseInt(value, 10);
    if (isNaN(targetIndex)) targetIndex = -1;

    // 1. 获取最近 20 条记录
    const recentMessages = effectiveChatContext.history.slice(-20);

    // 2. 初步筛选：找出所有用户发的图片
    const allUserImages = recentMessages.filter(m => 
        (m.sender === 'user' || m.sender === 'myProfile') && 
        (m.type === 'image' || m.type === 'uploaded_image')
    );

    // 3. 【核心修复】智能分堆：只保留“当前这一批”图片
    // 逻辑：从最后一张往前找，如果某张图和后一张图的时间差超过 5 分钟，就认为是“上一轮”的图，截断。
    let currentBatchImages = [];
    
    if (allUserImages.length > 0) {
        // 先放入最新的一张
        currentBatchImages.unshift(allUserImages[allUserImages.length - 1]);
        
        // 倒序遍历剩下的
        for (let i = allUserImages.length - 2; i >= 0; i--) {
            const currentImg = allUserImages[i];      // 当前这张（较旧）
            const nextImg = allUserImages[i + 1];     // 后一张（较新）
            
            // 设置阈值为 5 分钟 (300000毫秒)
            // 如果两张图间隔小于 5 分钟，视为同一批
            if (nextImg.timestamp - currentImg.timestamp < 300000) {
                currentBatchImages.unshift(currentImg); // 放到数组开头
            } else {
                // 时间间隔太久，说明前面的图是以前发的，停止收集
                break; 
            }
        }
    }

    if (currentBatchImages.length === 0) {
         await createSystemNotification(`(系统：更换失败，未在近期记录中找到图片)`, effectiveChatContext);
    } else {
        let selectedMsg = null;

        // 4. 根据序号在“当前批次”中找图片
        if (targetIndex > 0 && targetIndex <= currentBatchImages.length) {
            // AI 指定了序号 (1 代表数组第 0 个)
            selectedMsg = currentBatchImages[targetIndex - 1];
        } else {
            // 没指定或越界，默认选这批里最新的一张
            selectedMsg = currentBatchImages[currentBatchImages.length - 1];
        }

        if (selectedMsg) {
            // 5. 执行更换
            const newAvatarUrl = (selectedMsg.type === 'uploaded_image') ? selectedMsg.content.base64 : selectedMsg.url;
            
            senderProfile.avatar = newAvatarUrl;
            await kokoMemory.put('contacts', senderProfile);
            
            // 6. 刷新界面
            await renderContacts(); 
            if (document.getElementById('char-profile-screen').style.display === 'flex') {
                document.getElementById('char-profile-avatar').src = newAvatarUrl;
            }

            // 7. 提示成功
            const whichOneStr = (targetIndex > 0) ? `第 ${targetIndex} 张` : "最新一张";
            await createSystemNotification(`${senderProfile.name} 选中了你刚刚发的${whichOneStr}图片并换成了头像`, effectiveChatContext);
        }
    }
    
    processed = true; 
    break;
}
                        // ... 在 switch (command) 内部 ...

case 'start_survey': {
    // 指令格式: [start_survey: 主题]
    // 例如: [start_survey: 周末去哪玩]
    const topic = value.trim() || "恋爱默契";
    
    // 1. 发送一个邀请卡片
    const inviteHTML = `
        <div class="message game-invite-card" style="cursor: pointer; background: #fff0f5; border: 1px solid #f8bbd0; border-radius: 12px; padding: 10px; width: 240px;" onclick="acceptAiSurvey('${topic}', '${senderProfile.id}')">
            <div style="display:flex; align-items:center; gap:10px; margin-bottom:8px;">
                <div style="background:#e91e63; color:white; width:36px; height:36px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:18px;">
                    <i class="fas fa-heart"></i>
                </div>
                <div style="font-weight:bold; color:#d81b60;">默契挑战邀请</div>
            </div>
            <div style="font-size:13px; color:#555;">TA 想和你玩《${topic}》</div>
            <div style="margin-top:10px; text-align:center;">
                <span style="background:#d81b60; color:white; padding:4px 15px; border-radius:15px; font-size:12px;">接受挑战</span>
            </div>
        </div>
    `;

    // 2. 将卡片作为消息发送
    await createAndAddMessage({ type: 'html', content: inviteHTML }, senderProfile.id, effectiveChatContext, false, 'chat');
    
    processed = true;
    break;
}
// --- 🎁 修复版：支持心里话里带逗号 ---
case 'gift': {
    // 先按逗号切分
    const rawParts = value.split(/[,，]/);
    
    // 取出前两个固定参数
    const giftName = rawParts[0] ? rawParts[0].trim() : "神秘惊喜";
    const giftPrice = rawParts[1] ? rawParts[1].trim() : "999";
    
    // 【关键修改】把剩下所有的部分重新拼起来，作为完整的心里话
    // 这样 "老大，谢谢你，辛苦了" 就不会被切断了
    const giftDesc = rawParts.slice(2).join('，').trim() || "这是送给你的专属礼物，希望你喜欢！";
    
    await createAndAddMessage({
        type: 'gift',
        content: { 
            title: giftName, 
            price: giftPrice, 
            message: giftDesc 
        }
    }, senderProfile.id, effectiveChatContext, false, 'chat');
    
    processed = true;
    await sleep(500);
    break;
}
// --- 🥡 修复版：支持备注里带逗号 ---
case 'takeout': {
    const rawParts = value.split(/[,，]/);
    
    const shopName = rawParts[0] ? rawParts[0].trim() : "Koko食堂";
    const itemsStr = rawParts[1] ? rawParts[1].trim() : "爱心便当x1";
    const total = rawParts[2] ? rawParts[2].trim() : "0.00";
    const status = rawParts[3] ? rawParts[3].trim() : "配送中";
    
    // 【关键修改】从第5个部分开始，剩下的全部拼成备注
    const note = rawParts.slice(4).join('，').trim() || "记得按时吃饭哦~";

    const items = itemsStr.split('|').map(item => {
        const p = item.split(/[x×*]/);
        return { name: p[0].trim(), count: p[1] ? p[1].trim() : '1' };
    });

    await createAndAddMessage({
        type: 'takeout',
        content: { shopName, items, totalPrice: total, status, note }
    }, senderProfile.id, effectiveChatContext, false, 'chat');
    
    processed = true;
    await sleep(500);
    break;
}

                        // ▼▼▼ 【新增】独立指令：拍一拍 ▼▼▼
                        case 'nudge': {
                            // value 就是冒号后面的部位，比如 "狗头"
                            // 如果 AI 只发了 [nudge]，value 就是 undefined 或空字符串
                            let suffix = "肩膀"; // 默认部位
                            if (value && value.trim()) {
                                suffix = value.trim();
                            }

                            // 1. 发送系统提示 (灰字)
                            await createAndAddMessage({
                                type: 'system_notification',
                                sender: 'system',
                                content: `${senderProfile.name} 拍了拍你的${suffix}`
                            }, 'system', effectiveChatContext, false, 'chat');

                            // 2. 视觉特效：震动屏幕上所有“我”的头像
                            // (因为是 AI 拍我，所以震动右边的头像)
                            const myAvatars = document.querySelectorAll('.message-wrapper.sent .message-avatar img');
                            if (myAvatars.length > 0) {
                                const lastMyAvatar = myAvatars[myAvatars.length - 1];
                                
                                // 重置动画以支持连续震动
                                lastMyAvatar.classList.remove('avatar-shaking');
                                void lastMyAvatar.offsetWidth; // 强制重绘
                                lastMyAvatar.classList.add('avatar-shaking');
                            }
                            
                            processed = true;
                            break;
                        }
                        // ▲▲▲ 新增结束 ▲▲▲
                        // ... 在 switch (command) 内部 ...

                        // ▼▼▼ 【新增：记忆刻印处理】 ▼▼▼
                        case 'memory': {
                            const memoryContent = value.trim();
                            if (memoryContent) {
                                // 1. 初始化数组
                                if (!effectiveChatContext.permanent_memories) {
                                    effectiveChatContext.permanent_memories = [];
                                }

                                // 2. 检查容量限制 (比如限制 20 条)
                                if (effectiveChatContext.permanent_memories.length >= 20) {
                                    // 如果满了，默默地... 也许可以替换最旧的？或者发送系统提示说脑容量不足？
                                    // 这里我们做一个浪漫的处理：如果满了，就不存了，并在心声里体现遗憾（太复杂了先不弄），
                                    // 或者简单点：先进先出，或者直接不存。
                                    // 咱们设定为：满了就不存，必须由用户删除旧的腾位置（增加互动感）
                                    console.log("记忆库已满，无法写入:", memoryContent);
                                } else {
                                    // 3. 写入记忆
                                    effectiveChatContext.permanent_memories.push({
                                        id: `mem_${Date.now()}`,
                                        content: memoryContent,
                                        timestamp: Date.now()
                                    });
                                    
                                    await kokoMemory.put('contacts', effectiveChatContext);

                                    // 4. 发送一个唯美的系统提示
                                    await createAndAddMessage({ 
                                        type: 'system_notification', 
                                        sender: 'system',
                                        // 用一个脑子或者心的图标
                                        content: `💎 “${memoryContent}” 已刻入 Ta 的记忆核心。` 
                                    }, senderProfile.id, effectiveChatContext, false, contextMode);
                                }
                            }
                            processed = true; // 隐藏指令本身
                            // 记忆是瞬间的思维活动，不需要 sleep 延迟
                            break;
                        }
                        // ▲▲▲ 新增结束 ▲▲▲

                        // ... (继续其他的 case) ...
                        case 'action':
                            // ... (action 逻辑) ...
                            if (value === 'block_user') {
                                senderProfile.blockedStatus = 'ai_blocked_user';
                                await kokoMemory.put('contacts', senderProfile);
                                await createSystemNotification(`${senderProfile.name} 已将你拉黑。`, effectiveChatContext);
                                updateChatInputLockState('ai_blocked_user');
                            } else if (value === 'unblock_user') {
                                senderProfile.blockedStatus = 'none';
                                await kokoMemory.put('contacts', senderProfile);
                                await createSystemNotification(`${senderProfile.name} 已将你解除拉黑。`, effectiveChatContext);
                                updateChatInputLockState('none');
                            }
                            processed = true;
                            // (这个是系统动作，不需要延迟)
                            break;
                        case 'recall': {
                            const recalledText = value.trim();
                            if (recalledText) {
                                await createAndAddMessage({
                                    type: 'recall_ai',
                                    content: recalledText,
                                    isRevealed: false
                                }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            processed = true;
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                    }
                }

                // ... (在 switch 结束后的下方) ...

                if (!processed) {
                    // --- 🌟 核心增强：检测 [reply:...] 引用指令 ---
                    let quoteData = null;
                    let finalContent = line;

                    // 正则匹配 [reply:...]
                    const replyMatch = line.match(/\[reply:(.*?)\]/);
                    
                    if (replyMatch) {
                        const snippet = replyMatch[1].trim(); // 获取引用片段
                        
                        // 1. 在历史记录中倒序查找最近一条包含该片段的消息
                        // (排除系统消息和指令)
                        const targetMsg = effectiveChatContext.history.slice().reverse().find(m => 
                            m.type === 'text' && 
                            m.sender !== 'system' && 
                            m.sender !== 'system_instruction' &&
                            m.content.includes(snippet)
                        );

                        if (targetMsg) {
                            // 2. 解析被引用人的名字
                            let senderName = '未知用户';
                            if (targetMsg.sender === 'user' || targetMsg.sender === 'myProfile') {
                                senderName = state.myProfile.name;
                            } else if (targetMsg.sender === effectiveChatContext.id) {
                                senderName = effectiveChatContext.name;
                            } else if (effectiveChatContext.isGroup) {
                                // 群聊：尝试查找成员名字
                                const member = state.contacts.find(c => c.id === targetMsg.sender) || 
                                               (effectiveChatContext.npcMembers || []).find(n => n.id === targetMsg.sender);
                                if (member) senderName = member.name;
                            }

                            // 3. 构建引用数据对象
                            quoteData = {
                                messageId: targetMsg.id,
                                senderName: senderName,
                                content: targetMsg.content // 引用整句原话
                            };
                        }

                        // 4. 从 AI 的回复中删掉 [reply:...] 标记，只保留正文
                        finalContent = line.replace(replyMatch[0], '').trim();
                    }

                    // 如果删掉指令后还有内容，就发送
                    if (finalContent) {
                        await createAndAddMessage({ 
                            type: 'text', 
                            content: finalContent,
                            quote: quoteData // <--- ✨ 注入引用数据
                        }, senderProfile.id, effectiveChatContext, false, 'chat');
                        
                        await sleep(400 + Math.random() * 400);
                    }
                }
            }
        }
        
        // 循环结束后，检查缓冲区是否还有“未闭合”的HTML
        if (inHtmlBlock) {
            console.warn("AI发送了未闭合的HTML块，已强制输出。");
            await createAndAddMessage({
                type: 'html',
                content: htmlBuffer.join('\n')
            }, senderProfile.id, effectiveChatContext, false, 'chat');
            // ✨ 核心修复：补上这里的延迟
            await sleep(400 + Math.random() * 400); 
        }
        
        // --- 智能缓冲循环 V4 结束 ---
    }
// ▲▲▲ 替换到这里结束 ▲▲▲
    }
 // --- (替换) renderPostDetail 函数 (V2.1 - 支持评论图片) ---
        async function renderPostDetail() {
            const post = state.posts.find(p => p.id === state.activePostId);
            if (!post) {
                showFeedScreen();
                return;
            }
            const container = document.getElementById('post-detail-container');
            const commentsList = document.getElementById('comments-list');
            container.innerHTML = '';
            commentsList.innerHTML = '';

            // (渲染帖子本身的逻辑保持不变)
            const postItemEl = createPostItem(post, true); 
            if (postItemEl) {
                container.appendChild(postItemEl);
                container.querySelector('.like-btn')?.addEventListener('click', toggleLike);
                container.querySelector('.post-delete-btn')?.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const postId = e.currentTarget.dataset.postId;
                    if(confirm('确定要删除这条动态吗？')) { // 这里可以换成 showCustomConfirm
                        state.posts = state.posts.filter(p => p.id !== postId);
                        await kokoMemory.delete('posts', postId);
                        await showFeedScreen();
                    }
                });
                postItemEl.addEventListener('click', (e) => {
                    if (!e.target.closest('.post-action-btn, .mention, .post-delete-btn, .post-image-content')) { // 修正：点击图片也不聚焦
                         document.getElementById('comment-input').focus();
                    }
                });
            }
            
            if (post.comments.length > 0) {
                const sortedComments = [...post.comments].sort((a,b) => a.timestamp - b.timestamp);
                sortedComments.forEach(comment => {
                    const author = comment.author;
                    if (!author) return;

                    // ▼▼▼ 新增的评论图片逻辑 ▼▼▼
                    let commentImageHTML = '';
                    if (comment.image) {
                        commentImageHTML = `<img src="${comment.image}" class="comment-image-content">`;
                    }
                    // ▲▲▲ 新增结束 ▲▲▲

                    const commentEl = document.createElement('div');
                    commentEl.className = 'post-comment-item';
                    commentEl.dataset.authorName = author.name; 
                    commentEl.dataset.authorId = author.id;
                    
                    commentEl.innerHTML = `
                        <div style="display: flex; gap: 10px;">
                            <img src="${author.avatar}" style="width: 35px; height: 35px; border-radius: 50%;">
                            <div style="flex-grow: 1;">
                                <div>
                                    <span class="comment-author">${author.name}</span>
                                    ${comment.replyTo ? `<span class="comment-reply-to">回复 @${comment.replyTo}</span>` : ''}
                                </div>
                                <div class="comment-content">${parseMentions(comment.content)}</div>
                                
                                ${commentImageHTML} <div class="comment-meta">
                                    <span>${formatTimeAgo(comment.timestamp)}</span>
                                    <span class="comment-delete-btn" data-comment-id="${comment.id}"><i class="fas fa-trash-alt"></i> 删除</span>
                                </div>
                            </div>
                        </div>
                    `;

                    commentsList.appendChild(commentEl);
                });
            } else {
                commentsList.innerHTML = `<div style="text-align: center; color: #999; padding: 20px;">还没有评论，快来抢沙发吧！</div>`;
            }
        }
        function triggerPetAnimation(animationType) {
            const petElements = document.querySelectorAll('.slime');
            petElements.forEach(slimeEl => {
                if (animationType === 'jiggle') {
                    slimeEl.classList.add('happy-jiggle');
                    setTimeout(() => slimeEl.classList.remove('happy-jiggle'), 500);
                }
                if (animationType === 'blush') {
                    slimeEl.classList.add('is-blushing');
                    setTimeout(() => slimeEl.classList.remove('is-blushing'), 2000);
                }
            });
        }
// (V2 修复版) 显示引用预览：支持识别群聊 NPC
function showReplyPreview(message) {
    const previewBar = document.getElementById('reply-preview-bar');
    const currentChat = state.contacts.find(c => c.id === state.activeChatId);
    let senderName = '未知成员';

    // 1. 判断是不是自己
    if (message.sender === 'user' || message.sender === 'myProfile') {
        senderName = state.myProfile.name;
    } 
    // 2. 如果是群聊，进行全面查找
    else if (currentChat && currentChat.isGroup) {
        // A. 先在通讯录里找 (真实好友)
        let sender = state.contacts.find(c => c.id === message.sender);
        
        // B. 没找到？去群聊的 NPC 列表里找 (这一步是关键！)
        if (!sender && currentChat.npcMembers) {
            sender = currentChat.npcMembers.find(n => n.id === message.sender);
        }
        
        if (sender) senderName = sender.name;
    } 
    // 3. 如果是私聊，发送者就是对方
    else if (currentChat) {
        senderName = currentChat.name;
    }

    previewBar.innerHTML = `
        <div id="reply-preview-content">
            回复 <span class="sender">${senderName}</span>: ${message.content}
        </div>
        <div id="cancel-reply-btn">&times;</div>
    `;
    previewBar.style.display = 'flex';

    document.getElementById('cancel-reply-btn').addEventListener('click', cancelReply, { once: true });
}

function cancelReply() {
    activeReplyTarget = null;
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.style.display = 'none';
    previewBar.innerHTML = '';
}
// ==========================================================
// V17.0 新增：视频通话核心管理函数 (已整合我们的优化方案)
// ==========================================================
async function startVideoCall(contactId, initiatedBy = 'user') {
    if (state.activeCall) return; 
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    if (initiatedBy === 'user') {
        const decisionPrompt = `[SYSTEM: 用户正在向你发起视频通话请求。根据你们最近的对话和你当前的心情，请用一个词决定是否接听：“接听”或“拒绝”。\n\n- 如果你现在很忙、生气或不想说话，就回复“拒绝”。\n- 否则，回复“接听”。\n\n不要添加任何其他文字，只回复这两个词中的一个。]`;
        const decision = await generateAiResponse(contact, contact.history, decisionPrompt);
        if (decision.includes('拒绝')) {
            await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `${contact.name} 现在不想接电话` });
            await requestAiReply(`[SYSTEM: 你刚刚拒绝了用户的视频通话请求，请发送一条简短的文字消息向用户解释原因（例如：在忙、心情不好等）。]`);
            return;
        }
    }
    
    state.activeCall = {
        contactId: contact.id,
        startTime: Date.now(),
        isCharCameraOff: false,
        initiatedBy: initiatedBy // 记录发起者
    };

    const videoScreen = document.getElementById('video-call-screen');
    document.getElementById('call-contact-name').textContent = contact.name;
    document.getElementById('narrative-feed').innerHTML = '<p class="narrative-action">*正在接通...*</p>';
    videoScreen.style.display = 'flex';
    
    // 永久记录通话开始事件
    const startMessage = initiatedBy === 'user' ? `你向 ${contact.name} 发起了视频通话` : `${contact.name} 向你发起了视频通话`;
    await createAndAddMessage({ type: 'system_notification', sender: 'system', content: startMessage });

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallUI, 1000);
    updateCallUI();

    // 如果是用户发起的，让AI先开口
    if (initiatedBy === 'user') {
        await requestAiReply(`[SYSTEM: 视频通话已接通。你必须主动说第一句话来打破沉默，可以是一句问候，或者描述你看到的场景。例如：“喂？听得到吗？我看到你啦！”]`);
    }
}

// ✨ 解决方案 ✨
async function endVideoCall(endedBy = 'user', reason = '通话已挂断') {
    if (!state.activeCall) return;

    const duration = Math.floor((Date.now() - state.activeCall.startTime) / 1000);
    const contactId = state.activeCall.contactId;
    
    // 1. 在这里获取完整的 contact 对象
    const contact = state.contacts.find(c => c.id === contactId); 

    state.activeCall = null;
    
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    
    document.getElementById('video-call-screen').style.display = 'none';
    state.activeChatId = contactId;

    const durationMinutes = Math.floor(duration / 60);
    const durationSeconds = duration % 60;
    const durationText = `通话时长 ${durationMinutes}分${durationSeconds}秒`;

    // 2. 在调用时，把 contact 作为第三个参数传进去
    await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `${reason}，${durationText}` }, 'system', contact, false, 'chat'); 
    
    await createAndAddMessage({ type: 'text', content: '[SYSTEM: 通话已正式结束，立刻恢复标准聊天模式。]' }, 'system_instruction', contact, false, 'chat');

    if (endedBy === 'user') {
        // (这部分功能可以保留或根据你的需要调整)
        // await requestAiReply(`[SYSTEM: 用户刚刚挂断了视频通话。请你对此发表一句简短的感想或道别。]`);
    }
}
function updateCallUI() {
    if (!state.activeCall) return;
    const duration = Math.floor((Date.now() - state.activeCall.startTime) / 1000);
    const min = Math.floor(duration / 60).toString().padStart(2, '0');
    const sec = (duration % 60).toString().padStart(2, '0');
    const timeString = `${min}:${sec}`;
    document.getElementById('call-status').textContent = `通话中 ${timeString}`;
}

function handleIncomingCall(contact) {
    if (state.activeCall) return;
    const screen = document.getElementById('incoming-call-screen');
    document.getElementById('incoming-caller-avatar').src = contact.avatar;
    document.getElementById('incoming-caller-name').textContent = contact.name;
    screen.style.display = 'flex';

    // 使用克隆节点的方式，防止重复绑定事件
    const oldAcceptBtn = document.getElementById('accept-call-btn');
    const newAcceptBtn = oldAcceptBtn.cloneNode(true);
    oldAcceptBtn.parentNode.replaceChild(newAcceptBtn, oldAcceptBtn);
    newAcceptBtn.addEventListener('click', () => {
        screen.style.display = 'none';
        startVideoCall(contact.id, 'contact');
    });

    const oldDeclineBtn = document.getElementById('decline-call-btn');
    const newDeclineBtn = oldDeclineBtn.cloneNode(true);
    oldDeclineBtn.parentNode.replaceChild(newDeclineBtn, oldDeclineBtn);
    newDeclineBtn.addEventListener('click', async () => {
        screen.style.display = 'none';
        await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `你拒接了 ${contact.name} 的视频通话` }, 'system', contact, false, 'chat');
        //await requestAiReply(`[SYSTEM: 用户刚刚拒接了你的视频通话请求。你可能会感到失落或好奇，请发送一条文字消息询问原因。]`);
    });
}

// ▼▼▼ 使用这个【新版本】替换掉你原来的 sendVideoCallMessage 函数 ▼▼▼
async function sendVideoCallMessage() {
    if (!state.activeCall) return;
    const input = document.getElementById('video-call-input');
    const content = input.value.trim();
    if (!content) return;

    // 定位到当前通话的联系人
    const contact = state.contacts.find(c => c.id === state.activeCall.contactId);
    if (!contact) return;

    // 使用我们之前修复好的方式，明确指定消息的接收者
    await createAndAddMessage({ type: 'video_call_text', content: content }, 'user', contact, false, 'chat');

    const narrativeFeed = document.getElementById('narrative-feed');
    narrativeFeed.innerHTML += `<div class="user-message"><p>${content}</p></div>`;
    narrativeFeed.scrollTop = narrativeFeed.scrollHeight;
    input.value = '';
    
    // 关键修复！在请求AI回复时，把当前通话对象的ID传进去！
    await requestAiReply(null, state.activeCall.contactId); 
}
        
// --- 新增：处理消息编辑的核心函数（智能版，支持语音） ---
async function handleEditMessage(messageId) {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const message = contact.history.find(m => m.id === messageId);
    if (!message) return;

    // 1. 根据消息类型，智能获取当前的可编辑文本
    let currentText = '';
    if (message.type === 'voice') {
        currentText = message.content.text;
    } else { // 适用于 'text' 和 'html' 类型
        currentText = message.content;
    }

    // 2. 弹出编辑框，让用户输入新内容
    const newText = await showCustomPrompt('编辑消息', currentText);

    // 3. 如果用户点击了 "确定" 并且内容有变化
    if (newText !== null && newText.trim() !== currentText) {
        const trimmedNewText = newText.trim();

        // 4. 根据消息类型，智能地更新数据结构
        if (message.type === 'voice') {
            message.content.text = trimmedNewText;
            // 关键：重新计算并更新语音时长，这样气泡宽度也会自动变化
            message.content.duration = Math.max(1, Math.round(trimmedNewText.length / 4));
        } else { // 'text' 或 'html'
            message.content = trimmedNewText;
        }

        // 5. 保存修改到数据库，并刷新聊天界面
        await kokoMemory.put('contacts', contact);
        await openChat(state.activeChatId); // 重新渲染聊天，让修改生效
    }
}
/**
 * 渲染API预设下拉菜单
 */
async function renderApiPresetDropdown() {
    const selectEl = document.getElementById('api-preset-select');
    selectEl.innerHTML = '<option value="">-- 手动配置或选择预设 --</option>'; // 重置
    state.apiPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });
}

/**
 * 显示API预设管理页面
 */
async function showApiPresetManagementScreen() {
    hideAllScreens();
    document.getElementById('api-preset-management-screen').style.display = 'flex';
    await renderApiPresetsList();
}

/**
 * 渲染API预设管理列表
 */
async function renderApiPresetsList() {
    const listEl = document.getElementById('api-presets-list');
    const noPresetMsg = document.getElementById('no-api-preset-message');
    listEl.innerHTML = '';

    if (state.apiPresets.length === 0) {
        noPresetMsg.style.display = 'block';
    } else {
        noPresetMsg.style.display = 'none';
        state.apiPresets.forEach(preset => {
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.dataset.presetId = preset.id;
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${preset.name}</div>
                    <div class="preset-desc" style="font-size: 12px; color: #888;">
                        Endpoint: ${preset.endpoint || '未设置'}
                    </div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn delete delete-api-preset-btn" title="删除预设">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
            listEl.appendChild(item);
        });
    }

    // 为所有删除按钮绑定事件
    listEl.querySelectorAll('.delete-api-preset-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const presetId = e.currentTarget.closest('.preset-item').dataset.presetId;
            const confirmed = await showCustomConfirm('删除预设', '确定要删除这个API预设吗？', true);
            if (confirmed) {
                state.apiPresets = state.apiPresets.filter(p => p.id !== presetId);
                await kokoMemory.delete('apiPresets', presetId);
                await renderApiPresetsList(); // 重新渲染列表
            }
        });
    });
}
// --- 新增：回溯功能核心函数 ---
async function handleRewind() {
    if (!state.activeChatId) return;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history || contact.history.length === 0) return;

    // 1. 从后往前，找到你（用户）发送的最后一条消息的索引
    let lastUserMessageIndex = -1;
    for (let i = contact.history.length - 1; i >= 0; i--) {
        if (contact.history[i].sender === 'user') {
            lastUserMessageIndex = i;
            break;
        }
    }

    // 2. 处理边界情况
    if (lastUserMessageIndex === -1) {
        alert("聊天记录中没有你的消息，无法回溯。");
        return;
    }

    // 如果最后一条消息就是用户发的，说明AI还没回复，也无需回溯
    if (lastUserMessageIndex === contact.history.length - 1) {
        alert("AI 还未回复，无需回溯。");
        return;
    }

    // 3. 弹窗向用户确认，防止误触
    const confirmed = await showCustomConfirm(
        '确认回溯',
        '这将清除AI的最后一次回复，并让它重新生成一次。确定要继续吗？',
        false // false 表示这不是一个危险的红色按钮
    );

    if (confirmed) {
        // 4. 截取历史记录，保留到用户最后一条消息
        contact.history = contact.history.slice(0, lastUserMessageIndex + 1);

        // 5. 保存修改并刷新聊天界面
        await kokoMemory.put('contacts', contact);
        await openChat(contact.id); // 这会用截断后的历史记录重新渲染聊天界面

        // 6. 重新请求AI回复
        await requestAiReply();
    }
}
// --- 手动总结聊天记录功能核心函数 (V10 - 包含视频通话内容版) ---
async function handleChatSummarization() {
    if (!state.activeChatId) return;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history || contact.history.length === 0) {
        return alert('当前没有聊天记录可供总结。');
    }

    // 1. 查找上一次总结的位置
    const SUMMARY_MARKER_PREFIX = '--- 之前的记录已于';
    const lastMarkerIndex = contact.history.findLastIndex(msg =>
        msg.type === 'system_notification' && msg.content.startsWith(SUMMARY_MARKER_PREFIX)
    );

    const startIndex = lastMarkerIndex === -1 ? 0 : lastMarkerIndex + 1;
    const messagesToSummarize = contact.history.slice(startIndex);

    if (messagesToSummarize.length < 5) { 
        return alert('新的聊天记录太少，还不需要总结哦。');
    }

    // 2. 准备信息
    let charDisplayName = contact.name; 
    const nameMatch = contact.persona?.match(/(?:姓名|Name)[:：]\s*([^\n\r·,，\s.。;；]+)/i);
    if (nameMatch && nameMatch[1]) {
        charDisplayName = nameMatch[1].trim();
    }

    const userName = state.myProfile.name;
    const userDescription = contact.userPersona || state.myProfile.signature || "(用户未设置详细人设，请通过对话推断性别)";

    const bookName = `《聊天总结: ${contact.name}》`; 
    const summaryBook = state.worldBooks.find(b => b.name === bookName);
    const previous_summary = summaryBook ? summaryBook.content : '(无前情提要)';

    // ▼▼▼ 【核心修复：允许视频通话内容进入总结】 ▼▼▼
    const chat_history_text = messagesToSummarize
        .filter(msg => {
            // 排除系统指令
            if (msg.sender === 'system_instruction') return false;
            
            // 白名单：允许 'text' (普通聊天) 和 'video_call_text' (视频通话记录)
            return msg.type === 'text' || msg.type === 'video_call_text';
        })
        .map(msg => {
            const dateObj = new Date(msg.timestamp);
            const timeStr = `${dateObj.getMonth()+1}-${dateObj.getDate()} ${dateObj.getHours().toString().padStart(2,'0')}:${dateObj.getMinutes().toString().padStart(2,'0')}`;
            
            // 为了让 AI 区分，我们可以给视频通话加个标记 (可选，不加也行，因为内容本身就是对话)
            // 这里直接作为普通对话处理，更流畅
            return `[${timeStr}] ${msg.sender === 'user' ? userName : contact.name}: ${msg.content}`;
        })
        .join('\n');
    // ▲▲▲ 修复结束 ▲▲▲

    const charDescription = contact.persona || "(该角色暂无详细设定)";

    // 4. 构建 Prompt (保持 V9 的优秀逻辑)
    const prompt = `[SYSTEM]
你的任务是基于角色档案，将一段对话记录整理成一份客观、连贯的【剧情日志】。

# 角色档案
1. **甲方 (用户)**: ${userName}
   - 设定参考: "${userDescription}" (请据此准确判断性别和身份)
2. **乙方 (角色)**: ${charDisplayName} (他在聊天记录中的名字可能是 "${contact.name}")
   - 设定参考: """${charDescription}"""

# 前情提要
${previous_summary}

# 待总结的聊天记录
---
${chat_history_text}
---

# 总结要求 (请严格执行)
1.  **客观叙事**: 使用第三人称（直接称呼名字 "${userName}" 和 "${charDisplayName}"），客观记录两人之间发生的对话要点和互动行为。严禁使用“你”或“我”。
2.  **自适应时间**: 连续对话不报时，大跨度对话才在段首报时。
3.  **双人互动**: 重点概括交互内容，忽略无效寒暄。
4.  **格式**: 不同事件之间空一行。

# 输出风格示例
【连续对话】
${userName}询问${charDisplayName}关于宝石的线索，${charDisplayName}表示不知情并反过来质疑${userName}的动机。两人因此发生了争执。

【时间跨度】
11月20日晚，两人在酒吧偶遇并喝了一杯。

次日清晨，${userName}收到${charDisplayName}的短信约定见面。
`;

    // 5. 调用AI并处理结果
    const chatStatusEl = document.getElementById('chat-contact-status');
    const originalStatus = chatStatusEl.textContent;
    chatStatusEl.textContent = 'AI 正在总结中...';

    try {
        const summaryText = await generateAiResponse(contact, [], prompt, false, 'chat');
        
        const now = new Date();
        const summaryDate = `${now.getMonth()+1}月${now.getDate()}日 ${now.getHours()}:${now.getMinutes()}`;
        const newSummaryEntry = `\n\n--- 记录于 ${summaryDate} ---\n${summaryText}`;

        if (summaryBook) {
            summaryBook.content += newSummaryEntry;
            await kokoMemory.put('worldBooks', summaryBook);
        } else {
            const newBook = {
                id: 'summary_book_' + contact.id,
                name: bookName,
                category: '剧情日志', 
                content: newSummaryEntry.trim()
            };
            state.worldBooks.push(newBook);
            await kokoMemory.put('worldBooks', newBook);
            await updateWorldBookSelectors();
        }

        await createSystemNotification(`${SUMMARY_MARKER_PREFIX} ${summaryDate} ---`);

        alert(`剧情日志已更新至世界书 ${bookName}！`);

    } catch (error) {
        console.error("聊天总结失败:", error);
        alert(`总结失败: ${error.message}`);
    } finally {
        chatStatusEl.textContent = originalStatus;
    }
}
//========================================================
// =========== ▼▼▼ 论坛档案馆 - 核心功能函数 ▼▼▼ ============
// ==========================================================

// 函数：显示论坛档案馆页面
async function showForumArchivesScreen() {
    hideAllScreens();
    document.getElementById('forum-archives-screen').style.display = 'flex';
    await renderForumArchivesList();
}

// 函数：渲染存档列表
async function renderForumArchivesList() {
    const listEl = document.getElementById('forum-archives-list');
    const noArchivesMsg = document.getElementById('no-forum-archives-message');
    listEl.innerHTML = '';

    // 始终在列表顶部显示“默认世界”
    const defaultArchiveItem = document.createElement('div');
    defaultArchiveItem.className = 'preset-item';
    defaultArchiveItem.dataset.archiveId = 'default';
    const isDefaultActive = state.activeForumArchiveId === 'default';
    defaultArchiveItem.innerHTML = `
        <div class="preset-info">
            <div class="preset-name">默认世界 (当前)</div>
            <div class="preset-desc">未存档的即时世界线</div>
        </div>
        <div class="preset-actions">
            <span class="preset-action-btn switch-archive-btn ${isDefaultActive ? 'active' : ''}" title="切换到此世界线">
                <i class="fas fa-power-off"></i>
            </span>
        </div>`;
    listEl.appendChild(defaultArchiveItem);

    // 渲染其他已保存的存档
    if (state.forumArchives.length === 0) {
        noArchivesMsg.style.display = 'block';
    } else {
        noArchivesMsg.style.display = 'none';
        state.forumArchives.forEach(archive => {
            const isActive = state.activeForumArchiveId === archive.id;
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.dataset.archiveId = archive.id;
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${archive.name}</div>
                    <div class="preset-desc">${new Date(archive.timestamp).toLocaleString()} 存档</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn switch-archive-btn ${isActive ? 'active' : ''}" title="切换到此世界线">
                        <i class="fas fa-power-off"></i>
                    </span>
                    <span class="preset-action-btn delete delete-archive-btn" title="删除此存档">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>`;
            listEl.appendChild(item);
        });
    }
}

// 函数：切换活动的世界线 (V4 - 持久化选择版)
async function switchForumArchive(archiveId) {
    if (state.activeForumArchiveId === archiveId) return; 

    let settingsToRestore;
    let archiveName;

    if (archiveId === 'default') {
        settingsToRestore = await kokoMemory.get('forumSettings', 'main');
        if (!settingsToRestore) {
            settingsToRestore = JSON.parse(JSON.stringify(INITIAL_STATE.forumSettings));
        }
        archiveName = '默认世界';
    } else {
        const archive = state.forumArchives.find(a => a.id === archiveId);
        if (!archive || !archive.settings) {
            alert('错误：找不到该存档或存档数据已损坏。');
            return;
        }
        settingsToRestore = archive.settings;
        archiveName = archive.name;
    }

    state.forumSettings = Object.assign({}, state.forumSettings, settingsToRestore);
    await kokoMemory.put('forumSettings', { id: 'main', ...state.forumSettings });

    // 更新 state，标记当前激活的世界线ID
    state.activeForumArchiveId = archiveId;

    // 【核心修复 - 第1部分：保存选择】
    // 将当前激活的存档ID保存到 userSettings 表中，实现持久化
    const settings = await kokoMemory.get('userSettings', 'main') || { id: 'main' };
    settings.activeForumArchiveId = archiveId;
    await kokoMemory.put('userSettings', settings);
    
    // 重置论坛的标签页状态到默认值
    state.activeFeedTab = 'recommended';
    state.activeFeedSubTab = 'daily';

    await renderForumArchivesList();
    alert(`已成功切换到世界线: ${archiveName}。\n\n相关的论坛设定（用户面具、世界书等）已同步更新。`);
}

// 函数：删除一个存档及其所有相关帖子
async function deleteForumArchive(archiveId) {
    const archive = state.forumArchives.find(a => a.id === archiveId);
    if (!archive) return;

    const confirmed = await showCustomConfirm(
        '删除确认',
        `⚠️ 确定要永久删除存档“${archive.name}”吗？\n\n这将同时删除该世界线下的【所有帖子】，此操作无法恢复！`,
        true
    );

    if (confirmed) {
        // 1. 从 state 中删除存档
        state.forumArchives = state.forumArchives.filter(a => a.id !== archiveId);
        // 2. 从数据库中删除存档
        await kokoMemory.delete('forumArchives', archiveId);

        // 3. 从 state 中删除与该存档关联的所有帖子
        // ▼▼▼ 核心修复：只删除属于该存档且【不是】空间说说的帖子 ▼▼▼
        state.posts = state.posts.filter(p => {
            // 如果帖子属于这个存档，但它是空间说说，则【保留】(return true)
            if (p.archiveId === archiveId && p.category === 'qzone') return true;
            // 否则，如果属于这个存档，就删除 (return false)
            return p.archiveId !== archiveId;
        });
        // ▲▲▲ 修复结束 ▲▲▲
        // 4. 从数据库中删除这些帖子 (这是一个批量删除操作)
        const allPosts = await kokoMemory.getAll('posts');
        // ▼▼▼ 核心修复：数据库删除时也加同样的保护 ▼▼▼
        const postsToDelete = allPosts.filter(p => 
            p.archiveId === archiveId && p.category !== 'qzone' // 保护空间说说！
        );
        // ▲▲▲ 修复结束 ▲▲▲
        for (const post of postsToDelete) {
            await kokoMemory.delete('posts', post.id);
        }

        // 5. 如果被删除的是当前激活的存档，则自动切换回默认世界
        if (state.activeForumArchiveId === archiveId) {
            state.activeForumArchiveId = 'default';
        }

        // 6. 重新渲染存档列表
        await renderForumArchivesList();
    }
}

// ==========================================================
// --- 幸运字符 UI 逻辑 ---

// 1. 打开仓库弹窗函数
async function openLuckyCharModal(contact) {
    const modal = document.getElementById('lucky-char-modal');
    const listEl = document.getElementById('lucky-char-list');
    const tipsEl = document.getElementById('lucky-draw-tips');
    
    // 更新剩余次数提示
    if (!contact.luckyCharGacha) contact.luckyCharGacha = { count: 0, lastDate: "" };
    const today = new Date().toLocaleDateString();
    if (contact.luckyCharGacha.lastDate !== today) contact.luckyCharGacha.count = 0;
    const left = 3 - contact.luckyCharGacha.count;
    tipsEl.textContent = `今日剩余抽取次数：${left} 次`;

    // 渲染列表
    renderLuckyCharList(contact, listEl);

    // 绑定抽取按钮
    const drawBtn = document.getElementById('draw-lucky-char-btn');
    // 克隆以防重复绑定
    const newDrawBtn = drawBtn.cloneNode(true);
    drawBtn.parentNode.replaceChild(newDrawBtn, drawBtn);
    
    newDrawBtn.addEventListener('click', async () => {
        newDrawBtn.disabled = true;
        newDrawBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 祈祷中...';
        
        await sleep(1000); // 仪式感
        
        const newChar = await drawLuckyCharacter(contact);
        
        newDrawBtn.disabled = false;
        newDrawBtn.innerHTML = '<i class="fas fa-magic"></i> 抽取新字符';
        
        if (newChar) {
            // 抽到了！
            alert(`🎉 欧皇时刻！\n你获得了【${newChar.word}】(${newChar.meaning})！\n稀有度: ${newChar.type.toUpperCase()}`);
            // 刷新UI
            openLuckyCharModal(contact); // 重新加载弹窗内容
            openChat(contact.id); // 刷新聊天界面顶栏
        } else {
            // 没抽到或次数没了，只刷新次数提示
            openLuckyCharModal(contact); 
        }
    });

    // 绑定关闭
    document.getElementById('close-lucky-char-modal').onclick = () => modal.style.display = 'none';
    
    modal.style.display = 'flex';
}

// 2. 渲染列表子函数
function renderLuckyCharList(contact, container) {
    container.innerHTML = '';
    const inventory = contact.luckyCharInventory || [];
    const equippedId = contact.luckyChar ? contact.luckyChar.word : null; // 用word做唯一标识

    if (inventory.length === 0) {
        container.innerHTML = '<p style="text-align:center; color:#999;">仓库是空的，快去抽取吧！</p>';
        return;
    }

    // 按稀有度排序 (Epic > Rare > Common)
    const typeOrder = { epic: 3, rare: 2, common: 1 };
    inventory.sort((a, b) => typeOrder[b.type] - typeOrder[a.type]);

    inventory.forEach(char => {
        const item = document.createElement('div');
        const isEquipped = equippedId === char.word;
        item.className = `lucky-char-card ${isEquipped ? 'equipped' : ''}`;
        
        // 构建字母预览
        let lettersHTML = '';
        for (let i = 0; i < char.word.length; i++) {
            const status = i < char.unlockedCount ? 'unlocked' : 'locked';
            // 在列表里我们不需要那么大的光效，简单显示即可
            // 为了复用样式，我们需要包裹在一个 badge 容器里
            lettersHTML += `<span class="char-letter ${status}">${char.word[i]}</span>`;
        }

        item.innerHTML = `
            <div class="lucky-char-info">
                <div class="lucky-char-badge lucky-char-${char.type} ${char.isCompleted ? 'completed' : ''}">
                    ${lettersHTML}
                </div>
                <div class="lucky-char-meaning">${char.meaning} (${char.unlockedCount}/${char.word.length})</div>
            </div>
            <div class="lucky-char-actions">
                ${isEquipped 
                    ? `<button class="btn-unequip" disabled>佩戴中</button>` 
                    : `<button class="btn-equip" data-word="${char.word}">佩戴</button>`
                }
            </div>
        `;
        
        // ... 在 renderLuckyCharList 函数内部 ...

        // 绑定佩戴事件
        if (!isEquipped) {
            item.querySelector('.btn-equip').addEventListener('click', async () => {
                
                // ▼▼▼▼▼▼ 核心修复开始：切换前先存档 ▼▼▼▼▼▼
                if (contact.luckyChar) {
                    // 1. 在仓库里找到当前正在佩戴的这个字符（旧字符）
                    // 我们使用 id 或 word 来匹配
                    const inventoryIndex = contact.luckyCharInventory.findIndex(c => c.word === contact.luckyChar.word);
                    
                    if (inventoryIndex > -1) {
                        // 2. 把当前佩戴的（包含最新进度的）数据，覆盖回仓库
                        contact.luckyCharInventory[inventoryIndex] = contact.luckyChar;
                        console.log(`已同步旧字符 [${contact.luckyChar.word}] 的进度回仓库`);
                    }
                }
                // ▲▲▲▲▲▲ 核心修复结束 ▲▲▲▲▲▲

                contact.luckyChar = char; // 切换引用到新字符
                
                await kokoMemory.put('contacts', contact); // 保存到数据库
                renderLuckyCharList(contact, container); // 刷新列表状态
                openChat(contact.id); // 刷新聊天界面顶栏
            });
        }

        container.appendChild(item);
    });
}
// =========== ▲▲▲ 论坛档案馆 - 核心功能函数 END ▲▲▲ =========
/**
 * (新增) 智能模糊查找表情包
 * 规则：
 * 1. 优先完全匹配
 * 2. 其次尝试相互包含 (AI说的词包含表情名，或表情名包含AI说的词)
 * 3. 如果有多个匹配，选择字数差异最小的那个
 */
function findBestMatchingEmoticon(keyword) {
    if (!keyword) return null;
    const cleanKeyword = keyword.trim();
    
    // 1. 尝试完全匹配 (优先级最高)
    let match = state.emoticons.find(e => e.name === cleanKeyword);
    if (match) return match;

    // 2. 尝试宽泛匹配
    // 逻辑：表情名包含AI说的词，或者 AI说的词包含表情名
    const candidates = state.emoticons.filter(e => 
        e.name.includes(cleanKeyword) || cleanKeyword.includes(e.name)
    );

    if (candidates.length > 0) {
        // 3. 智能排序：找出最像的那个
        // 按照“名字长度差值”排序，差值越小越匹配
        candidates.sort((a, b) => {
            const diffA = Math.abs(a.name.length - cleanKeyword.length);
            const diffB = Math.abs(b.name.length - cleanKeyword.length);
            return diffA - diffB;
        });
        
        console.log(`表情包模糊匹配成功: AI输入"${cleanKeyword}" -> 匹配为"${candidates[0].name}"`);
        return candidates[0];
    }

    return null;
}
// ==========================================================
// ==========================================================
// V-Final 新增: 锁屏功能逻辑
// ==========================================================
let lockScreenClockInterval = null; // 用于存放时钟的定时器
let photoCarouselInterval = null;   // ▼▼▼ 新增下面这两行 ▼▼▼
let currentPhotoIndex = 0;
let inactivityTimer = null;
/**
 * 更新锁屏上的时间和日期
 */
function updateLockScreenTime() {
    const timeEl = document.getElementById('lock-screen-time');
    const dateEl = document.getElementById('lock-screen-date');
    if (!timeEl || !dateEl) return;

    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const dayNames = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
    
    timeEl.textContent = `${hours}:${minutes}`;
    dateEl.textContent = `${now.getMonth() + 1}月${now.getDate()}日 ${dayNames[now.getDay()]}`;
}
// ==========================================================
// V-Final 新增: 锁屏组件内容更新函数
// ==========================================================
async function updateLockScreenWidgets() {
    // 1. 读取并显示备忘录
    const memoEl = document.getElementById('lock-screen-memo');
    if (!window.userSettings) window.userSettings = { id: 'main' }; 
    if (userSettings.lockScreenMemo) { memoEl.textContent = userSettings.lockScreenMemo; } 
    else { memoEl.textContent = '点击这里编辑你的备忘录...'; }

    // 2. 处理置顶纪念日/倒数日
    const countdownDaysEl = document.querySelector('#lock-screen-countdown .countdown-days');
    const countdownLabelEl = document.querySelector('#lock-screen-countdown .countdown-label');
    let pinnedEvent = null;
    for (const contact of state.contacts) {
        if (contact.events && contact.events.length > 0) {
            const foundEvent = contact.events.find(event => event.isPinned);
            if (foundEvent) { pinnedEvent = foundEvent; break; }
        }
    }
    if (pinnedEvent) {
        const today = new Date(); today.setHours(0, 0, 0, 0);
        const eventDate = new Date(pinnedEvent.date); eventDate.setHours(0, 0, 0, 0);
        const diff = (eventDate - today) / (1000 * 60 * 60 * 24);
        countdownDaysEl.textContent = Math.round(Math.abs(diff));
        if (diff >= 0) { countdownLabelEl.textContent = `距离 ${pinnedEvent.eventName} 还有`; } 
        else { countdownLabelEl.textContent = `${pinnedEvent.eventName} 已经`; }
    } else {
        countdownDaysEl.textContent = 'Pin!';
        countdownLabelEl.textContent = "去“我们的日子”置顶一个纪念日吧";
    }

    // 3. 处理所有未读消息
    const notificationWidget = document.getElementById('lock-screen-notification-widget');
    const notificationTextEl = document.getElementById('lock-screen-notification-text');
    let allUnreadMessages = [];
    state.contacts.forEach(contact => {
        if (contact.unreadCount > 0 && contact.history.length > 0) {
            const unreadMessages = contact.history.slice(-contact.unreadCount);
            unreadMessages.forEach(msg => {
                let contentPreview = msg.content;
                switch (msg.type) {
                    case 'image': case 'picture_description': contentPreview = '[图片]'; break;
                    case 'voice': contentPreview = '[语音消息]'; break;
                    case 'red_packet': contentPreview = `[红包] ${msg.content.blessing}`; break;
                }
                allUnreadMessages.push({
                    timestamp: msg.timestamp,
                    text: `<div>${contact.name}: ${contentPreview}</div>`
                });
            });
        }
    });
    if (allUnreadMessages.length > 0) {
        allUnreadMessages.sort((a, b) => a.timestamp - b.timestamp);
        const fullNotificationHTML = allUnreadMessages.map(msg => msg.text).join('');
        notificationTextEl.innerHTML = fullNotificationHTML;
        notificationWidget.style.display = 'flex';
        const animationDuration = Math.max(8, allUnreadMessages.length * 4);
        notificationTextEl.style.animationDuration = `${animationDuration}s`;
    } else {
        notificationWidget.style.display = 'none';
    }
}

/**
 * 显示锁屏界面 (V10 - 重构版)
 */
async function showLockScreen() {
    if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; }

    const lockScreenEl = document.getElementById('lock-screen');
    const backgroundEl = document.querySelector('.lock-screen-background');

    // 设置智能背景
    let backgroundUrl = 'https://i.postimg.cc/SQ3DH79X/MEITU-20250811-151831796.jpg';
    if (userSettings && userSettings.chatBackground) { backgroundUrl = userSettings.chatBackground; }
    const lastContact = state.contacts.find(c => c.id === state.activeChatId);
    if (lastContact && lastContact.customChatBackground) { backgroundUrl = lastContact.customChatBackground; }
    backgroundEl.style.backgroundImage = `url(${backgroundUrl})`;

    // ▼▼▼ 核心改动：直接调用我们的新函数来更新所有组件 ▼▼▼
    await updateLockScreenWidgets();
    // ▲▲▲ 改动结束 ▲▲▲

    // 显示锁屏和启动其他功能 (不变)
    lockScreenEl.style.display = 'flex';
    setTimeout(() => { lockScreenEl.classList.remove('hidden'); }, 10);
    if (!lockScreenClockInterval) {
        updateLockScreenTime();
        lockScreenClockInterval = setInterval(updateLockScreenTime, 1000);
    }
    startPhotoCarousel();
}

/**
 * 隐藏锁屏界面
 */
function hideLockScreen() {
    const lockScreenEl = document.getElementById('lock-screen');
    lockScreenEl.classList.add('hidden');

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    // 停止照片轮播的定时器
    if (photoCarouselInterval) {
        clearInterval(photoCarouselInterval);
        photoCarouselInterval = null;
    }
    // ▲▲▲ 新增结束 ▲▲▲

    setTimeout(() => {
        lockScreenEl.style.display = 'none';
    }, 500);
    // ▼▼▼ 新增：解锁后，开始无活动计时 ▼▼▼
    resetInactivityTimer();
    // ▲▲▲ 新增结束 ▲▲▲
}

// 为锁屏界面绑定“解锁”事件 (V2 - 备忘录兼容版)
document.getElementById('lock-screen').addEventListener('click', (e) => {
    // 如果我们点击的目标是正在编辑的备忘录输入框，则不执行解锁操作
    if (e.target.id === 'memo-edit-textarea') {
        return;
    }
    hideLockScreen();
});
// ==========================================================
// ==========================================================
// V-Final 新增: 锁屏备忘录编辑功能
// ==========================================================
const memoContainer = document.getElementById('lock-screen-memo');

memoContainer.addEventListener('click', function(event) {
    // 阻止点击事件冒泡，防止点击备忘录时直接解锁屏幕
    event.stopPropagation();

    // 如果当前已经是编辑模式，就什么都不做
    if (document.getElementById('memo-edit-textarea')) {
        return;
    }

    const currentText = memoContainer.textContent;
    
    // 创建一个textarea输入框
    const textarea = document.createElement('textarea');
    textarea.id = 'memo-edit-textarea';
    textarea.value = (currentText === '点击这里编辑你的备忘录...') ? '' : currentText;
    
    // 应用一些和显示文本差不多的样式
    textarea.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        background-color: transparent;
        color: white;
        font-family: inherit;
        font-size: 15px;
        line-height: 1.6;
        resize: none;
        outline: none;
        padding: 0;
        margin: 0;
    `;

    // 替换显示区域为输入框
    memoContainer.innerHTML = '';
    memoContainer.appendChild(textarea);
    textarea.focus(); // 自动聚焦，让用户可以直接输入

    // 当输入框失去焦点时 (例如点击了其他地方)，就保存并切换回显示模式
    textarea.addEventListener('blur', async function() {
        const newText = textarea.value.trim();
        
        // 更新并保存备忘录内容
        userSettings.lockScreenMemo = newText;
        await kokoMemory.put('userSettings', userSettings);

        // 切换回文本显示模式
        memoContainer.innerHTML = ''; // 先清空
        if (newText) {
            memoContainer.textContent = newText;
        } else {
            memoContainer.textContent = '点击这里编辑你的备忘录...';
        }
    });
});
// ==========================================================
// V-Final 新增: 锁屏相册功能逻辑
// ==========================================================

// 函数：显示锁屏相册管理页面
async function showLockScreenPhotosScreen() {
    hideAllScreens();
    document.getElementById('lock-screen-photos-screen').style.display = 'flex';
    await renderLockScreenPhotos();
}

// 函数：渲染相册中的所有照片
async function renderLockScreenPhotos() {
    const grid = document.getElementById('lock-screen-photos-grid');
    const noPhotosMsg = document.getElementById('no-lock-screen-photos-message');
    grid.innerHTML = '';

    const photos = await kokoMemory.getAll('lockScreenPhotos');

    if (photos.length === 0) {
        noPhotosMsg.style.display = 'block';
    } else {
        noPhotosMsg.style.display = 'none';
        photos.forEach(photo => {
            const item = document.createElement('div');
            item.className = 'emoticon-item'; // 复用表情包的样式
            item.innerHTML = `
                <img src="${photo.base64}" alt="锁屏照片">
                <button class="emoticon-delete-btn" data-photo-id="${photo.id}">&times;</button>
            `;
            grid.appendChild(item);
        });
    }
}
// ==========================================================
// V-Final 新增: 锁屏照片轮播核心功能
// ==========================================================
async function startPhotoCarousel() {
    const photoBlock = document.querySelector('.lock-block.photo-block');
    if (!photoBlock) return;

    // 1. 从数据库读取所有照片
    const photos = await kokoMemory.getAll('lockScreenPhotos');

    // 2. 如果相册是空的，就什么都不做，显示默认的占位符
    if (!photos || photos.length === 0) {
        photoBlock.innerHTML = '<div class="placeholder-text"><i class="fas fa-images"></i><p>去锁屏相册添加照片</p></div>';
        return;
    }

    // 3. 如果有照片，就清空占位符，准备开始轮播
    photoBlock.innerHTML = ''; 
    currentPhotoIndex = 0; // 每次都从第一张开始

    // 4. 定义一个切换图片的函数
    const changePhoto = () => {
        // 计算下一张照片的索引，如果到了最后一张，就循环回第一张
        currentPhotoIndex = (currentPhotoIndex + 1) % photos.length;
        // 设置背景图
        photoBlock.style.backgroundImage = `url(${photos[currentPhotoIndex].base64})`;
    };

    // 5. 立刻显示第一张照片
    photoBlock.style.backgroundImage = `url(${photos[0].base64})`;

    // 6. 启动定时器，每5秒切换一次照片
    // (如果之前有定时器在跑，先清除掉)
    if (photoCarouselInterval) clearInterval(photoCarouselInterval);
    photoCarouselInterval = setInterval(changePhoto, 5000); // 5000毫秒 = 5秒
}
// ==========================================================
// V-Final 新增: 自动锁屏计时器逻辑
// ==========================================================
let autoLockDelay = 0; // 默认禁用

// 函数：重置并启动计时器
function resetInactivityTimer() {
    // 先清除上一个计时器
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
    }
    // 如果设置的延迟大于0，则启动一个新的计时器
    if (autoLockDelay > 0) {
        inactivityTimer = setTimeout(() => {
            // 时间到了，就显示锁屏
            showLockScreen();
        }, autoLockDelay * 1000); // 将秒转换为毫秒
    }
}

// 监听用户的各种操作事件，只要有操作，就重置计时器
window.addEventListener('mousemove', resetInactivityTimer);
window.addEventListener('mousedown', resetInactivityTimer);
window.addEventListener('keypress', resetInactivityTimer);
window.addEventListener('touchstart', resetInactivityTimer);
// ==========================================================
// --- 新增：进入短信编辑模式 ---
function enterSmsEditMode() {
    const screen = document.getElementById('sms-chat-screen');
    if (!screen) return;

    smsEditModeState.active = true;
    smsEditModeState.selectedMessageIds.clear();
    screen.classList.add('sms-edit-mode'); // 添加标记类

    // 重新渲染消息以启用选择功能（如果需要特别处理的话，
    // 但我们可以在点击事件里直接判断是否是编辑模式）
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (contact) renderSmsChatMessages(contact);
}

// --- 新增：退出短信编辑模式 ---
async function exitSmsEditMode() {
    const screen = document.getElementById('sms-chat-screen');
    if (!screen) return;

    smsEditModeState.active = false;
    screen.classList.remove('sms-edit-mode'); // 移除标记类

    // ▼▼▼ 添加这一行 ▼▼▼
    const editBar = document.getElementById('sms-edit-mode-bar');
    if (editBar) editBar.style.display = 'none';
    // ▲▲▲ 添加结束 ▲▲▲

    // 退出后需要重新渲染消息列表，去掉选中状态
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (contact) await renderSmsChatMessages(contact);
}
// --- 新增：处理短信消息选择 ---
function handleSmsMessageSelection(wrapper) {
    if (!smsEditModeState.active) return; // 只有编辑模式才响应

    const msgId = wrapper.dataset.messageId;
    if (!msgId) return;

    // 切换选中状态和样式
    if (smsEditModeState.selectedMessageIds.has(msgId)) {
        smsEditModeState.selectedMessageIds.delete(msgId);
        wrapper.classList.remove('selected');
    } else {
        smsEditModeState.selectedMessageIds.add(msgId);
        wrapper.classList.add('selected');
    }
}
// --- 新增：删除选中的短信消息 ---
async function deleteSelectedSmsMessages() {
    if (smsEditModeState.selectedMessageIds.size === 0) {
        return alert('请先选择要删除的短信。');
    }
    const confirmed = await showCustomConfirm('删除短信', `确定要删除选中的 ${smsEditModeState.selectedMessageIds.size} 条短信吗？`, true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.smsHistory) {
            // 核心：过滤掉被选中的消息
            contact.smsHistory = contact.smsHistory.filter(msg => !smsEditModeState.selectedMessageIds.has(msg.id));
            // 保存更改
            await kokoMemory.put('contacts', contact);
        }
        // 退出编辑模式（会自动刷新列表）
        await exitSmsEditMode();
        // (可选) 刷新短信主列表的预览
        await renderSmsConversations();
    }
}
// ▼▼▼ 把下面这一整块新代码，粘贴到JS里 ▼▼▼
// --- 新增：渲染短信主列表函数 (V2 - 显示所有非群聊联系人) ---
async function renderSmsConversations() {
    const container = document.getElementById('sms-content-container'); // 确保ID正确
    container.innerHTML = ''; // 清空

    // ✨ 核心修改1：筛选出所有非群聊联系人 ✨
    const allNonGroupContacts = state.contacts.filter(c => !c.isGroup);

    // ✨ (可选) 排序：这里简单按名字排序，你也可以按其他方式排 ✨
    allNonGroupContacts.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    if (allNonGroupContacts.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 50px 20px; color: #888;">
                <i class="fas fa-user-plus" style="font-size: 48px; margin-bottom: 15px;"></i>
                <p>你还没有添加任何联系人哦</p>
                <p>去“聊天”页面添加一个吧</p>
            </div>`;
        return;
    }

    allNonGroupContacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-item'; // 复用样式
        item.style.cursor = 'pointer';
        item.dataset.contactId = contact.id;

        // ✨ 核心修改2：根据是否有短信历史决定显示内容 ✨
        let lastMessageText = '点击发送第一条短信';
        let lastMessageTime = '';
        if (contact.smsHistory && contact.smsHistory.length > 0) {
            const lastSms = contact.smsHistory[contact.smsHistory.length - 1];
            if (lastSms.type === 'text') {
                lastMessageText = lastSms.content;
            } else if (lastSms.type === 'uploaded_image' || lastSms.type === 'image') {
                lastMessageText = '[图片]';
            }
            if (lastSms.sender === 'user') {
                lastMessageText = '我: ' + lastMessageText;
            }
            lastMessageTime = lastSms.time || formatTimeAgo(lastSms.timestamp);
        }

        item.innerHTML = `
            <div class="contact-avatar">
                ${contact.avatar ? `<img src="${contact.avatar}" alt="${contact.name}头像">` : '<i class="fas fa-user"></i>'}
            </div>
            <div class="contact-info">
                <div class="contact-name">${contact.name}</div>
                <div class="contact-last-message" style="${!lastMessageTime ? 'color:#aaa; font-style:italic;' : ''}">${lastMessageText.substring(0, 30)}${lastMessageText.length > 30 ? '...' : ''}</div>
            </div>
            ${lastMessageTime ? `<div class="contact-time-info" style="text-align: right;"><div class="contact-time">${lastMessageTime}</div></div>` : ''}
        `;
        container.appendChild(item);
    });
}
// --- 新增：打开短信聊天界面函数 ---
async function openSmsChat(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    hideAllScreens(); // 隐藏其他屏幕
    const smsChatScreen = document.getElementById('sms-chat-screen');
    smsChatScreen.style.display = 'flex'; // 显示短信聊天屏幕

    state.currentChatMode = 'sms'; // 设置当前模式为短信
    state.activeChatId = contactId; // 设置当前聊天对象

    // 更新顶部标题
    document.getElementById('sms-chat-contact-name').textContent = contact.name;

    // 渲染短信消息
    await renderSmsChatMessages(contact);

    // --- 绑定发送按钮事件 (使用克隆节点防止重复绑定) ---
    const oldSendBtn = document.getElementById('sms-send-btn');
    const newSendBtn = oldSendBtn.cloneNode(true);
    oldSendBtn.parentNode.replaceChild(newSendBtn, oldSendBtn);
    newSendBtn.addEventListener('click', sendSmsMessage);

// --- 绑定图片上传按钮事件 (已修改为“模拟图片”) ---
    const oldUploadBtn = document.getElementById('sms-upload-image-btn');
    const newUploadBtn = oldUploadBtn.cloneNode(true);
    oldUploadBtn.parentNode.replaceChild(newUploadBtn, oldUploadBtn);
    
    newUploadBtn.addEventListener('click', () => {
        // 1. 找到并显示“发送图片”弹窗
        const modal = document.getElementById('send-picture-modal');
        const descriptionInput = document.getElementById('send-picture-description-input');
        descriptionInput.value = ''; // 清空输入框
        modal.style.display = 'flex';

        // 2. 找到确认按钮，并使用克隆节点方法绑定一次性事件
        const oldConfirmBtn = document.getElementById('confirm-send-picture-btn');
        const newConfirmBtn = oldConfirmBtn.cloneNode(true);
        oldConfirmBtn.parentNode.replaceChild(newConfirmBtn, oldConfirmBtn);

        newConfirmBtn.addEventListener('click', async () => {
            const description = descriptionInput.value.trim();
            if (description) {
                const contact = state.contacts.find(c => c.id === state.activeChatId);
                // 确保我们是在短信模式下
                if (contact && state.currentChatMode === 'sms') {
                    // 3. 创建 picture_description 消息
                    await createAndAddMessage(
                        { 
                            type: 'picture_description', // 使用和主聊天一样的类型
                            content: { description } 
                        },
                        'user',  // sender
                        contact, // targetContact
                        false,   // forceShowAvatar
                        'sms'    // contextMode
                    );
                    
                    // 4. 关闭弹窗
                    modal.style.display = 'none';

                }
            }
        });

        // 6. 确保弹窗的关闭按钮也能用 (防止重复绑定)
        const closeBtn = document.getElementById('close-send-picture-modal');
        const newCloseBtn = closeBtn.cloneNode(true);
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
        newCloseBtn.addEventListener('click', () => {
            modal.style.display = 'none';
        });
    });

    // --- 绑定返回按钮事件 ---
    const oldBackBtn = document.getElementById('back-from-sms-chat');
    const newBackBtn = oldBackBtn.cloneNode(true);
    oldBackBtn.parentNode.replaceChild(newBackBtn, oldBackBtn);
    newBackBtn.addEventListener('click', () => {
        state.currentChatMode = 'sms'; // 确保返回时模式正确
        showSmsScreen(); // 返回短信列表
    });

    // --- 绑定图片选择后的处理事件 ---
    const imageUploader = document.getElementById('sms-image-upload-input');
    const newImageUploader = imageUploader.cloneNode(true);
    imageUploader.parentNode.replaceChild(newImageUploader, imageUploader);
    newImageUploader.addEventListener('change', handleSmsImageUpload);
}
// --- 新增：渲染短信聊天消息函数 ---
async function renderSmsChatMessages(contact) {
    const messagesContainer = document.getElementById('sms-chat-messages');
    messagesContainer.innerHTML = ''; // 清空

    if (!contact.smsHistory || contact.smsHistory.length === 0) {
        messagesContainer.innerHTML = `<div id="sms-chat-placeholder" style="text-align: center; color: #999; padding: 20px;">开始发送短信吧...</div>`;
        return;
    }

    let lastTime = null;
    contact.smsHistory.forEach(msg => {
        // 添加时间戳 (如果需要)
        const msgTime = msg.time || new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        if (msgTime !== lastTime) {
            const timeEl = document.createElement('div');
            timeEl.className = 'sms-timestamp';
            timeEl.innerHTML = `<span>${msgTime}</span>`;
            messagesContainer.appendChild(timeEl);
            lastTime = msgTime;
        }
        // 创建并添加消息元素
        const messageEl = createSmsMessageElement(msg);
        if (messageEl) {
        if (smsEditModeState.active && smsEditModeState.selectedMessageIds.has(msg.id)) { messageEl.classList.add('selected');
        } 
            messagesContainer.appendChild(messageEl);
        }
    });

    // 滚动到底部
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// ▼▼▼ 使用这个【V2 修正版】替换旧的 createSmsMessageElement ▼▼▼
function createSmsMessageElement(message) {
    const wrapper = document.createElement('div');
    const isSent = message.sender === 'user';
    wrapper.className = `sms-row ${isSent ? 'sent' : 'received'}`;
    wrapper.dataset.messageId = message.id;

    let contentHTML = '';
    if (message.type === 'text') {
        contentHTML = `<div class="sms-bubble ${isSent ? 'sent' : 'received'}">${message.content.replace(/\n/g, '<br>')}</div>`;
    } else if (message.type === 'uploaded_image' || message.type === 'image') {
        const imageUrl = (message.type === 'uploaded_image') ? message.content.base64 : message.url;
        contentHTML = `
            <div class="sms-bubble image-message ${isSent ? 'sent' : 'received'}">
                <img src="${imageUrl}" class="sms-image" alt="短信图片">
            </div>`;
            
    // ▼▼▼ ✨ 核心修改点 ✨ ▼▼▼
    } else if (message.type === 'picture_description') {
        // 模拟图片，显示 [图片] 文字，并使其可点击
        contentHTML = `<div class="sms-bubble ${isSent ? 'sent' : 'received'}" style="cursor: pointer;"><i class="fas fa-image" style="margin-right: 5px;"></i> [图片]</div>`;
    // ▲▲▲ 修改结束 ▲▲▲

    } else {
        return null; // 不支持的消息类型，直接忽略
    }

    wrapper.innerHTML = contentHTML;

    // ▼▼▼ ✨ 核心新增：为 picture_description 添加隐藏的描述文本框 ✨ ▼▼▼
    if (message.type === 'picture_description') {
        const transcribedTextEl = document.createElement('div');
        transcribedTextEl.className = 'transcribed-text';
        // (为短信模式添加一点内联样式，让它更好看)
        transcribedTextEl.style.cssText = "background: #f0f0f0; color: #333; margin-top: 4px; border-radius: 8px; padding: 8px 12px;";
        wrapper.appendChild(transcribedTextEl);
    }
    // ▲▲▲ 新增结束 ▲▲▲

    return wrapper;
}
// ▲▲▲ 替换结束 ▲▲▲
// --- 新增：发送短信消息函数 ---
async function sendSmsMessage() {
    const input = document.getElementById('sms-message-input');
    const content = input.value.trim();
    if (!content || !state.activeChatId) return;

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 创建消息对象
    const newMessage = {
        id: `sms_${Date.now()}_${Math.random()}`,
        timestamp: Date.now(),
        sender: 'user',
        type: 'text',
        content: content,
        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) // 添加 time 字段
    };

    // 添加到历史记录
    if (!contact.smsHistory) contact.smsHistory = [];
    contact.smsHistory.push(newMessage);

    // 保存和更新UI
    await kokoMemory.put('contacts', contact);
    await renderSmsChatMessages(contact); // 用新函数更新短信界面
    input.value = ''; // 清空输入框
    input.style.height = 'auto'; // 恢复高度

    
    
}

// --- 新增：处理短信图片上传函数 ---
async function handleSmsImageUpload(e) {
    const file = e.target.files[0];
    if (!file || !state.activeChatId) return;

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    try {
        // 复用图片压缩和转Base64的函数
        const base64String = await handleImageUpload(file);

        // 创建图片消息对象
        const newMessage = {
            id: `sms_${Date.now()}_${Math.random()}`,
            timestamp: Date.now(),
            sender: 'user',
            type: 'uploaded_image', // 使用这个类型表示是用户上传的
            content: { base64: base64String },
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        };

        // 添加到历史记录
        if (!contact.smsHistory) contact.smsHistory = [];
        contact.smsHistory.push(newMessage);

        // 保存和更新UI
        await kokoMemory.put('contacts', contact);
        await renderSmsChatMessages(contact);

        // 触发AI对图片的回复 (可以加个简单的系统提示)
        await requestAiSmsReply(contact, '[SYSTEM: 用户给你发送了一张图片，请根据聊天记录回应。]');

    } catch (error) {
        console.error('短信图片处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空 input
    }
}
// ▼▼▼ 使用这个【V6 - 统一记忆流版】替换旧的 requestAiSmsReply 函数 ▼▼▼
async function requestAiSmsReply(contact, additionalInstruction = null) {
    if (!contact) return;

    // 显示“对方正在输入...”状态 (可选)
    const statusEl = document.getElementById('sms-chat-contact-status');
    const originalStatus = statusEl.textContent;
    statusEl.textContent = '对方正在输入...';

    try {
        // ==========================================================
        // =========== ▼▼▼ 核心修复点就在这里 ▼▼▼ ============
        // ==========================================================
        
        // --- 1. (全新) 构建统一时序记忆流 ---
        let unifiedMemoryStream = [];
        const myProfile = state.myProfile;
        const now = Date.now();
        // 短信回复时，记忆窗口应该更长，因为可能是时隔几天的回复
        const memoryWindow = 24 * 60 * 60 * 1000 * 7; // 7天
        
        // --- 1a. 添加App内聊天记录 ---
        if (contact && contact.history) {
            const recentChatHistory = contact.history.filter(msg => (now - msg.timestamp < memoryWindow));
            recentChatHistory.forEach(msg => {
                let content = '';
                let memoryType = 'App内聊天'; // 明确渠道
                
                switch (msg.type) {
                    case 'image':
                    case 'uploaded_image':
                        content = msg.isEmoticon ? `[sticker:${msg.emoticonName}]` : '[picture:用户发送了一张图片]';
                        break;
                    case 'picture_description':
                        content = `[picture:${msg.content.description}]`;
                        break;
                    case 'voice':
                        content = `[voice:${msg.content.text}]`;
                        break;
                    case 'red_packet':
                        content = `[red_packet:blessing="${msg.content.blessing}", amount=${msg.content.amount}]`;
                        break;
                    case 'transfer':
                        content = `[transfer:${msg.content.amount}]`;
                        break;
                    case 'text':
                    case 'html':
                        content = msg.content;
                        break;
                    // ... (可以根据需要从 generateAiResponse 复制更多case) ...
                }

                if (content) {
                    const authorName = msg.sender === 'user' ? myProfile.name : (contact.name || '系统');
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: memoryType,
                        author: authorName,
                        content: content
                    });
                }
            });
        }
        
        // --- 1b. 添加短信记录 ---
        if (contact && contact.smsHistory) {
            const recentSmsHistory = contact.smsHistory.slice(-100); // 短信记录条数
            recentSmsHistory.forEach(msg => {
                 let content = '';
                 let memoryType = '短信'; // 明确渠道
                 if (msg.type === 'text') {
                    content = msg.content;
                 } else if (msg.type === 'uploaded_image' || msg.type === 'image') {
                    content = '(发送了一张图片)';
                 } else if (msg.type === 'picture_description') {
                    content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                 }

                if (content) {
                    const authorName = msg.sender === 'user' ? myProfile.name : contact.name;
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: memoryType,
                        author: authorName,
                        content: content
                    });
                }
            });
        }

        // --- 1c. 排序并格式化 ---
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
        const memoryLimit = state.apiSettings.longTermMemoryLength || 100; // 短信模式用更长的记忆
        
        // 检查App内的总开关 (如果未定义，默认为 false)
        const isTimeAware = contact.isTimeAware ?? false; 

        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
            // 只有在总开关打开时才显示时间
            const timeTag = isTimeAware ? formatHybridTimeForAI(mem.timestamp) : '';
            return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // ==========================================================
        // =========== ▲▲▲ 核心修复点结束 ▲▲▲ =======================
        // ==========================================================

        // --- 2. 【V5 优化版】获取拉黑状态并动态注入指令 ---
        const blockStatus = contact.blockedStatus || '正常';
        let blockInstruction = ''; // 默认情况下，AI不需要知道任何关于拉黑的事

        if (blockStatus === 'user_blocked_ai') {
            blockInstruction = '[重要提示：你目前被用户在App内拉黑了，你们只能通过短信交流。]';
        } else if (blockStatus === 'ai_blocked_user') {
            blockInstruction = `
[重要提示：你目前在App内拉黑了用户，你们只能通过短信交流。]

[✨ 特殊指令：解除拉黑 ✨]
你现在处于拉黑用户的状态。你有权决定是否原谅TA。

如果用户在短信中【明确请求你解除拉黑】（例如说“求你了”、“原谅我吧”、“把我从黑名单放出来”等），
你【必须】对此作出回应。你可以选择：
1.  **同意解除**: 如果你决定原谅TA，你就在回复中【单独包含一行】特殊指令 \`[action:unblock_user]\`。
2.  **拒绝解除**: 如果你还很生气，不想原谅，就【不要】使用该指令，并正常回复短信告诉TA你的理由。

这个 \`[action:unblock_user]\` 指令是隐形的，它会为你解锁App内的聊天功能。
`;
        }
        
        // --- 3. 【V4 修正版】判断是否为“长时间未联系” ---
        let contextSwitchInstruction = '';
        const lastOverallInteractionTimestamp = (unifiedMemoryStream.length > 1) 
            ? unifiedMemoryStream[unifiedMemoryStream.length - 2].timestamp 
            : 0;
            
        const LONG_GAP_THRESHOLD = 7200 * 1000; // 2小时

        if (lastOverallInteractionTimestamp === 0 && unifiedMemoryStream.length <= 1) {
            contextSwitchInstruction = `[重要指令：这是用户第一次给你发短信。请在回复中自然地提及这一点，比如“咦？怎么突然给我发短信啦？”。]`;
        } else {
            const timeGap = Date.now() - lastOverallInteractionTimestamp;
            if (timeGap > LONG_GAP_THRESHOLD) {
                const hoursGap = (timeGap / 3600000).toFixed(0); 
                contextSwitchInstruction = `[重要指令：用户在很长一段时间（超过${hoursGap}小时）没给你发短信之后，突然给你发了这条短信。请在回复中自然地表达惊讶或好奇，比如“哇，好久不见，怎么突然想起来给我发短信了？”。]`;
            }
        }
        
        // --- 4. 组装最终的 Prompt (这部分不变，会加载人设) ---
        let basePromptStructure = NORMAL_BASE_PROMPT.split('# 统一时序记忆流')[0]; 
        const preset = state.thoughtPresets.find(p => p.id === contact?.thoughtPreset);
        const thoughtPresetContent = preset ? preset.prompt : '(无特殊思维准则)';
        let personaAwarePrompt = NORMAL_BASE_PROMPT.replace('{{thought_preset_content}}', thoughtPresetContent);
        let personaDirectives = "";
        if (contact?.persona) {
            personaDirectives += `\n\n# 核心角色指令 (Your Core Role Directive)\n---\n这是你的核心身份，你必须严格、完全地代入以下角色进行对话：\n${contact.persona}\n---`;
        }
        if (contact?.userPersona) {
            personaDirectives += `\n\n# 对话者信息 (Your Counterpart's Information)\n---\n与你对话的用户的角色设定如下，请将TA视为真实存在的角色并进行互动：\n${contact.userPersona}\n---`;
        }
        const firstLineEndIndex = personaAwarePrompt.indexOf(']');
        if (firstLineEndIndex !== -1 && personaDirectives) {
            personaAwarePrompt = personaAwarePrompt.slice(0, firstLineEndIndex + 1) + personaDirectives + personaAwarePrompt.slice(firstLineEndIndex + 1);
        } else {
            personaAwarePrompt = personaAwarePrompt + personaDirectives;
        }
        
        // --- 5. (全新) 替换 Prompt 中的记忆流 ---
        personaAwarePrompt = personaAwarePrompt.replace('{{memory_stream}}', '(你正在短信模式下，请参考下方的专属聊天记录)');
        
        // 注入短信专用指令
        personaAwarePrompt += `\n\n[当前情景：短信交流]\n${blockInstruction}\n${contextSwitchInstruction}\n`; // 你的新指令在这里被注入
        if(additionalInstruction) {
             personaAwarePrompt += `\n${additionalInstruction}\n`;
        }
        
        const finalSmsPrompt = `
${personaAwarePrompt} 

# 统一时序记忆流 (包含App聊天和短信)
这是你和用户最近按【时间顺序】发生的所有互动记录。这是你决策的【最高优先级】信息源。
---
${finalMemoryString}
---

[短信回复要求]
1. 你的回复必须是**纯文本**或**图片描述指令 \`[picture:描述]\`**。
2. 风格要简洁，符合短信交流习惯。
3. **禁止**使用红包、转账、语音、音乐分享、表情包指令 \`[sticker:]\` 等App内功能。
4. 回复内容要结合【统一时序记忆流】和当前的【拉黑状态】。
5. **绝对禁止**在回复中包含你的内心想法 \`[heart_voice]\` 或日记 \`[diary]\` 标签！短信里不说这些。

`;

        // --- 6. 调用 AI (不变) ---
        const rawResponse = await generateAiResponse(contact, [], finalSmsPrompt.trim(), false, 'chat');

        // --- 7. 处理回复 (V3 修正版) ---
        await processAndDisplayAiResponse(rawResponse, contact, contact, 'sms');

    } catch (error) {
        console.error("请求AI短信回复失败:", error);
    } finally {
        statusEl.textContent = '短信'; // 恢复状态显示
    }
}
// ▲▲▲ 替换到这里结束 ▲▲▲
// --- 新增：处理短信/窥探模式页签切换的核心函数 ---
function handleSmsTabClick(event) {
    const clickedTab = event.target.closest('.feed-tab-btn');
    if (!clickedTab) return;

    // 1. 移除所有按钮的 'active' 高亮状态
    document.querySelectorAll('#sms-tabs .feed-tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // 2. 只给被点击的按钮加上高亮
    clickedTab.classList.add('active');

    // 3. 根据点击的按钮，决定要显示什么内容
    const tabType = clickedTab.dataset.tab;
    if (tabType === 'my-sms') {
        renderSmsConversations(); // 调用函数显示短信列表
    } else if (tabType === 'snoop-mode') {
        renderSnoopModeList(); // 调用函数显示窥探列表
    }
}

// --- 新增：渲染“我的短信”列表的占位函数 ---
function renderMySmsList() {
    const container = document.getElementById('sms-content-container');
    // 现在先放个提示，之后再做真的列表
    container.innerHTML = `
        <div style="text-align: center; padding: 50px 20px; color: #888;">
            <i class="fas fa-envelope-open-text" style="font-size: 48px; margin-bottom: 15px;"></i>
            <p>你的短信收件箱是空的</p>
        </div>
    `;
}

// ▼▼▼ 使用这个【新版本】替换掉旧的 renderSnoopModeList 函数 ▼▼▼
function renderSnoopModeList() {
    const container = document.getElementById('sms-content-container');
    container.innerHTML = ''; // 先清空

    // 筛选出所有非群聊的、可以被窥探的联系人
    const snoopableContacts = state.contacts.filter(c => !c.isGroup);

    if (snoopableContacts.length === 0) {
        container.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><p>还没有可以窥探的目标哦~</p></div>`;
        return;
    }

    // 为每个联系人创建一个漂亮的卡片
    snoopableContacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-item'; // 复用现有的联系人列表样式
        item.style.cursor = 'pointer';
        item.dataset.contactId = contact.id; // 在元素上存好联系人ID

        item.innerHTML = `
            <div class="contact-avatar">
                <img src="${contact.avatar}" alt="${contact.name}头像">
            </div>
            <div class="contact-info">
                <div class="contact-name">${contact.name}</div>
                <div class="contact-last-message">点击进入TA的秘密空间...</div>
            </div>
        `;
        container.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这两个新函数粘贴到JS里 ▼▼▼

// --- 新增：打开“TA的手机”界面的函数 ---
function openSnoopedPhoneScreen(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    hideAllScreens(); // 隐藏所有其他主页面
    const screen = document.getElementById('snooped-phone-screen');
    screen.style.display = 'flex'; // 显示我们的“手机桌面”
    
    // 把顶部的标题改成对应角色的名字
    document.getElementById('snooped-contact-name').textContent = `${contact.name}的手机`;
    // 在页面上存好当前正在窥探的 contactId，方便后续使用
    screen.dataset.currentContactId = contactId;
}
// ▼▼▼ 把这个新函数粘贴到你的 JS 代码里 ▼▼▼
async function loadSnoopDataCache() {
    try {
        const allSnoopData = await kokoMemory.getAll('snoopData'); // 从新表读取所有数据
        allSnoopData.forEach(item => {
            snoopDataCache[item.contactId] = item; // 填充到内存缓存
        });
        console.log(`成功从 IndexedDB 加载了 ${allSnoopData.length} 条窥探数据缓存。`);
    } catch (error) {
        console.error("加载窥探数据缓存失败:", error);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 使用这个【精简版】替换旧的 handleSnoopAppClick 函数 ▼▼▼
function handleSnoopAppClick(event) {
    const appIcon = event.target.closest('.attachment-menu-item');
    if (appIcon) {
        const appType = appIcon.dataset.snoopApp;
        const contactId = document.getElementById('snooped-phone-screen').dataset.currentContactId;
        // 核心改动：不再调用 generateAndShowSnoopedData
        // 改为调用新的 showSnoopedAppContent 函数，让它检查缓存并显示
        showSnoopedAppContent(contactId, appType);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 把这两个【核心魔法函数】完整粘贴到你的JS里 ▼▼▼

// 全局变量，用于缓存窥探数据，避免频繁请求AI
let snoopDataCache = {}; 

// ▼▼▼ 把这两个【全新的函数】，粘贴到你的JS里 ▼▼▼
// ▼▼▼ 它们会一起替代掉旧的 generateAndShowSnoopedData ▼▼▼

/**
 * (已重构 + 恢复完整数量要求 V3) 核心函数：获取【全部】窥探数据
 * @param {string} contactId - 要窥探的联系人ID
 * @returns {Promise<boolean>} - 返回 true 表示成功, false 表示失败
 */
async function fetchSnoopDataFromAI(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) {
        console.error("fetchSnoopDataFromAI: 找不到联系人");
        return false; // 获取失败
    }

    try {
        // 1. 获取通用背景（这部分不变）
        const baseContext = await getSnoopBaseContext(contact);
        
        const now = new Date();
        const currentTimeString = now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
        const currentDateString = now.toLocaleDateString('zh-CN');

        // 2. ▼▼▼ 核心修复：使用你原始文件中的【完整JSON模板】，包含了所有数量要求 ▼▼▼
        const megaPrompt = `[SYSTEM] 你是角色 "${contact.name}" 的生活模拟器。
${baseContext}

[任务要求]
请生成一份包含以下所有项目的数字生活快照。所有内容都要自然、真实，并符合上述时间规则和独立生活模拟指令。请为每个列表生成足够多的、符合情理的条目（具体数量见下方各字段说明）。
**特别注意：所有涉及【时间 HH:MM】的字段，都必须严格早于当前时间 ${currentTimeString}。所有涉及【日期 MM-DD】的字段，都必须严格小于等于当前日期 ${currentDateString}。**

**请严格按照下面的JSON格式输出，不要有任何多余的解释或Markdown标记。**
\`\`\`json
{
  "browser_history": [ // (生成 8-10 条记录)
    { "time": "HH:MM", "query": "搜索内容", "reason": "为什么搜索", "found_content_summary": "可能找到了什么内容的简述" }
  ],
  "shopping_cart": [ // (生成 3-4 条记录, reason 可以是未来意图)
    { "item": "商品名称", "price": "价格", "reason": "（例如：打算生日时送给XX）" }
  ],
  "purchase_history": [ // (生成 3-4 条记录, thought 可以涉及未来用途)
    { "item": "商品名称", "price": "价格", "date": "MM-DD", "thought": "（例如：买了这个周末露营用）" }
  ],
  "call_log": [ // (生成 8 条记录)
    { "name": "通话对象", "type": "呼入/呼出/未接", "duration": "通话时长", "time": "HH:MM", "summary": "通话内容简述" }
  ],
  "memos": [ // (生成 8 条记录, content 和 thought 可以包含未来计划)
    { "icon": "fas fa-calendar-alt", "content": "明天下午3点和XX开会", "thought": "（准备好会议资料）" }
  ],
  "media_history": {
    "novels": [ // (生成 4-5 条记录, 记录过去的阅读)
        { "title": "小说标题", "review": "简短书评", "highlight": { "text": "收藏的句子", "comment": "收藏时的想法" } }
    ],
    "videos": [ // (生成 5-6 条记录, 记录过去的观看)
      { "title": "视频标题", "description": "视频描述", "interaction": "liked/commented/shared/bookmarked/viewed", "thought": "观看时的想法", "like_count": "获赞数(可选)" }
    ]
  },
  "timeline_events": [ // (生成 20-23 条【不同种类】的已发生事件记录, 按时间倒序)
    { "time": "HH:MM", "icon": "fas fa-lock-open", "description": "Ta 在刚刚解锁了手机屏幕" }
  ],
  "unlock_count": 25, // (随机生成一个10-50之间的数字)
  "sms_log": [ // (生成 5 条【不同联系人】的对话记录, 每组包含 4-5 条消息)
    {
      "contact": "联系人A (较长对话示例)",
      "messages": [
        {"sender": "联系人A", "content": "资料发你邮箱了，查收下", "time": "10:30"},
        {"sender": "${contact.name}", "content": "收到！太感谢了！救大命！", "time": "10:31"}
      ]
    }
  ],
  "music_activity": { // (生成 7-9 条记录)
    "recently_played": [
      { "song_title": "歌曲名", "artist": "歌手", "listen_time": "HH:MM", "duration_listened": "X分钟", "platform": "音乐平台", "thought": "（为什么听这首歌/听歌时的心情想法）" }
    ],
    "total_recent_duration": "最近总听歌时长 (例如: 2小时15分钟)"
  },
  "photo_gallery": {
    "recent_camera": [ // (生成 5-7 条记录)
      { "description": "照片描述", "time": "HH:MM", "location": "地点(可选)", "thought": "（为什么拍这张照片的想法）" }
    ],
    "screenshots": [ // (生成 5-7 条记录)
      { "app_name": "截图时所在App", "content_summary": "截图内容概要", "time": "HH:MM", "thought": "（为什么截这张图的想法）" }
    ],
    "private_album": [ // (生成 3-5 条记录, 内容可以非近期)
      { "description": "私密照片描述", "reason_private": "为什么设为私密" }
    ]
  },
  "financial_assets": {
    "bank_cards": [ // (生成 1-3 张银行卡, 根据人设决定数量和余额范围)
      { "card_name": "XX银行储蓄卡", "card_number_last4": "尾号XXXX", "balance": "¥X,XXX.XX" }
    ],
    "investments": [ // (生成 0-5 项投资, 【极其重要】: 数量和类型必须严格符合角色人设！必须包含所有收益字段！)
      {
        "type": "基金/股票/信托",
        "name": "具体产品名称",
        "current_value": "当前市值 ¥X,XXX.XX", 
        "holding_percentage": "占比 XX.XX%", 
        "daily_profit_loss": "+/-¥XX.XX / +/-X.XX%", 
        "holding_profit_loss": "+/-¥XXX.XX / +/-X.XX%", 
        "cumulative_profit_loss": "+/-¥XXXX.XX" 
      }
    ],
    "recent_transactions": [ // (生成 12-15 条记录, 时间必须早于 ${currentTimeString})
      {"time": "HH:MM", "description": "交易描述", "amount": "-/+XXX.XX", "type": "支出/收入"}
    ]
  },
  "wechat_log": [ // (生成 2-3 个私聊 + 1-2 个群聊记录, 每组包含 3-6 条消息)
    {
      "contact": "联系人C (私聊示例)",
      "is_group_chat": false,
      "messages": [ {"sender": "联系人C", "content": "...", "time": "HH:MM"} ]
    },
    {
      "contact": "工作群 (群聊示例)",
      "is_group_chat": true,
      "messages": [ {"sender": "成员1", "content": "...", "time": "HH:MM"}, {"sender": "${contact.name}", "content": "...", "time": "HH:MM"} ]
    }
  ]
}
\`\`\`
`;
        // ▲▲▲ 核心修复：完整的JSON格式定义结束 ▲▲▲

        // 3. 调用AI
        const rawResponse = await generateAiResponse(contact, [], megaPrompt, false, 'snoop');
        
        // 4. 清洗AI的回复（防止它在前后加“好的”）
        const jsonMatch = rawResponse.match(/```json\s*([\s\S]*?)\s*```/);
        if (!jsonMatch || !jsonMatch[1]) {
             throw new Error("AI未能返回有效的JSON代码块。");
        }
        const cleanedResponse = jsonMatch[1];
        
        const snoopedData = JSON.parse(cleanedResponse);

        // --- 5. 数据保存逻辑 (保持不变) ---
        const dataToStore = {
            contactId: contactId,
            timestamp: Date.now(),
            data: snoopedData
        };
        await kokoMemory.put('snoopData', dataToStore);
        snoopDataCache[contactId] = dataToStore;
        console.log(`角色 ${contact.name} 的【全部】窥探数据已获取并存入数据库！`);
        // --- 保存逻辑结束 ---

        return true; // 获取成功

    } catch (error) {
        console.error(`为角色 ${contact.name} 生成【全部】窥探数据失败:`, error);
        // 关键：在抛出错误时，附带上AI返回的原始文本，方便你调试
        throw new Error(`AI未能成功生成【全部】窥探数据，可能是格式错误或API问题。\n原始错误: ${error.message}\n\nAI原始回复(供调试):\n${error.rawResponse || '未能捕获原始回复'}`);
    }
}
/**
 * (正确版本) 按钮点击处理器：处理“单独刷新”按钮的点击事件
 */
async function handlePartialSnoopRefresh() {
    const screen = document.getElementById('snooped-app-content-screen');
    const contactId = document.getElementById('snooped-phone-screen').dataset.currentContactId;
    const appType = screen.dataset.currentAppType;
    
    if (!contactId || !appType) {
        return alert("无法确定要刷新的内容，请返回重试。");
    }

    const refreshBtn = document.getElementById('refresh-snoop-app-btn');
    const bodyEl = document.getElementById('snooped-app-content-body');
    const originalBtnHTML = refreshBtn.innerHTML;
    
    // 1. 显示加载状态
    refreshBtn.disabled = true;
    refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    bodyEl.style.opacity = '0.5'; // 界面变暗，表示加载中

    try {
        // 2. 【已修正】我们不再检查旧缓存是否存在，直接调用“大脑”函数
        const partialData = await fetchPartialSnoopData(contactId, appType);

        // 3. 调用“合并”函数 (这个函数是智能的，没有旧缓存它会自动创建)
        await mergePartialSnoopData(contactId, appType, partialData);

        // 4. 成功后，重新渲染当前页面
        displaySnoopContent(snoopDataCache[contactId].data, appType);

    } catch (error) {
        console.error(`单独刷新 ${appType} 失败:`, error);
        alert(`刷新失败：${error.message}`);
    } finally {
        // 5. 恢复UI
        refreshBtn.disabled = false;
        refreshBtn.innerHTML = originalBtnHTML;
        bodyEl.style.opacity = '1';
    }
}
/**
 * (全新) 核心函数：只获取【单个应用】的数据
 * @param {string} contactId
 * @param {string} appType
 */
async function fetchPartialSnoopData(contactId, appType) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) throw new Error("找不到联系人");

    // 1. 调用辅助函数，获取所有通用背景材料
    const baseContext = await getSnoopBaseContext(contact);
    
    let taskPrompt = '';
    let jsonFormatInstructions = '';

    // 2. 根据 appType 构建“专属任务”
    switch (appType) {
        case 'sms':
            taskPrompt = `[任务]：请为角色生成 5 条【不同联系人】的【短信(SMS)】对话记录 (每组 4-5 条消息)。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "sms_log" 键，直接返回数组：
[
  { "contact": "...", "messages": [{"sender": "...", "content": "...", "time": "HH:MM"}, ...] },
  ...
]`;
            break;
        
        case 'call_log':
            taskPrompt = `[任务]：请为角色生成 8 条【通话记录(Call Logs)】。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "call_log" 键，直接返回数组：
[
  { "name": "...", "type": "...", "duration": "...", "time": "HH:MM", "summary": "..." },
  ...
]`;
            break;

        case 'browser':
            taskPrompt = `[任务]：请为角色生成 8-10 条【浏览器搜索记录(Browser History)】。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "browser_history" 键，直接返回数组：
[
  { "time": "HH:MM", "query": "...", "reason": "...", "found_content_summary": "..." },
  ...
]`;
            break;

        case 'shopping':
            taskPrompt = `[任务]：请为角色生成 3-4 条【购物车(Shopping Cart)】记录和 3-4 条【购买历史(Purchase History)】记录。`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，必须包含 "shopping_cart" 和 "purchase_history" 两个键：
{
  "shopping_cart": [ { "item": "...", "price": "...", "reason": "..." }, ... ],
  "purchase_history": [ { "item": "...", "price": "...", "date": "MM-DD", "thought": "..." }, ... ]
}`;
            break;

        case 'memos':
            taskPrompt = `[任务]：请为角色生成 8 条【备忘录(Memos)】记录 (可以包含未来计划)。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "memos" 键，直接返回数组：
[
  { "icon": "fas fa-...", "content": "...", "thought": "..." },
  ...
]`;
            break;

        case 'novels':
            taskPrompt = `[任务]：请为角色生成 4-5 条【小说阅读(Novels)】记录。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "novels" 键，直接返回数组：
[
  { "title": "...", "review": "...", "highlight": { "text": "...", "comment": "..." } },
  ...
]`;
            break;

        case 'videos':
            taskPrompt = `[任务]：请为角色生成 5-6 条【视频观看(Videos)】记录。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "videos" 键，直接返回数组：
[
  { "title": "...", "description": "...", "interaction": "...", "thought": "...", "like_count": "..." },
  ...
]`;
            break;

        case 'couple_app':
            taskPrompt = `[任务]：请为角色生成 20-23 条【手机时间线(Timeline Events)】记录 (按时间倒序)，并生成一个【解锁次数】。`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，必须包含 "timeline_events" 和 "unlock_count" 两个键：
{
  "timeline_events": [ { "time": "HH:MM", "icon": "fas fa-...", "description": "..." }, ... ],
  "unlock_count": ... 
}`;
            break;

        case 'music':
            taskPrompt = `[任务]：请为角色生成 7-9 条【最近听歌(Music Activity)】记录，并生成一个【总时长】。`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，不要包含 "music_activity" 键，直接返回对象：
{
  "recently_played": [ { "song_title": "...", "artist": "...", "listen_time": "HH:MM", "duration_listened": "...", "platform": "...", "thought": "..." }, ... ],
  "total_recent_duration": "..."
}`;
            break;

        case 'photos':
            taskPrompt = `[任务]：请为角色生成 5-7 条【最近拍摄】、5-7 条【屏幕截图】和 3-5 条【私密相册】记录。`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，不要包含 "photo_gallery" 键，直接返回对象：
{
  "recent_camera": [ { "description": "...", "time": "HH:MM", "location": "...", "thought": "..." }, ... ],
  "screenshots": [ { "app_name": "...", "content_summary": "...", "time": "HH:MM", "thought": "..." }, ... ],
  "private_album": [ { "description": "...", "reason_private": "..." }, ... ]
}`;
            break;
            
        case 'assets':
            taskPrompt = `[任务]：请为角色生成 1-3 张【银行卡(Bank Cards)】、0-5 项【投资组合(Investments)】和 12-15 条【最近账单流水(Recent Transactions)】。
【极其重要】：投资组合的数量和类型必须严格符合角色人设！`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，不要包含 "financial_assets" 键，直接返回对象：
{
  "bank_cards": [ { "card_name": "...", "card_number_last4": "...", "balance": "..." }, ... ],
  "investments": [ { "type": "...", "name": "...", "current_value": "...", "holding_percentage": "...", "daily_profit_loss": "...", "holding_profit_loss": "...", "cumulative_profit_loss": "..." }, ... ],
  "recent_transactions": [ {"time": "HH:MM", "description": "...", "amount": "-/+...", "type": "..."}, ... ]
}`;
            break;
            
        case 'wechat':
            taskPrompt = `[任务]：请为角色生成 2-3 个【私聊】和 1-2 个【群聊】的【微信(WeChat)】对话记录 (每组 3-6 条消息)。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "wechat_log" 键，直接返回数组：
[
  { "contact": "...", "is_group_chat": false, "messages": [ ... ] },
  { "contact": "...", "is_group_chat": true, "messages": [ {"sender": "...", "content": "...", "time": "HH:MM"}, ... ] },
  ...
]`;
            break;

        default:
            throw new Error(`未知的单独刷新类型: ${appType}`);
    }

    // 3. 组装最终的 Prompt
    const finalPrompt = `[SYSTEM] 你是角色 "${contact.name}" 的生活模拟器。
${baseContext}

${taskPrompt}

[输出格式]
请严格按照下面的JSON格式输出，不要有任何多余的解释或Markdown标记。
\`\`\`json
${jsonFormatInstructions}
\`\`\`
`;

    // 4. 调用AI
    const rawResponse = await generateAiResponse(contact, [], finalPrompt, false, 'snoop');
    const cleanedResponse = rawResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
    
    // 5. 返回解析后的【小块】JSON数据
    return JSON.parse(cleanedResponse);
}
/**
 * (全新) 辅助函数：获取生成窥探剧本所需的“通用背景材料”
 * (这是从旧的 fetchSnoopDataFromAI 函数中重构并提取出来的)
 */
async function getSnoopBaseContext(contact) {
    const now = new Date();
    const currentTimeString = now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
    const currentDateString = now.toLocaleDateString('zh-CN');

    // 1. 获取旧数据 (用于连续性)
    let oldDataPromptBlock = '';
    const oldSnoopData = snoopDataCache[contact.id] ? snoopDataCache[contact.id].data : null;
    if (oldSnoopData) {
        try {
            // 节选关键数据用于保持连续性
            const continuityData = {
                financial_assets: oldSnoopData.financial_assets ? {
                    bank_cards: oldSnoopData.financial_assets.bank_cards,
                    investments: oldSnoopData.financial_assets.investments
                } : {},
                photo_gallery: oldSnoopData.photo_gallery ? {
                    private_album: oldSnoopData.photo_gallery.private_album
                } : {},
                memos: oldSnoopData.memos ? oldSnoopData.memos.slice(0, 3) : []
            };
            const oldDataJson = JSON.stringify(continuityData, null, 2);
            oldDataPromptBlock = `
[!!! 核心参考：上一次的生活快照（节选）!!!]
这是你（${contact.name}）上一次的【关键数据快照】。
\`\`\`json
${oldDataJson}
\`\`\`
`;
        } catch (e) { /* 忽略序列化失败 */ }
    }

    // 2. 获取世界书
    let worldBookContextString = '(未关联任何用于窥探的世界书)';
    const bookIds = contact.snoopRelevantWorldBookIds || contact.worldBooks || [];
    if (bookIds.length > 0) {
        const booksContent = (await Promise.all(
            bookIds.map(id => kokoMemory.get('worldBooks', id))
        )).filter(Boolean).map(book => 
            `--- (世界书: ${book.name}) ---\n${book.content}`
        ).join('\n\n');
        
        if (booksContent) {
            worldBookContextString = `[相关世界书背景知识 (重要参考)]\n${booksContent}\n---`;
        }
    }

    // 3. 获取聊天记录
    const recentHistory = (contact.history || [])
        .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
        .slice(-50)
        .map(msg => `${msg.sender === 'user' ? state.myProfile.name : contact.name}: ${msg.content}`)
        .join('\n');
    
    // 4. 组装并返回
    return `
**[当前时间]**: ${currentDateString} ${currentTimeString}

**[你的角色]**: "${contact.name}"
- **TA的人设**: ${contact.persona}
- **TA眼中的你**: ${contact.userPersona || '（未设置特别关系）'}

**[背景资料]**
${worldBookContextString}
${oldDataPromptBlock}
- **最近的聊天记录摘要**:
---
${recentHistory || "(最近没有聊天记录)"}
---

**[!!! 核心演变指令 !!!]**
你必须在【上一次的快照】（如果提供了）的基础上进行**演变**，而不是完全重写。
- **对于银行卡、投资组合、私密相册、备忘录等**: 必须保持连续性。
- **对于通话、短信、浏览记录等**: 这些应该是全新的，代表最近24小时内发生的【新事件】。

**[!!! 核心时间规则区分 !!!]**
1.  **【已发生行为记录 - 必须是过去时】**: Call Logs, SMS Logs, Browser History, Video History, Timeline Events, Photo Gallery (拍摄/截图时间), Financial Assets (交易时间), Music Activity (播放时间), WeChat Log 的所有时间戳 (HH:MM / MM-DD) 都【必须】严格早于当前时间 (${currentTimeString} / ${currentDateString})。
2.  **【计划/意图内容 - 可以包含未来】**: Memos (备忘录), Shopping Cart (购物车里的购买原因), Purchase History (购买后的想法), Photo Gallery (私密相册原因), Investments (投资预期) 这些反映【想法或计划】的内容，则【可以】包含对未来的规划。

**[核心指令：独立生活模拟]**
1.  所有生成的内容都必须**首先**符合角色 "${contact.name}" 的核心人设以及【世界书背景】。
2.  你必须为 "${contact.name}" 创造一些**与用户完全无关**的个人生活片段。
3.  **只有一小部分**（约30%）的内容可以与用户 "${state.myProfile.name}" 或聊天记录有**间接、微妙**的关联。
`;
}
/**
 * (全新) 核心函数：将AI返回的“局部”数据，智能合并到“全局”缓存中
 * @param {string} contactId - 联系人ID
 * @param {string} appType - 刚刚刷新的应用类型 (e.g., 'sms', 'photos')
 * @param {object | Array} partialData - AI返回的该应用的数据 (e.g., sms_log 数组, 或 photo_gallery 对象)
 */
async function mergePartialSnoopData(contactId, appType, partialData) {
    if (!snoopDataCache[contactId] || !snoopDataCache[contactId].data) {
        // 健壮性检查：如果连基础缓存都没有，说明用户从未进行过“完全刷新”
        // 此时我们不能合并，而是直接创建一个新的缓存
        snoopDataCache[contactId] = {
            contactId: contactId,
            timestamp: Date.now(),
            data: {} // 创建一个空的 data 对象
        };
        console.warn("没有找到基础缓存，已创建一个新缓存。");
    }

    const cachedData = snoopDataCache[contactId];
    
    // 这是我们的“钥匙”映射表
    const topLevelKeyMap = {
        'sms': 'sms_log',
        'call_log': 'call_log',
        'browser': 'browser_history',
        'shopping': ['shopping_cart', 'purchase_history'], // 特殊：一个应用对应多个键
        'memos': 'memos',
        'videos': 'media_history', // 特殊：媒体
        'novels': 'media_history', // 特殊：媒体
        'couple_app': ['timeline_events', 'unlock_count'], // 特殊：一个应用对应多个键
        'music': 'music_activity',
        'photos': 'photo_gallery',
        'assets': 'financial_assets',
        'wechat': 'wechat_log'
    };

    const keyOrKeys = topLevelKeyMap[appType];

    if (Array.isArray(keyOrKeys)) {
        // --- 1. 处理复杂类型 (如 'shopping', 'couple_app') ---
        // AI 返回的是一个对象: { "shopping_cart": [...], "purchase_history": [...] }
        for (const key of keyOrKeys) {
            if (partialData[key] !== undefined) {
                cachedData.data[key] = partialData[key];
                console.log(`已合并 ${key}`);
            }
        }
    } else if (keyOrKeys === 'media_history') {
        // --- 2. 处理 'media_history' (视频/小说) ---
        if (!cachedData.data.media_history) {
            cachedData.data.media_history = {}; // 如果媒体库不存在，先创建
        }
        if (appType === 'novels') {
            // AI 返回的是: [...] (小说数组)
            cachedData.data.media_history.novels = partialData;
            console.log("已合并 media_history.novels");
        } else if (appType === 'videos') {
            // AI 返回的是: [...] (视频数组)
            cachedData.data.media_history.videos = partialData;
            console.log("已合并 media_history.videos");
        }
    } else if (keyOrKeys) {
        // --- 3. 处理简单类型 (如 'sms', 'photos') ---
        // AI 返回的是: [...] 或 {...}
        cachedData.data[keyOrKeys] = partialData;
        console.log(`已合并 ${keyOrKeys}`);
    } else {
        console.error(`合并失败：未知的 appType "${appType}"`);
        return;
    }

    // 更新时间戳并保存回数据库
    cachedData.timestamp = Date.now();
    await kokoMemory.put('snoopData', cachedData);
    snoopDataCache[contactId] = cachedData;
    console.log("数据合并完成并已保存到数据库。");
}
/**
 * 新函数2：根据缓存状态显示窥探内容或提示刷新
 * @param {string} contactId - 要窥探的联系人ID
 * @param {string} appType - 要查看的应用类型
 */
function showSnoopedAppContent(contactId, appType) {
    hideAllScreens(); 
    const screen = document.getElementById('snooped-app-content-screen');
    screen.style.display = 'flex'; 

    // ▼▼▼ 核心新增：把当前的应用类型存到 DOM 元素上 ▼▼▼
    screen.dataset.currentAppType = appType;
    // ▲▲▲ 新增结束 ▲▲▲

    if (snoopDataCache[contactId]) {
        console.log("缓存命中！准备显示内容。");
        displaySnoopContent(snoopDataCache[contactId].data, appType);
    } else {
        console.warn("缓存未命中！显示刷新提示。");
        const bodyEl = document.getElementById('snooped-app-content-body');
        bodyEl.innerHTML = `
            <div style="text-align: center; padding: 50px 20px; color: #888;">
                <i class="fas fa-sync-alt" style="font-size: 48px; margin-bottom: 15px;"></i>
                <p>请先点击右上角的“刷新”按钮</p>
                <p>同步TA的最新生活动态~</p>
            </div>
        `;
         const titleEl = document.getElementById('snooped-app-title');
         titleEl.textContent = '暂无数据';
    }
}


// ▼▼▼ 使用这个【包含照片想法 + 支付宝流水渲染的最终版 V3】替换旧的 displaySnoopContent 函数 ▼▼▼
/**
 * 魔法函数2：把AI返回的JSON数据“翻译”成漂亮的HTML（V3 照片想法+流水版）
 * @param {object} data - 从AI那里拿到的完整JSON数据
 * @param {string} appType - 用户想看的应用类型
 */
function displaySnoopContent(data, appType) {
    const titleEl = document.getElementById('snooped-app-title');
    const bodyEl = document.getElementById('snooped-app-content-body');
    let html = '';
    const contactId = document.getElementById('snooped-phone-screen').dataset.currentContactId;
    const contact = state.contacts.find(c => c.id === contactId); // 获取当前窥探的角色信息

    // 定义应用标题映射 (加入新应用)
    const appTitles = {
        sms: '短信', call_log: '通话记录', browser: '浏览器',
        shopping: '🍑宝', memos: '备忘录', videos: '抖Yin',
        novels: '小说', couple_app: '甜蜜空间',
        music: '音乐', photos: '相册', assets: '资产', wechat: '微信' // 新增
    };
    titleEl.textContent = appTitles[appType] || '查看内容'; // 更新标题

    // 更新最后同步时间戳 (逻辑不变)
    const timestampEl = document.getElementById('snoop-last-synced');
    if (snoopDataCache[contactId]) {
        const lastSyncTime = snoopDataCache[contactId].timestamp;
        const minutesAgo = Math.round((Date.now() - lastSyncTime) / 60000);
        timestampEl.textContent = minutesAgo < 1 ? '刚刚同步' : `数据同步于 ${minutesAgo} 分钟前`;
    }

    // 先清空内容区和可能的背景图
    bodyEl.innerHTML = '';
    bodyEl.style.backgroundImage = 'none'; // 清除可能残留的背景

    // 为照片和资产添加一点基本样式，让排版好看些
    const itemStyle = "background: white; border-radius: 8px; padding: 12px; margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.06);";
    const thoughtStyle = "font-size: 13px; color: #666; background: #f5f5f5; padding: 6px 10px; border-radius: 6px; margin-top: 8px; border-left: 3px solid #ccc;";

    try {
        switch (appType) {
            // --- 短信 (复用之前的渲染逻辑) ---
            case 'sms':
                if (!data.sms_log || data.sms_log.length === 0) {
                     html = '<p style="text-align:center; color:#999; padding: 20px;">还没有短信记录哦。</p>';
                } else {
                     html = data.sms_log.map(conversation => {
                        let conversationHTML = `<div class="snoop-sms-chat-container">`;
                        conversationHTML += `<div class="snoop-sms-header"><span class="contact-name">${conversation.contact}</span></div>`;
                        conversationHTML += `<div class="snoop-sms-area">`;
                        let lastTime = null;
                        (conversation.messages || []).forEach(msg => {
                            if (msg.time !== lastTime) {
                                conversationHTML += `<div class="snoop-sms-timestamp"><span>${msg.time}</span></div>`;
                                lastTime = msg.time;
                            }
                            const isSent = msg.sender === contact.name;
                            const rowClass = isSent ? 'sent' : 'received';
                            const bubbleClass = isSent ? 'sent' : 'received';
                            conversationHTML += `<div class="snoop-sms-row ${rowClass}"><div class="snoop-sms-bubble ${bubbleClass}">${msg.content}</div></div>`;
                        });
                        conversationHTML += `</div></div>`;
                        return conversationHTML;
                    }).join('');
                }
                break;

            // --- 通话记录 (复用之前的渲染逻辑) ---
            case 'call_log':
                 if (!data.call_log || data.call_log.length === 0) {
                    html = '<p style="text-align:center; color:#999; padding: 20px;">还没有通话记录哦。</p>';
                } else {
                    html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                    html += data.call_log.map(call => {
                        let iconClass = 'fa-phone-alt', iconColor = '#607d8b', typeText = '未知';
                        if (call.type.includes('呼入')) { iconClass = 'fa-phone-volume'; iconColor = '#81c784'; typeText = '呼入'; }
                        else if (call.type.includes('呼出')) { iconClass = 'fa-phone'; iconColor = '#ffb74d'; typeText = '呼出'; }
                        else if (call.type.includes('未接')) { iconClass = 'fa-phone-slash'; iconColor = '#e57373'; typeText = '未接'; }
                        return `
                        <div style="${itemStyle} display: flex; align-items: flex-start; gap: 15px;">
                            <div style="width: 45px; height: 45px; border-radius: 50%; background-color: ${iconColor}20; color: ${iconColor}; display: flex; align-items: center; justify-content: center; font-size: 20px; flex-shrink: 0;"><i class="fas ${iconClass}"></i></div>
                            <div style="flex-grow: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: baseline;"><span style="font-weight: 600; font-size: 16px;">${call.name}</span><span style="font-size: 12px; color: #999;">${call.time}</span></div>
                                <div style="font-size: 13px; color: #777; margin-top: 4px;">${typeText} ${call.duration ? ` - 通话 ${call.duration}` : ''}</div>
                                <div style="margin-top: 8px; font-size: 14px; line-height: 1.5; background: #f9f9f9; padding: 8px 10px; border-radius: 6px;">${call.summary}</div>
                            </div>
                        </div>`;
                    }).join('');
                    html += '</div>';
                }
                break;

            // --- 浏览器 (复用之前的渲染逻辑) ---
            case 'browser':
                 if (!data.browser_history || data.browser_history.length === 0) {
                    html = '<p style="text-align:center; color:#999; padding: 20px;">还没有浏览记录哦。</p>';
                 } else {
                    html = '<ul class="trending-list" style="background:none; padding: 0;">';
                    html += data.browser_history.map(item => `
                        <li class="trending-item" style="background:white; margin-bottom:8px; border-radius:10px; padding: 15px; flex-direction: column; align-items: flex-start;">
                            <div style="display: flex; justify-content: space-between; width: 100%; align-items: center; margin-bottom: 8px;">
                                <div class="trending-title" style="font-size: 15px; flex-grow: 1; margin-right: 10px; word-wrap: break-word;"><i class="fas fa-search" style="color: #64b5f6; margin-right: 6px;"></i>${item.query}</div>
                                <span style="font-size: 12px; color: #aaa; flex-shrink: 0;">${item.time}</span>
                            </div>
                            <div style="font-size: 13px; color: #666; background: #e3f2fd; padding: 6px 10px; border-radius: 6px; width: 100%; margin-bottom: 5px; word-wrap: break-word;"><strong>原因:</strong> ${item.reason || '无'}</div>
                            <div style="font-size: 13px; color: #555; background: #f1f8e9; padding: 6px 10px; border-radius: 6px; width: 100%; word-wrap: break-word;"><strong>结果:</strong> ${item.found_content_summary || '无'}</div>
                        </li>
                    `).join('');
                    html += '</ul>';
                 }
                 break;

            // --- 购物 (复用之前的渲染逻辑) ---
             case 'shopping':
                html = '<div style="display: flex; flex-direction: column; gap: 15px;">';
                html += '<h3>🛒 购物车</h3>';
                if (!data.shopping_cart || data.shopping_cart.length === 0) {
                    html += '<p style="color:#999; text-align:center;">购物车是空的</p>';
                } else {
                    html += data.shopping_cart.map(item => `<div style="${itemStyle}"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;"><span style="font-weight: 600; font-size: 15px; word-wrap: break-word;">${item.item}</span><span style="color:#ff7043; font-weight:bold; font-size: 16px; flex-shrink: 0; margin-left: 10px;">¥${item.price}</span></div>${item.reason ? `<div style="${thoughtStyle} background: #fef7e0; border-left-color: #ffcc80;">🛒 想买：${item.reason}</div>` : ''}</div>`).join('');
                }
                html += '<h3 style="margin-top:10px;">🧾 最近购买</h3>';
                 if (!data.purchase_history || data.purchase_history.length === 0) {
                    html += '<p style="color:#999; text-align:center;">最近没有购买记录</p>';
                } else {
                    html += data.purchase_history.map(item => `<div style="${itemStyle}"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;"><span style="font-weight: 600; font-size: 15px; word-wrap: break-word;">${item.item} <span style="font-size:12px; color:#999; font-weight: normal;">(${item.date})</span></span><span style="font-weight:bold; font-size: 16px; flex-shrink: 0; margin-left: 10px;">¥${item.price}</span></div>${item.thought ? `<div style="${thoughtStyle} background: #e8f5e9; border-left-color: #a5d6a7;">💡 当时想：${item.thought}</div>` : ''}</div>`).join('');
                }
                html += '</div>';
                break;

            // --- 备忘录 (复用之前的渲染逻辑) ---
            case 'memos':
                if (!data.memos || data.memos.length === 0) {
                    html = '<p style="text-align:center; color:#999; padding: 20px;">备忘录是空的哦。</p>';
                } else {
                    html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
                    html += data.memos.map(memo => `
                        <div style="${itemStyle} border-left: 4px solid #ffc107;">
                            <div style="display: flex; align-items: flex-start; width: 100%; margin-bottom: 8px;">
                                <i class="${memo.icon && memo.icon.startsWith('fas fa-') ? memo.icon : 'fas fa-pencil-alt'}" style="color: #a08d53; margin-right: 12px; font-size: 1.2em; margin-top: 2px; width: 20px; text-align: center;"></i>
                                <div style="font-size: 15px; line-height: 1.6; color: #333; flex-grow: 1; word-wrap: break-word;">${memo.content.replace(/\n/g, '<br>')}</div>
                            </div>
                            ${memo.thought ? `<div style="${thoughtStyle} background: #fffde7;">💡 当时想：${memo.thought}</div>` : ''}
                        </div>`).join('');
                    html += '</div>';
                }
                break;

            // --- 视频/小说 (复用之前的渲染逻辑) ---
            case 'videos':
            case 'novels':
                 const mediaData = data.media_history || {};
                 if (appType === 'novels') {
                     const items = mediaData.novels || [];
                     if (items.length === 0) { html = '<p style="text-align:center; color:#999; padding: 20px;">最近没有看小说哦。</p>'; }
                     else { html = items.map(novel => `<div class="world-book-item" style="${itemStyle} margin-bottom: 15px;"><div class="book-header" style="margin-bottom: 10px;"><div class="book-name" style="font-size: 16px; word-wrap: break-word;"><i class="fas fa-book-reader" style="margin-right: 8px; color: #ba68c8;"></i>${novel.title}</div></div>${novel.review ? `<div style="font-size: 14px; color: #555; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #e0e0e0; word-wrap: break-word;">💬 书评：${novel.review}</div>` : ''}${novel.highlight && novel.highlight.text ? `<div style="background: #f3e5f5; padding: 10px 12px; border-radius: 8px; border-left: 3px solid #ce93d8;"><p style="font-size: 14px; color: #8e44ad; margin: 0 0 6px 0; line-height: 1.5; word-wrap: break-word;">📌 收藏：“${novel.highlight.text}”</p>${novel.highlight.comment ? `<p style="font-size: 13px; color: #ab47bc; margin: 0; word-wrap: break-word;">✍️ 想法：${novel.highlight.comment}</p>` : ''}</div>` : ''}</div>`).join(''); }
                 } else if (appType === 'videos') {
                     const items = mediaData.videos || [];
                      if (items.length === 0) { html = '<p style="text-align:center; color:#999; padding: 20px;">最近没有刷视频哦。</p>'; }
                      else { html = '<div style="display: flex; flex-direction: column; gap: 15px;">'; html += items.map(item => { let icon = 'fa-eye', color = '#90a4ae', text = '浏览'; switch (item.interaction) { case 'liked': icon = 'fa-heart'; color = '#ef5350'; text = '点赞了'; break; case 'commented': icon = 'fa-comment-dots'; color = '#42a5f5'; text = '评论了'; break; case 'shared': icon = 'fa-share'; color = '#66bb6a'; text = '分享了'; break; case 'bookmarked': icon = 'fa-bookmark'; color = '#ffb74d'; text = '收藏了'; break; } return `<div style="${itemStyle} display: flex; gap: 10px;"><div style="width: 70px; height: 90px; background-color: #f0f2f5; border-radius: 6px; display: flex; align-items: center; justify-content: center; color: #bdbdbd; font-size: 24px; flex-shrink: 0;"><i class="fas fa-film"></i></div><div style="flex-grow: 1; display: flex; flex-direction: column;"><div><div style="font-weight: 600; font-size: 15px; margin-bottom: 4px; word-wrap: break-word;">${item.title}</div><div style="font-size: 13px; color: #666; margin-bottom: 8px; word-wrap: break-word;">${item.description || '暂无描述'}</div></div><div style="margin-top: auto; padding-top: 8px; border-top: 1px solid #f5f5f5; display: flex; flex-direction: column; gap: 5px;"><div style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: ${color};"><i class="fas ${icon}"></i><span>${text} ${item.like_count ? ` · ${item.like_count} 赞` : ''}</span></div>${item.thought ? `<div style="${thoughtStyle} display: flex; align-items: flex-start; gap: 4px;"><i class="far fa-comment-alt" style="margin-top: 2px;"></i><span style="word-wrap: break-word; flex: 1;">想法: ${item.thought}</span></div>` : ''}</div></div></div>`; }).join(''); html += '</div>'; }
                 }
                 break;

            // --- 甜蜜空间/时间线 (复用之前的渲染逻辑) ---
            case 'couple_app':
                bodyEl.style.padding = '15px';

                html = '<div id="sweet-space-timeline" style="display: flex; flex-direction: column;">';

                if (!data.timeline_events || data.timeline_events.length === 0) {
                    html += '<p style="text-align:center; color:#888; background: rgba(255,255,255,0.7); padding: 20px; border-radius: 10px;">今天还没有活动记录哦~</p>';
                } else {
                    let lastTime = null;
                    const sortedEvents = [...data.timeline_events].reverse();

                    sortedEvents.forEach(event => {
                        if (event.time !== lastTime) {
                            html += `<div style="text-align: center; color: #aaa; font-size: 12px; margin: 15px 0 10px 0; background-color: rgba(230, 230, 230, 0.6); padding: 3px 8px; border-radius: 10px; display: inline-block; position: relative; left: 50%; transform: translateX(-50%);">${event.time}</div>`;
                            lastTime = event.time;
                        }

                        let iconColor = '#ff8aae';
                        if (event.icon.includes('lock')) iconColor = '#90a4ae';
                        if (event.icon.includes('signal')) iconColor = '#4dd0e1';
                        if (event.icon.includes('shopping')) iconColor = '#ff8a65';
                        if (event.icon.includes('youtube')) iconColor = '#e57373';
                        if (event.icon.includes('map')) iconColor = '#81c784';
                        if (event.icon.includes('comment')) iconColor = '#4caf50';
                        if (event.icon.includes('book')) iconColor = '#ba68c8';
                        if (event.icon.includes('phone')) iconColor = '#64b5f6';
                        if (event.icon.includes('camera')) iconColor = '#fff176';
                        if (event.icon.includes('music')) iconColor = '#f06292';
                        if (event.icon.includes('gamepad')) iconColor = '#7986cb';
                        if (event.icon.includes('wallet')) iconColor = '#ffd54f';
                        if (event.icon.includes('calendar')) iconColor = '#a1887f';
                        if (event.icon.includes('cloud-sun')) iconColor = '#4fc3f7';

                        html += `
                            <div class="message-wrapper" style="align-self: center; margin-bottom: 8px; max-width: 85%;">
                                <div class="message-body" style="align-items: center;">
                                    <div class="message" style="background-color: #ffffff; border-radius: 18px; display: flex; align-items: center; padding: 8px 15px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                                        <i class="${event.icon || 'fas fa-info-circle'}" style="color: ${iconColor}; margin-right: 8px; font-size: 1.1em;"></i>
                                        <span style="font-size: 14px; color: #555; word-wrap: break-word;">${event.description}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    });

                    if (data.unlock_count) {
                        html += `
                        <div style="background-color: rgba(255, 235, 238, 0.8); border: 1px solid #ffcdd2; color: #c2185b; padding: 10px 15px; border-radius: 12px; text-align: center; font-size: 13px; margin-top: 20px; font-weight: 500;">
                            <i class="fas fa-calculator"></i> Ta 今日拿手机次数${data.unlock_count > 20 ? '超出 20 次' : `为 ${data.unlock_count} 次`}~
                        </div>`;
                    }
                }
                html += '</div>';
                break;

// --- 音乐 (V5 - 模仿截图样式 + 右侧信息) ---
            case 'music':
                const musicData = data.music_activity || {};
                html = '<div class="snoop-music-list">';
                if (musicData.recently_played && musicData.recently_played.length > 0) {
html += musicData.recently_played.map((song, index) => {
                        let metaRightHTML = '';
                        if (song.duration_listened) {
                            metaRightHTML += `<span class="snoop-music-duration">${song.duration_listened}</span>`;
                        }
                        if (song.platform) {
                            metaRightHTML += `<span class="snoop-music-platform ${song.duration_listened ? 'new-line' : ''}">@ ${song.platform}</span>`;
                        }

                        // --- 新增：准备“想法”的 HTML ---
                        let thoughtHTML = '';
                        if (song.thought) {
                            // 使用新的 CSS 类 snoop-music-thought
                            thoughtHTML = `<div class="snoop-music-thought">${song.thought}</div>`;
                        }
                        // --- 新增结束 ---

                        return `
                        <div class="snoop-music-item">
                            <div class="snoop-music-index">${index + 1}</div>
                            <div class="snoop-music-cover">
                                <i class="fas fa-music"></i>
                            </div>
                            <div class="snoop-music-info">
                                <div class="snoop-music-title">${song.song_title || '未知歌曲'}</div>
                                <div class="snoop-music-artist">${song.artist || '未知艺术家'}</div>
                                
                                ${thoughtHTML}
                                
                            </div>
                            <div class="snoop-music-meta-right">
                                ${metaRightHTML}
                            </div>
                        </div>
                    `}).join('');
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 20px;">最近没有听歌记录哦。</p>';
                }
                html += '</div>';

                // 总时长显示 (不变)
                if (musicData.total_recent_duration) {
                     html += `<p style="text-align: center; margin-top: 15px; font-size: 13px; color: #888;">最近总听歌时长：${musicData.total_recent_duration}</p>`;
                }
                break;
            // --- 音乐 V5 结束 ---

// --- 相册 (V5 - 图标点击展开样式, thought样式修正) ---
            case 'photos':
                const gallery = data.photo_gallery || {};
                html = '';

                // 注意：这里我们把 thoughtStyle 变量的内容直接整合进了CSS (.thought-style-div)
                // 所以下面生成HTML时，直接使用 <div class="thought-style-div"> 即可

                const createPhotoItemHTML = (item, iconClass, detailsGenerator) => {
                    const itemId = `photo-item-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                    return `
                        <div class="snoop-photo-item-container">
                            <div class="snoop-photo-item" data-details-id="${itemId}" title="点击查看详情">
                                <i class="fas ${iconClass}"></i>
                            </div>
                            <div class="snoop-photo-details" id="${itemId}">
                                ${detailsGenerator(item)}
                            </div>
                        </div>`;
                };

                // --- 最近拍摄 ---
                html += `<h3><i class="fas fa-camera"></i> 最近拍摄</h3>`;
                if (gallery.recent_camera && gallery.recent_camera.length > 0) {
                    html += '<div class="snoop-photo-grid">';
                    html += gallery.recent_camera.map(p => createPhotoItemHTML(p, 'fa-camera-retro', item => `
                        <p><strong>描述:</strong> ${item.description || '无'}</p>
                        <p><small>时间: ${item.time || '未知'} ${item.location ? `| 地点: ${item.location}` : ''}</small></p>
                        ${item.thought ? `<div class="thought-style-div">💡 想法：${item.thought}</div>` : ''}
                    `)).join('');
                    html += '</div>';
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">无</p>';
                }

                // --- 屏幕截图 ---
                html += `<h3 style="margin-top: 20px;"><i class="fas fa-crop-alt"></i> 屏幕截图</h3>`;
                if (gallery.screenshots && gallery.screenshots.length > 0) {
                     html += '<div class="snoop-photo-grid">';
                     html += gallery.screenshots.map(s => createPhotoItemHTML(s, 'fa-crop', item => `
                        <p><strong>内容:</strong> ${item.content_summary || '无'}</p>
                        <p><small>时间: ${item.time || '未知'} | App: ${item.app_name || '未知'}</small></p>
                        ${item.thought ? `<div class="thought-style-div">💡 想法：${item.thought}</div>` : ''}
                     `)).join('');
                     html += '</div>';
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">无</p>';
                }

                // --- 私密相册 ---
                html += `<h3 style="margin-top: 20px;"><i class="fas fa-lock"></i> 私密相册</h3>`;
                if (gallery.private_album && gallery.private_album.length > 0) {
                     html += '<div class="snoop-photo-grid">';
                     html += gallery.private_album.map(p => createPhotoItemHTML(p, 'fa-user-secret', item => `
                        <p><strong>描述:</strong> ${item.description || '无'}</p>
                        <div class="thought-style-div reason-private">🔒 原因：${item.reason_private || '未说明'}</div>
                     `)).join('');
                     html += '</div>';
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">无</p>';
                }
                break;
            // --- 相册 V5 结束 ---

// --- 资产 (V4 - 银行卡 + 详细投资 + 流水) ---
            case 'assets':
                const assets = data.financial_assets || {};
                html = '<div class="snoop-assets-container">'; // 新增容器

                // --- 渲染银行卡 ---
                html += `<h3><i class="fas fa-credit-card"></i> 银行卡</h3>`;
                if (assets.bank_cards && assets.bank_cards.length > 0) {
                    html += '<div class="snoop-bank-cards-grid">'; // 网格布局
                    html += assets.bank_cards.map(card => `
                        <div class="snoop-bank-card">
                            <div class="snoop-bank-card-name">${card.card_name || '未知银行卡'} (${card.card_number_last4 || '尾号未知'})</div>
                            <div class="snoop-bank-card-balance">${card.balance || '¥0.00'}</div>
                        </div>
                    `).join('');
                    html += '</div>';
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">暂无银行卡信息。</p>';
                }

                // --- 渲染投资组合 ---
// --- 渲染投资组合 (V6 - 表格样式) ---
                html += `<h3 style="margin-top: 20px;"><i class="fas fa-chart-pie"></i> 投资组合</h3>`; // 修改图标
                if (assets.investments && assets.investments.length > 0) {
                    html += '<div class="snoop-investments-list-v6">'; // 新容器类名
                    // --- 添加表头 ---
                    html += `
                        <div class="snoop-investment-header-row">
                            <div class="inv-col-name">名称/金额</div>
                            <div class="inv-col-daily">日收益</div>
                            <div class="inv-col-holding">持有收益</div>
                            <div class="inv-col-cumulative">累计收益</div>
                        </div>
                    `;
                    // --- 渲染每一项 ---
                    html += assets.investments.map(inv => {
                        // --- 判断各种收益的正负并添加 CSS 类 ---
                        const getStatusClass = (statusString) => {
                            if (!statusString) return 'neutral';
                            if (statusString.includes('+') || (statusString.includes('¥') && !statusString.includes('-'))) return 'profit'; // 包含+ 或 包含¥但不含-
                            if (statusString.includes('-')) return 'loss';
                            return 'neutral';
                        };
                        const dailyClass = getStatusClass(inv.daily_profit_loss);
                        const holdingClass = getStatusClass(inv.holding_profit_loss);
                        const cumulativeClass = getStatusClass(inv.cumulative_profit_loss);
                        // --- 判断结束 ---
                        return `
                        <div class="snoop-investment-item-v6">
                            <div class="inv-col-name">
                                <span class="inv-name">${inv.name || '未知产品'} <span class="inv-type">[${inv.type || '未知'}]</span></span>
                                <span class="inv-value">${inv.current_value || '¥0.00'}</span>
                                <span class="inv-percentage">${inv.holding_percentage || '占比 --'}</span>
                            </div>
                            <div class="inv-col-daily ${dailyClass}">${inv.daily_profit_loss || '0.00'}</div>
                            <div class="inv-col-holding ${holdingClass}">${inv.holding_profit_loss || '0.00'}</div>
                            <div class="inv-col-cumulative ${cumulativeClass}">${inv.cumulative_profit_loss || '--'}</div>
                        </div>
                    `}).join('');
                    html += '</div>'; // 结束 .snoop-investments-list-v6
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">暂无投资记录。</p>';
                }
// --- 渲染最近交易流水 (V6 - 银行明细样式) ---
                html += `<h3 style="margin-top: 20px;"><i class="fas fa-receipt"></i> 最近账单流水</h3>`;
                if (assets.recent_transactions && assets.recent_transactions.length > 0) {
                     html += '<div class="snoop-transactions-list-v6">'; // 新容器类名
                     html += assets.recent_transactions.map(tx => {
                        const amountClass = tx.type === '收入' ? 'income' : 'expense';
                        const amountText = tx.amount || '0.00';
                        // --- 尝试从描述中分离出方法/对象 (可能不完美) ---
                        let mainDesc = tx.description || '未知交易';
                        let subDesc = tx.time || '时间未知'; // 默认把时间放下面
                        const separators = ['-', ' via ', '来自', '发给', '通过', '来自']; // 可能的分隔符
                        for (const sep of separators) {
                            if (mainDesc.includes(sep)) {
                                const parts = mainDesc.split(sep);
                                mainDesc = parts[0].trim(); // 主要描述
                                subDesc = sep + parts.slice(1).join(sep).trim() + ` (${tx.time || ''})`; // 次要描述+时间
                                break;
                            }
                        }
                        // --- 分离结束 ---
                        return `
                        <div class="snoop-transaction-item-v6">
                            <div class="tx-left">
                                <div class="tx-desc">${mainDesc}</div>
                                <div class="tx-subdesc">${subDesc}</div> 
                            </div>
                            <div class="tx-amount ${amountClass}">${amountText}</div>
                        </div>`;
                     }).join('');
                     html += '</div>'; // 结束 .snoop-transactions-list-v6
                } else {
                     html += '<p style="text-align:center; color:#999; padding: 10px 0;">暂无交易记录。</p>';
                }
                html += '</div>'; // 结束 .snoop-assets-container
                break;
            // --- 资产 V4 结束 ---
// --- 微信 (使用新的专属类名渲染) ---
            case 'wechat':
                const wechatLog = data.wechat_log || [];
                if (wechatLog.length === 0) {
                    html = '<p style="text-align:center; color:#999; padding: 20px;">还没有微信聊天记录哦。</p>';
                } else {
                    html = wechatLog.map(conversation => {
                         // ▼▼▼ 注意：这里所有的 class 都改成了 snoop-wechat- ▼▼▼
                         let conversationHTML = `<div class="snoop-wechat-chat-container">`; // <--- 修改
                         conversationHTML += `<div class="snoop-wechat-header"><span class="contact-name">${conversation.contact} ${conversation.is_group_chat ? '(群聊)' : ''}</span></div>`; // <--- 修改
                         conversationHTML += `<div class="snoop-wechat-area">`; // <--- 修改
                         let lastTime = null;
                         (conversation.messages || []).forEach(msg => {
                             if (msg.time !== lastTime) {
                                 conversationHTML += `<div class="snoop-wechat-timestamp"><span>${msg.time}</span></div>`; // <--- 修改
                                 lastTime = msg.time;
                             }
                             const isSent = msg.sender === contact.name; // 假设 contact 变量在此可用
                             const rowClass = isSent ? 'sent' : 'received';
                             const bubbleClass = isSent ? 'sent' : 'received';
                             const senderName = conversation.is_group_chat && !isSent ? `<div style="font-size: 11px; color: #888; margin-bottom: 2px;">${msg.sender}</div>` : '';
                             conversationHTML += `<div class="snoop-wechat-row ${rowClass}"><div style="max-width: 100%;">${senderName}<div class="snoop-wechat-bubble ${bubbleClass}">${msg.content}</div></div></div>`; // <--- 修改 x2
                         });
                         conversationHTML += `</div></div>`;
                         // ▲▲▲ 类名修改结束 ▲▲▲
                         return conversationHTML;
                    }).join('');
                }
                break;
            default:
                 html = '<p style="text-align:center; color:#999; padding: 20px;">未知应用类型。</p>';
                 break;
        }

        bodyEl.innerHTML = html || '<p style="text-align:center; color:#999; padding: 20px;">TA的这部分生活还是空白哦~</p>';

    } catch (e) {
        console.error("渲染窥探内容失败:", e);
        bodyEl.innerHTML = `<p style="text-align:center; color:var(--soft-red); padding: 20px;">内容格式错误或数据不完整，无法显示。<br><small>${e.message}</small></p>`;
    }
}
// ▲▲▲ 替换 displaySnoopContent 结束 ▲▲▲
// ▲▲▲ 替换 displaySnoopContent 结束 ▲▲▲
// =========== ▼▼▼ 地图功能核心逻辑 (V2 多地图版) ▼▼▼ ========
// ==========================================================
let currentMapData = null; // 用于存储当前正在编辑的地图数据
let editingLocationId = null;
let editingMapId = null;

// 函数：显示地图管理中心
async function showMapManagementScreen() {
    hideAllScreens();
    document.getElementById('map-management-screen').style.display = 'flex';
    await renderMapList();
}

// 函数：渲染地图管理列表
async function renderMapList() {
    const maps = await kokoMemory.getAll('maps');
    const listEl = document.getElementById('map-list');
    listEl.innerHTML = '';

    if (maps.length === 0) {
        listEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><p>还没有创建任何地图。</p><p>点击右上角“+”来创建你的第一个世界吧！</p></div>`;
        return;
    }

    maps.forEach(map => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.dataset.mapId = map.id;
        item.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${map.name}</div>
                <div class="preset-desc">${map.description ? map.description.substring(0, 50) + '...' : '暂无描述'}</div>
            </div>
            <div class="preset-actions">
                <span class="preset-action-btn edit-map-btn" title="编辑地图宏观信息"><i class="fas fa-edit"></i></span>
                <span class="preset-action-btn delete delete-map-btn" title="删除地图"><i class="fas fa-trash-alt"></i></span>
            </div>
        `;
        // 点击整个条目进入地图编辑器
        item.querySelector('.preset-info').addEventListener('click', () => openMapScreen(map.id));
        listEl.appendChild(item);
    });
}
// 智能打开地图并定位到具体地点（支持自动钻取层级）
async function openMapAndFocusLocation(mapId, locationId) {
    const mapData = await kokoMemory.get('maps', mapId);
    if (!mapData) {
        alert('地图数据不存在！');
        return;
    }
    
    const targetLoc = mapData.locations.find(l => l.id === locationId);
    
    // 如果找不到地点，或者地点在最外层，就用普通方式打开
    if (!targetLoc) {
        openMapScreen(mapId);
        if (locationId) alert('未找到该地点，可能已被删除。');
        return;
    }

    // --- 核心逻辑：倒推家谱，构建面包屑 ---
    currentMapData = mapData;
    mapNavigationStack = []; // 先清空
    
    let curr = targetLoc;
    // 只要它有父级，就往上找
    while (curr.parentId) {
        const parent = mapData.locations.find(l => l.id === curr.parentId);
        if (parent) {
            // 把父级加到栈的开头（因为我们是倒着找的）
            mapNavigationStack.unshift({ id: parent.id, name: parent.name });
            curr = parent; // 继续往上找爷爷
        } else {
            break; // 找不到父级数据（可能父级被删了），停止
        }
    }

    // 设置当前层级为目标地点的父级ID
    currentMapParentId = targetLoc.parentId;

    // --- 渲染UI ---
    hideAllScreens();
    document.getElementById('map-screen').style.display = 'flex';
    document.getElementById('map-title').textContent = currentMapData.name;

    renderMapIcons(); // 这会根据 currentMapParentId 渲染正确的层级
    
    // 最后，聚焦高亮
    setTimeout(() => {
        focusOnLocation(locationId);
    }, 300); // 稍微延迟一点，等待渲染完成
}
// 打开并渲染指定的地图编辑器（修改版：初始化嵌套状态）
async function openMapScreen(mapId) {
    const mapData = await kokoMemory.get('maps', mapId);
    if (!mapData) {
        alert('找不到地图数据！');
        return;
    }
    currentMapData = mapData;

    // ▼▼▼ 新增：每次打开地图时，重置到最外层 ▼▼▼
    currentMapParentId = null; // 默认回到最外层 (Root)
    mapNavigationStack = [];   // 清空面包屑导航历史
    // ▲▲▲ 新增结束 ▲▲▲

    hideAllScreens();
    document.getElementById('map-screen').style.display = 'flex';
    document.getElementById('map-title').textContent = currentMapData.name;

    renderMapIcons(); // 这会自动渲染第一层的内容
}

// 渲染当前层级的所有地点图标 + 目录列表
function renderMapIcons() {
    const container = document.getElementById('map-grid-container');
    const directoryList = document.getElementById('map-directory-list'); // 获取目录容器
    
    container.innerHTML = ''; 
    directoryList.innerHTML = ''; // 清空目录

    if (currentMapData && currentMapData.locations) {
        // 1. 核心筛选：只显示 parentId 等于当前层级ID 的地点
        // (兼容旧数据：如果 loc.parentId 不存在，视为 null)
        const visibleLocations = currentMapData.locations.filter(loc => {
            const locParent = loc.parentId || null;
            return locParent === currentMapParentId;
        });

        // 如果当前层级没东西，显示提示
        if (visibleLocations.length === 0) {
            directoryList.innerHTML = '<div style="padding:10px; color:#999; text-align:center; font-size:12px;">当前区域暂无地点</div>';
        }

        visibleLocations.forEach(loc => {
            // --- A. 渲染地图上的图标 ---
            const iconEl = document.createElement('div');
            iconEl.className = 'map-icon';
            iconEl.dataset.locationId = loc.id;
            iconEl.classList.add('tier-' + (loc.tier || 2));
            iconEl.style.left = `${loc.x}px`;
            iconEl.style.top = `${loc.y}px`;
            // 增加双击进入功能
            iconEl.ondblclick = (e) => {
                e.stopPropagation(); // 防止触发添加
                enterMapLayer(loc);
            };
            
            iconEl.innerHTML = `
                <i class="${loc.icon || 'fas fa-map-marker-alt'}" style="color: ${loc.color || '#333'}"></i>
                <span class="map-icon-label">${loc.name}</span>
            `;
            container.appendChild(iconEl);

            // --- B. 渲染右上角的目录项 ---
            const dirItem = document.createElement('div');
            dirItem.className = 'directory-item';
            dirItem.innerHTML = `<i class="${loc.icon || 'fas fa-map-marker-alt'}"></i><span>${loc.name}</span>`;
            
            // 点击目录：定位并高亮
            dirItem.addEventListener('click', () => {
                focusOnLocation(loc.id);
            });
            
            directoryList.appendChild(dirItem);
        });
    }
    
    // 渲染面包屑导航
    renderMapBreadcrumbs();
}
// 进入某个地点的内部层级
function enterMapLayer(location) {
    // 压入历史栈
    mapNavigationStack.push({
        id: location.id,
        name: location.name
    });
    // 更新当前父ID
    currentMapParentId = location.id;
    
    // 重新渲染
    renderMapIcons();
}

// 返回到某一层
function navigateToMapLayer(targetId) {
    if (targetId === 'root') {
        currentMapParentId = null;
        mapNavigationStack = [];
    } else {
        // 找到目标在栈中的索引
        const index = mapNavigationStack.findIndex(item => item.id === targetId);
        if (index !== -1) {
            // 截断数组，保留目标层级及之前的
            mapNavigationStack = mapNavigationStack.slice(0, index + 1);
            currentMapParentId = targetId;
        }
    }
    renderMapIcons();
}

// 渲染面包屑 (修正版：使用 dataset 绑定，解决点击无反应问题)
function renderMapBreadcrumbs() {
    const container = document.getElementById('map-breadcrumbs');
    
    // 1. 渲染根节点 (世界/城市名)
    // 注意：去掉了 onclick="..."，改用 data-target-id="root"
    let html = `<span class="breadcrumb-item ${currentMapParentId === null ? 'active' : ''}" data-target-id="root">🗺️ ${currentMapData.name}</span>`;
    
    // 2. 渲染中间层级
    mapNavigationStack.forEach((level, index) => {
        const isActive = (index === mapNavigationStack.length - 1);
        html += `
            <span class="breadcrumb-separator"><i class="fas fa-chevron-right" style="font-size:10px;"></i></span>
            <span class="breadcrumb-item ${isActive ? 'active' : ''}" 
                  ${!isActive ? `data-target-id="${level.id}"` : ''}>
                  ${level.name}
            </span>
        `;
    });
    
    container.innerHTML = html;
}

// 定位并高亮某个地点
function focusOnLocation(locId) {
    const icon = document.querySelector(`.map-icon[data-location-id="${locId}"]`);
    if (!icon) return;

    // 1. 移除所有旧高亮
    document.querySelectorAll('.map-icon.highlighted').forEach(el => el.classList.remove('highlighted'));

    // 2. 添加新高亮
    icon.classList.add('highlighted');
    
    // 3. 滚动容器，让图标居中
    const container = document.querySelector('.api-content'); // 滚动的容器
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;
    
    // 这里的 left/top 是相对于 1000x1000 画布的
    const targetX = parseInt(icon.style.left); 
    const targetY = parseInt(icon.style.top);

    container.scrollTo({
        left: targetX - containerWidth / 2,
        top: targetY - containerHeight / 2,
        behavior: 'smooth'
    });
    
    // 4. 1.5秒后自动移除高亮
    setTimeout(() => icon.classList.remove('highlighted'), 1500);
}

// 打开地点编辑/添加弹窗（修改版：移除了地点级别选择）
function openLocationModal(config) {
    const modal = document.getElementById('map-location-modal');
    const titleEl = document.getElementById('map-location-modal-title');
    const deleteBtn = document.getElementById('delete-map-location-btn');

    // 重置输入框
    document.getElementById('location-id-input').value = '';
    document.getElementById('location-name-input').value = '';
    document.getElementById('location-icon-input').value = 'fas fa-map-marker-alt';
    document.getElementById('location-description-input').value = '';
    // ❌ 删除了 tier 的重置代码

    // 检查并添加“进入该地点内部”按钮
    let enterBtn = document.getElementById('enter-map-layer-btn');
    if (!enterBtn) {
        enterBtn = document.createElement('button');
        enterBtn.id = 'enter-map-layer-btn';
        enterBtn.className = 'form-button';
        enterBtn.style.backgroundColor = '#673ab7';
        enterBtn.style.marginTop = '10px';
        enterBtn.innerHTML = '<i class="fas fa-door-open"></i> 进入该地点内部';
        const saveBtn = document.getElementById('save-map-location-btn');
        saveBtn.parentNode.insertBefore(enterBtn, saveBtn);
        
        enterBtn.addEventListener('click', () => {
            const locId = document.getElementById('location-id-input').value;
            if(locId) {
                const loc = currentMapData.locations.find(l => l.id === locId);
                if(loc) {
                    document.getElementById('map-location-modal').style.display = 'none';
                    enterMapLayer(loc);
                }
            }
        });
    }

    if (config.isEditing) {
        // --- 编辑模式 ---
        titleEl.textContent = '编辑地点';
        editingLocationId = config.location.id;
        document.getElementById('location-id-input').value = config.location.id;
        document.getElementById('location-x-input').value = config.location.x;
        document.getElementById('location-y-input').value = config.location.y;
        document.getElementById('location-name-input').value = config.location.name;
        document.getElementById('location-icon-input').value = config.location.icon;
        document.getElementById('location-description-input').value = config.location.description;
        
        // ❌ 删除了 tier 的赋值代码
        
        deleteBtn.style.display = 'block';
        enterBtn.style.display = 'block';
    } else {
        // --- 新增模式 ---
        titleEl.textContent = '在地图上添加新地点';
        editingLocationId = null;
        document.getElementById('location-x-input').value = config.x;
        document.getElementById('location-y-input').value = config.y;
        
        // ❌ 删除了 tier 的赋值代码
        
        deleteBtn.style.display = 'none';
        enterBtn.style.display = 'none';
    }
    modal.style.display = 'flex';
}

// 函数：打开地图宏观信息编辑弹窗
function openMapDetailsModal(map = null) {
    const modal = document.getElementById('map-details-modal');
    if (map) {
        // 编辑模式
        editingMapId = map.id;
        document.getElementById('map-details-modal-title').textContent = '编辑地图信息';
        document.getElementById('map-id-input').value = map.id;
        document.getElementById('map-name-input').value = map.name;
        document.getElementById('map-description-input').value = map.description || '';
    } else {
        // 创建模式
        editingMapId = null;
        document.getElementById('map-details-modal-title').textContent = '创建新地图';
        document.getElementById('map-id-input').value = '';
        document.getElementById('map-name-input').value = '';
        document.getElementById('map-description-input').value = '';
    }
    modal.style.display = 'flex';
}

// 函数：更新联系人设置里的地图下拉菜单
async function updateContactMapSelector() {
    const maps = await kokoMemory.getAll('maps');
    const selectEl = document.getElementById('contact-map-select');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!selectEl || !contact) return;

    selectEl.innerHTML = '<option value="">-- 不关联任何地图 --</option>';
    maps.forEach(map => {
        const option = document.createElement('option');
        option.value = map.id;
        option.textContent = map.name;
        if (contact.mapId === map.id) {
            option.selected = true;
        }
        selectEl.appendChild(option);
    });
}
async function openLocationPicker(mapId) {
    const modal = document.getElementById('send-location-modal');
    const listEl = document.getElementById('location-picker-list');
    listEl.innerHTML = '<p>加载中...</p>'; // 提示用户正在加载

    const mapData = await kokoMemory.get('maps', mapId);

    if (!mapData || !mapData.locations || mapData.locations.length === 0) {
        listEl.innerHTML = '<p style="color: #888; text-align: center;">这张地图上还没有设定任何地点。</p>';
    } else {
        listEl.innerHTML = ''; // 清空加载提示
        mapData.locations.forEach(location => {
            const item = document.createElement('div');
            item.className = 'discover-item'; // 复用一个看起来不错的现有样式
            item.style.marginBottom = '8px';
            item.innerHTML = `
                <div class="discover-icon"><i class="${location.icon || 'fas fa-map-marker-alt'}"></i></div>
                <div class="discover-info">
                    <div class="discover-name">${location.name}</div>
                    <div class="discover-desc">${location.description.substring(0, 30)}...</div>
                </div>
            `;
            // 【核心】为每个地点条目绑定点击事件
            item.addEventListener('click', async () => {
                // 创建并发送位置消息
                await createAndAddMessage({
                    type: 'location_share',
                    content: {
                        mapId: mapId,
                        locationId: location.id,
                        name: location.name,
                        icon: location.icon,
                        x: location.x,
                        y: location.y
                    }
                });
                modal.style.display = 'none'; // 发送后关闭弹窗
            });
            listEl.appendChild(item);
        });
    }

    modal.style.display = 'flex';
    // 绑定关闭按钮
    document.getElementById('close-location-picker-modal').addEventListener('click', () => {
        modal.style.display = 'none';
    }, { once: true });
}
// ▼▼▼ 把下面所有新函数，完整地粘贴到你的JS代码区 ▼▼▼
/// ▼▼▼ 使用这个【超级加强版】替换旧的 refresh-snoop-data-btn 监听代码 ▼▼▼

// --- 新增：为窥探模式的“刷新”按钮绑定【真正刷新】的功能 ---
document.getElementById('refresh-snoop-data-btn').addEventListener('click', async () => {
    const screen = document.getElementById('snooped-phone-screen');
    const contactId = screen.dataset.currentContactId;
    const refreshBtn = document.getElementById('refresh-snoop-data-btn');
    const timestampEl = document.getElementById('snoop-last-synced');

    if (contactId && refreshBtn) {
        // 1. 开始加载：禁用按钮，显示旋转图标，更新提示文字
        refreshBtn.disabled = true;
        refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; // 显示旋转图标
        timestampEl.textContent = '正在同步最新数据...';
        timestampEl.style.color = '#888'; // 恢复默认颜色

        try {
            // 2. 调用我们新分离出来的 AI 请求函数
            const success = await fetchSnoopDataFromAI(contactId);

            if (success) {
                // 3. 成功反馈：更新时间戳，给用户提示
                const lastSyncTime = snoopDataCache[contactId].timestamp;
                timestampEl.textContent = `数据同步于 刚刚`;
                alert('数据同步成功！现在点击APP图标查看最新内容吧~');
            } else {
                 // 理论上 fetchSnoopDataFromAI 失败会抛出错误进入catch
                 // 但以防万一，还是加个失败提示
                 throw new Error("AI未能成功返回数据。");
            }

        } catch (error) {
            // 4. 失败反馈：显示错误信息
            console.error("手动刷新窥探数据失败:", error);
            timestampEl.textContent = '同步失败，请检查网络或API设置';
            timestampEl.style.color = 'var(--soft-red)'; // 用红色提示错误
            alert(`数据同步失败：${error.message}`);
        } finally {
            // 5. 无论成功失败，最后都要恢复按钮状态
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i>'; // 恢复刷新图标
        }
    }
});

// ▲▲▲ 替换到这里结束 ▲▲▲
// ▼▼▼ 把这段新代码，粘贴到 attachEventListeners 函数里面 ▼▼▼

// --- 修改：监听“短信/窥探模式”列表的点击 ---
document.getElementById('sms-content-container').addEventListener('click', (e) => {
    const contactItem = e.target.closest('.contact-item');
    if (!contactItem) return;

    const contactId = contactItem.dataset.contactId;
    const currentTab = document.querySelector('#sms-tabs .feed-tab-btn.active')?.dataset.tab;

    if (currentTab === 'my-sms') {
        // ✨ 如果在“我的短信”页签下点击，就打开短信聊天界面 ✨
        openSmsChat(contactId);
    } else if (currentTab === 'snoop-mode') {
        // 如果在“窥探模式”页签下点击，就打开TA的手机桌面
        openSnoopedPhoneScreen(contactId);
    }
});

// 2. 监听“手机桌面”上所有APP图标的点击
document.getElementById('snooped-phone-screen').addEventListener('click', handleSnoopAppClick);

// 3. 监听从“手机桌面”返回的按钮
document.getElementById('back-from-snooped-phone').addEventListener('click', showSmsScreen);

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 把这段代码添加到 attachEventListeners 函数的末尾 ▼▼▼
document.getElementById('back-from-snooped-app').addEventListener('click', () => {
    // 从 "TA的手机" 屏幕上存储的 contactId 获取当前正在查看的角色ID
    const contactId = document.getElementById('snooped-phone-screen').dataset.currentContactId;
    if(contactId) {
        openSnoopedPhoneScreen(contactId); // 调用函数返回到 "TA的手机" 屏幕
    } else {
        showSmsScreen(); // 作为备选，如果找不到ID，就返回短信主列表
    }
});
// ▲▲▲ 添加结束 ▲▲▲
// ▼▼▼ 粘贴这段新代码到 attachEventListeners ▼▼▼

// "发现" -> "窥探API设置"
document.getElementById('snoop-api-settings-btn').addEventListener('click', showSnoopApiSettingsScreen);

// "窥探API设置" -> "发现" (返回)
document.getElementById('back-from-snoop-api').addEventListener('click', showDiscoverScreen);

// "窥探API设置" -> "拉取模型"
document.getElementById('fetch-snoop-models-btn').addEventListener('click', (e) => {
    const apiKey = document.getElementById('snoop-api-key-input').value;
    const endpoint = document.getElementById('snoop-api-endpoint-input').value.trim();
    fetchModels(endpoint, apiKey, document.getElementById('snoop-model-select'), e.currentTarget);
});

// "窥探API设置" -> "保存设置"
document.getElementById('save-snoop-api-settings-btn').addEventListener('click', async () => {
    state.snoopApiSettings.apiKey = document.getElementById('snoop-api-key-input').value;
    state.snoopApiSettings.endpoint = document.getElementById('snoop-api-endpoint-input').value.trim();
    state.snoopApiSettings.model = document.getElementById('snoop-model-select').value;

    await kokoMemory.put('snoopApiSettings', { id: 'main', ...state.snoopApiSettings });

    alert('窥探API设置已保存！');
    showDiscoverScreen();
});

// ▲▲▲ 粘贴结束 ▲▲▲
// --- V-新功能：日程与事件模块 ---

let editingScheduleId = null;
let editingEventId = null;

// 函数：显示日程表页面
function showScheduleScreen() {
    hideAllScreens();
    document.getElementById('schedule-screen').style.display = 'flex';
    renderSchedule();
}

// 函数：渲染日程表内容
function renderSchedule() {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    const container = document.getElementById('schedule-content-list');
    container.innerHTML = '';

    if (!contact || !contact.schedule || contact.schedule.length === 0) {
        container.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-calendar-alt" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有添加任何日程安排。</p><p>点击右上角“+”来添加第一条记录吧！</p></div>`;
        return;
    }

    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    const dayNames = { monday: '星期一', tuesday: '星期二', wednesday: '星期三', thursday: '星期四', friday: '星期五', saturday: '星期六', sunday: '星期日' };

    days.forEach(day => {
        const itemsForDay = contact.schedule.filter(item => item.dayOfWeek === day).sort((a,b) => a.startTime.localeCompare(b.startTime));
        if (itemsForDay.length > 0) {
            const daySection = document.createElement('div');
            daySection.className = 'discover-section';
            daySection.style.marginBottom = '15px';
            
            let itemsHTML = itemsForDay.map(item => `
                <div class="discover-item" data-schedule-id="${item.id}" style="cursor:pointer;">
                    <div class="discover-icon" style="background-color:#e3f2fd; color:#42a5f5;"><i class="fas fa-book-open"></i></div>
                    <div class="discover-info">
                        <div class="discover-name">${item.startTime} - ${item.endTime}：${item.courseName}</div>
                        <div class="discover-desc">${item.location || '地点未定'}</div>
                    </div>
                </div>
            `).join('');

            daySection.innerHTML = `<div class="section-title" style="font-weight:bold; color:var(--text-dark);">${dayNames[day]}</div>${itemsHTML}`;
            container.appendChild(daySection);
        }
    });
}

// 函数：显示重要日子页面
function showEventsScreen() {
    hideAllScreens();
    document.getElementById('events-screen').style.display = 'flex';
    renderEvents();
}
// 函数：渲染重要日子内容 (V3 - 周年纪念版)
function renderEvents() {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    const container = document.getElementById('events-content-list');
    container.innerHTML = '';
    
    // --- 保持卡片容器样式 ---
    container.className = 'diary-content';
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.padding = '15px';
    container.style.gap = '15px';

    if (!contact || !contact.events || !contact.events.length) {
        container.style.display = 'block'; // 恢复默认，让提示居中
        container.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-heart" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有添加任何重要的日子。</p><p>点击右上角“+”来添加吧！</p></div>`;
        return;
    }

    // --- 核心升级：全新的日期计算逻辑 ---
    const calculateDateInfo = (event) => {
        if (!event.date) return { days: '?', label: '日期无效', anniversaryText: '' };
        
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const eventDate = new Date(event.date); // 原始日期 (e.g., 1999-11-17)
        eventDate.setHours(0, 0, 0, 0);

        // 如果是“周年纪念日”类型
        if (event.type === 'anniversary') {
            const todayYear = today.getFullYear();
            const eventMonth = eventDate.getMonth();
            const eventDay = eventDate.getDate();

            // 计算今年的纪念日
            const thisYearsAnniversary = new Date(todayYear, eventMonth, eventDay);
            let totalYears = todayYear - eventDate.getFullYear();
            let diffDays = Math.ceil((thisYearsAnniversary.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

            if (diffDays > 0) {
                // --- 还没到 ---
                return { days: diffDays, label: '天后', anniversaryText: `第 ${totalYears} 周年` };
            } else if (diffDays === 0) {
                // --- 就是今天 ---
                return { days: '今', label: '天', anniversaryText: `第 ${totalYears} 周年` };
            } else {
                // --- 今年已经过了，计算明年的 ---
                const nextYearsAnniversary = new Date(todayYear + 1, eventMonth, eventDay);
                diffDays = Math.ceil((nextYearsAnniversary.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                return { days: diffDays, label: '天后', anniversaryText: `第 ${totalYears + 1} 周年` };
            }

        } else {
            // “生理期”或“其他”类型的旧逻辑（一次性倒数）
            const diffTime = eventDate.getTime() - today.getTime();
            const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays > 0) {
                return { days: diffDays, label: '天后', anniversaryText: '' };
            } else if (diffDays < 0) {
                return { days: Math.abs(diffDays), label: '天前', anniversaryText: '' };
            } else {
                return { days: '今', label: '天', anniversaryText: '' };
            }
        }
    };
    // --- 核心升级结束 ---

    const sortedEvents = [...contact.events].sort((a,b) => {
        if (a.isPinned && !b.isPinned) return -1;
        if (!a.isPinned && b.isPinned) return 1;
        const diffA = calculateDateInfo(a).days;
        const diffB = calculateDateInfo(b).days;
        // 让“今天”的排最前
        if (diffA === '今') return -1;
        if (diffB === '今') return 1;
        // 然后按天数升序
        return diffA - diffB;
    });
    
    sortedEvents.forEach(event => {
        const { days, label, anniversaryText } = calculateDateInfo(event); // 获取所有新信息
        const isActive = event.isPinned ? 'active' : '';

        // 格式化原始日期（e.g., "1999年11月17日"）
        const originalDateStr = new Date(event.date).toLocaleDateString('zh-CN', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });

        const card = document.createElement('div');
        card.className = 'event-card';
        card.dataset.type = event.type;
        card.dataset.eventId = event.id;

        card.innerHTML = `
            <div class="event-card-countdown">
                <div class="event-card-days">${days}</div>
                <div class="event-card-label">${label}</div>
            </div>
            <div class="event-card-info">
                <div class="event-card-name">${event.eventName}</div>
                <div class="event-card-date">
                    ${originalDateStr} ${anniversaryText ? `<span style="color: #c62828; font-weight: bold; margin-left: 8px;">(${anniversaryText})</span>` : ''}
                </div>
                <div class="event-card-notes">${event.notes || ''}</div>
            </div>
            <div class="event-card-actions">
                <button class="preset-action-btn pin-event-btn ${isActive}" data-event-id="${event.id}" title="在锁屏显示">
                    <i class="fas ${isActive ? 'fa-thumbtack' : 'fa-thumbtack'}"></i>
                </button>
                <button class="preset-action-btn delete delete-event-btn" data-event-id="${event.id}" title="删除">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
        `;
        container.appendChild(card);
    });
}
// 函数：打开日程编辑/添加弹窗
function openScheduleModal(scheduleItem = null) {
    const modal = document.getElementById('schedule-modal');
    const deleteBtn = document.getElementById('delete-schedule-item-btn'); // ✨ 1. 获取删除按钮
    
    if (scheduleItem) {
        // 编辑模式
        editingScheduleId = scheduleItem.id;
        document.getElementById('schedule-modal-title').textContent = '编辑日程';
        document.getElementById('schedule-item-id').value = scheduleItem.id;
        document.getElementById('schedule-name-input').value = scheduleItem.courseName;
        document.getElementById('schedule-day-select').value = scheduleItem.dayOfWeek;
        document.getElementById('schedule-start-input').value = scheduleItem.startTime;
        document.getElementById('schedule-end-input').value = scheduleItem.endTime;
        document.getElementById('schedule-location-input').value = scheduleItem.location;
        deleteBtn.style.display = 'block'; // ✨ 2. 显示删除按钮
    } else {
        // 添加模式
        editingScheduleId = null;
        document.getElementById('schedule-modal-title').textContent = '添加日程';
        document.getElementById('schedule-item-id').value = '';
        
        // ✨ (优化) 手动清空所有输入框
        document.getElementById('schedule-name-input').value = '';
        document.getElementById('schedule-day-select').value = 'monday';
        document.getElementById('schedule-start-input').value = '';
        document.getElementById('schedule-end-input').value = '';
        document.getElementById('schedule-location-input').value = '';

        deleteBtn.style.display = 'none'; // ✨ 3. 隐藏删除按钮
    }
    modal.style.display = 'flex';
}

// 函数：打开事件编辑/添加弹窗
function openEventModal(eventItem = null) {
    const modal = document.getElementById('event-modal');
    if (eventItem) {
        // 编辑模式
        editingEventId = eventItem.id;
        document.getElementById('event-modal-title').textContent = '编辑重要日子';
        document.getElementById('event-item-id').value = eventItem.id;
        document.getElementById('event-name-input').value = eventItem.eventName;
        document.getElementById('event-date-input').value = eventItem.date;
        document.getElementById('event-type-select').value = eventItem.type;
        document.getElementById('event-notes-input').value = eventItem.notes;
    } else {
        // 添加模式
        editingEventId = null;
        document.getElementById('event-modal-title').textContent = '添加重要日子';
        document.getElementById('event-item-id').value = '';
         document.querySelector('#event-modal form')?.reset();
    }
    modal.style.display = 'flex';
}

// ▲▲▲ 把上面所有新函数，完整地粘贴到你的JS代码区 ▲▲▲
// ==========================================================
// =========== ▼▼▼ 新增：图片处理核心函数 ▼▼▼ ============
// ==========================================================
/**
 * 处理用户上传的图片文件，进行压缩并转换为Base64
 * @param {File} file - 用户选择的图片文件
 * @returns {Promise<string>} - 返回一个Promise，解析为压缩后的Base64字符串
 */
function handleImageUpload(file) {
    return new Promise((resolve, reject) => {
        const MAX_DIMENSION = 1024; // 设定图片最大尺寸为1024像素
        const reader = new FileReader();

        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                let { width, height } = img;

                // 如果图片尺寸大于最大值，则进行等比缩放
                if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                    if (width > height) {
                        height = Math.round((height * MAX_DIMENSION) / width);
                        width = MAX_DIMENSION;
                    } else {
                        width = Math.round((width * MAX_DIMENSION) / height);
                        height = MAX_DIMENSION;
                    }
                }

                // 使用 canvas 进行压缩
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // 将压缩后的图片转换为Base64，这里使用JPEG格式并设置了压缩质量
                const compressedBase64 = canvas.toDataURL('image/jpeg', 0.8);
                resolve(compressedBase64);
            };
            img.onerror = reject;
            img.src = event.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}
// ▼▼▼ 把下面所有新函数，都粘贴到你的 JS 代码区 ▼▼▼

// 函数1：显示分组选择弹窗 (核心)
async function showGroupSelectorModal(contactId) {
    const modal = document.getElementById('group-selector-modal');
    const listEl = document.getElementById('group-selector-list');
    listEl.innerHTML = ''; // 清空旧列表

    const contact = await kokoMemory.get('contacts', contactId);
    const allGroups = await kokoMemory.getAll('contactGroups');

    // 1. 添加一个“未分组”的选项
    const ungroupedItem = document.createElement('div');
    ungroupedItem.className = 'contact-picker-item';
    ungroupedItem.innerHTML = `<label style="width: 100%; cursor: pointer;"><input type="radio" name="group-select" value="null" ${!contact.groupId ? 'checked' : ''}> 未分组</label>`;
    ungroupedItem.addEventListener('click', () => moveContactToGroup(contactId, null));
    listEl.appendChild(ungroupedItem);

    // 2. 渲染所有已创建的分组
    allGroups.forEach(group => {
        const groupItem = document.createElement('div');
        groupItem.className = 'contact-picker-item';
        groupItem.innerHTML = `<label style="width: 100%; cursor: pointer;"><input type="radio" name="group-select" value="${group.id}" ${contact.groupId === group.id ? 'checked' : ''}> ${group.name}</label>`;
        groupItem.addEventListener('click', () => moveContactToGroup(contactId, group.id));
        listEl.appendChild(groupItem);
    });

    // 3. 绑定弹窗上的按钮事件 (使用克隆节点防止重复绑定)
    const oldCreateBtn = document.getElementById('create-new-group-btn');
    const newCreateBtn = oldCreateBtn.cloneNode(true);
    oldCreateBtn.parentNode.replaceChild(newCreateBtn, oldCreateBtn);
    newCreateBtn.addEventListener('click', () => createNewGroup(contactId));

    // (管理分组功能我们稍后实现，先放个提示)
    const oldManageBtn = document.getElementById('manage-groups-btn');
    const newManageBtn = oldManageBtn.cloneNode(true);
    oldManageBtn.parentNode.replaceChild(newManageBtn, oldManageBtn);
    newManageBtn.addEventListener('click', () => alert('管理分组功能待开发...'));

    document.getElementById('close-group-selector-modal').onclick = () => modal.style.display = 'none';
    
    // 4. 显示弹窗
    modal.style.display = 'flex';
}

// ▼▼▼ 使用这个【修正版】替换掉你原来的 moveContactToGroup 函数 ▼▼▼
async function moveContactToGroup(contactId, groupId) {
    // 1. 从数据库获取最新的联系人数据
    const contact = await kokoMemory.get('contacts', contactId);
    
    if (contact) {
        // 2. 更新它的 groupId
        contact.groupId = (groupId === 'null' || groupId === null) ? null : groupId;
        
        // 3. 把更新后的数据存回数据库
        await kokoMemory.put('contacts', contact);

        // 4. 【核心修复】在这里同步更新内存中的 state 对象！
        const contactInState = state.contacts.find(c => c.id === contactId);
        if (contactInState) {
            contactInState.groupId = contact.groupId;
        }

        // 5. 现在用更新后的 state 重新渲染列表，界面就会立刻变化了
        await renderContacts();
    }
    
    // 6. 关闭弹窗
    document.getElementById('group-selector-modal').style.display = 'none';
}

// 函数3：创建新分组
async function createNewGroup(contactIdForRefresh) {
    const newGroupName = await showCustomPrompt('创建新分组', '请输入分组名称');
    if (newGroupName && newGroupName.trim()) {
        const newGroup = {
            id: 'group_' + Date.now(),
            name: newGroupName.trim()
        };
        await kokoMemory.put('contactGroups', newGroup);
        // 创建成功后，刷新分组选择弹窗，以显示新创建的分组
        showGroupSelectorModal(contactIdForRefresh);
    }
}

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- 【全新】图片圆形裁剪器辅助函数 ---
function createCircularImage(imageUrl, size) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = size;
        canvas.height = size;

        const img = new Image();
        // 尝试解决跨域问题，不一定对所有外部图片生效，但对base64和大部分图床有效
        img.crossOrigin = 'Anonymous'; 
        
        img.onload = () => {
            // 1. 创建一个圆形的剪裁路径
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.clip(); // 应用剪裁

            // 2. 智能计算图片绘制尺寸，实现 object-fit: cover 的效果，防止拉伸
            const aspect = img.width / img.height;
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (canvas.width / canvas.height > aspect) {
                drawWidth = canvas.width;
                drawHeight = canvas.width / aspect;
                offsetX = 0;
                offsetY = (canvas.height - drawHeight) / 2;
            } else {
                drawHeight = canvas.height;
                drawWidth = canvas.height * aspect;
                offsetX = (canvas.width - drawWidth) / 2;
                offsetY = 0;
            }
            
            // 3. 将图片绘制到被剪裁的画布上
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

            // 4. 将画布内容导出为新的 base64 图片 URL
            resolve(canvas.toDataURL('image/png'));
        };
        
        img.onerror = () => {
            // 如果图片加载失败，直接返回原始URL，避免整个图表崩溃
            console.warn(`图片加载失败，无法裁剪: ${imageUrl}`);
            resolve(imageUrl); // 降级处理
        };

        img.src = imageUrl;
    });
}
// --- 【全新】关系网络功能模块 V2.0 ---

let editingCharacterId = null; // 用于跟踪正在编辑的角色
let pendingNpcAvatarBase64 = null;

// 函数1：显示关系网页面 (不变)
async function showRelationshipScreen(contactId) {
    hideAllScreens();
    const screen = document.getElementById('relationship-network-screen');
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    document.getElementById('relationship-network-title').textContent = `${contact.name} 的关系网`;
    screen.style.display = 'flex';
    screen.dataset.currentContactId = contactId;

    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId); 
}
/**
 * (新) 辅助函数：将点击的关系填充到编辑器中
 */
function populateRelationshipEditor(dataset) {
    const { sourceId, targetId, relationship, detail } = dataset;

    // 1. 填充简单的字段
    document.getElementById('relation-source-select').value = sourceId;
    document.getElementById('relation-target-select').value = targetId;
    document.getElementById('relation-detail-input').value = detail;

    // 2. 智能填充“关系类型”下拉菜单
    const typeSelect = document.getElementById('relation-type-select');
    let optionExists = false;
    // 检查这个关系是不是一个“标准选项”
    for (let i = 0; i < typeSelect.options.length; i++) {
        if (typeSelect.options[i].value === relationship) {
            optionExists = true;
            break;
        }
    }

    if (optionExists) {
        // 选项存在 (例如 "朋友", "恋人"), 直接选中它
        typeSelect.value = relationship;
    } else {
        // 选项不存在 (是"自定义"的, 比如 "师徒")
        // 我们动态创建这个选项
        const newOption = new Option(relationship, relationship, true, true);
        // 插入到“自定义”选项的前面
        typeSelect.insertBefore(newOption, typeSelect.options[typeSelect.options.length - 1]);
    }
}
// (V7 僵尸猎手版) 渲染关系网：强制识别无效数据并允许删除
async function renderRelationshipNetwork(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    let networkData = await kokoMemory.get('relationshipNetworks', contactId);

    // --- 数据初始化 ---
    if (!networkData) networkData = { contactId: contactId, nodes: [], edges: [] };
    if (!networkData.nodes) networkData.nodes = [];
    if (!networkData.edges) networkData.edges = [];

    // 1. 核心节点保底
    if (!networkData.nodes.some(n => n.id === contactId)) {
        networkData.nodes.push({ id: contact.id, name: contact.name, avatar: contact.avatar, isContact: true });
    }
    if (!networkData.nodes.some(n => n.id === 'myProfile')) {
        networkData.nodes.push({ id: 'myProfile', name: state.myProfile.name + ' (你)', avatar: state.myProfile.avatar, isContact: true });
    }

    // 2. 自动填充逻辑 (保持不变)
    if (contact.isGroup) {
        if (contact.members) {
            contact.members.forEach(memberId => {
                if (memberId === 'myProfile' || networkData.nodes.some(n => n.id === memberId)) return;
                const memberProfile = state.contacts.find(c => c.id === memberId);
                if (memberProfile) {
                    networkData.nodes.push({ id: memberProfile.id, name: memberProfile.name, avatar: memberProfile.avatar, isContact: true });
                }
            });
        }
        if (contact.npcMembers) {
            contact.npcMembers.forEach(npc => {
                if (networkData.nodes.some(n => n.id === npc.id)) return;
                networkData.nodes.push({ id: npc.id, name: npc.name, avatar: npc.avatar, isContact: false, persona: npc.persona });
            });
        }
    }

    await kokoMemory.put('relationshipNetworks', networkData);
    
    // --- 3. 渲染列表 UI (核心修改区域) ---
    const charListEl = document.getElementById('character-list');
    charListEl.innerHTML = '';
    
    networkData.nodes.forEach(node => {
        let currentNodeName = node.name;
        let currentNodeAvatar = node.avatar;
        let statusTag = ""; 
        
        // 标记是否为核心不可删节点
        const isCoreMember = (node.id === contactId) || (node.id === 'myProfile');
        let canDelete = !isCoreMember; // 默认除了自己和群本身，都能删

        // --- 🕵️‍♀️ 僵尸侦测逻辑 ---
        if (!isCoreMember) {
            // 1. 检查是否为真实联系人
            const realContact = state.contacts.find(c => c.id === node.id);
            // 2. 检查是否为有效 NPC
            const validNpc = contact.npcMembers && contact.npcMembers.find(n => n.id === node.id);
            
            // 如果两边都找不到，说明是残留的僵尸数据！
            if (!realContact && !validNpc) {
                statusTag = '<span style="font-size:10px; background:#ffebee; color:#c62828; padding:1px 4px; border-radius:4px; margin-left:5px;">(数据残留/无效)</span>';
                canDelete = true; // 强制允许删除
            } else if (validNpc) {
                // 如果是 NPC，加个标
                statusTag = '<span style="font-size:10px; background:#eee; padding:1px 4px; border-radius:4px; margin-left:5px;">NPC</span>';
            } else if (realContact) {
                // 如果是真实联系人，更新头像和名字
                currentNodeName = realContact.name;
                currentNodeAvatar = realContact.avatar;
            }
        } else {
            // 核心节点更新
            if (node.id === contactId) { currentNodeName = contact.name; currentNodeAvatar = contact.avatar; }
            if (node.id === 'myProfile') { currentNodeName = (contact.customUserName || state.myProfile.name) + ' (你)'; currentNodeAvatar = contact.customUserAvatar || state.myProfile.avatar; }
        }

        const item = document.createElement('div');
        item.className = 'preset-item';
        
        // 只要不是核心成员，一律显示删除按钮
        const actionsHTML = !canDelete ? '' : `
            <div class="preset-actions">
                ${statusTag.includes('NPC') ? `<span class="preset-action-btn edit-character-btn" data-char-id="${node.id}" title="编辑角色"><i class="fas fa-edit"></i></span>` : ''}
                <span class="preset-action-btn delete delete-character-btn" data-char-id="${node.id}" title="强制移除"><i class="fas fa-trash-alt"></i></span>
            </div>
        `;
        
        item.innerHTML = `
            <div class="preset-info" style="display: flex; align-items: center;">
                <img src="${currentNodeAvatar || 'https://via.placeholder.com/40'}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 15px;">
                <div class="preset-name">
                    ${currentNodeName} 
                    ${statusTag}
                </div>
            </div>
            ${actionsHTML}
        `;
        charListEl.appendChild(item);
    });

    // 渲染下拉菜单 (也同步过滤掉无效数据)
    const sourceSelect = document.getElementById('relation-source-select');
    const targetSelect = document.getElementById('relation-target-select');
    sourceSelect.innerHTML = '';
    targetSelect.innerHTML = '';
    networkData.nodes.forEach(node => {
        // 只把有效的数据放进下拉框，防止选到僵尸
        // ... (这里的逻辑保持简单即可，主要是列表要能删)
        const displayName = node.name; 
        const option1 = new Option(displayName, node.id);
        const option2 = new Option(displayName, node.id);
        sourceSelect.appendChild(option1);
        targetSelect.appendChild(option2);
    });
    
    // 渲染关系列表 (保持不变)
    const listEl = document.getElementById('relationship-list');
    listEl.innerHTML = '';
    if (!networkData.edges || networkData.edges.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #888;">还没有任何关系。</p>';
    } else {
        networkData.edges.forEach(edge => {
            const sourceNode = networkData.nodes.find(n => n.id === edge.source);
            const targetNode = networkData.nodes.find(n => n.id === edge.target);
            const sName = sourceNode ? sourceNode.name : '未知(失效)';
            const tName = targetNode ? targetNode.name : '未知(失效)';

            const item = document.createElement('div');
            item.className = 'preset-item';
            item.innerHTML = `
                <div class="preset-info" 
                     data-source-id="${edge.source}" 
                     data-target-id="${edge.target}" 
                     data-relationship="${edge.relationship}" 
                     data-detail="${edge.detail || ''}"
                     style="cursor: pointer;" title="点击编辑">
                    <div class="preset-name">${sName} → ${tName}: 【${edge.relationship}】</div>
                    <div class="preset-desc">${edge.detail || '暂无细节描述'}</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn delete delete-relationship-btn" data-source-id="${edge.source}" data-target-id="${edge.target}" title="删除此关系">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
            listEl.appendChild(item);
        });
    }
}

// 函数3：保存/更新一条关系 (V2.1 简化版)
async function saveRelationship() {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const sourceId = document.getElementById('relation-source-select').value;
    const targetId = document.getElementById('relation-target-select').value;
    // ▼▼▼ 核心修改：直接读取最终值，不再处理弹窗 ▼▼▼
    const relationshipType = document.getElementById('relation-type-select').value;
    const detail = document.getElementById('relation-detail-input').value.trim();

    if(sourceId === targetId) return alert('不能和自己建立关系！');
    // 如果关系类型还是“自定义”，说明用户没输入，就阻止保存
    if (relationshipType === '自定义') {
        return alert('请先在弹出的输入框中指定一个自定义关系类型！');
    }

    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    const existingEdgeIndex = networkData.edges.findIndex(e => e.source === sourceId && e.target === targetId);

    if (existingEdgeIndex > -1) {
        networkData.edges[existingEdgeIndex].relationship = relationshipType;
        networkData.edges[existingEdgeIndex].detail = detail;
    } else {
        networkData.edges.push({ source: sourceId, target: targetId, relationship: relationshipType, detail: detail });
    }

    await kokoMemory.put('relationshipNetworks', networkData);

    document.getElementById('relation-detail-input').value = '';
    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId);
}

// 函数4：删除一条关系 (V2.0 大改版)
async function deleteRelationship(sourceId, targetId) {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const confirmed = await showCustomConfirm('删除关系', '确定要删除这条关系吗？', true);
    if (confirmed) {
        const networkData = await kokoMemory.get('relationshipNetworks', contactId);
        if (networkData && networkData.edges) {
            networkData.edges = networkData.edges.filter(e => !(e.source === sourceId && e.target === targetId));
            await kokoMemory.put('relationshipNetworks', networkData);
            await renderRelationshipNetwork(contactId);
            await renderRelationshipGraph(contactId); // 刷新图表
        }
    }
}

// (新 V3) 函数5：打开角色编辑/添加弹窗 (支持人设)
function openCharacterModal(character = null) {
    const modal = document.getElementById('character-modal');
    const preview = document.getElementById('character-avatar-preview');
    // (新) 获取人设输入框
    const personaInput = document.getElementById('character-persona-input');

    if (character) {
        // 编辑模式
        editingCharacterId = character.id;
        document.getElementById('character-modal-title').textContent = '编辑角色';
        document.getElementById('character-id-input').value = character.id;
        document.getElementById('character-name-input').value = character.name;
        personaInput.value = character.persona || ''; // (新) 加载人设
        
        if (character.avatar) {
            preview.src = character.avatar;
            preview.style.display = 'block';
        } else {
            preview.style.display = 'none';
        }
    } else {
        // 添加模式 (NPC)
        editingCharacterId = null;
        document.getElementById('character-modal-title').textContent = '添加新角色 (NPC)';
        document.getElementById('character-id-input').value = '';
        document.getElementById('character-name-input').value = '';
        personaInput.value = ''; // (新) 清空人设
        
        preview.src = '';
        preview.style.display = 'none';
    }
    modal.style.display = 'flex';
}

// (新 V3) 函数6：保存一个角色 (NPC) (支持人设)
async function saveCharacter() {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const name = document.getElementById('character-name-input').value.trim();
    // (新) 获取人设
    const persona = document.getElementById('character-persona-input').value.trim();
    
    if (!name || !persona) { // (新) 检查人设是否为空
        alert('请输入角色姓名和人设！');
        return;
    }

    const avatar = document.getElementById('character-avatar-preview').src;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);

    if (editingCharacterId) {
        // 编辑
        const char = networkData.nodes.find(n => n.id === editingCharacterId);
        if (char) {
            char.name = name;
            char.avatar = avatar; 
            char.persona = persona; // (新) 保存人设
        }
    } else {
        // 新增NPC
        networkData.nodes.push({
            id: 'npc_' + Date.now(),
            name: name,
            avatar: avatar, 
            isContact: false,
            persona: persona // (新) 保存人设
        });
    }

    await kokoMemory.put('relationshipNetworks', networkData);
    document.getElementById('character-modal').style.display = 'none';
    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId);
}

// (V3 强力删除版) 删除关系网中的角色节点
async function deleteCharacter(charId) {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const confirmed = await showCustomConfirm('移除角色', '确定要从关系网中移除这个角色吗？\n(这会删除所有与他/她连着的关系线，但不会影响他在其他群聊或私聊中的存在)', true);
    
    if (confirmed) {
        const networkData = await kokoMemory.get('relationshipNetworks', contactId);
        
        if (networkData) {
            // 1. 过滤掉目标节点
            const originalNodeCount = networkData.nodes.length;
            networkData.nodes = networkData.nodes.filter(n => n.id !== charId);
            
            // 2. 过滤掉所有相关的连线
            networkData.edges = networkData.edges.filter(e => e.source !== charId && e.target !== charId);
            
            // 3. 强制保存
            await kokoMemory.put('relationshipNetworks', networkData);
            
            // 4. 刷新界面
            await renderRelationshipNetwork(contactId);
            await renderRelationshipGraph(contactId);
            
            // 5. 验证是否删除成功（可选调试）
            if (networkData.nodes.length < originalNodeCount) {
                // alert("已成功清除残留数据！现在你可以重新导入了。");
            }
        }
    }
}

// --- 【全新】V7.0 关系网络图表渲染函数 (Canvas终极兼容版) ---
async function renderRelationshipGraph(contactId) {
    const graphContainer = document.getElementById('relationship-graph-container');
    if (!graphContainer) return;
    const myChart = echarts.init(graphContainer);

    // 这就是关键：我们拿到了当前这个聊天的联系人对象
    const contact = state.contacts.find(c => c.id === contactId); 
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    
    if(!networkData || !networkData.nodes || !networkData.nodes.length === 0) {
        myChart.clear(); 
        return;
    }

    // 1. 【核心修正】我们不再从头构建节点...
    const nodeInfos = networkData.nodes.map(node => {
        const isCenter = node.id === contactId;
        
        let finalName = node.name;
        let finalAvatar = node.avatar;

        if (node.id === contactId) {
            // 刷新关系网的主人公 (这部分不变)
            finalName = contact.name;
            finalAvatar = contact.avatar;
        
        } else if (node.id === 'myProfile') {
            // ▼▼▼ ✨ 这就是你想要的修复！✨ ▼▼▼
            // 刷新“你”（用户）
            // 优先使用当前 contact(TA) 里设置的马甲，如果没设置，再用全局 profile
            finalName = contact.customUserName || state.myProfile.name;
            finalName += ' (你)'; // 确保 "(你)" 标签还在
            finalAvatar = contact.customUserAvatar || state.myProfile.avatar;
            // ▲▲▲ ✨ 修复结束 ✨ ▲▲▲
            
        } else if (node.isContact) {
            // (刷新其他联系人的代码，这部分不变)
            const contactProfile = state.contacts.find(c => c.id === node.id);
            if(contactProfile) {
                finalName = contactProfile.name;
                finalAvatar = contactProfile.avatar;
            }
        }
        
        return {
            id: node.id,
            name: finalName, // <-- 现在用的是修复后的名字
            avatar: finalAvatar || `https://via.placeholder.com/${isCenter ? 60 : 45}/DDD/666?text=${finalName.substring(0,1)}`, // <-- 现在用的是修复后的头像
            size: isCenter ? 60 : 45
        }
    });

    // 2. 并行处理所有节点的图片 (这部分不变)
    const imagePromises = nodeInfos.map(node => createCircularImage(node.avatar, node.size));
    const circularImageUrls = await Promise.all(imagePromises);

    // 3. 用裁剪好的图片数据，构建ECharts节点 (这部分不变)
    const nodesForGraph = nodeInfos.map((node, index) => ({
        id: node.id,
        name: node.name, // 这里会自动用上我们刚刚修复好的 finalName
        symbolSize: node.size,
        symbol: 'image://' + circularImageUrls[index], // 这里会自动用上修复好的头像
        label: {
            show: true,
            position: 'bottom',
            color: '#333',
            fontWeight: 'bold'
        },
        itemStyle: {
            borderWidth: 2,
            borderColor: '#fff',
            shadowBlur: 6,
            shadowColor: 'rgba(0, 0, 0, 0.4)'
        }
    }));

    // 4. 配置图表 (不变)
    const option = {
        tooltip: {},
        series: [{
            type: 'graph',
            layout: 'force',
            roam: true,
            force: { repulsion: 250, edgeLength: 150, gravity: 0.05 },
            data: nodesForGraph, //把更新后的节点数据喂给图表
            links: networkData.edges ? networkData.edges.map(edge => ({
                source: edge.source,
                target: edge.target,
                label: { show: true, formatter: edge.relationship },
                tooltip: { formatter: edge.detail }
            })) : [],
            lineStyle: { opacity: 0.9, width: 2, curveness: 0.1 }
        }]
    };

    // 5. 应用配置 (不变)
    myChart.setOption(option);
    window.addEventListener('resize', () => { myChart.resize(); });
}
// (优化版) 打开“添加角色到名册”模态框
async function openAddToRosterModal() {
    const modal = document.getElementById('add-to-roster-modal');
    const contactSelect = document.getElementById('import-contact-select');
    const npcSelect = document.getElementById('import-existing-npc-select');
    
    contactSelect.innerHTML = '';
    npcSelect.innerHTML = '<option value="">-- 请选择 --</option>';

    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    
    // 获取当前正在编辑的关系网
    const currentNetwork = await kokoMemory.get('relationshipNetworks', contactId);
    const existingNodeIds = currentNetwork ? currentNetwork.nodes.map(node => node.id) : [];

    // --- A. 填充“真实联系人”列表 (不变) ---
    const importableContacts = state.contacts.filter(contact => 
        !contact.isGroup && 
        !existingNodeIds.includes(contact.id) && 
        contact.id !== contactId 
    );

    if (importableContacts.length > 0) {
        importableContacts.forEach(contact => {
            contactSelect.appendChild(new Option(contact.name, contact.id));
        });
        document.getElementById('confirm-import-contact-btn').disabled = false;
    } else {
        contactSelect.appendChild(new Option('没有可导入的联系人了', ''));
        document.getElementById('confirm-import-contact-btn').disabled = true;
    }

    // --- B. 填充“其他关系网 NPC”列表 (核心修改) ---
    const allNetworks = await kokoMemory.getAll('relationshipNetworks');
    const foundNPCs = new Map();

    for (const network of allNetworks) {
        const ownerContact = state.contacts.find(c => c.id === network.contactId);
        // 跳过自己：不能从当前正在编辑的这个关系网里导入
        if (network.contactId === contactId) continue;

        const ownerName = ownerContact ? ownerContact.name : "未知角色";

        if (network.nodes) {
            network.nodes.forEach(node => {
                // 筛选：是NPC + 不是自己 + 不在当前列表中
                if (!node.isContact && node.id !== 'myProfile' && !existingNodeIds.includes(node.id)) {
                    
                    if (!foundNPCs.has(node.id)) {
                        // ✨ 核心修改：把 sourceId (原主人ID) 也打包进去
                        foundNPCs.set(node.id, {
                            nodeData: node,
                            sourceName: ownerName,
                            sourceId: network.contactId 
                        });
                    }
                }
            });
        }
    }

    if (foundNPCs.size > 0) {
        foundNPCs.forEach((value, key) => {
            const label = `${value.nodeData.name} (来自: ${value.sourceName})`;
            const option = document.createElement('option');
            
            // ✨ 核心：将 NPC数据 和 原主人ID 一起存入 value
            const payload = {
                node: value.nodeData,
                sourceId: value.sourceId
            };
            option.value = JSON.stringify(payload); 
            option.textContent = label;
            npcSelect.appendChild(option);
        });
        document.getElementById('confirm-import-npc-btn').disabled = false;
    } else {
        npcSelect.innerHTML = '<option>没有发现其他 NPC</option>';
        document.getElementById('confirm-import-npc-btn').disabled = true;
    }

    modal.style.display = 'flex';
}
// ==========================================================
// =========== ▼▼▼ 聊天记录搜索核心功能 ▼▼▼ =================
// ==========================================================

// 1. 显示/隐藏搜索界面的函数
function showChatSearch() {
    const overlay = document.getElementById('chat-search-overlay');
    const input = document.getElementById('chat-search-input');
    // 清空上次的搜索
    input.value = '';
    document.getElementById('search-results-container').innerHTML = '<div class="search-placeholder">输入关键词搜索</div>';
    document.getElementById('clear-search-btn').style.display = 'none';
    
    overlay.style.display = 'flex';
    // 自动聚焦输入框，提升体验
    setTimeout(() => input.focus(), 100);
}
window.showChatSearch = showChatSearch; // 👈 把这个函数“导出”到全局
function hideChatSearch() {
    document.getElementById('chat-search-overlay').style.display = 'none';
}
window.hideChatSearch = hideChatSearch; // 👈 顺便把关闭函数也导出了
// 2. 执行搜索的核心函数
function performChatSearch(keyword) {
    const container = document.getElementById('search-results-container');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !keyword.trim()) {
        container.innerHTML = '<div class="search-placeholder">输入关键词搜索</div>';
        return;
    }

    const trimmedKeyword = keyword.trim().toLowerCase();
    const results = [];

    // 根据当前模式决定搜索哪个历史记录
    const historySource = (state.currentChatMode === 'sms') ? (contact.smsHistory || []) : (contact.history || []);

    // 遍历历史记录查找匹配项
    historySource.forEach(msg => {
        // 目前只支持搜索文本消息 (text) 和语音转文字 (voice)
        let contentToSearch = '';
        if (msg.type === 'text') {
            contentToSearch = msg.content;
        } else if (msg.type === 'voice' && msg.content.text) {
            contentToSearch = msg.content.text;
        }

        if (contentToSearch && contentToSearch.toLowerCase().includes(trimmedKeyword)) {
            results.push({
                msg: msg,
                // 获取发送者名字
                senderName: msg.sender === 'user' ? state.myProfile.name : (contact.isGroup ? (state.contacts.find(c=>c.id===msg.sender)?.name || '未知成员') : contact.name),
                // 保存用于显示的原始内容
                originalContent: contentToSearch 
            });
        }
    });

    // 渲染结果
    if (results.length === 0) {
        container.innerHTML = '<div class="search-placeholder">没有找到相关记录</div>';
    } else {
        container.innerHTML = ''; // 清空占位符
        // 按时间倒序排列，最新的在最上面 (符合大多数人的搜索习惯)
        results.reverse().forEach(result => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            // 核心：把消息ID存到 dataset 里，用于跳转
            item.dataset.messageId = result.msg.id;

            // 高亮关键词
            const highlightedContent = highlightKeyword(result.originalContent, keyword);

            item.innerHTML = `
                <div class="result-header">
                    <span class="result-sender">${result.senderName}</span>
                    <span class="result-time">${new Date(result.msg.timestamp).toLocaleString()}</span>
                </div>
                <div class="result-content">${highlightedContent}</div>
            `;

            // 绑定点击跳转事件
            item.addEventListener('click', () => {
                jumpToMessageAndHighlight(result.msg.id);
            });

            container.appendChild(item);
        });
    }
}

// 辅助函数：高亮关键词
function highlightKeyword(text, keyword) {
    // 使用正则表达式进行全局、不区分大小写的替换
    const regex = new RegExp(`(${keyword})`, 'gi');
    // 将匹配到的关键词用带颜色的 span 包裹
    return text.replace(regex, '<span class="highlight-keyword">$1</span>');
}

// --- 3. [终极优化] 跳转并高亮消息 (支持上下无限加载) ---
async function jumpToMessageAndHighlight(messageId) {
    hideChatSearch(); // 关闭搜索界面

    const isSmsMode = state.currentChatMode === 'sms';
    const messagesContainer = document.getElementById(isSmsMode ? 'sms-chat-messages' : 'chat-messages');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 1. 确定历史记录源
    const historySource = isSmsMode ? (contact.smsHistory || []) : (contact.history || []);
    const msgIndex = historySource.findIndex(m => m.id === messageId);
    
    if (msgIndex === -1) {
        return alert('定位失败：未在记录中找到该消息。');
    }

    // 2. 初始化切片范围 (初始显示前后 15 条，共 31 条)
    let currentStartIndex = Math.max(0, msgIndex - 15);
    let currentEndIndex = Math.min(historySource.length, msgIndex + 16);

    // 3. 清空屏幕，准备渲染
    messagesContainer.innerHTML = '';

    // ============================================================
    // 🎨 辅助函数：渲染一批消息并插入到指定位置
    // ============================================================
    const renderBatch = (messages, insertPosition = 'append') => {
        const fragment = document.createDocumentFragment();
        
        messages.forEach((msg, i) => {
            let isFirstInSequence = true;
            // 简单的头像判断逻辑 (对比前一条)
            // 注意：这里只在当前 batch 内部对比，跨 batch 边界可能会重复显示头像，
            // 但在历史查看模式下这是可以接受的，反而更清晰。
            if (i > 0) {
                const prevMsg = messages[i - 1];
                if (prevMsg.sender === msg.sender && 
                    prevMsg.type !== 'system_notification' && 
                    msg.type !== 'system_notification') {
                    isFirstInSequence = false;
                }
            }

            let messageEl;
            if (isSmsMode) {
                messageEl = createSmsMessageElement(msg);
            } else {
                messageEl = createMessageElement(msg, contact, isFirstInSequence);
            }

            if (messageEl) fragment.appendChild(messageEl);
        });

        if (insertPosition === 'prepend') {
            // 插入到顶部加载按钮之后
            const topBtn = document.getElementById('history-load-prev-btn');
            if (topBtn && topBtn.nextSibling) {
                messagesContainer.insertBefore(fragment, topBtn.nextSibling);
            } else {
                // 如果没有按钮（理论上不应该），直接插到最前
                messagesContainer.prepend(fragment);
            }
        } else {
            // 插入到底部加载按钮之前
            const bottomBtn = document.getElementById('history-load-next-btn');
            if (bottomBtn) {
                messagesContainer.insertBefore(fragment, bottomBtn);
            } else {
                messagesContainer.appendChild(fragment);
            }
        }
    };

    // ============================================================
    // 🔼 顶部区域：加载更早的消息 + 回到最新
    // ============================================================
    const topControlArea = document.createElement('div');
    topControlArea.id = 'history-load-prev-btn';
    topControlArea.style.cssText = "text-align:center; padding:10px; margin-bottom:10px;";

    // 按钮 A: 加载更早
    const loadOlderBtn = document.createElement('div');
    loadOlderBtn.style.cssText = "display:inline-block; padding:5px 15px; background:#f0f2f5; color:#666; border-radius:15px; font-size:12px; cursor:pointer; margin-right:10px;";
    loadOlderBtn.innerHTML = `<i class="fas fa-arrow-up"></i> 加载更早的消息`;
    
    // 按钮 B: 直接回到现在
    const backToNowBtn = document.createElement('div');
    backToNowBtn.style.cssText = "display:inline-block; padding:5px 15px; background:#e3f2fd; color:#1976d2; border-radius:15px; font-size:12px; cursor:pointer; font-weight:bold;";
    backToNowBtn.innerHTML = `<i class="fas fa-sign-out-alt"></i> 退出历史模式`;

    // 绑定事件：加载更早
    loadOlderBtn.onclick = () => {
        if (currentStartIndex <= 0) {
            loadOlderBtn.textContent = "已到达聊天记录起点";
            loadOlderBtn.style.cursor = "default";
            return;
        }
        
        // 1. 记录当前的滚动高度和位置
        const oldScrollHeight = messagesContainer.scrollHeight;
        const oldScrollTop = messagesContainer.scrollTop;

        // 2. 计算新范围
        const newStart = Math.max(0, currentStartIndex - 20);
        const newMessages = historySource.slice(newStart, currentStartIndex);
        
        // 3. 渲染并插入
        renderBatch(newMessages, 'prepend');
        
        // 4. 更新索引
        currentStartIndex = newStart;

        // 5. 核心：保持滚动位置不变 (防止画面乱跳)
        const newScrollHeight = messagesContainer.scrollHeight;
        messagesContainer.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);

        if (currentStartIndex === 0) {
            loadOlderBtn.textContent = "已到达起点";
        }
    };

    // 绑定事件：退出
    backToNowBtn.onclick = () => openChat(contact.id);

    topControlArea.appendChild(loadOlderBtn);
    topControlArea.appendChild(backToNowBtn);
    messagesContainer.appendChild(topControlArea);


    // ============================================================
    // 📜 中间区域：渲染初始切片
    // ============================================================
    // 为了让 appendChild 正常工作，我们先创建一个底部的占位符，再往它前面插
    const bottomControlArea = document.createElement('div');
    bottomControlArea.id = 'history-load-next-btn';
    messagesContainer.appendChild(bottomControlArea);

    // 渲染初始的 30 条
    const initialSlice = historySource.slice(currentStartIndex, currentEndIndex);
    renderBatch(initialSlice, 'append');


    // ============================================================
    // 🔽 底部区域：加载更新的消息
    // ============================================================
    bottomControlArea.style.cssText = "text-align:center; padding:15px; margin-top:10px; cursor:pointer; color:#666; font-size:12px; background:#f5f5f5; border-radius:8px;";
    
    const updateBottomBtnState = () => {
        const remaining = historySource.length - currentEndIndex;
        if (remaining > 0) {
            bottomControlArea.innerHTML = `<i class="fas fa-arrow-down"></i> 下方还有 ${remaining} 条消息 (点击加载)`;
            bottomControlArea.onclick = loadNewerMessages;
        } else {
            bottomControlArea.innerHTML = `<i class="fas fa-check"></i> 已显示最新消息 (点击刷新界面)`;
            bottomControlArea.style.backgroundColor = "#e8f5e9";
            bottomControlArea.style.color = "#2e7d32";
            bottomControlArea.onclick = () => openChat(contact.id); // 回到正常模式
        }
    };

    const loadNewerMessages = () => {
        if (currentEndIndex >= historySource.length) return;

        const newEnd = Math.min(historySource.length, currentEndIndex + 20);
        const newMessages = historySource.slice(currentEndIndex, newEnd);
        
        renderBatch(newMessages, 'append');
        
        currentEndIndex = newEnd;
        updateBottomBtnState();
        
        // 向下加载时，稍微滚动一点点，提示用户有新内容
        messagesContainer.scrollTop += 100; 
    };

    updateBottomBtnState(); // 初始化底部按钮文字


    // ============================================================
    // 🎯 滚动定位与高亮
    // ============================================================
    setTimeout(() => {
        const targetEl = messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
        if (targetEl) {
            targetEl.scrollIntoView({ behavior: 'auto', block: 'center' });
            highlightElement(targetEl);
        }
    }, 50);
}

// 辅助：高亮特效 (保持不变)
function highlightElement(el) {
    el.classList.remove('highlighted');
    void el.offsetWidth; 
    el.classList.add('highlighted');
}
// ==========================================================
// =========== ▲▲▲ 搜索功能结束 ▲▲▲ =========================
// --- ✨ 新增：导出主题功能 (V2 - 自定义命名版) ✨ ---
async function exportTheme() {
    try {
        // 1. 定义哪些数据属于“主题”
        const themeKeys = [
            'chatBackground', 'customBubbleCss', 'customThemeCss', 
            'customNarrativeCss', 'customFontSize', 'customFontUrl', 'customFontName'
        ];

        // 2. 打包数据
        const themeData = {};
        themeKeys.forEach(key => {
            themeData[key] = userSettings[key];
        });
        themeData._info = {
            type: 'koko_theme_pack',
            version: 1,
            exported_at: Date.now()
        };

        // 3. ✨ 核心新增：弹窗询问文件名 ✨
        // 生成一个默认名字，比如 "koko_theme_2023-11-07"
        const defaultName = `koko_theme_${new Date().toLocaleDateString('zh-CN').replace(/\//g, '-')}`;
        let fileName = await showCustomPrompt('给主题起个名字', defaultName);

        // 如果用户点了取消，就终止导出
        if (fileName === null) return;

        // 如果用户没输入内容直接点了确定，就用默认名字
        fileName = fileName.trim() || defaultName;

        // 确保文件名以 .json 结尾
        if (!fileName.toLowerCase().endsWith('.json')) {
            fileName += '.json';
        }

        // 4. 生成并下载文件
        const jsonString = JSON.stringify(themeData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName; // <--- 使用你起的新名字！
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert(`主题包“${fileName}”已成功导出！`);

    } catch (error) {
        console.error('导出主题失败:', error);
        alert('导出失败，请重试。');
    }
}

// --- ✨ 新增：导入主题功能 ✨ ---
function importTheme(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const themeData = JSON.parse(e.target.result);

            // 简单的验证：看看它是不是咱们 Koko 的主题包
            if (themeData._info && themeData._info.type !== 'koko_theme_pack') {
                if (!confirm('警告：这个文件看起来不像标准的 Koko 主题包。确定要继续导入吗？')) {
                    event.target.value = ''; // 清空选择
                    return;
                }
            }

            // 1. 定义允许导入的字段（白名单机制，防止导入不安全的数据）
            const allowedKeys = [
                'chatBackground', 'customBubbleCss', 'customThemeCss', 
                'customNarrativeCss', 'customFontSize', 'customFontUrl', 'customFontName'
            ];

            // 2. 覆盖当前的设置
            let importCount = 0;
            allowedKeys.forEach(key => {
                if (themeData.hasOwnProperty(key)) {
                    userSettings[key] = themeData[key];
                    importCount++;
                }
            });

            // 3. 保存到数据库
            await kokoMemory.put('userSettings', userSettings);

            // 4. 立即应用新主题！
            applyAppearanceSettings();

            // 5. 极其重要：更新页面上的输入框，让它们显示新的值
            document.getElementById('bubble-css-input').value = userSettings.customBubbleCss || '';
            document.getElementById('theme-css-input').value = userSettings.customThemeCss || '';
            document.getElementById('narrative-css-input').value = userSettings.customNarrativeCss || '';
            document.getElementById('font-size-input').value = userSettings.customFontSize || '';
            document.getElementById('font-url-input').value = userSettings.customFontUrl || '';
            document.getElementById('font-name-input').value = userSettings.customFontName || '';
            // 更新预览框
            setTimeout(loadPreviewFromInputs, 50);

            alert(`成功导入了主题！(更新了 ${importCount} 项设置)`);

        } catch (error) {
            console.error('导入主题失败:', error);
            alert('导入失败：文件格式错误。');
        } finally {
            event.target.value = ''; // 清空文件选择控件，确保下次能选同一个文件
        }
    };
    reader.readAsText(file);
}
// ==========================================================
// =========================================
// 🎵 全新音乐搜索核心模块 (内置代理版) 🎵
// =========================================

// 你提供的固定代理地址
const BUILTIN_MUSIC_API = 'https://kokomusic.netlify.app/api';

// 1. 核心搜索函数
async function searchMusicInModal(keyword) {
    // ✨ 核心改动：直接使用内置地址，不再从设置里读取
    const apiBase = BUILTIN_MUSIC_API;
    
    const resultsContainer = document.getElementById('music-search-results-modal');
    resultsContainer.innerHTML = '<p style="text-align: center; color: #666;"><i class="fas fa-spinner fa-spin"></i> 正在搜索...</p>';

    try {
        // 使用 V3 代理的搜索方式
        const response = await fetch(`${apiBase}?word=${encodeURIComponent(keyword)}`);
        const resData = await response.json();

        if (resData.code !== 200 || !Array.isArray(resData.data) || resData.data.length === 0) {
            resultsContainer.innerHTML = '<p style="text-align: center; color: #999;">未找到相关歌曲，换个关键词试试？</p>';
            return;
        }

        // 渲染结果列表
        let html = '<div class="preset-list" style="gap: 5px; box-shadow: none; border: none; background: transparent; padding: 0;">';
        resData.data.forEach(song => {
            html += `
                <div class="preset-item music-search-result-item" data-song-id="${song.id}" style="padding: 8px; cursor: pointer; align-items: center; border: 1px solid #eee;">
                    <img src="${song.cover}" style="width: 36px; height: 36px; border-radius: 4px; margin-right: 10px;">
                    <div class="preset-info" style="overflow: hidden;">
                        <div class="preset-name" style="font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${song.song}</div>
                        <div class="preset-desc" style="font-size: 12px; color: #999; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${song.singer}</div>
                    </div>
                    <i class="fas fa-cloud-download-alt" style="color: var(--theme-accent, #007AFF); opacity: 0.7;"></i>
                </div>
            `;
        });
        html += '</div>';
        resultsContainer.innerHTML = html;

        // 绑定点击事件
        resultsContainer.querySelectorAll('.music-search-result-item').forEach(item => {
            item.addEventListener('click', () => fetchMusicDetailsForModal(item.dataset.songId));
        });

    } catch (error) {
        console.error("搜索出错:", error);
        resultsContainer.innerHTML = `<p style="text-align: center; color: var(--soft-red);">搜索出错: ${error.message}</p>`;
    }
}

// 2. 核心详情获取 & 自动填充函数
async function fetchMusicDetailsForModal(songId) {
    // ✨ 核心改动：直接使用内置地址
    const apiBase = BUILTIN_MUSIC_API;
    
    const resultsContainer = document.getElementById('music-search-results-modal');
    const originalContent = resultsContainer.innerHTML; // 备份列表，失败时恢复
    resultsContainer.innerHTML = '<p style="text-align: center; color: #666;"><i class="fas fa-spinner fa-spin"></i> 正在获取链接和歌词...</p>';

    try {
        // 并行请求详情(vkeys)和歌词(网易云)
        // 注意：这里使用了 V4 测试版里的“暗号”逻辑
        const detailUrl = `${apiBase}?id=${songId}`;
        // 我们的代理支持用 ?type=lyric 来区分请求
        const lyricUrl = `${apiBase}?type=lyric&id=${songId}&lv=1&kv=1&tv=-1`;

        const [detailRes, lyricRes] = await Promise.all([
            fetch(detailUrl),
            fetch(lyricUrl)
        ]);

        const detailData = await detailRes.json();
        // 歌词API有时候返回 text 有时候返回 json，这里做个容错处理
        let lyricData = {};
        try { lyricData = await lyricRes.json(); } catch (e) { console.warn("歌词非JSON格式"); }

        if (detailData.code !== 200 || !detailData.data || !detailData.data.url) {
            throw new Error("无法获取播放链接 (可能是VIP歌曲)");
        }

        // 提取歌词
        let lyricText = "";
        if (lyricData.lrc && lyricData.lrc.lyric) {
            lyricText = lyricData.lrc.lyric;
        }

        // 🎉 自动填充到下方的输入框！
        const song = detailData.data;
        document.getElementById('send-music-title-input').value = song.song;
        document.getElementById('send-music-artist-input').value = song.singer;
        document.getElementById('send-music-url-input').value = song.url;
        document.getElementById('send-music-lrc-input').value = lyricText; // 填充隐藏的歌词框
        document.getElementById('send-music-cover-input').value = song.cover || '';

        // 恢复列表显示，并给个小提示
        resultsContainer.innerHTML = originalContent;
        alert(`已自动填充：《${song.song}》\n点击下方的“确认分享”即可发送！`);

    } catch (error) {
        alert(`获取失败: ${error.message}`);
        resultsContainer.innerHTML = originalContent; // 恢复列表
    }
}
// ==========================================================
// ==========================================================
// =========== ▼▼▼ 新增：角色卡单独导入/导出功能 ▼▼▼ =========
// ==========================================================
// ==========================================================
// =========== ▼▼▼ PNG 角色卡核心引擎 (Tavern Card V2) ▼▼▼ ===
// ==========================================================

const PNG_Metadata = {
    // 将数据写入 PNG
    write: async (imageBlob, textData) => {
        const buffer = await imageBlob.arrayBuffer();
        const data = new Uint8Array(buffer);
        
        // 1. 准备 tEXt 块数据
        // 格式: keyword (chara) + null separator + base64_text
        const keyword = "chara";
        const base64Content = btoa(unescape(encodeURIComponent(textData))); // UTF-8 safe base64
        
        const chunkData = new Uint8Array(keyword.length + 1 + base64Content.length);
        for(let i=0; i<keyword.length; i++) chunkData[i] = keyword.charCodeAt(i);
        chunkData[keyword.length] = 0; // null separator
        for(let i=0; i<base64Content.length; i++) chunkData[keyword.length + 1 + i] = base64Content.charCodeAt(i);

        // 2. 构建 Chunk
        // Length (4 bytes) + Type (4 bytes) + Data + CRC (4 bytes)
        const chunkLength = chunkData.length;
        const fullChunk = new Uint8Array(4 + 4 + chunkLength + 4);
        
        // Length
        new DataView(fullChunk.buffer).setUint32(0, chunkLength, false);
        // Type (tEXt)
        fullChunk.set([116, 69, 88, 116], 4);
        // Data
        fullChunk.set(chunkData, 8);
        // CRC (简化处理，浏览器通常能容忍错误的CRC，或者我们可以计算它)
        // 为了代码精简，这里我们生成一个简单的占位CRC，大多数读取器只关心内容
        // 如果需要严格兼容，需要引入 CRC32 算法
        const crc = PNG_Metadata.crc32(fullChunk.subarray(4, 8 + chunkLength));
        new DataView(fullChunk.buffer).setUint32(8 + chunkLength, crc, false);

        // 3. 插入到 IHDR 块之后 (通常 index 33 或者是 8 + 25)
        // PNG signature (8) + IHDR (25) = 33
        const newPng = new Uint8Array(data.length + fullChunk.length);
        newPng.set(data.subarray(0, 33), 0);
        newPng.set(fullChunk, 33);
        newPng.set(data.subarray(33), 33 + fullChunk.length);

        return new Blob([newPng], { type: 'image/png' });
    },

    // 从 PNG 读取数据
    read: async (file) => {
        const buffer = await file.arrayBuffer();
        const view = new DataView(buffer);
        
        // 检查 PNG 头
        if (view.getUint32(0) !== 0x89504e47) throw new Error("不是有效的PNG图片");

        let offset = 8;
        while (offset < view.byteLength) {
            const length = view.getUint32(offset, false);
            const type = String.fromCharCode(
                view.getUint8(offset + 4), view.getUint8(offset + 5),
                view.getUint8(offset + 6), view.getUint8(offset + 7)
            );

            if (type === 'tEXt') {
                // 解析 tEXt 块
                const dataStart = offset + 8;
                const chunkData = new Uint8Array(buffer, dataStart, length);
                
                // 寻找 null separator
                let nullIndex = -1;
                for(let i=0; i<length; i++) {
                    if (chunkData[i] === 0) { nullIndex = i; break; }
                }

                if (nullIndex > -1) {
                    const keyword = new TextDecoder().decode(chunkData.subarray(0, nullIndex));
                    if (keyword === 'chara') {
                        const base64Text = new TextDecoder().decode(chunkData.subarray(nullIndex + 1));
                        try {
                            const jsonStr = decodeURIComponent(escape(atob(base64Text)));
                            return JSON.parse(jsonStr);
                        } catch (e) {
                            console.error("PNG数据解析失败", e);
                        }
                    }
                }
            }
            // 跳过当前块 (Length + Type + Data + CRC)
            offset += 12 + length;
        }
        return null;
    },

    // 简易 CRC32 表生成与计算
    crcTable: [],
    makeCrcTable: function() {
        let c;
        for(let n =0; n < 256; n++){
            c = n;
            for(let k =0; k < 8; k++){
                c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
            }
            this.crcTable[n] = c;
        }
    },
    crc32: function(buf) {
        if (this.crcTable.length === 0) this.makeCrcTable();
        let crc = 0 ^ (-1);
        for (let i = 0; i < buf.length; i++ ) {
            crc = (crc >>> 8) ^ this.crcTable[(crc ^ buf[i]) & 0xFF];
        }
        return (crc ^ (-1)) >>> 0;
    }
};
// =========== ▲▲▲ 引擎结束 ▲▲▲ =============================
// 2. 【导入】点击按钮触发文件选择
document.getElementById('import-char-card-btn').addEventListener('click', () => {
    document.getElementById('import-char-card-input').click();
});
// ==========================================================
// =========== ▼▼▼ 新增：Koko 专属图片卡导入/导出 (纯净版) ▼▼▼
// ==========================================================

// 1. 【导出】Koko 专属图片卡 (最终增强版：带地图、CSS、设定、语音、背景)
document.getElementById('export-char-card-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return alert("未找到当前角色数据");

    const includeHistory = await showCustomConfirm(
        '导出角色卡', 
        '请选择导出模式：\n\n- 确定：【完整备份】(含聊天记录，适合迁移)。\n- 取消：【纯净分享】(仅含人设与设定，无隐私，适合分享)。', 
        false
    );

    const charData = JSON.parse(JSON.stringify(contact));
    let suffix = '完整备份';

    // 1. 清空头像数据 (使用图片本身作为头像，减小体积)
    charData.avatar = ""; 

    // 2. 【打包世界书】(之前的逻辑)
    if (charData.worldBooks && charData.worldBooks.length > 0) {
        charData._bundledWorldBooks = state.worldBooks.filter(book => charData.worldBooks.includes(book.id));
    }
    if (charData.snoopRelevantWorldBookIds && charData.snoopRelevantWorldBookIds.length > 0) {
        const snoopBooks = state.worldBooks.filter(book => charData.snoopRelevantWorldBookIds.includes(book.id));
        charData._bundledWorldBooks = charData._bundledWorldBooks || [];
        snoopBooks.forEach(sb => {
            if (!charData._bundledWorldBooks.find(b => b.id === sb.id)) {
                charData._bundledWorldBooks.push(sb);
            }
        });
    }

    // 3. 【核心新增：打包关联地图】
    if (charData.mapId) {
        const mapData = state.maps.find(m => m.id === charData.mapId);
        if (mapData) {
            charData._bundledMap = mapData; // 把整张地图数据包进去
        }
    }

    if (!includeHistory) {
        suffix = '分享卡';
        // --- 清洗隐私数据 ---
        
        // 清空记录
        charData.history = []; charData.diary = []; charData.smsHistory = [];
        charData.memories = []; charData.permanent_memories = [];
        
        // 清空用户侧的私有设定 (但也保留了部分通用设定)
        charData.userPersona = ''; charData.customUserName = null; 
        charData.customUserAvatar = null; 
        // charData.customChatBackground = null; // 保留背景图
        // charData.customBubbleCss = null;      // 【保留】角色专属CSS
        
        charData.userVoiceProvider = ''; charData.userVoiceId = ''; 
        // 注意：charData.voiceId (角色语音) 和 charData.minimaxGroupId 等是保留的

        // 清空游戏和状态数据
        charData.luckyChar = null; charData.luckyCharInventory = []; 
        charData.luckyCharGacha = null; charData.sparkData = null; 
        charData.pet = null; charData.gold_coins = 50; 
        charData.transactions = []; 
        charData.sharedPlaylist = { tracks: [], currentIndex: 0, playbackMode: 'list', isPlaying: false }; 
        charData.totalListenTime = 0;
        
        // 重置状态
        charData.apiCallCounter = 0; charData.unreadCount = 0; 
        charData.blockedStatus = 'none'; charData.firstChatDate = Date.now();
        charData.status = '在线'; 
        
        // 【明确保留】以下字段原本就不会被清除，这里注释说明一下：
        // charData.isTimeAware (时间感知) - 保留
        // charData.isAvatarHidden (隐藏头像) - 保留
        // charData.mapId (地图关联) - 保留
    }

    const exportObj = {
        type: 'koko_character_card', 
        version: 1,
        timestamp: Date.now(),
        data: charData
    };
    const jsonString = JSON.stringify(exportObj);

    // 准备底图
    let sourceImage = contact.avatar;
    if (!sourceImage || sourceImage.length < 100) {
        sourceImage = "https://s21.ax1x.com/2025/11/09/pZ9FrMd.png"; 
    }

    try {
        const imageBlob = await new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.onload = () => {
                const MAX_SIZE = 720; 
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > MAX_SIZE) { height *= MAX_SIZE / width; width = MAX_SIZE; }
                } else {
                    if (height > MAX_SIZE) { width *= MAX_SIZE / height; height = MAX_SIZE; }
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, width, height);
                
                canvas.toBlob(resolve, 'image/png');
            };
            img.onerror = (e) => reject(new Error("图片加载失败"));
            img.src = sourceImage;
        });

        const finalPngBlob = await PNG_Metadata.write(imageBlob, jsonString);

        const url = URL.createObjectURL(finalPngBlob);
        const a = document.createElement('a');
        a.href = url;
        const safeName = contact.name.replace(/[\\/:*?"<>|]/g, '_');
        a.download = `KokoCard_${safeName}_${suffix}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        let successInfo = `成功导出！\n模式：${suffix}\n包含：背景、设定、语音配置`;
        if(charData._bundledWorldBooks) successInfo += `、${charData._bundledWorldBooks.length}本世界书`;
        if(charData._bundledMap) successInfo += `、地图数据`;
        
        alert(successInfo);

    } catch (e) {
        console.error("图片生成失败", e);
        alert("导出失败：" + e.message);
    }
});

// 2. 【导入】支持 PNG (修复版：增加防崩溃检查，自动解包地图、世界书、背景、语音、CSS)
document.getElementById('import-char-card-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        let importedData = null;
        let imageBase64 = null; 

        if (file.type === 'image/png') {
            // --- PNG 模式 ---
            importedData = await PNG_Metadata.read(file);
            if (!importedData) throw new Error("这张图片不是 Koko 角色卡 (未检测到数据)。");

            try {
                imageBase64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            const MAX_DIMENSION = 800; 
                            let { width, height } = img;
                            if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                                if (width > height) { height *= MAX_SIZE / width; width = MAX_DIMENSION; }
                                else { width *= MAX_DIMENSION / height; height = MAX_DIMENSION; }
                            }
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            resolve(canvas.toDataURL('image/jpeg', 0.8));
                        };
                        img.onerror = reject;
                        img.src = event.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            } catch (imgErr) {
                console.warn("头像压缩失败:", imgErr);
            }
            
        } else {
            // --- JSON 模式 ---
            const text = await file.text();
            importedData = JSON.parse(text);
        }

        let newContact;
        if (importedData.type === 'koko_character_card' && importedData.data) {
            newContact = importedData.data;
        } else {
            throw new Error("格式错误：这似乎不是一张 Koko 角色卡。");
        }

        if (imageBase64) {
            newContact.avatar = imageBase64;
        } else if (!newContact.avatar) {
            newContact.avatar = "https://s21.ax1x.com/2025/11/09/pZ9FrMd.png";
        }

        const timestamp = Date.now();
        newContact.id = `contact_imported_${timestamp}_${Math.floor(Math.random()*1000)}`;
        newContact.firstChatDate = Date.now();
        
        // -------------------------------------------------
        // ▼▼▼ 【修复点 1】强制重置分组ID ▼▼▼
        // -------------------------------------------------
        newContact.groupId = null; 
        newContact.isPinned = false; 

        // 补全缺失字段
        if (typeof newContact.isGroup === 'undefined') newContact.isGroup = false;
        if (!newContact.schedule) newContact.schedule = [];
        if (!newContact.events) newContact.events = [];

        // -------------------------------------------------
        // ▼▼▼ 【修复点 2】自动导入关联的世界书 (增加空值检查) ▼▼▼
        // -------------------------------------------------
        let addedBooksCount = 0;
        if (newContact._bundledWorldBooks && Array.isArray(newContact._bundledWorldBooks)) {
            
            // ★★★ 关键修复：如果 state.worldBooks 不存在，先初始化为空数组 ★★★
            if (!state.worldBooks) state.worldBooks = [];

            for (const book of newContact._bundledWorldBooks) {
                // 检查本地是否已存在同ID的书
                const exists = state.worldBooks.some(b => b.id === book.id);
                if (!exists) {
                    state.worldBooks.push(book);
                    await kokoMemory.put('worldBooks', book);
                    addedBooksCount++;
                }
            }
            if (addedBooksCount > 0) {
                await renderWorldBooks(); 
                await updateWorldBookSelectors();
            }
            delete newContact._bundledWorldBooks;
        }

        // -------------------------------------------------
        // ▼▼▼ 【修复点 3】自动导入关联的地图 (增加空值检查) ▼▼▼
        // -------------------------------------------------
        let mapImported = false;
        if (newContact._bundledMap) {
            const mapData = newContact._bundledMap;
            
            // ★★★ 关键修复：如果 state.maps 不存在，先初始化为空数组 ★★★
            if (!state.maps) state.maps = [];

            // 检查本地是否已有同ID地图
            const exists = state.maps.some(m => m.id === mapData.id);
            if (!exists) {
                state.maps.push(mapData);
                await kokoMemory.put('maps', mapData);
                mapImported = true;
            }
            delete newContact._bundledMap; 
        }

        state.contacts.push(newContact);
        await kokoMemory.put('contacts', newContact);
        await renderContacts();

        let successMsg = `🎉 成功导入角色：${newContact.name}`;
        if (newContact.customChatBackground) successMsg += `\n🖼️ 包含专属背景`;
        if (newContact.voiceId) successMsg += `\n🎙️ 包含语音配置`;
        if (newContact.customBubbleCss) successMsg += `\n🎨 包含专属样式`;
        if (addedBooksCount > 0) successMsg += `\n📚 导入了 ${addedBooksCount} 本世界书`;
        if (mapImported) successMsg += `\n🗺️ 导入了关联地图`;
        if (newContact.isTimeAware) successMsg += `\n⏰ 已开启时间感知`;
        
        alert(successMsg);

    } catch (error) {
        console.error("导入失败:", error);
        // 打印更详细的错误堆栈，方便调试
        alert(`导入失败：${error.message}`);
    } finally {
        e.target.value = '';
    }
});
// =========== ▲▲▲ 新增结束 ▲▲▲ =============================
// ==========================================================
// =========== ▼▼▼ 虚拟伴侣 (番茄钟) 核心逻辑 ▼▼▼ ==========
// ==========================================================

let cpConfig = {
    images: { normal: null, shy: null, angry: null, happy: null },
    zones: [],
    persona: '你是一个温柔、占有欲略强的男友。',
    focusDuration: 25
};

let cpIsEditing = false;
let cpSelectedZoneId = null;
let cpFocusTimer = null;
let cpFocusSecondsLeft = 0;
let cpImageResetTimer = null;

// ▼▼▼ 更新后的初始化函数 (包含沉浸模式入口) ▼▼▼
async function initCompanionApp() {
    console.log("正在初始化虚拟伴侣设置...");

    const settings = await kokoMemory.get('userSettings', 'main') || {};
    if (settings.companionData) {
        cpConfig = { ...cpConfig, ...settings.companionData };
    }
    
    if (typeof updateCpImagePreviews === 'function') updateCpImagePreviews();
    const charEl = document.getElementById('cp-character');
    if(charEl && cpConfig.images.normal) {
        charEl.style.backgroundImage = `url('${cpConfig.images.normal}')`;
    }
    
    // 填充输入框 (安全检查)
    const durationInput = document.getElementById('cp-duration-input');
    if (durationInput) durationInput.value = cpConfig.focusDuration || 25;

    const intervalInput = document.getElementById('cp-care-interval-input');
    if (intervalInput) intervalInput.value = (cpConfig.careInterval !== undefined) ? cpConfig.careInterval : 5;
    
    const selectEl = document.getElementById('cp-contact-select');
    if (selectEl) {
        selectEl.innerHTML = '<option value="">-- 请选择 (使用默认设定) --</option>';
        const validContacts = state.contacts.filter(c => !c.isGroup);
        validContacts.forEach(c => {
            const option = document.createElement('option');
            option.value = c.id;
            option.textContent = c.name;
            if (cpConfig.contactId === c.id) option.selected = true;
            selectEl.appendChild(option);
        });
    }

    // --- 插入语音开关 (之前的逻辑) ---
    let voiceToggleContainer = document.getElementById('cp-voice-setting-container');
    if (!voiceToggleContainer) {
        const insertPoint = document.getElementById('cp-duration-input').closest('.contact-form-group');
        voiceToggleContainer = document.createElement('div');
        voiceToggleContainer.id = 'cp-voice-setting-container';
        voiceToggleContainer.className = 'contact-form-group';
        voiceToggleContainer.style.cssText = "display:flex; justify-content:space-between; align-items:center; background:#f0f4ff; padding:10px; border-radius:8px; border:1px solid #c5cae9; margin-bottom: 10px;";
        
        voiceToggleContainer.innerHTML = `
            <div>
                <label class="contact-form-label" style="margin:0; color:#3f51b5; font-weight:bold;">🎙️ 开启语音互动</label>
                <div style="font-size:11px; color:#7986cb;">触摸或定时关怀时播放语音</div>
            </div>
            <label class="switch">
                <input type="checkbox" id="cp-voice-toggle">
                <span class="slider round"></span>
            </label>
        `;
        insertPoint.parentNode.insertBefore(voiceToggleContainer, insertPoint);
    }
    document.getElementById('cp-voice-toggle').checked = cpConfig.enableVoice || false;

    // --- ✨ 核心新增：插入沉浸模式按钮 ---
    let immersiveBtn = document.getElementById('cp-btn-immersive');
    if (!immersiveBtn) {
        // 找到“生成台词”按钮，插在它前面
        const genBtn = document.getElementById('cp-btn-gen-dialogue');
        
        immersiveBtn = document.createElement('button');
        immersiveBtn.id = 'cp-btn-immersive';
        immersiveBtn.className = 'cp-big-btn';
        // 给个漂亮的渐变色
        immersiveBtn.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
        immersiveBtn.style.color = 'white';
        immersiveBtn.style.marginBottom = '15px';
        immersiveBtn.innerHTML = '🕶️ 进入沉浸模式 (隐藏UI)';
        
        genBtn.parentNode.insertBefore(immersiveBtn, genBtn);

        // 绑定点击事件
        immersiveBtn.addEventListener('click', enterCpImmersiveMode);
    }
    // --- 新增结束 ---

    if (typeof cpRenderZones === 'function') cpRenderZones();
}

// ▼▼▼ 2. 更新保存函数 (保存语音开关状态) ▼▼▼
async function cpSaveSettings() {
    // 1. 保存联系人ID
    const contactSelect = document.getElementById('cp-contact-select');
    if(contactSelect) cpConfig.contactId = contactSelect.value;
    
    // 2. 保存人设 (如果存在)
    const personaInput = document.getElementById('cp-persona-input');
    if (personaInput) cpConfig.persona = personaInput.value;
    
    // 3. 保存时长
    const durationInput = document.getElementById('cp-duration-input');
    if (durationInput) cpConfig.focusDuration = parseInt(durationInput.value) || 25;
    
    // 4. 保存频率
    const intervalInput = document.getElementById('cp-care-interval-input');
    if (intervalInput) {
        const intervalVal = intervalInput.value;
        cpConfig.careInterval = (intervalVal === '' || parseInt(intervalVal) < 0) ? 5 : parseInt(intervalVal);
    }

    // --- ✨ 核心新增：保存语音开关 ---
    const voiceToggle = document.getElementById('cp-voice-toggle');
    if (voiceToggle) {
        cpConfig.enableVoice = voiceToggle.checked;
    }
    // --- 新增结束 ---

    // 5. 写入数据库
    const settings = await kokoMemory.get('userSettings', 'main') || { id: 'main' };
    settings.companionData = cpConfig;
    await kokoMemory.put('userSettings', settings);
    
    // 6. 刷新
    cpCareLinesCache = []; 
    alert('设置已保存！');
    document.getElementById('cp-settings-panel').style.display = 'none';
}
// 3. 图片上传处理
async function cpHandleImageUpload(e, type) {
    const file = e.target.files[0];
    if (!file) return;
    const base64 = await handleImageUpload(file); // 复用Koko的图片压缩
    cpConfig.images[type] = base64;
    
    updateCpImagePreviews();
    if(type === 'normal') {
        document.getElementById('cp-character').style.backgroundImage = `url('${base64}')`;
    }
    // 自动保存一下
    cpSaveSettings();
}

function updateCpImagePreviews() {
    ['normal', 'shy', 'angry', 'happy'].forEach(type => {
        const box = document.getElementById(`cp-preview-${type}`).parentNode;
        const preview = document.getElementById(`cp-preview-${type}`);
        if(cpConfig.images[type]) {
            preview.style.backgroundImage = `url('${cpConfig.images[type]}')`;
            preview.innerText = "";
            box.classList.add('has-img');
        } else {
            preview.style.backgroundImage = 'none';
            const emojis = { normal: '🏠', shy: '😳', angry: '💢', happy: '✨' };
            preview.innerText = emojis[type];
            box.classList.remove('has-img');
        }
    });
}

// 4. 热区系统
function cpRenderZones() {
    const container = document.getElementById('cp-zone-container');
    container.innerHTML = '';
    cpConfig.zones.forEach(zone => {
        const el = document.createElement('div');
        el.className = `cp-zone-circle ${zone.id === cpSelectedZoneId ? 'selected' : ''}`;
        el.style.left = zone.x + '%';
        el.style.top = zone.y + '%';
        el.style.width = zone.size + '%';
        el.style.paddingBottom = zone.size + '%';
        
        // 绑定点击
        el.onclick = (e) => {
            e.stopPropagation();
            if(cpIsEditing) {
                cpSelectedZoneId = zone.id;
                cpRenderZones();
                cpUpdateEditorUI();
            } else {
                cpTriggerZoneEvent(zone);
            }
        };
        container.appendChild(el);
    });
}

// ▼▼▼ 3. 更新触摸事件 (加入语音播放) ▼▼▼
async function cpTriggerZoneEvent(zone) {
    // 震动
    if(navigator.vibrate) navigator.vibrate(30);

    let text = "";
    let emotion = "normal";

    if (zone.lines && zone.lines.length > 0) {
        const randomPick = zone.lines[Math.floor(Math.random() * zone.lines.length)];
        text = randomPick.text;
        emotion = randomPick.emotion || "normal";
    } else {
        text = `你触碰了${zone.name}`;
    }

    cpShowBubble(text);
    cpChangeCharacterImage(emotion);

    // --- ✨ 核心新增：检查开关并播放语音 ---
    if (cpConfig.enableVoice && cpConfig.contactId) {
        const contact = state.contacts.find(c => c.id === cpConfig.contactId);
        // 只有当选择了联系人，且该联系人配置了语音时才播放
        if (contact && (contact.voiceId || contact.userVoiceId)) {
            // 使用 playNextInQueue 防止语音重叠
            // 这里的 'contact' 参数告诉函数用 AI 的声音
            playNextInQueue(text, contact); 
        }
    }
    // --- 新增结束 ---
}

function cpChangeCharacterImage(emotion) {
    const targetImage = cpConfig.images[emotion] || cpConfig.images.normal;
    if (!targetImage) return;

    document.getElementById('cp-character').style.backgroundImage = `url('${targetImage}')`;

    if (cpImageResetTimer) clearTimeout(cpImageResetTimer);
    if (emotion !== 'normal') {
        cpImageResetTimer = setTimeout(() => {
            if(cpConfig.images.normal) {
                document.getElementById('cp-character').style.backgroundImage = `url('${cpConfig.images.normal}')`;
            }
        }, 4000);
    }
}

function cpShowBubble(text) {
    const el = document.getElementById('cp-bubble');
    el.innerText = text;
    el.style.opacity = 1;
    el.style.transform = "translateX(-50%) translateY(0)";
    
    // 智能停留时间
    const time = Math.max(3000, text.length * 200);
    
    if(window.cpBubbleTimeout) clearTimeout(window.cpBubbleTimeout);
    window.cpBubbleTimeout = setTimeout(() => {
        el.style.opacity = 0;
        el.style.transform = "translateX(-50%) translateY(10px)";
    }, time);
}

// 5. 编辑模式
function cpEnterEditMode() {
    cpIsEditing = true;
    document.getElementById('cp-app-container').classList.add('cp-mode-edit');
    document.getElementById('cp-app-container').classList.remove('cp-mode-play');
    document.getElementById('cp-settings-panel').style.display = 'none';
    document.getElementById('cp-editor-toolbar').style.display = 'flex';
    document.getElementById('cp-bubble').innerText = "点击屏幕任意位置添加热区";
    document.getElementById('cp-bubble').style.opacity = 1;
}

function cpExitEditMode() {
    cpIsEditing = false;
    cpSelectedZoneId = null;
    document.getElementById('cp-app-container').classList.remove('cp-mode-edit');
    document.getElementById('cp-app-container').classList.add('cp-mode-play');
    document.getElementById('cp-editor-toolbar').style.display = 'none';
    cpSaveSettings(); // 自动保存
}

function cpUpdateEditorUI() {
    const controls = document.getElementById('cp-selected-controls');
    if (cpSelectedZoneId) {
        controls.style.display = 'flex';
        const zone = cpConfig.zones.find(z => z.id === cpSelectedZoneId);
        document.getElementById('cp-zone-name').value = zone.name;
        document.getElementById('cp-zone-size').value = zone.size;
    } else {
        controls.style.display = 'none';
    }
}

function cpUpdateCurrentZone() {
    if (!cpSelectedZoneId) return;
    const zone = cpConfig.zones.find(z => z.id === cpSelectedZoneId);
    zone.name = document.getElementById('cp-zone-name').value;
    zone.size = document.getElementById('cp-zone-size').value;
    cpRenderZones();
}

function cpDeleteCurrentZone() {
    if (!cpSelectedZoneId) return;
    cpConfig.zones = cpConfig.zones.filter(z => z.id !== cpSelectedZoneId);
    cpSelectedZoneId = null;
    cpRenderZones();
    cpUpdateEditorUI();
}

// ▼▼▼ 替换旧的 cpStartFocus 函数 (加入历史记录重置) ▼▼▼
function cpStartFocus() {
    if(!cpConfig.images.normal) return alert("请先在设置里上传【常态】立绘！");
    const task = document.getElementById('cp-task-input').value.trim() || "发呆";
    
    document.getElementById('cp-task-input-container').style.display = 'none';
    document.getElementById('cp-btn-start').style.display = 'none';
    document.getElementById('cp-btn-stop').style.display = 'block';
    document.getElementById('cp-timer-display').style.display = 'block';
    
    const totalDurationMins = cpConfig.focusDuration;
    cpFocusSecondsLeft = totalDurationMins * 60;
    cpUpdateTimerDisplay();
    
    const intervalSetting = (cpConfig.careInterval !== undefined) ? cpConfig.careInterval : 5;
    const intervalSec = intervalSetting * 60;

    // 🔥【关键修改】每次开始新任务，先清空缓存和历史记录
    cpPendingMessage = null;
    cpSessionHistory = []; 

    // 开场白
    const startMsg = `开始专注：${task}！我会一直陪着你的。`;
    cpShowBubble(startMsg);
    // 把开场白也记进去，防止AI第一句就重复开场白
    cpSessionHistory.push(startMsg);
    
    // 立即启动预加载
    if (intervalSec > 0 && intervalSec < cpFocusSecondsLeft) {
        const firstTargetElapsed = intervalSetting;
        const firstTargetRemaining = totalDurationMins - intervalSetting;
        cpPreloadCareMessage(task, firstTargetElapsed, firstTargetRemaining, totalDurationMins);
    }
    
    if(cpFocusTimer) clearInterval(cpFocusTimer);

    cpFocusTimer = setInterval(() => {
        cpFocusSecondsLeft--;
        cpUpdateTimerDisplay();
        
        if(cpFocusSecondsLeft <= 0) {
            cpFinishFocus();
            return;
        }
        
        const elapsedSec = (totalDurationMins * 60) - cpFocusSecondsLeft;
        
        if (intervalSec > 0 && elapsedSec > 0 && elapsedSec % intervalSec === 0) {
            
                        // A. 显示
            if (cpPendingMessage) {
                console.log(`[番茄钟] 显示预加载: ${cpPendingMessage.text}`);
                cpShowBubble(cpPendingMessage.text);
                cpChangeCharacterImage(cpPendingMessage.emotion);
                
                // --- ✨ 核心新增：定时关怀也要说话 ---
                if (cpConfig.enableVoice && cpConfig.contactId) {
                    const contact = state.contacts.find(c => c.id === cpConfig.contactId);
                    if (contact) {
                        playNextInQueue(cpPendingMessage.text, contact);
                    }
                }
                // --- 新增结束 ---

                cpPendingMessage = null;
            }

            // B. 预加载下一句
            const nextElapsedSec = elapsedSec + intervalSec;
            const nextRemainingSec = cpFocusSecondsLeft - intervalSec;
            
            if (nextRemainingSec > 0) {
                const nextElapsedMins = Math.floor(nextElapsedSec / 60);
                const nextRemainingMins = Math.ceil(nextRemainingSec / 60);
                cpPreloadCareMessage(task, nextElapsedMins, nextRemainingMins, totalDurationMins);
            }
        }
        
    }, 1000);
}
// ▲▲▲ 替换结束 ▲▲▲

function cpStopFocus() {
    if(!confirm("确定要放弃吗？")) return;
    clearInterval(cpFocusTimer);
    cpResetFocusUI();
    cpShowBubble("没关系，休息一下再来。");
}

function cpFinishFocus() {
    clearInterval(cpFocusTimer);
    cpResetFocusUI();
    if(navigator.vibrate) navigator.vibrate([200, 100, 200]);
    alert("专注完成！快去摸摸我作为奖励吧！");
    cpShowBubble("辛苦啦！我是你最好的奖励~ ❤️");
}

function cpResetFocusUI() {
    document.getElementById('cp-task-input-container').style.display = 'block';
    document.getElementById('cp-btn-start').style.display = 'block';
    document.getElementById('cp-btn-stop').style.display = 'none';
    document.getElementById('cp-timer-display').style.display = 'none';
}

function cpUpdateTimerDisplay() {
    const m = Math.floor(cpFocusSecondsLeft / 60).toString().padStart(2, '0');
    const s = (cpFocusSecondsLeft % 60).toString().padStart(2, '0');
    document.getElementById('cp-timer-display').innerText = `${m}:${s}`;
}

// 7. AI生成逻辑 (复用 Koko 的 generateAiResponse)
// 缓存的关怀语
let cpCareLinesCache = [];
// ▼▼▼ 新增：用于暂存下一条 AI 台词的缓存 ▼▼▼
let cpPendingMessage = null; 
// ▲▲▲ 新增结束 ▲▲▲
// ▼▼▼ 新增：用于记录本次专注期间 AI 说过的所有话 ▼▼▼
let cpSessionHistory = []; 
// ▲▲▲ 新增结束 ▲▲▲
// ▼▼▼ 替换旧的 cpPreloadCareMessage (加入去重逻辑) ▼▼▼
async function cpPreloadCareMessage(task, futureElapsedMins, futureRemainingMins, totalMins) {
    let personaContext = "";
    let chatHistoryContext = "(暂无聊天记录)";
    let userName = state.myProfile.name;
    
    const contactId = cpConfig.contactId;
    const contact = state.contacts.find(c => c.id === contactId);

    if (contact) {
        const charName = contact.name;
        const charPersona = contact.persona || "温柔的伴侣";
        const userPersona = contact.userPersona || state.myProfile.signature || "普通用户";

        if (contact.history && contact.history.length > 0) {
            chatHistoryContext = contact.history
                .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction' && msg.type !== 'system_notification')
                .slice(-30)
                .map(msg => `${msg.sender === 'user' ? userName : charName}: ${msg.content.replace(/<[^>]+>/g, '')}`)
                .join('\n');
        }

        personaContext = `
[角色身份]
你正在扮演: ${charName}
你的核心设定: ${charPersona}
[对话对象]
你的伴侣: ${userName}
TA在你眼中的设定: ${userPersona}
[相处模式参考]
${chatHistoryContext}`;
    } else {
        personaContext = `你的角色设定是：${cpConfig.persona || "温柔的虚拟伴侣"}`;
    }

    let timeContextDesc = "";
    if (futureRemainingMins <= 5 && totalMins > 10) {
        timeContextDesc = `🔴 冲刺阶段！(假设只剩 ${futureRemainingMins} 分钟)。请给予强力的鼓励，或期待休息。`;
    } else if (futureElapsedMins < 8) {
        timeContextDesc = `🟢 开始阶段。(假设已开始 ${futureElapsedMins} 分钟)。请让他静心。`;
    } else if (futureRemainingMins < totalMins / 2) {
        timeContextDesc = `🟡 下半场。(假设进度过半)。有点累了，请温柔鼓励。`;
    } else {
        timeContextDesc = `🔵 进行中。(假设已坚持 ${futureElapsedMins} 分钟)。给一句简单的陪伴。`;
    }

    // 🔥【关键修改】构建已说话语列表
    const spokenHistoryStr = cpSessionHistory.length > 0 
        ? cpSessionHistory.map((s, i) => `${i+1}. ${s}`).join('\n') 
        : "(本次专注尚未说话)";

    const prompt = `[SYSTEM]
${personaContext}

[当前情境]
${userName} 正在专注做：【${task}】。

[你在此次专注期间已经说过的话 (Session History)]
${spokenHistoryStr}

[生成任务]
请想象时间流逝到了：**${timeContextDesc}**
请预先生成 **1句** 最贴切的关怀语录。

[去重指令]
**严格禁止**重复上面"已经说过的话"中的句式或具体内容！请换一种说法、换一个角度（比如从关心身体、夸奖坚持、描绘休息后的奖励等不同角度切入）。

[要求]
1. **符合假设时间点**: 不要说“现在”，要带入假设的时间感。
2. **符合人设**: 语气自然。
3. **简短**: 30字以内，15字以上。
4. **返回格式**: 严格 JSON。 {"text": "台词内容", "emotion": "happy/shy/angry/normal"}

[JSON示例]
{"text":"稍微活动一下脖子吧，别太累了。","emotion":"normal"}`;

    try {
        const res = await generateAiResponse(null, [], prompt, false, 'chat');
        const jsonMatch = res.match(/\{[\s\S]*\}/);
        
        if(jsonMatch) {
            const data = JSON.parse(jsonMatch[0]);
            
            // 存入暂存区（等待时间到显示）
            cpPendingMessage = data;
            
            // 🔥【关键修改】生成成功后，立刻加入历史记录
            // 这样，当函数下一次被调用时，这一句话就已经在 "Session History" 里了，AI 就不会再说了。
            cpSessionHistory.push(data.text);
            
            console.log(`[番茄钟] 预加载成功: "${data.text}" (历史记录数: ${cpSessionHistory.length})`);
        }
    } catch(e) {
        console.error("预加载失败", e);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// 一键生成热区台词
// ▼▼▼ 视觉增强版：生成热区台词 (带图片识别) ▼▼▼
async function cpGenerateAllDialogues() {
    if(cpConfig.zones.length === 0) return alert("请先在编辑模式添加热区！");

    // 1. 获取按钮并设置加载状态
    const btn = window.event ? window.event.target : document.getElementById('cp-btn-gen-dialogue');
    const oldText = btn.innerText;
    btn.disabled = true;
    btn.innerText = "👀 AI 正在观察立绘并生成..."; // 提示语变了

    // --- 2. 构建人设与记忆上下文 ---
    let personaContext = "";
    let chatHistoryContext = "(暂无聊天记录)";
    let userName = state.myProfile.name;
    
    const contactId = cpConfig.contactId;
    const contact = state.contacts.find(c => c.id === contactId);

    if (contact) {
        const charName = contact.name;
        const charPersona = contact.persona || "普通人";
        const userPersona = contact.userPersona || state.myProfile.signature || "普通用户";

        // 提取最近聊天记录
        if (contact.history && contact.history.length > 0) {
            chatHistoryContext = contact.history
                .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction' && msg.type !== 'system_notification')
                .slice(-50)
                .map(msg => {
                    const senderName = msg.sender === 'user' ? userName : charName;
                    const content = msg.content.replace(/<[^>]+>/g, '');
                    return `${senderName}: ${content}`;
                })
                .join('\n');
        }

        personaContext = `
[角色身份]
你正在扮演: ${charName}
你的核心设定: ${charPersona}

[互动对象]
用户: ${userName}
TA在你眼中的设定: ${userPersona}

[你们的共同回忆 (最近聊天记录)]
(请参考以下记录来判断你们当前的关系亲密程度和相处模式)
===
${chatHistoryContext}
===
`;
    } else {
        personaContext = `你的角色设定是：${cpConfig.persona || "可爱的虚拟伴侣"}`;
    }

    const zoneNames = cpConfig.zones.map(z => z.name);
    
    // --- 3. 获取立绘图片 (Base64 或 URL) ---
    const charImage = cpConfig.images.normal; 

    // --- 4. 构建 视觉+文本 的混合指令 ---
    
    // 4a. 文本指令 (Text Prompt)
    // 关键：在 Prompt 里明确告诉 AI 要看图！
    const textPrompt = `[SYSTEM]
${personaContext}

[当前交互情境]
用户正在伸出手，触摸你（即附带图片中的人物）的不同身体部位。
请你保持“沉浸式角色扮演”，结合你的【视觉形象】、【性格】以及【关系状态】，对这些触摸做出反应。

[视觉关联指令 - 重要！]
请仔细观察附带的立绘图片：
1. **衣着与饰品**: 如果触摸部位有特殊的衣服（如丝袜、领带）或饰品（如眼镜、兽耳、帽子），台词中最好能体现出来！
2. **表情与姿态**: 根据图片中的神态来决定说话的语气（是高冷、羞涩还是元气）。

[生成任务]
为以下部位分别生成 5 句被触摸时的反应台词：${JSON.stringify(zoneNames)}。

[要求]
1. **符合关系**: 聊天记录甜蜜则害羞/享受，冷战则抗拒/傲娇。
2. **结合画面**: 如果摸头且图中有兽耳，可以说“别摸耳朵，很敏感”；如果摸腿且有丝袜，可以提及丝袜。
3. **格式**: 纯 JSON 对象。键是部位名，值是对象数组。
4. **对象结构**: {"text": "台词内容", "emotion": "happy/shy/angry/normal"} (emotion 请根据台词内容选择最匹配的表情)

[JSON示例]
{"头部": [{"text":"别弄乱我的发型！","emotion":"angry"}, {"text":"(蹭蹭手心) 嘿嘿...","emotion":"happy"}]}`;

    // 4b. 构造多模态消息体 (Multi-modal Message)
    const userMessageContent = [
        { type: "text", text: textPrompt }
    ];

    // 如果有图片，就塞进去！
    if (charImage) {
        userMessageContent.push({
            type: "image_url",
            image_url: { url: charImage }
        });
        console.log("已将立绘图片加入 Prompt，准备发送给视觉模型...");
    } else {
        console.warn("未找到常态立绘，将仅使用文本生成。");
    }

    const finalMessages = [
        { role: 'user', content: userMessageContent }
    ];

    try {
        // 5. 调用 AI (使用 forceMessages 后门)
        // 注意：第 6 个参数传入了包含图片的 messages 数组
        const res = await generateAiResponse(null, [], null, false, 'chat', finalMessages);
        
        const jsonMatch = res.match(/\{[\s\S]*\}/);
        
        if(jsonMatch) {
            const data = JSON.parse(jsonMatch[0]);
            let count = 0;
            
            // 6. 更新数据
            cpConfig.zones.forEach(z => {
                if(data[z.name]) {
                    z.lines = data[z.name];
                    count++;
                }
            });
            
            // 7. 保存并提示
            await cpSaveSettings(); // 自动保存
            alert(`✨ 视觉生成成功！\nAI 已根据立绘细节和你们的关系，更新了 ${count} 个部位的反应！`);
        } else {
            throw new Error("AI 返回格式错误");
        }
    } catch(e) {
        console.error(e);
        alert("生成失败：" + e.message + "\n(提示：请确保你使用的 API 模型支持图片识别，如 GPT-4o 或 Gemini-1.5-Pro)");
    } finally {
        btn.disabled = false;
        btn.innerText = oldText;
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ==========================================
// 🕶️ 沉浸模式逻辑 (双击空白处退出)
// ==========================================

// 1. 进入沉浸模式
function enterCpImmersiveMode() {
    // 隐藏设置面板
    document.getElementById('cp-settings-panel').style.display = 'none';
    
    // 给主屏幕加类名
    document.getElementById('companion-screen').classList.add('immersive');
    
    // 给个提示
    cpShowBubble("已进入沉浸模式。\n💡 双击屏幕空白处可退出。");
    
    // 绑定双击监听器
    const appContainer = document.getElementById('cp-app-container');
    appContainer.addEventListener('dblclick', handleImmersiveDoubleClick);
}

// 2. 退出沉浸模式
function exitCpImmersiveMode() {
    document.getElementById('companion-screen').classList.remove('immersive');
    cpShowBubble("欢迎回来！");
    
    // 解绑监听器
    const appContainer = document.getElementById('cp-app-container');
    appContainer.removeEventListener('dblclick', handleImmersiveDoubleClick);
}

// 3. 双击处理函数
function handleImmersiveDoubleClick(e) {
    // A. 必须是在沉浸模式下
    if (!document.getElementById('companion-screen').classList.contains('immersive')) return;

    // B. 【核心判断】如果点击的是“热区圆圈”，就不退出！
    // 这样用户双击热区（可能是想快速互动）时不会误退
    if (e.target.classList.contains('cp-zone-circle')) {
        return; 
    }

    // C. 只有点击背景容器（cp-zone-container 或其他空白层）时才退出
    if(navigator.vibrate) navigator.vibrate(50); // 震动反馈
    exitCpImmersiveMode();
}
// =========== ▲▲▲ 虚拟伴侣逻辑结束 ▲▲▲ ===================
// ==========================================
// 📱 反向查手机 (Phone Simulator) 核心逻辑 V2 (手动编辑版)
// ==========================================

// 1. 数据存储 (区分单聊/群聊)
let psData = {
    single_chat: [], 
    group_chat: [],  
    group_name: "相亲相爱一家人",
    tiktok: [],      
    browser: [],     
    alipay: [],      
    currentApp: 'wechat',
    wxMode: 'single' // 'single' | 'group'
};

// 临时变量，用于编辑
let psEditingIndex = -1; // -1 表示新增，>=0 表示编辑

// 2. 初始化与导航
document.getElementById('open-phone-sim-btn').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('phone-simulator-screen').style.display = 'flex';
    renderPhoneSimulator();
});

document.getElementById('back-from-phone-sim').addEventListener('click', () => {
    document.getElementById('phone-simulator-screen').style.display = 'none';
    document.getElementById('investment-center-screen').style.display = 'flex';
});

// 3. 应用切换逻辑
document.querySelectorAll('.ps-dock-item').forEach(item => {
    item.addEventListener('click', () => {
        const app = item.dataset.app;
        psData.currentApp = app;
        
        // 更新样式
        document.querySelectorAll('.ps-dock-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        const dock = document.getElementById('ps-dock');
        if (app === 'tiktok') dock.classList.add('dark-mode');
        else dock.classList.remove('dark-mode');

        document.querySelectorAll('.ps-screen-content').forEach(s => s.style.display = 'none');
        document.getElementById(`ps-screen-${app}`).style.display = 'block';
        
        renderPhoneSimulator();
    });
});

// 4. 微信模式切换
window.togglePsWxMode = function() {
    // 只有在微信界面才允许切换
    if (psData.currentApp !== 'wechat') return;
    
    if (psData.wxMode === 'single') {
        psData.wxMode = 'group';
    } else {
        psData.wxMode = 'single';
    }
    renderPhoneSimulator();
};

// 4. 核心渲染函数 (修正版：支持群名修改)
function renderPhoneSimulator() {
    // A. 微信
    const wxListEl = document.getElementById('ps-wx-list');
    const wxTitleEl = document.getElementById('ps-wx-title');
    const wxModeTag = document.getElementById('ps-wx-mode-tag');
    const renameBtn = document.getElementById('ps-rename-group-btn'); // 获取小铅笔
    
    wxListEl.innerHTML = '';
    
    // 决定使用哪份数据
    const chatData = psData.wxMode === 'single' ? psData.single_chat : psData.group_chat;
    
    // 更新标题和图标状态
    if (psData.wxMode === 'single') {
        wxTitleEl.textContent = '微信';
        wxModeTag.textContent = '单聊';
        wxModeTag.style.background = '#333';
        // 单聊隐藏改名笔
        if(renameBtn) renameBtn.style.display = 'none'; 
    } else {
        // 群聊显示自定义名字
        const memberCount = chatData.length + 1; // 假装人数
        wxTitleEl.textContent = `${psData.group_name} (${memberCount})`;
        wxModeTag.textContent = '群聊';
        wxModeTag.style.background = '#07c160'; // 绿色标
        // 群聊显示改名笔
        if(renameBtn) renameBtn.style.display = 'block'; 
    }

    chatData.forEach((msg, index) => {
        const isMe = msg.sender === 'me';
        const avatarColor = isMe ? '#95ec69' : '#ddd';
        const nameHtml = (psData.wxMode === 'group' && !isMe) ? `<div class="ps-wx-name">${msg.nickname || '群友'}</div>` : '';
        
        const div = document.createElement('div');
        div.onclick = () => openPsEditModal(index); 
        div.innerHTML = `
            <div class="ps-wx-time">${msg.time || ''}</div>
            <div class="ps-wx-msg ${isMe ? 'me' : ''}">
                <div class="ps-wx-avatar" style="background:${avatarColor}"></div>
                <div class="ps-wx-content">
                    ${nameHtml}
                    <div class="ps-wx-bubble">${msg.content}</div>
                </div>
            </div>
        `;
        wxListEl.appendChild(div);
    });

    // B. 抖音
    const dyListEl = document.getElementById('ps-dy-list');
    dyListEl.innerHTML = '';
    psData.tiktok.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'ps-dy-item';
        div.onclick = () => openPsEditModal(index);
        div.innerHTML = `
            <div class="ps-dy-cover"><i class="fas fa-play"></i></div>
            <div style="flex:1">
                <div style="font-size:14px; margin-bottom:5px;">${item.title}</div>
                <div style="color:#aaa; font-size:12px">@${item.author}</div>
            </div>`;
        dyListEl.appendChild(div);
    });

    // C. 浏览器
    const brListEl = document.getElementById('ps-br-list');
    brListEl.innerHTML = '';
    psData.browser.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'ps-br-item';
        div.onclick = () => openPsEditModal(index);
        div.innerHTML = `
            <i class="fas fa-clock" style="color:#ccc"></i>
            <div style="flex:1; font-size:14px;">${item.text}</div>
            <div style="font-size:12px; color:#ccc">${item.time}</div>`;
        brListEl.appendChild(div);
    });

    // D. 支付宝
    const aliListEl = document.getElementById('ps-ali-list');
    let totalExpense = 0;
    aliListEl.innerHTML = '';
    psData.alipay.forEach((item, index) => {
        if(item.type === 'expense') totalExpense += parseFloat(item.amount);
        const color = item.type === 'income' ? '#fe3b30' : '#333';
        const sign = item.type === 'income' ? '+' : '-';
        
        const div = document.createElement('div');
        div.className = 'ps-ali-item';
        div.onclick = () => openPsEditModal(index);
        div.innerHTML = `
            <div>
                <div style="font-size:15px;">${item.desc}</div>
                <div style="font-size:12px; color:#999">今天</div>
            </div>
            <div style="font-weight:bold; color:${color}">${sign}${item.amount}</div>`;
        aliListEl.appendChild(div);
    });
    document.getElementById('ps-ali-total').textContent = totalExpense.toFixed(2);
}

// 6. 手动添加按钮
document.getElementById('ps-add-btn').addEventListener('click', () => {
    openPsEditModal(-1); // -1 代表添加新条目
});

// 7. 打开编辑/添加弹窗 (核心逻辑：根据 APP 动态生成表单)
function openPsEditModal(index) {
    psEditingIndex = index;
    const modal = document.getElementById('ps-edit-modal');
    const formContainer = document.getElementById('ps-edit-form');
    const title = document.getElementById('ps-edit-title');
    
    // 获取当前数据源
    let dataSource;
    if (psData.currentApp === 'wechat') {
        dataSource = psData.wxMode === 'single' ? psData.single_chat : psData.group_chat;
    } else {
        dataSource = psData[psData.currentApp];
    }
    
    const item = (index >= 0 && dataSource[index]) ? dataSource[index] : {};
    title.textContent = index >= 0 ? "修改内容" : "添加新内容";
    formContainer.innerHTML = ''; // 清空

    // 动态生成表单 HTML
    let html = '';

    if (psData.currentApp === 'wechat') {
        // --- 微信表单 ---
        if (psData.wxMode === 'group' && index === -1 && !item.group_name_edited) {
             // 如果是群聊且还没改名，允许改群名 (这里简单处理，改群名功能放别处更好，这里只加消息)
        }
        
        const isMe = item.sender === 'me';
        html += `
            <div class="form-group">
                <label class="form-label">发送者</label>
                <select id="ps-edit-sender" class="form-input" onchange="togglePsNickInput(this.value)">
                    <option value="other" ${!isMe?'selected':''}>对方 / 群友</option>
                    <option value="me" ${isMe?'selected':''}>我 (绿色气泡)</option>
                </select>
            </div>
            <div class="form-group" id="ps-group-nick-group" style="display:${(psData.wxMode === 'group' && !isMe) ? 'block' : 'none'}">
                <label class="form-label">群昵称</label>
                <input type="text" id="ps-edit-nickname" class="form-input" value="${item.nickname || ''}">
            </div>
            <div class="form-group">
                <label class="form-label">消息内容</label>
                <textarea id="ps-edit-content" class="form-textarea" style="height:80px;">${item.content || ''}</textarea>
            </div>
            <div class="form-group">
                <label class="form-label">时间 (可选)</label>
                <input type="text" id="ps-edit-time" class="form-input" value="${item.time || ''}" placeholder="12:00">
            </div>
        `;
    } else if (psData.currentApp === 'alipay') {
        // --- 支付宝表单 ---
        const type = item.type || 'expense';
        html += `
            <div class="form-group">
                <label class="form-label">类型</label>
                <select id="ps-edit-ali-type" class="form-input">
                    <option value="expense" ${type==='expense'?'selected':''}>支出 (-)</option>
                    <option value="income" ${type==='income'?'selected':''}>收入 (+)</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">账单描述</label>
                <input type="text" id="ps-edit-ali-desc" class="form-input" value="${item.desc || ''}">
            </div>
            <div class="form-group">
                <label class="form-label">金额</label>
                <input type="number" id="ps-edit-ali-amount" class="form-input" value="${item.amount || ''}">
            </div>
        `;
    } else if (psData.currentApp === 'browser') {
        // --- 浏览器表单 ---
        html += `
            <div class="form-group">
                <label class="form-label">搜索/访问记录</label>
                <input type="text" id="ps-edit-br-text" class="form-input" value="${item.text || ''}">
            </div>
            <div class="form-group">
                <label class="form-label">时间</label>
                <input type="text" id="ps-edit-br-time" class="form-input" value="${item.time || '10:00'}">
            </div>
        `;
    } else if (psData.currentApp === 'tiktok') {
        // --- 抖音表单 ---
        html += `
            <div class="form-group">
                <label class="form-label">视频标题</label>
                <input type="text" id="ps-edit-dy-title" class="form-input" value="${item.title || ''}">
            </div>
            <div class="form-group">
                <label class="form-label">博主名字</label>
                <input type="text" id="ps-edit-dy-author" class="form-input" value="${item.author || ''}">
            </div>
        `;
    }

    // 添加保存和删除按钮
    html += `
        <div style="display:flex; gap:10px; margin-top:20px;">
            <button class="form-button" onclick="savePsItem()" style="background:var(--theme-primary);">保存</button>
            ${index >= 0 ? `<button class="form-button" onclick="deletePsItem()" style="background:#ff4d4f;">删除</button>` : ''}
        </div>
    `;

    formContainer.innerHTML = html;
    modal.style.display = 'flex';
}

// 辅助：切换微信群昵称输入框显示
window.togglePsNickInput = function(val) {
    const div = document.getElementById('ps-group-nick-group');
    if (psData.wxMode === 'group' && val === 'other') {
        div.style.display = 'block';
    } else {
        div.style.display = 'none';
    }
};

// 8. 保存编辑
window.savePsItem = function() {
    let newItem = {};
    const app = psData.currentApp;

    if (app === 'wechat') {
        newItem.sender = document.getElementById('ps-edit-sender').value;
        newItem.content = document.getElementById('ps-edit-content').value;
        newItem.time = document.getElementById('ps-edit-time').value;
        if (psData.wxMode === 'group') {
            newItem.nickname = document.getElementById('ps-edit-nickname').value;
        }
    } else if (app === 'alipay') {
        newItem.type = document.getElementById('ps-edit-ali-type').value;
        newItem.desc = document.getElementById('ps-edit-ali-desc').value;
        newItem.amount = document.getElementById('ps-edit-ali-amount').value;
    } else if (app === 'browser') {
        newItem.text = document.getElementById('ps-edit-br-text').value;
        newItem.time = document.getElementById('ps-edit-br-time').value;
    } else if (app === 'tiktok') {
        newItem.title = document.getElementById('ps-edit-dy-title').value;
        newItem.author = document.getElementById('ps-edit-dy-author').value;
    }

    // 确定目标数组
    let targetArray;
    if (app === 'wechat') {
        targetArray = psData.wxMode === 'single' ? psData.single_chat : psData.group_chat;
    } else {
        targetArray = psData[app];
    }

    // 新增或更新
    if (psEditingIndex >= 0) {
        targetArray[psEditingIndex] = newItem;
    } else {
        targetArray.push(newItem);
    }

    renderPhoneSimulator();
    document.getElementById('ps-edit-modal').style.display = 'none';
};

// 9. 删除条目
window.deletePsItem = function() {
    if (confirm("确定删除吗？")) {
        let targetArray;
        if (psData.currentApp === 'wechat') {
            targetArray = psData.wxMode === 'single' ? psData.single_chat : psData.group_chat;
        } else {
            targetArray = psData[psData.currentApp];
        }
        
        targetArray.splice(psEditingIndex, 1);
        renderPhoneSimulator();
        document.getElementById('ps-edit-modal').style.display = 'none';
    }
};
// --- 新增：修改模拟器群名称 ---
document.getElementById('ps-rename-group-btn').addEventListener('click', async (e) => {
    // 阻止冒泡，防止触发切换模式
    e.stopPropagation(); 
    
    const newName = await showCustomPrompt("修改群名称", psData.group_name);
    
    if (newName && newName.trim()) {
        psData.group_name = newName.trim();
        renderPhoneSimulator(); // 刷新界面
    }
});

// 10. AI 生成逻辑
document.getElementById('ps-ai-settings-btn').addEventListener('click', () => {
    document.getElementById('ps-ai-modal').style.display = 'flex';
});
document.getElementById('close-ps-ai-modal').addEventListener('click', () => {
    document.getElementById('ps-ai-modal').style.display = 'none';
});

document.getElementById('ps-generate-btn').addEventListener('click', async () => {
    const prompt = document.getElementById('ps-prompt-input').value.trim();
    if (!prompt) return alert("请输入剧情描述！");

    const btn = document.getElementById('ps-generate-btn');
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 生成中...';

    // 根据当前所在的微信模式生成
    const mode = psData.wxMode;

    const systemPrompt = `你是一个手机数据生成器。请根据用户描述生成JSON数据。
    [Keys说明]
    - single_chat: [{sender:'me'|'other', content:'', time:'HH:MM'}] (单聊记录，me是我，other是对方)
    - group_chat: [{sender:'me'|'other', nickname:'群昵称', content:'', time:'HH:MM'}] (群聊记录)
    - tiktok: [{title:'视频标题', author:'博主名'}] (抖音点赞记录)
    - browser: [{text:'搜索关键词', time:'HH:MM'}] (浏览历史)
    - alipay: [{type:'expense'|'income', desc:'账单描述', amount:100}] (支付宝账单)

    [生成规则]
    1. 请严格返回JSON格式，不要包含Markdown标记。
    2. 如果用户当前选择了${mode === 'single' ? '单聊' : '群聊'}模式，请重点生成 ${mode === 'single' ? 'single_chat' : 'group_chat'} 字段。
    3. 其他字段(tiktok/browser/alipay)也要生成一些符合剧情的辅助数据。
    `;

    try {
        const rawResponse = await generateAiResponse(null, [], systemPrompt, false, 'chat', [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: prompt }
        ]);

        const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            const newData = JSON.parse(jsonMatch[0]);
            
            // 合并数据
            if (newData.single_chat) psData.single_chat = newData.single_chat;
            if (newData.group_chat) psData.group_chat = newData.group_chat;
            if (newData.tiktok) psData.tiktok = newData.tiktok;
            if (newData.browser) psData.browser = newData.browser;
            if (newData.alipay) psData.alipay = newData.alipay;

            renderPhoneSimulator();
            document.getElementById('ps-ai-modal').style.display = 'none';
            alert("生成成功！");
        } else {
            throw new Error("AI生成格式错误");
        }
    } catch (e) {
        console.error(e);
        alert("生成失败：" + e.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
    }
});

// ==========================================
// 🚀 11. 终极合并转发系统 (V4.0 - 全家桶版)
// ==========================================

// 全局暂存最终要发送的数据包
let finalForwardData = null;

// A. 点击悬浮按钮 -> 打开“数据源选择器”
document.getElementById('ps-share-btn').addEventListener('click', () => {
    const modal = document.getElementById('ps-merge-selector-modal');
    const list = document.getElementById('ps-merge-list');
    list.innerHTML = '';

    // 定义可用数据源 (检查是否有数据)
    const sources = [
        { id: 'wechat', name: '微信聊天记录', icon: 'fab fa-weixin', color: '#07c160', hasData: (psData.wxMode==='single'?psData.single_chat:psData.group_chat).length > 0 },
        { id: 'alipay', name: '支付宝账单', icon: 'fab fa-alipay', color: '#1677ff', hasData: psData.alipay.length > 0 },
        { id: 'browser', name: '浏览器历史', icon: 'fab fa-safari', color: '#ff9800', hasData: psData.browser.length > 0 },
        { id: 'tiktok', name: '抖音点赞', icon: 'fab fa-tiktok', color: '#000', hasData: psData.tiktok.length > 0 }
    ];

    let validCount = 0;
    sources.forEach(s => {
        if (!s.hasData) return; // 没数据的 App 不显示
        validCount++;
        
        // 默认勾选当前所在的 App
        const isChecked = (s.id === psData.currentApp) ? 'checked' : '';
        
        const item = document.createElement('label');
        item.style.cssText = "display: flex; align-items: center; padding: 12px; background: #f9f9f9; border-radius: 8px; cursor: pointer; border: 1px solid #eee;";
        item.innerHTML = `
            <input type="checkbox" class="ps-merge-check" value="${s.id}" ${isChecked} style="transform: scale(1.2); margin-right: 10px;">
            <i class="${s.icon}" style="color: ${s.color}; font-size: 20px; margin-right: 10px;"></i>
            <span style="font-weight: 600; font-size: 14px;">${s.name}</span>
        `;
        list.appendChild(item);
    });

    if (validCount === 0) return alert("所有模拟器均无数据，无法转发！");

    modal.style.display = 'flex';
});

// B. 确认选择 -> 处理数据 -> 选人发送
document.getElementById('ps-confirm-merge-btn').addEventListener('click', async () => {
    const checkedBoxes = document.querySelectorAll('.ps-merge-check:checked');
    if (checkedBoxes.length === 0) return alert("请至少选择一项！");

    const selectedApps = Array.from(checkedBoxes).map(cb => cb.value);
    
    // 1. 关闭选择器
    document.getElementById('ps-merge-selector-modal').style.display = 'none';

    // 2. 如果包含了微信单聊，需要先问名字
    let targetName = "对方";
    if (selectedApps.includes('wechat') && psData.wxMode === 'single') {
        const inputName = await showCustomPrompt("转发设置", "微信单聊对象的名字是？", "前任");
        if (!inputName) return; // 用户取消
        targetName = inputName;
    }

    // 3. 构建合并数据包 (核心!)
    finalForwardData = buildMergedData(selectedApps, targetName);

    // 4. 打开联系人选择器
    openPsContactPicker();
});

// C. 核心：构建合并后的数据包
function buildMergedData(apps, targetName) {
    let allMessages = [];
    let participants = { 'myProfile': { name: state.myProfile.name } };
    let titleParts = [];

    // 辅助：添加分隔线消息
    const addSeparator = (text) => {
        allMessages.push({
            type: 'text',
            content: `———————— ${text} ————————`,
            sender: 'system_separator', // 特殊ID
            timestamp: Date.now()
        });
        participants['system_separator'] = { name: '系统分割线' };
    };

    // --- 1. 处理微信 ---
    if (apps.includes('wechat')) {
        const source = psData.wxMode === 'single' ? psData.single_chat : psData.group_chat;
        titleParts.push("聊天");
        
        // 注册参与者
        if (psData.wxMode === 'single') {
            participants['target_user'] = { name: targetName };
        } else {
            // 群聊名字动态注册
        }

        source.forEach(item => {
            let senderId, senderDisplayName;
            if (item.sender === 'me') {
                senderId = 'myProfile';
            } else {
                if (psData.wxMode === 'single') {
                    senderId = 'target_user';
                } else {
                    const nick = item.nickname || '群友';
                    senderId = `group_member_${nick}`;
                    senderDisplayName = nick;
                    // 动态注册群友
                    if (!participants[senderId]) participants[senderId] = { name: nick };
                }
            }
            
            allMessages.push({
                type: 'text',
                content: item.content,
                sender: senderId,
                timestamp: Date.now()
            });
        });
    }

    // --- 2. 处理支付宝 ---
    if (apps.includes('alipay')) {
        titleParts.push("账单");
        if (allMessages.length > 0) addSeparator("支付宝记录");
        
        participants['alipay_sys'] = { name: '支付宝' };
        
        psData.alipay.forEach(item => {
            const sign = item.type === 'income' ? '+' : '-';
            allMessages.push({
                type: 'text',
                content: `[${item.type==='income'?'收入':'支出'}] ${item.desc}\n金额：${sign}${item.amount}`,
                sender: 'alipay_sys',
                timestamp: Date.now()
            });
        });
        // 加上总计
        const total = document.getElementById('ps-ali-total').textContent;
        allMessages.push({
            type: 'text',
            content: `本月总支出：¥${total}`,
            sender: 'alipay_sys',
            timestamp: Date.now()
        });
    }

    // --- 3. 处理抖音 ---
    if (apps.includes('tiktok')) {
        titleParts.push("抖音");
        if (allMessages.length > 0) addSeparator("抖音点赞");
        
        participants['tiktok_sys'] = { name: '抖音' };
        
        psData.tiktok.forEach(item => {
            allMessages.push({
                type: 'text',
                content: `❤️ 视频：${item.title}\n博主：@${item.author}`,
                sender: 'tiktok_sys',
                timestamp: Date.now()
            });
        });
    }

    // --- 4. 处理浏览器 ---
    if (apps.includes('browser')) {
        titleParts.push("浏览");
        if (allMessages.length > 0) addSeparator("浏览历史");
        
        participants['browser_sys'] = { name: '浏览器' };
        
        psData.browser.forEach(item => {
            allMessages.push({
                type: 'text',
                content: `[${item.time}] 访问了：${item.text}`,
                sender: 'browser_sys',
                timestamp: Date.now()
            });
        });
    }

    // 生成标题 (例如: "聊天、账单、抖音记录")
    const finalTitle = titleParts.join("、") + "记录";

    return {
        sourceChatName: finalTitle,
        messages: allMessages,
        participants: participants
    };
}

// D. 打开联系人选择器 (复用逻辑)
function openPsContactPicker() {
    const modal = document.getElementById('repost-contact-picker-modal');
    const contactListEl = document.getElementById('repost-contact-list');
    const titleEl = modal.querySelector('.modal-title');
    
    contactListEl.innerHTML = '';
    if (titleEl) titleEl.textContent = `转发：${finalForwardData.sourceChatName}`;

    state.contacts.forEach(contact => {
        if (contact.isGroup) return; 
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
            <input type="checkbox" id="ps-share-final-${contact.id}" value="${contact.id}">
            <label for="ps-share-final-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                <img src="${contact.avatar}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                <span>${contact.name}</span>
            </label>
        `;
        contactListEl.appendChild(item);
    });

    // 绑定确认
    const confirmBtn = document.getElementById('confirm-repost-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

    newConfirmBtn.addEventListener('click', async () => {
        const selectedIds = Array.from(contactListEl.querySelectorAll('input:checked')).map(cb => cb.value);
        if (selectedIds.length === 0) return alert("请选择联系人");

        // 发送！
        for (const uid of selectedIds) {
            const contact = state.contacts.find(c => c.id === uid);
            if (contact) {
                await createAndAddMessage({ 
                    type: 'chat_history_share', 
                    content: finalForwardData 
                }, 'user', contact);
            }
        }

        modal.style.display = 'none';
        alert("已合并转发！");
    });
    
    modal.style.display = 'flex';
}
// =========== ▼▼▼ 股票 + 彩票 核心功能函数 ▼▼▼ ============
// ==========================================================
// ==========================================================
// =================== 海龟汤 游戏核心逻辑 (V5-关系网集成版) ===========
// ==========================================================

// --- 游戏全局变量 ---
let GAME_AI_TEAMMATES = []; // { name: "Koko", persona: "..." }
let GAME_SECRET_SOUP_BOTTOM = ""; 
let GAME_HOST_PERSONA_PROMPT = ""; // 存储GM的人设
let GAME_USER_PERSONA_PROMPT = ""; // 存储玩家的人设
let GAME_LAST_KEYWORDS = ""; // 存储上次的关键词
const GAME_HOST_NAME = "主持人";
let gameMessages = []; // 游戏历史
let tempAllNpcList = []; // (新) 临时存储从关系网读出的NPC

// --- 游戏DOM引用 ---
let gameChatScreen, gamePuzzleTextEl, gameChatLog, gameChatLogWrapper, 
    gameUserInput, gameAskHostBtn, gameDiscussBtn, gameSurrenderBtn, 
    gamePlayAgainBtn, gameInputArea, gameExitBtn;
let gameGmPersonaInput, gameCustomNpcsInput, gameKeywordsInput, gameUserPersonaSelect;

/**
 * 启动游戏时，集中获取一次所有DOM元素
 */
function cacheGameDOMElements() {
    gameChatScreen = document.getElementById('game-chat-screen');
    gamePuzzleTextEl = document.getElementById('game-puzzle-text');
    gameChatLog = document.getElementById('game-chat-log');
    gameChatLogWrapper = document.getElementById('game-chat-log-wrapper');
    gameUserInput = document.getElementById('game-user-input');
    gameAskHostBtn = document.getElementById('game-ask-host-btn');
    gameDiscussBtn = document.getElementById('game-discuss-btn');
    gameSurrenderBtn = document.getElementById('game-surrender-btn');
    gamePlayAgainBtn = document.getElementById('game-play-again-btn');
    gameInputArea = document.getElementById('game-input-area');
    gameExitBtn = document.getElementById('game-exit-btn');
    
    // 弹窗的引用
    gameGmPersonaInput = document.getElementById('game-gm-persona-input');
    gameCustomNpcsInput = document.getElementById('game-custom-npcs-input');
    gameKeywordsInput = document.getElementById('soup-keywords-input');
    gameUserPersonaSelect = document.getElementById('game-user-persona-select');
}

/**
 * (修复版) 显示“AI 正在思考中”的提示
 * 修复了气泡被撑大的问题
 */
function showGameLoadingIndicator() {
    removeGameLoadingIndicator(); 
    
    const indicatorHTML = `
        <div class="message-wrapper ai-player" id="game-typing-indicator">
            <div class="sender-name" style="color: #8e8e93;">AI 正在思考...</div>
            
            <div class="message" style="background-color: #2c2c2e; font-size: 18px; width: fit-content; display: inline-block; min-width: auto;">
                <i class="fas fa-spinner fa-spin"></i>
            </div>
        </div>
    `;
    
    gameChatLog.insertAdjacentHTML('beforeend', indicatorHTML);
    gameChatLogWrapper.scrollTop = gameChatLogWrapper.scrollHeight;
}

/**
 * (新) 移除“AI 正在思考中”的提示
 */
function removeGameLoadingIndicator() {
    const indicator = document.getElementById('game-typing-indicator');
    if (indicator) {
        indicator.remove();
    }
}


// --- (不变) AI 剧本 1: 游戏主持人 (GM)，用于创作谜题 ---
function getGMPrompt(keywords) {
    const keywordHint = keywords ? `请围绕这个关键词： "${keywords}"` : "请随机创作";
    return `[SYSTEM] 你是海龟汤（情景猜谜）的【出题官】。
[你的扮演人设]
${GAME_HOST_PERSONA_PROMPT}
[任务]
你的任务是创作一个【符合你人设的】、简短但有趣的海龟汤谜题。${keywordHint}。
[要求]
1.  **汤面 (face)**: 必须是简短、诡异、且信息不全的场景描述。
2.  **汤底 (bottom)**: 必须是揭示真相、逻辑自洽的答案。
[输出格式]
你必须严格按照 JSON 格式输出，不要有任何多余的解释或Markdown标记。
{
  "face": "...",
  "bottom": "..."
}`;
}

// --- (不变 V3) AI 剧本 2: 提问主持人 (支持群聊互动) ---
function getHostPrompt(history, userInput) {
    const teammateNames = GAME_AI_TEAMMATES.map(t => t.name).join('、 ');
    const teammatePersonas = GAME_AI_TEAMMATES.map(t => `- ${t.name} (人设: ${t.persona})`).join('\n');
    
    return `
[SYSTEM] 你是一个“海龟汤”(猜故事)的游戏AI。
你将同时扮演【多个角色】来推进游戏。

[你的核心身份]
你是 ${GAME_HOST_NAME} (人设: ${GAME_HOST_PERSONA_PROMPT})。

[你现在扮演的角色]
1.  **${GAME_HOST_NAME} (主持人)**:
    * **能力**: 你知道“汤底”(秘密答案)。
    * **规则**: 
        a. 当玩家提问时，你【只能】回答 "是"、"否" 或 "与此无关"。
        b. **【胜利检查】**: 在回答前，你必须【悄悄】判断玩家的问题是否已经非常接近或猜中了汤底。
2.  **${teammateNames} (AI队友们)**:
    * **能力**: 你【假装不知道】“汤底”。你和 "玩家" (人设: ${GAME_USER_PERSONA_PROMPT}) 是队友。
    * **规则**: 你的任务是“表演”得像一个真实的玩家。
    * **【关键互动】**: 你的队友们会【互相讨论】，而不是都只回复玩家。

[AI队友列表 (你将扮演他们)]
${teammatePersonas}

[秘密汤底 - 只有 ${GAME_HOST_NAME} 知道]
${GAME_SECRET_SOUP_BOTTOM}
[秘密汤底 结束]

[游戏历史记录]
${formatHistory(history)}

[当前任务]
玩家 (人设: ${GAME_USER_PERSONA_PROMPT}) 刚刚向【主持人】提问："${userInput}"

[你的行动]
1.  **[主持人-胜利检查]**: 玩家的提问 "${userInput}" 是否猜中了汤底？
2.  **[主持人-回答]**: 给出 "是"、"否" 或 "与此无关"。
3.  **[AI队友-表演]**: 扮演 1-2 名 AI 队友，针对主持人的回答，展开一段【你来我往】的简短讨论。

[输出格式] (必须严格遵守 Koko App 的剧本格式)
VERDICT: [这里填 "是" / "否" / "与此无关" / "VICTORY" (如果玩家猜中了)]

MESSAGE_START
SPEAKER: ${GAME_HOST_NAME}
CONTENT: [这里重复你的VERDICT，但如果是VICTORY，就说一句恭喜的话]
MESSAGE_END

MESSAGE_START
SPEAKER: [AI队友A的名字]
CONTENT: [队友A针对“主持人”的回答发表评论]
MESSAGE_END

(可选, 强烈推荐)
MESSAGE_START
SPEAKER: [AI队友B的名字]
CONTENT: [队友B【回复队友A】，而不是回复主持人]
MESSAGE_END
`;
}

// --- (不变 V3) AI 剧本 3: 和队友讨论 (支持群聊互动) ---
function getDiscussPrompt(history, userInput) {
    const teammateNames = GAME_AI_TEAMMATES.map(t => t.name).join('、 ');
    const teammatePersonas = GAME_AI_TEAMMATES.map(t => `- ${t.name} (人设: ${t.persona})`).join('\n');

    return `
[SYSTEM] 你【只】扮演 AI 队友们: ${teammateNames}。
你是一个正在玩“海龟汤”的普通玩家，你【不知道】秘密答案。
* 你的队友 "玩家" (人设: ${GAME_USER_PERSONA_PROMPT}) 正在和你私下讨论，【主持人听不见】。
* 你的任务是和玩家一起头脑风暴，进行推理。

[AI队友列表 (你将扮演他们)]
${teammatePersonas}

[游戏历史记录]
(这是目前为止所有的公开线索)
${formatHistory(history)}

[当前任务]
你的队友 "玩家" (人设: ${GAME_USER_PERSONA_PROMPT}) 刚刚私下对大家说："${userInput}"

[你的行动]
扮演 2 到 3 名 AI 队友，针对玩家的话，展开一段【你来我往、互相回复】的简短【穿插讨论】。
* 第一个队友可以回复玩家。
* 第二个队友【必须回复第一个队友】，让对话延续下去。

[输出格式] (必须严格遵守 Koko App 的剧本格式)
MESSAGE_START
SPEAKER: [AI队友A的名字]
CONTENT: [队友A针对“玩家”的话发表评论]
MESSAGE_END

MESSAGE_START
SPEAKER: [AI队友B的名字]
CONTENT: [队友B【回复队友A】，而不是回复玩家]
MESSAGE_END
`;
}

/**
 * (不变) 游戏专用的消息显示函数
 */
function addGameMessage(sender, text, senderName) {
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${sender}`;
    
    let nameClass = sender;
    let displayName = "你"; // 默认

    if (sender === 'ai-player') {
        displayName = senderName; // 动态传入
        nameClass = 'ai-player';
    } else if (sender === 'host') {
        displayName = GAME_HOST_NAME;
        nameClass = 'host';
    } else if (sender === 'user') {
        nameClass = 'user';
    }

    const isHostIntro = (sender === 'host' && text.startsWith('汤面：'));
    const isVictory = (sender === 'host' && text.includes('恭喜'));
    const isSurrender = (sender === 'host' && text.startsWith('汤底是：'));

    let messageClass = 'message';
    if(isHostIntro) { /* no extra class */ }
    else if(isVictory) { messageClass += ' victory'; }
    else if(isSurrender) { messageClass += ' surrender'; }
    else if(sender === 'host') { messageClass += ' answer'; }
    
    if (!isHostIntro) {
        const nameEl = document.createElement('div');
        nameEl.className = `sender-name ${nameClass}`;
        nameEl.textContent = displayName;
        wrapper.appendChild(nameEl);
    }
    
    const messageEl = document.createElement('div');
    messageEl.className = messageClass;
    messageEl.innerHTML = text.replace(/\n/g, '<br>');
    wrapper.appendChild(messageEl);

    gameChatLog.appendChild(wrapper);
    gameChatLogWrapper.scrollTop = gameChatLogWrapper.scrollHeight;
}

/**
 * (不变) 格式化游戏历史
 */
function formatHistory(messages) {
    return messages.map(msg => `${msg.role}: ${msg.content}`).join('\n');
}

/**
 * (不变 V2) 游戏专用的AI调用函数
 */
async function callGameAI(systemPrompt) {
    const apiConfig = getApiFor('chat'); 
    const { apiKey, model, endpoint } = apiConfig;

    if (!apiKey || !endpoint || !model) {
        const errorMsg = "错误：游戏无法启动，因为【聊天API设置】未配置。请前往“发现-API设置”进行配置。";
        console.error(errorMsg);
        alert(errorMsg);
        throw new Error(errorMsg);
    }

    const bodyPayload = {
        model: model,
        messages: [
            { role: "user", content: systemPrompt }
        ]
    };
    
    if (systemPrompt.includes('"face":')) {
        bodyPayload.response_format = { type: "json_object" };
    }

    try {
        let data;
        if (endpoint.includes('generativelanguage.googleapis.com')) {
            data = await handleGeminiTranslation(bodyPayload, apiKey);
        } else {
            const cleanEndpoint = normalizeApiEndpoint(endpoint); 
            const chatEndpoint = `${cleanEndpoint}/v1/chat/completions`;
            
            const response = await fetch(chatEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify(bodyPayload)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error ? errorData.error.message : 'Unknown API error');
            }
            data = await response.json();
        }
        return data.choices[0].message.content.trim();
    } catch (error) {
        console.error('游戏AI调用失败:', error);
        throw error;
    }
}

/**
 * ✨✨ (新 V4) 启动游戏的主函数 ✨✨
 */
async function handleStartGame() {
    // 1. 保存GM人设
    GAME_HOST_PERSONA_PROMPT = gameGmPersonaInput.value.trim();
    if (!GAME_HOST_PERSONA_PROMPT) GAME_HOST_PERSONA_PROMPT = "一个普通的主持人";
    
    // (新) 1b. 保存“你(玩家)”的人设
    GAME_USER_PERSONA_PROMPT = gameUserPersonaSelect.value; 
    if (!GAME_USER_PERSONA_PROMPT) {
        GAME_USER_PERSONA_PROMPT = "一个聪明的玩家"; // 默认人设
    }

    // 2. 保存关键词
    const keywords = gameKeywordsInput.value.trim();
    GAME_LAST_KEYWORDS = keywords; // (新) 保存关键词以便重玩
    
    // 3. 组合AI队友
    GAME_AI_TEAMMATES = [];
    
    // 3a. 从联系人列表添加
    const selectedPlayerCheckboxes = document.querySelectorAll('#game-player-picker-list input:checked');
    Array.from(selectedPlayerCheckboxes).forEach(cb => {
        const contact = state.contacts.find(c => c.id === cb.value);
        if(contact) GAME_AI_TEAMMATES.push({ 
            name: contact.name, 
            persona: contact.persona || '一个普通玩家' 
        });
    });

    // ▼▼▼ 3b. (新) 从关系网NPC列表添加 ▼▼▼
    const selectedNpcCheckboxes = document.querySelectorAll('#game-npc-picker-list input:checked');
    Array.from(selectedNpcCheckboxes).forEach(cb => {
        // (新) 从我们之前存的 tempAllNpcList 列表里找
        const npc = tempAllNpcList.find(n => n.id === cb.value);
        if (npc) {
            GAME_AI_TEAMMATES.push({ 
                name: npc.name, 
                persona: npc.persona || '一个神秘的NPC' // (新) 使用NPC的人设
            });
        }
    });
    // ▲▲▲ 新增结束 ▲▲▲

    // 3c. 从自定义NPC文本域添加
    const teammatesText = gameCustomNpcsInput.value.trim();
    if (teammatesText) {
        teammatesText.split('\n').forEach(line => {
            const parts = line.split('|');
            const name = parts[0] ? parts[0].trim() : null;
            if (name) GAME_AI_TEAMMATES.push({ name: name, persona: (parts[1] ? parts[1].trim() : '一个普通玩家') });
        });
    }

    // 4. 切换UI (不变)
    document.getElementById('start-game-modal').style.display = 'none';
    hideAllScreens(); 
    gameChatScreen.style.display = 'flex'; 
    setGameButtonsDisabled(true); 
    gamePuzzleTextEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 主持人正在创作谜题中...';
    gameChatLogWrapper.classList.add('loading');
    
    // 5. 调用GM AI生成谜题 (不变)
    try {
        const gmPrompt = getGMPrompt(keywords);
        const rawResponse = await callGameAI(gmPrompt);
        
        // 6. 解析谜题 (不变)
        let puzzleJSON;
        try {
            const jsonMatch = rawResponse.match(/{[\s\S]*}/);
            if (!jsonMatch) throw new Error("AI未返回有效的JSON格式。");
            puzzleJSON = JSON.parse(jsonMatch[0]);
        } catch (e) {
            console.error("解析谜题JSON失败:", e, "AI原始回复:", rawResponse);
            puzzleJSON = { face: "AI返回格式错误", bottom: `AI回复：${rawResponse}` };
        }

        if (!puzzleJSON.face || !puzzleJSON.bottom) {
             puzzleJSON = { face: "AI未按要求返回", bottom: `AI回复：${rawResponse}` };
        }
        
        GAME_SECRET_SOUP_BOTTOM = puzzleJSON.bottom; 

        // 7. 启动游戏 (不变)
        initGame(puzzleJSON.face); 

    } catch (error) {
        console.error("生成谜题失败:", error);
        alert("游戏启动失败: " + error.message);
        gameChatScreen.style.display = 'none';
        showDiscoverScreen(); 
    } finally {
        setGameButtonsDisabled(false);
        gameChatLogWrapper.classList.remove('loading');
    }
}

/**
 * (不变 V2) 重新开始一局新游戏 (再玩一局)
 */
async function replayGame() {
    setGameButtonsDisabled(true); 
    gamePuzzleTextEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 主持人正在创作新谜题中...';
    gameChatLogWrapper.classList.add('loading');
    
    try {
        const gmPrompt = getGMPrompt(GAME_LAST_KEYWORDS); 
        const rawResponse = await callGameAI(gmPrompt);
        
        let puzzleJSON;
        try {
            const jsonMatch = rawResponse.match(/{[\s\S]*}/);
            if (!jsonMatch) throw new Error("AI未返回有效的JSON格式。");
            puzzleJSON = JSON.parse(jsonMatch[0]);
        } catch (e) {
            puzzleJSON = { face: "AI返回格式错误", bottom: `AI回复：${rawResponse}` };
        }
        if (!puzzleJSON.face || !puzzleJSON.bottom) {
             puzzleJSON = { face: "AI未按要求返回", bottom: `AI回复：${rawResponse}` };
        }
        
        GAME_SECRET_SOUP_BOTTOM = puzzleJSON.bottom; 
        initGame(puzzleJSON.face); 

    } catch (error) {
        console.error("生成新谜题失败:", error);
        alert("开始新一局失败: " + error.message);
        gameChatScreen.style.display = 'none';
        showDiscoverScreen();
    } finally {
        setGameButtonsDisabled(false);
        gameChatLogWrapper.classList.remove('loading');
    }
}

/**
 * (新 V4) 解析并显示AI的多段回复
 */
function parseAndDisplayAiResponse(rawResponse, mode) {
    removeGameLoadingIndicator(); // (新) 隐藏“正在思考”

    // 1. (不变) 先剥离VERDICT
    if (mode === 'host') {
        const verdictMatch = rawResponse.match(/VERDICT:\s*(.*)/);
        if (verdictMatch) {
            const verdict = verdictMatch[1].trim();
            if (verdict === "VICTORY") {
                endGame(true); 
                return; 
            }
        }
    }

    // 2. (不变 V3) 使用 Koko App 的剧本解析器
    const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
    let match;
    const responsesToShow = []; 

    while ((match = messageRegex.exec(rawResponse)) !== null) {
        const speakerName = match[1].trim();
        const content = match[2].trim();
        if (!content) continue;
        
        if (speakerName === GAME_HOST_NAME) {
            responsesToShow.push({ sender: 'host', name: GAME_HOST_NAME, text: content });
        } else if (GAME_AI_TEAMMATES.some(t => t.name === speakerName)) {
            responsesToShow.push({ sender: 'ai-player', name: speakerName, text: content });
        }
    }

    // 3. (不变) 模拟真实聊天延迟，依次显示
    (async function showResponsesSequentially() {
        
        for (const res of responsesToShow) {
            await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 500));
            addGameMessage(res.sender, res.text, res.name);
            gameMessages.push({ role: res.name, content: res.text });
        }
        
        setGameButtonsDisabled(false); 
    })();
}

/**
 * (新 V4) 处理“提问主持人”
 */
async function handleAskHost() {
    const text = gameUserInput.value.trim();
    if (!text) return;
    gameUserInput.value = '';
    gameUserInput.style.height = 'auto';
    setGameButtonsDisabled(true);

    addGameMessage('user', text, "你");
    gameMessages.push({ role: '玩家', content: text }); 
    showGameLoadingIndicator(); // (新) 显示“正在思考”

    try {
        const hostPrompt = getHostPrompt(gameMessages, text);
        const aiRawResponse = await callGameAI(hostPrompt);
        parseAndDisplayAiResponse(aiRawResponse, 'host');
    } catch (error) {
        removeGameLoadingIndicator();
        setGameButtonsDisabled(false);
    }
}

/**
 * (新 V4) 处理“和TA讨论”
 */
async function handleDiscuss() {
    const text = gameUserInput.value.trim();
    if (!text) return;
    gameUserInput.value = '';
    gameUserInput.style.height = 'auto';
    setGameButtonsDisabled(true);

    addGameMessage('user', text, "你");
    const historyText = `(玩家私下对大家说: ${text})`; 
    gameMessages.push({ role: '玩家', content: historyText }); 
    showGameLoadingIndicator(); // (新) 显示“正在思考”

    try {
        const discussPrompt = getDiscussPrompt(gameMessages, text);
        const aiRawResponse = await callGameAI(discussPrompt);
        parseAndDisplayAiResponse(aiRawResponse, 'discuss');
    } catch (error) {
        removeGameLoadingIndicator();
        setGameButtonsDisabled(false);
    }
}

/**
 * (新) 玩家只发送消息，不触发AI回复 (纯净版)
 */
function handleJustSend() {
    const text = gameUserInput.value.trim();
    if (!text) return; 
    gameUserInput.value = '';
    gameUserInput.style.height = 'auto';
    addGameMessage('user', text, "你");
    gameMessages.push({ role: '玩家', content: text }); 
    setGameButtonsDisabled(false); 
    // gameUserInput.focus(); // (已注释掉，防止自动弹起)
}


/**
 * (不变) 游戏结束/认输 逻辑
 */
function endGame(isVictory) {
    setGameButtonsDisabled(true); 
    gameInputArea.classList.add('game-ended'); 
    gameSurrenderBtn.style.display = 'none'; 
    
    if (isVictory) {
        addGameMessage('host', '🎉 恭喜！你猜对了！🎉', GAME_HOST_NAME);
    } else {
        addGameMessage('host', '游戏结束', GAME_HOST_NAME);
    }
    
    addGameMessage('host', `汤底是：\n${GAME_SECRET_SOUP_BOTTOM}`, GAME_HOST_NAME);
    
    gamePlayAgainBtn.style.display = 'block'; 
}

/**
 * (新 V2) 辅助：批量禁用/启用游戏按钮
 */
function setGameButtonsDisabled(disabled) {
    if (!gameAskHostBtn) return; // DOM还没加载完
    gameAskHostBtn.disabled = disabled;
    gameDiscussBtn.disabled = disabled;
    gameUserInput.disabled = disabled;
    gameSurrenderBtn.disabled = disabled;
    // (已删除自动 focus)
}

/**
* (新 V5) 打开游戏玩家选择弹窗
*/
async function openSeaTurtleModal() {
    // 1. 设定默认GM人设
    const defaultHostPersona = "一个冷静、严肃、惜字如金的主持人，只说必要的话。";
    document.getElementById('game-gm-persona-input').value = defaultHostPersona;
    
    // 2. 填充“你(玩家)”的人设下拉菜单
    const userPersonaSelect = document.getElementById('game-user-persona-select');
    userPersonaSelect.innerHTML = '<option value="">-- 默认 (一个聪明的玩家) --</option>'; 
    state.userPersonaPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.description; 
        option.textContent = preset.name; 
        userPersonaSelect.appendChild(option);
    });

    // 3. 填充可选的AI队友列表 (联系人)
    const playerListEl = document.getElementById('game-player-picker-list');
    playerListEl.innerHTML = '';
    const otherContacts = state.contacts.filter(c => !c.isGroup);

    if (otherContacts.length === 0) {
        playerListEl.innerHTML = '<p style="color: #888; text-align: center;">没有AI联系人可以当队友</p>';
    } else {
        otherContacts.forEach(c => { 
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="checkbox" id="game-player-${c.id}" value="${c.id}" style="margin-right: 15px;">
                <label for="game-player-${c.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <img src="${c.avatar}" alt="${c.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                    <span>${c.name}</span>
                </label>
            `;
            playerListEl.appendChild(item);
        });
    }

    // 4. (新) 填充可选的AI队友列表 (关系网NPC)
    const npcListEl = document.getElementById('game-npc-picker-list');
    npcListEl.innerHTML = '';
    tempAllNpcList = []; // (新) 清空临时NPC列表
    const seenNpcIds = new Set();
    const allNetworks = await kokoMemory.getAll('relationshipNetworks');

    allNetworks.forEach(network => {
        if (network.nodes) {
            network.nodes.forEach(node => {
                // 筛选：是NPC 且 还没被添加过 且 有人设
                if (node.isContact === false && !seenNpcIds.has(node.id) && node.persona) {
                    tempAllNpcList.push(node); // (新) 存入临时列表
                    seenNpcIds.add(node.id);
                    
                    const item = document.createElement('div');
                    item.className = 'contact-picker-item';
                    item.innerHTML = `
                        <input type="checkbox" id="game-player-${node.id}" value="${node.id}" style="margin-right: 15px;">
                        <label for="game-player-${node.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                            <img src="${node.avatar}" alt="${node.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                            <span>${node.name} (NPC)</span>
                        </label>
                    `;
                    npcListEl.appendChild(item);
                }
            });
        }
    });
    
    if (npcListEl.innerHTML === '') {
        npcListEl.innerHTML = '<p style="color: #888; text-align: center;">没有从关系网找到带人设的NPC</p>';
    }

    // 5. 清空自定义NPC和关键词
    document.getElementById('game-custom-npcs-input').value = '';
    document.getElementById('soup-keywords-input').value = '';
    
    // 6. 显示弹窗
    document.getElementById('start-game-modal').style.display = 'flex';
}

/**
 * (新 V5) 游戏初始化 (修改了“再玩一局”和“回车”的逻辑)
 */
function initGame(soupFace) {
    // 1. 设置置顶汤面
    gamePuzzleTextEl.textContent = soupFace;
    
    // 2. 清空聊天记录和游戏历史
    gameChatLog.innerHTML = '';
    gameMessages = [{ role: GAME_HOST_NAME, content: `汤面：${soupFace}` }];
    
    // 3. 重置UI状态
    setGameButtonsDisabled(false);
    gameSurrenderBtn.style.display = 'block';
    gamePlayAgainBtn.style.display = 'none';
    gameInputArea.classList.remove('game-ended');
    gameUserInput.focus();
    
    // 4. (重新)绑定按钮事件 (使用克隆节点大法)
    const newAskBtn = gameAskHostBtn.cloneNode(true);
    gameAskHostBtn.parentNode.replaceChild(newAskBtn, gameAskHostBtn);
    newAskBtn.addEventListener('click', handleAskHost);
    gameAskHostBtn = newAskBtn;
    
    const newDiscussBtn = gameDiscussBtn.cloneNode(true);
    gameDiscussBtn.parentNode.replaceChild(newDiscussBtn, gameDiscussBtn);
    newDiscussBtn.addEventListener('click', handleDiscuss);
    gameDiscussBtn = newDiscussBtn;
    
    const newSurrenderBtn = gameSurrenderBtn.cloneNode(true);
    gameSurrenderBtn.parentNode.replaceChild(newSurrenderBtn, gameSurrenderBtn);
    newSurrenderBtn.addEventListener('click', () => endGame(false));
    gameSurrenderBtn = newSurrenderBtn;

    const newPlayAgainBtn = gamePlayAgainBtn.cloneNode(true);
    gamePlayAgainBtn.parentNode.replaceChild(newPlayAgainBtn, gamePlayAgainBtn);
    newPlayAgainBtn.addEventListener('click', () => {
        // (新) "再玩一局" 应该调用 replayGame()
        replayGame();
    });
    gamePlayAgainBtn = newPlayAgainBtn;
    
    // 退出按钮
    const newExitBtn = gameExitBtn.cloneNode(true);
    gameExitBtn.parentNode.replaceChild(newExitBtn, gameExitBtn);
    newExitBtn.addEventListener('click', () => {
        gameChatScreen.style.display = 'none';
        showDiscoverScreen();
    });
    gameExitBtn = newExitBtn;
    
    // 输入框
    const newUserInput = gameUserInput.cloneNode(true);
    gameUserInput.parentNode.replaceChild(newUserInput, gameUserInput);
    
    // (新) 回车键只发送，不提问
    newUserInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !newAskBtn.disabled) {
            e.preventDefault();
            handleJustSend(); // <-- 核心修改在这里
        }
    });
    
    // 输入框自动长高
    newUserInput.addEventListener('input', function() {
        this.style.height = 'auto';
        const maxHeight = 100;
        const newHeight = Math.min(this.scrollHeight, maxHeight);
        this.style.height = newHeight + 'px';
    });
    gameUserInput = newUserInput;
}
// --- 股票功能函数 ---

// ▼▼▼ 用下面【一整个代码块】替换掉旧的 startStockMarket, stopStockMarket, updateStockMarketUI, handleStockTrade 四个函数 ▼▼▼

// --- 全局变量 ---
let stockEventInterval = null; // 新的事件循环定时器
let activeStockId = 'KOK'; // 默认选中的股票
const STOCK_IDS = ['KOK', 'TECH', 'BIO']; // 我们的三只股票
const STOCK_NAMES = { KOK: 'KokoCoin', TECH: 'Koko 科技', BIO: 'Koko 医药' };

// ▼▼▼ 用这个【40个事件豪华版】替换旧的 stockEventDefinitions 数组 ▼▼▼
const stockEventDefinitions = [
    // ==========================================================
    // 类别 1：公司经营 (Operations) - 10个事件
    // ==========================================================
    { type: 'positive', category: '经营', text: "发布了革命性新产品，分析师连夜上调评级！" },
    { type: 'positive', category: '经营', text: "财报远超预期，净利润同比增长200%！" },
    { type: 'positive', category: '经营', text: "宣布聘请了业界的传奇人物 'Koko酱' 担任新任CEO！" },
    { type: 'positive', category: '经营', text: "核心技术取得重大突破，获得关键性专利。" },
    { type: 'positive', category: '经营', text: "成功开拓海外市场，签订了价值数十亿的长期合同。" },
    
    { type: 'negative', category: '经营', text: "核心产品发现严重安全漏洞，正在全球范围内紧急召回。" },
    { type: 'negative', category: '经营', text: "CEO 突发丑闻，公司形象受损，董事会紧急开会。" },
    { type: 'negative', category: '经营', text: "关键技术专利诉讼败诉，面临巨额赔偿和禁售风险。" },
    { type: 'negative', category: '经营', text: "重要工厂发生火灾，预计将导致供应链中断数周。" },
    
    { type: 'neutral', category: '经营', text: "公司宣布进行常规组织架构调整，业务线不变。" },

    // ==========================================================
    // 类别 2：资本运作 (Capital) - 9个事件
    // ==========================================================
    { type: 'positive', category: '资本', text: "神秘财团宣布大举增持，市场信心爆棚。" },
    { type: 'positive', category: '资本', text: "宣布与行业巨头“腾达集团”达成战略合并协议。" },
    { type: 'positive', category: '资本', text: "公司宣布一项高达50亿的股票回购计划。" },
    { type: 'positive', category: '资本', text: "信用评级被“标普”从A-上调至A+。" },

    { type: 'negative', category: '资本', text: "大股东宣布清仓式减持，引发市场恐慌。" },
    { type: 'negative', category: '资本', text: "与“腾达集团”的合并谈判意外破裂，需支付巨额分手费。" },
    { type: 'negative', category: '资本', text: "宣布增发新股以偿还债务，稀释现有股东权益。" },
    { type: 'negative', category: '资本', text: "信用评级被“穆迪”下调至“垃圾级”。" },
    
    { type: 'neutral', category: '资本', text: "宣布“10送10”高送转方案，股价除权。" },

    // ==========================================================
    // 类别 3：国家推动 (Policy) - 9个事件
    // ==========================================================
    { type: 'positive', category: '政策', text: "被纳入国家重点扶持“芯片”产业名单，喜提巨额补贴。" },
    { type: 'positive', category: '政策', text: "成功中标“智慧城市”千亿级政府独家采购大单。" },
    { type: 'positive', category: '政策', text: "行业准入标准大幅提高，小企业被清退，利好龙头。" },
    { type: 'positive', category: '政策', text: "政府宣布对竞争对手（海外）的进口商品加征100%关税。" },

    { type: 'negative', category: '政策', text: "遭遇反垄断调查，或将面临天价罚款。" },
    { type: 'negative', category: '政策', text: "新环保法案出台，公司核心业务面临合规压力，成本剧增。" },
    { type: 'negative', category: '政策', text: "被移出“政府补贴”名单，未来盈利能力存疑。" },
    { type: 'negative', category: '政策', text: "因地缘政治紧张，被“漂亮国”列入实体管制清单。" },

    { type: 'neutral', category: '政策', text: "行业协会发布年度白皮书，重申了发展的重要性。" },

    // ==========================================================
    // 类别 4：舆论影响 (PR/Opinion) - 9个事件
    // ==========================================================
    { type: 'positive', category: '舆论', text: "社交媒体疯传！某产品成现象级爆款。" },
    { type: 'positive', category: '舆论', text: "公司意外获得“年度最佳雇主”奖，人才吸引力大增。" },
    { type: 'positive', category: '舆论', text: "新签代言人“顶流Koko”形象正面，带动粉丝疯狂抢购。" },
    { type: 'positive', category: '舆论', text: "CEO在慈善晚宴上的感人演讲被疯传，公司好感度拉满。" },

    { type: 'negative', category: '舆论', text: "知名机构“浑水”发布做空报告，指控公司财务造假。" },
    { type: 'negative', category: '舆论', text: "#抵制Koko 话题登上热搜，疑似广告中出现不当言论。" },
    { type: 'negative', category: '舆论', text: "大量用户投诉售后服务“形同虚设”，监管介入调查。" },
    { type: 'negative', category: '舆论', text: "被曝“996”加班文化严重，引发全网打工人共情抵制。" },

    { type: 'neutral', category: '舆论', text: "公司宣布更换新Logo，市场反应平平，设计师被骂惨。" },
    
    // ==========================================================
    // 类别 5：搞笑事件 (Funny) - 3个事件 (约 7.5%)
    // ==========================================================
    { type: 'positive', category: '舆论', text: "【搞笑】CEO在发布会上养的猫意外抢镜，公司Meme图火爆全网，股价意外拉升。" },
    { type: 'negative', category: '经营', text: "【搞笑】公司食堂换了新外包，新菜单导致员工集体在官推下抗议，怨声载道。" },
    { type: 'neutral', category: '舆论', text: "【搞笑】公司新吉祥物被指控长得太像隔壁公司CEO，引发网友热议，双方均表示'很无辜'。" }
];
// ▲▲▲ 替换结束 ▲▲▲

/**
 * (V2.0) 启动股票模拟器 (重写)
 */
async function startStockMarket() {
    // 1. 停止旧的定时器（如果有）
    if (stockEventInterval) clearInterval(stockEventInterval);

    // 2. 初始化所有股票数据
    for (const stockId of STOCK_IDS) {
        let savedData = await kokoMemory.get('stockMarket', stockId);
        if (!savedData) {
            // 如果是第一次，初始化历史数据
            let timestamp = Date.now() - 100 * 5000;
            let price = 100.00 + (Math.random() - 0.5) * 50; // 初始价格不同
            let history = [];
            for (let i = 0; i < 100; i++) {
                price += (Math.random() - 0.48) * 5; 
                price = Math.max(10, price); 
                history.push([timestamp, parseFloat(price.toFixed(2))]);
                timestamp += 5000;
            }
            savedData = {
                id: stockId,
                price: parseFloat(price.toFixed(2)),
                history: history
            };
            await kokoMemory.put('stockMarket', savedData);
        }
    }
    
    // 3. 清空新闻大屏，并加载历史新闻
    const newsFeed = document.getElementById('stock-news-feed');
    newsFeed.innerHTML = '';
    const historicalEvents = await kokoMemory.getAll('stockEvents');
    historicalEvents.slice(-10).forEach(event => logStockEvent(event.text, event.type, true)); // 悄悄加载，不滚动

    // 4. 启动新的“事件”更新定时器（例如 5 到 10 秒随机一次）
    const runCycle = () => {
        runStockEventCycle(); // 立即执行一次
        const nextInterval = (Math.random() * 5000 + 5000); // 5-10秒
        stockEventInterval = setTimeout(runCycle, nextInterval);
    };
    runCycle();

    // 5. 渲染UI (默认显示 KOK)
    activeStockId = 'KOK';
    updateStockMarketUI(activeStockId);
}

/**
 * (V2.0) 停止股票模拟器 (重写)
 */
function stopStockMarket() {
    if (stockEventInterval) clearTimeout(stockEventInterval); // 改为 clearTimeout
    stockEventInterval = null;
}

/**
 * (V2.1 - 带盈亏显示) 刷新UI和图表 (重写)
 * @param {string} stockId - 要显示的股票ID
 */
async function updateStockMarketUI(stockId) {
    if (document.getElementById('stock-market-screen').style.display !== 'flex') {
        return; // 如果页面没打开，就不渲染
    }

    activeStockId = stockId; // 更新当前激活的ID

    // 1. 更新标签页高亮
    document.querySelectorAll('#stock-tabs-container .feed-tab-btn').forEach(btn => {
        if (btn.dataset.stockId === stockId) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });

    // 2. 加载该股票的数据
    const stockData = await kokoMemory.get('stockMarket', stockId);
    if (!stockData) return;

    // ▼▼▼ 核心修改：计算盈亏 ▼▼▼
    const profile = state.myProfile;
    // ✨ 确保我们能读到新字段，并提供默认值
    const myInvest = profile.investments[activeStockId] || { shares: 0, avgBuyPrice: 0, cumulativeProfitLoss: 0 };
    const myShares = myInvest.shares || 0;
    const myCost = myInvest.avgBuyPrice || 0;
    const currentValue = myShares * stockData.price;
    
    // ✨ 新增：计算持仓盈亏 (当前市值 - 总成本)
    const myTotalCost = myCost * myShares;
    const holdingProfitLoss = (myShares > 0) ? (currentValue - myTotalCost) : 0;
    
    // ✨ 新增：获取累计盈亏
    const cumulativeProfitLoss = myInvest.cumulativeProfitLoss || 0;

    // 3. 更新老的UI
    document.getElementById('stock-current-price').textContent = `¥${stockData.price.toFixed(2)}`;
    document.getElementById('stock-my-shares').textContent = `${myShares} 股 (成本: ¥${myCost.toFixed(2)})`;
    document.getElementById('stock-my-value').textContent = `¥${currentValue.toFixed(2)}`;

    // 4. ✨ 新增：更新两个新 <div/> 的内容，并加上红涨绿跌
    const holdingPlEl = document.getElementById('stock-holding-pl');
    const cumulativePlEl = document.getElementById('stock-cumulative-pl');
    
    // (这是一个小工具函数，用来设置文本和颜色)
    const setProfitLossStyle = (el, value) => {
        el.textContent = `${value >= 0 ? '+' : ''}¥${value.toFixed(2)}`;
        el.style.color = value >= 0 ? '#f44336' : '#4caf50'; // 红涨绿跌
    };

    setProfitLossStyle(holdingPlEl, holdingProfitLoss);
    setProfitLossStyle(cumulativePlEl, cumulativeProfitLoss);
    // ▲▲▲ 核心修改结束 ▲▲▲

    // 5. 更新 ECharts 图表 (这部分不变)
    const chartDom = document.getElementById('stock-chart-container');
    let myStockChart = echarts.getInstanceByDom(chartDom);
    if (!myStockChart) {
        myStockChart = echarts.init(chartDom);
    }
    
    // (检查历史数据是否足够，防止图表报错)
    const lastPrice = stockData.history.length > 1 ? stockData.history[stockData.history.length-2][1] : stockData.price;
    const isUp = stockData.price >= lastPrice;

    myStockChart.setOption({
        tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
        xAxis: { type: 'time', show: false },
        yAxis: { type: 'value', scale: true, splitLine: { lineStyle: { type: 'dashed' } }, axisLabel: { formatter: '¥{value}' } },
        grid: { left: '15%', right: '5%', top: '5%', bottom: '10%' },
        series: [{
            data: stockData.history,
            type: 'line',
            symbol: 'none',
            lineStyle: { color: isUp ? '#f44336' : '#4caf50', width: 2 }, // 根据涨跌显示红绿
            areaStyle: {
                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
                    offset: 0, color: isUp ? 'rgba(244, 67, 54, 0.3)' : 'rgba(76, 175, 80, 0.3)'
                }, {
                    offset: 1, color: isUp ? 'rgba(244, 67, 54, 0)' : 'rgba(76, 175, 80, 0)'
                }])
            }
        }]
    }, true);
}

/**
 * (V2.1 - 带盈亏计算) 核心：实现“赔大于赚”的交易函数 (重写)
 * @param {'buy' | 'sell'} type - 交易类型
 */
async function handleStockTrade(type) {
    const amountInput = document.getElementById('stock-amount-input');
    const shares = parseInt(amountInput.value, 10);
    if (isNaN(shares) || shares <= 0) {
        return alert('请输入有效的股数！');
    }

    const stockData = await kokoMemory.get('stockMarket', activeStockId);
    if (!stockData) return;

    const currentPrice = stockData.price;
    const profile = state.myProfile;
    const TRANSACTION_FEE_RATE = 0.015; // 1.5% 的手续费

    // ▼▼▼ 步骤 2：修改“买入”逻辑 ▼▼▼
    if (!profile.investments[activeStockId]) {
        // ✨ 修改点：在这里添加 cumulativeProfitLoss: 0
        profile.investments[activeStockId] = { shares: 0, avgBuyPrice: 0, cumulativeProfitLoss: 0 };
    }
    const myInvest = profile.investments[activeStockId];
    // ▲▲▲ 修改结束 ▲▲▲

    if (type === 'buy') {
        const cost = shares * currentPrice;
        const fee = cost * TRANSACTION_FEE_RATE;
        const totalCost = cost + fee;

        if (profile.balance < totalCost) {
            return alert(`余额不足！购买 ${shares} 股需要 ${totalCost.toFixed(2)} 元 (含手续费 ${fee.toFixed(2)} 元)`);
        }
        
        profile.balance -= totalCost;
        await addTransaction('expense', totalCost, `购买 ${shares} 股 ${STOCK_NAMES[activeStockId]}`);
        
        const oldTotalCost = myInvest.avgBuyPrice * myInvest.shares;
        myInvest.shares += shares;
        myInvest.avgBuyPrice = parseFloat(((oldTotalCost + cost) / myInvest.shares).toFixed(2));

        alert(`购买成功！花费 ${totalCost.toFixed(2)} 元。`);

    } else if (type === 'sell') {
        if (myInvest.shares < shares) {
            return alert(`持仓不足！你只有 ${myInvest.shares} 股。`);
        }
        
        // ▼▼▼ 步骤 3：修改“卖出”逻辑 ▼▼▼
        const revenue = shares * currentPrice;
        const fee = revenue * TRANSACTION_FEE_RATE;
        const totalRevenue = revenue - fee;
        
        // ✨ 核心计算：算出卖掉这些股票的“成本价”
        const costOfSharesSold = myInvest.avgBuyPrice * shares;
        // ✨ 核心计算：(实际收入 - 成本) = 本次交易利润
        const profitFromThisSale = totalRevenue - costOfSharesSold;
        
        profile.balance += totalRevenue;
        await addTransaction('income', totalRevenue, `卖出 ${shares} 股 ${STOCK_NAMES[activeStockId]}`);
        
        // ✨ 核心存储：将本次利润累加到“累计盈亏”中
        myInvest.cumulativeProfitLoss = (myInvest.cumulativeProfitLoss || 0) + profitFromThisSale;
        
        myInvest.shares -= shares;
        if (myInvest.shares === 0) {
            myInvest.avgBuyPrice = 0; // 清仓，成本归零
        }
        // ▲▲▲ 修改结束 ▲▲▲

        alert(`卖出成功！获得 ${totalRevenue.toFixed(2)} 元 (已扣除手续费 ${fee.toFixed(2)} 元)`);
    }

    // 保存并更新UI
    amountInput.value = '';
    await kokoMemory.put('myProfile', state.myProfile);
    renderMyProfile(); // 刷新钱包余额
    updateStockMarketUI(activeStockId); // 刷新交易所UI
}
// ▼▼▼ 把下面【所有】新函数，粘贴到 handleStockTrade 函数的【下方】 ▼▼▼

/**
 * (V2.0-新) 核心游戏循环：发生一个新事件
 */
async function runStockEventCycle() {
    // 1. 随机挑一只股票
    const stockId = STOCK_IDS[Math.floor(Math.random() * STOCK_IDS.length)];
    
    // 2. 随机挑一个事件
    const event = { ...stockEventDefinitions[Math.floor(Math.random() * stockEventDefinitions.length)] };
    event.stockName = STOCK_NAMES[stockId];
    event.text = `【${event.stockName} | ${event.category}】${event.text}`;
    event.id = `evt_${Date.now()}`;

    // 3. 【显示新闻】(你说的“大屏”)
    logStockEvent(event.text, event.type, false);
    // 保存新闻
    await kokoMemory.put('stockEvents', event);

    // 4. 【让用户预看】等待 3 秒
    await sleep(3000); 

    // 5. 【应用价格变动】
    const stockData = await applyPriceChange(stockId, event.type);

    // 6. 如果用户正好在看这只股票，就刷新图表
    if (activeStockId === stockId && document.getElementById('stock-market-screen').style.display === 'flex') {
        updateStockMarketUI(stockId);
    }
}

/**
 * (V2.0-新) 辅助函数：在“大屏”上显示新闻
 */
function logStockEvent(text, type, isSilent = false) {
    const newsFeed = document.getElementById('stock-news-feed');
    if (!newsFeed) return;

    const item = document.createElement('div');
    item.className = `news-item ${type}`; // positive, negative, neutral
    item.textContent = text;
    
    newsFeed.appendChild(item);
    
    if (!isSilent) {
        // 滚动到底部，让新消息可见
        newsFeed.scrollTop = newsFeed.scrollHeight;
    }
    
    // 限制只显示 50 条新闻，防止 DOM 爆炸
    while (newsFeed.children.length > 50) {
        newsFeed.removeChild(newsFeed.firstChild);
    }
}

/**
 * (V2.1-牛市版) 辅助函数：应用价格变动（含涨跌停）
 */
async function applyPriceChange(stockId, eventType) {
    const stockData = await kokoMemory.get('stockMarket', stockId);
    if (!stockData) return;

    let price = stockData.price;
    let changePercent = 0;

    // ▼▼▼ 核心修改在这里！▼▼▼
    switch (eventType) {
        case 'positive':
            // 涨得多！(涨 10% 到 20%)
            changePercent = 0.10 + Math.random() * 0.10; 
            break;
        case 'negative':
            // 跌得少！(只跌 3% 到 8%)
            changePercent = -0.03 - Math.random() * 0.05; 
            break;
        case 'neutral':
            changePercent = (Math.random() - 0.5) * 0.02; // 中性，微小波动 (不变)
            break;
    }
    // ▲▲▲ 修改结束 ▲▲▲

    // 2. 计算新价格
    let newPrice = price * (1 + changePercent);

    // 3. 【应用涨跌停】(假设涨跌停板为 10%)
    const maxPrice = price * 1.10;
    const minPrice = price * 0.90;
    
    // ✨ 修正：如果我们的“牛市”涨幅超过了10%的涨停板，就让它涨停
    newPrice = Math.max(minPrice, Math.min(maxPrice, newPrice));
    
    // 4. 价格不低于 10 元
    newPrice = Math.max(10.00, newPrice); 

    // 5. 更新数据
    stockData.price = parseFloat(newPrice.toFixed(2));
    stockData.history.push([Date.now(), stockData.price]);
    if (stockData.history.length > 200) {
        stockData.history.shift();
    }
    
    await kokoMemory.put('stockMarket', stockData);
    return stockData;
}

// --- 刮刮乐功能函数 ---

/**
 * 辅助函数：洗牌算法
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/**
 * 辅助函数：生成一个01-30之间的随机两位数号码
 */
function getRandomLotteryNumber() {
    return Math.floor(Math.random() * 30 + 1).toString().padStart(2, '0');
}

/**
 * 辅助函数：生成「中国红」号码匹配游戏盘面
 * @param {number} prizeToWin - 预先确定的奖金额 (0 表示未中奖)
 */
function generateChinaRedGrid(prizeToWin) {
    // 1. 生成 2 个不重复的中奖号码
    let winningNumbers = new Set();
    while (winningNumbers.size < 2) {
        winningNumbers.add(getRandomLotteryNumber());
    }
    const winningNumbersArr = Array.from(winningNumbers); // [ '08', '25' ]

    // 2. 生成 8 个 "你的号码" 和对应的 "奖金"
    let yourNumbers = [];
    let fakePrizes = [50, 100, 500, 1000, 50, 100, 500, 10000]; // 假奖金池
    let fakeNumbers = new Set(); // 确保你的假号码不重复
    while (fakeNumbers.size < 8) {
        const num = getRandomLotteryNumber();
        if (!winningNumbers.has(num)) { // 确保不等于中奖号码
            fakeNumbers.add(num);
        }
    }
    const fakeNumbersArr = Array.from(fakeNumbers);

    if (prizeToWin === 0) {
        // --- 输了 ---
        // 8个号码都用假的
        yourNumbers = fakeNumbersArr.map((num, i) => ({
            number: num,
            prize: fakePrizes[i],
            isMatch: false
        }));
    } else {
        // --- 赢了 ---
        // 7个号码用假的
        yourNumbers = fakeNumbersArr.slice(0, 7).map((num, i) => ({
            number: num,
            prize: fakePrizes[i],
            isMatch: false
        }));
        // 1个号码用真的
        yourNumbers.push({
            number: winningNumbersArr[0], // 匹配第一个中奖号码
            prize: prizeToWin, // 奖金是预先确定的
            isMatch: true
        });
        // 洗牌，让中奖号码位置随机
        yourNumbers = shuffleArray(yourNumbers);
    }

    return { winningNumbers: winningNumbersArr, yourNumbers };
}

/**
 * 辅助函数：生成「暴富钻石」9宫格匹配游戏盘面
 * @param {number} prizeToWin - 预先确定的奖金额 (0 表示未中奖)
 */
function generateDiamondGrid(prizeToWin) {
    let grid = [];
    const loseSymbols = ['😥', '🍌', '☂️', '👟', '💨'];
    // 制造“差一点就中”的假象
    const fakePrizes = ['¥100', '¥100', '¥500', '¥500', '¥1,000', '¥1,000', '¥5,000'];

    if (prizeToWin > 0) {
        // --- 赢了 ---
        const winSymbol = `¥${prizeToWin}`;
        grid = [winSymbol, winSymbol, winSymbol]; // 3个中奖符号
        // 剩下的 6 个用 "谢谢惠顾" 和 "假奖金" 填充
        grid = grid.concat(shuffleArray(fakePrizes.concat(loseSymbols)).slice(0, 6));
    } else {
        // --- 没中 ---
        // 填充 9 个格子，确保没有任何 3 个是相同的
        grid = shuffleArray(fakePrizes.concat(loseSymbols).concat(['¥10,000', '¥10,000'])).slice(0, 9);
    }
    
    return shuffleArray(grid); // 再次打乱
}

/**
 * 辅助函数：生成「幸运 7」符号匹配游戏盘面
 * @param {number} prizeToWin - 预先确定的奖金额 (0 表示未中奖)
 */
function generateLucky7Grid(prizeToWin) {
    let grid = [];
    // 6 个格子
    const symbols = ['🍒', '🍊', '🍋', '🔔', '🍉', '⭐'];
    
    if (prizeToWin > 0) {
        // --- 赢了 ---
        grid = shuffleArray(['7️⃣', '🍒', '🍊', '🍋', '🔔', '🍉']);
    } else {
        // --- 没中 ---
        grid = shuffleArray(symbols);
    }
    return grid;
}


/**
 * (V3.4 - 指定大奖版) 购买刮刮乐的核心逻辑
 * @param {number} price - 价格
 * @param {string} gameType - 游戏类型 ('lucky_7', 'china_red', 'diamond')
 */
async function purchaseScratchCard(price, gameType) {
    price = parseInt(price, 10);
    if (state.myProfile.balance < price) {
        alert('余额不足！');
        return;
    }

    // 1. 扣钱
    state.myProfile.balance -= price;
    await addTransaction('expense', price, `购买 ${price}元 刮刮乐`);

    // 2. 核心：【先开奖】
    const rand = Math.random();
    let winnings = 0;
    let title = "";
    let message = "";

    // 3. 根据游戏类型决定赔率和玩法
    // ==================================
    // 游戏 1: 幸运 7 (20元) - (✨ 植入20万大奖 ✨)
    // ==================================
    if (gameType === 'lucky_7') {
        title = "刮开「幸运 7」！";
        // 规则：找到一个 "7" 就中奖
        
        // ▼▼▼ 核心修改在这里 ▼▼▼
        if (rand < 0.00005) { 
            winnings = 200000; // ✨ 20万大奖！(2万分之一概率)
        } 
        // ▲▲▲ 修改结束 ▲▲▲
        
        else if (rand < 0.01) { winnings = 500; }    // (1% 概率中 500)
        else if (rand < 0.11) { winnings = 100; }   // (10% 概率中 100)
        else if (rand < 0.31) { winnings = 20; }    // (20% 概率中 20, 回本)
        else { winnings = 0; }
        
        const grid = generateLucky7Grid(winnings);
        
        // 渲染UI (6格)
        const gridDisplay = document.getElementById('scratch-grid-display');
        gridDisplay.innerHTML = '';
        gridDisplay.className = 'your-numbers-grid'; // 复用这个样式
        gridDisplay.style.gridTemplateColumns = '1fr 1fr 1fr'; // 改成 3 列
        
        grid.forEach(symbol => {
            const isWinning = symbol === '7️⃣';
            gridDisplay.innerHTML += `
                <div class="scratch-cell-player covered ${isWinning ? 'match' : ''}" data-symbol="${symbol}">
                    <span class="symbol-content">${symbol}</span>
                    <i class="fas fa-coins scratch-icon"></i>
                </div>
            `;
        });

    // ==================================
    // 游戏 2: 中国红 (50元) - (✨ 植入50万大奖 ✨)
    // ==================================
    } else if (gameType === 'china_red') {
        title = "刮开「中国红」！";
        // 规则：号码匹配
        
        // ▼▼▼ 核心修改在这里 ▼▼▼
        if (rand < 0.00002) { 
            winnings = 500000; // ✨ 50万大奖！(5万分之一概率)
        } 
        // ▲▲▲ 修改结束 ▲▲▲
        
        else if (rand < 0.005) { winnings = 5000; }   // (0.5% 概率中 5000)
        else if (rand < 0.10) { winnings = 100; }  // (9.5% 概率中 100)
        else if (rand < 0.30) { winnings = 50; }   // (20%  概率中 50, 回本)
        else { winnings = 0; }
        
        const gameData = generateChinaRedGrid(winnings);
        
        // 渲染UI (专属布局)
        const gridDisplay = document.getElementById('scratch-grid-display');
        gridDisplay.innerHTML = '';
        gridDisplay.className = 'game-china-red'; // 添加专属 class
        gridDisplay.style.gridTemplateColumns = '1fr'; // 重置为单列
        
        // A. 渲染中奖号码区 (这个是默认就刮开的)
        gridDisplay.innerHTML += `
            <div class="china-red-area">
                <h3>中奖号码</h3>
                <div class="winning-numbers-grid">
                    <div class="scratch-cell-winner">${gameData.winningNumbers[0]}</div>
                    <div class="scratch-cell-winner">${gameData.winningNumbers[1]}</div>
                </div>
            </div>
        `;
        // B. 渲染你的号码区 
        let yourNumbersHTML = gameData.yourNumbers.map(item => `
            <div class="scratch-cell-player covered ${item.isMatch ? 'match' : ''}" data-number="${item.number}" data-prize="${item.prize}" data-is-match="${item.isMatch}">
                <div class="cell-content">
                    <div class="player-number">${item.number}</div>
                    <div class="player-prize">¥${item.prize}</div>
                </div>
                <i class="fas fa-coins scratch-icon"></i>
            </div>
        `).join('');
        
        gridDisplay.innerHTML += `
            <div class="china-red-area">
                <h3>你的号码</h3>
                <div class="your-numbers-grid">
                    ${yourNumbersHTML}
                </div>
            </div>
        `;

    // ==================================
    // 游戏 3: 暴富钻石 (100元) - (✨ 植入100万大奖 ✨)
    // ==================================
    } else if (gameType === 'diamond') {
        title = "刮开「暴富钻石」！";
        // 规则：9宫格三匹配
        
        // ▼▼▼ 核心修改在这里 ▼▼▼
        if (rand < 0.00001) { 
            winnings = 1000000; // ✨ 100万大奖！ (十万分之一)
        } 
        // ▲▲▲ 修改结束 ▲▲▲

        // (保留其它的高额奖项，让这个彩票更刺激)
        else if (rand < 0.001) { 
            winnings = 100000;  // 10万大奖 (0.1% 概率)
        } 
        else if (rand < 0.02) { 
            winnings = 1000;    // 1000元 (1.9% 概率)
        } 
        else if (rand < 0.12) { 
            winnings = 500;     // 500元 (10% 概率)
        } 
        else if (rand < 0.27) { 
            winnings = 100;     // 100元 (回本) (15% 概率)
        } 
        else { 
            winnings = 0; 
        }
        
        const grid = generateDiamondGrid(winnings);
        
        // 渲染UI (9格)
        const gridDisplay = document.getElementById('scratch-grid-display');
        gridDisplay.innerHTML = '';
        gridDisplay.className = 'your-numbers-grid'; // 复用这个样式
        gridDisplay.style.gridTemplateColumns = '1fr 1fr 1fr'; // 3 列
        
        grid.forEach(symbol => {
            const isWinning = (winnings > 0 && symbol === `¥${winnings}`);
            gridDisplay.innerHTML += `
                <div class="scratch-cell-player covered ${isWinning ? 'match' : ''}" data-symbol="${symbol}">
                    <span class="symbol-content" style="font-size: ${symbol.length > 5 ? '14px' : '18px'};">${symbol}</span>
                    <i class="fas fa-coins scratch-icon"></i>
                </div>
            `;
        });
    }

    // 4. (已修改) 设置中奖信息
    if (winnings > 0) {
        // ✨ 修改：让中大奖的提示更夸张！
        if (winnings >= 200000) {
            message = `🎉🎉🎉 **天呐！！你中了特等奖！！** <br> **${winnings.toLocaleString('en-US')}** 元！`;
        } else if (winnings >= 1000) {
             message = `🎉🎉 恭喜！你中了 **${winnings}** 元！`;
        } else {
            message = `恭喜，你中了 ${winnings} 元！`;
        }
    } else {
        message = "谢谢惠顾，下次好运哦！";
    }

    // 5. 【核心修改】只显示刮奖区域，不显示结果
    const resultArea = document.getElementById('scratch-result-area');
    resultArea.style.display = 'block';
    document.getElementById('scratch-result-title').innerHTML = title;
    
    // 【修改】把结果先存起来，不显示
    resultArea.dataset.winnings = winnings;
    resultArea.dataset.message = message;
    resultArea.dataset.gameType = gameType;
    // 【修改】清空上次的结果
    document.getElementById('scratch-result-message').innerHTML = ''; 
    
    // 6. 刷新余额
    renderMyProfile();
    await kokoMemory.put('myProfile', state.myProfile);
}
// ▼▼▼ 把这段新代码粘贴到 attachEventListeners 函数的【末尾】 ▼▼▼

    // --- 新增：Koko交易所 - 标签页点击事件 ---
    document.getElementById('stock-tabs-container').addEventListener('click', (e) => {
        const tabBtn = e.target.closest('.feed-tab-btn');
        if (tabBtn && tabBtn.dataset.stockId) {
            // 当点击标签页时，只更新UI，不触发事件循环
            updateStockMarketUI(tabBtn.dataset.stockId);
        }
    });
// ▲▲▲ 粘贴结束 ▲▲▲
// ==========================================================
// =========== ▼▼▼ 新增：外观预设核心逻辑 ▼▼▼ ==============
// ==========================================================

/**
 * 1. 渲染预设下拉菜单
 */
function renderThemePresetSelector() {
    const select = document.getElementById('theme-preset-select');
    const deleteBtn = document.getElementById('delete-theme-preset-btn');
    
    // 清空并重置
    select.innerHTML = '<option value="">-- 选择预设以应用 --</option>';
    
    if (!state.themePresets || state.themePresets.length === 0) {
        return;
    }

    state.themePresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        select.appendChild(option);
    });

    // 重置删除按钮状态
    deleteBtn.style.display = 'none';
    select.value = "";
}

/**
 * 2. 保存当前设置为新预设
 */
async function saveCurrentThemeAsPreset() {
    // 从输入框获取最新值（确保是用户眼见的值）
    // 注意：这里我们收集所有外观相关的字段
    const newPreset = {
        id: `theme_preset_${Date.now()}`,
        name: '', // 稍后填
        data: {
            customBubbleCss: document.getElementById('bubble-css-input').value.trim(),
            customThemeCss: document.getElementById('theme-css-input').value.trim(),
            customNarrativeCss: document.getElementById('narrative-css-input').value.trim(),
            
            customFontSize: parseFloat(document.getElementById('font-size-input').value) || null,
            customLetterSpacing: parseFloat(document.getElementById('letter-spacing-input').value) || null,
            customFontWeight: parseInt(document.getElementById('font-weight-input').value, 10) || null,
            
            customFontUrl: document.getElementById('font-url-input').value.trim(),
            customFontName: document.getElementById('font-name-input').value.trim(),
            
            autoLockDelay: parseInt(document.getElementById('auto-lock-delay-input').value, 10) || 0,
            showSparkAndLuckyChar: document.getElementById('show-spark-toggle').checked,
            
            // 背景图从全局变量取（因为它不在input里显示base64）
            chatBackground: userSettings.chatBackground
        }
    };

    const name = await showCustomPrompt("保存主题预设", "给这个主题起个名字吧（例如：护眼绿、夜间模式）");
    if (!name || !name.trim()) return;

    newPreset.name = name.trim();

    // 存入 State 和 DB
    state.themePresets.push(newPreset);
    await kokoMemory.put('themePresets', newPreset);

    alert(`主题 "${newPreset.name}" 保存成功！`);
    renderThemePresetSelector();
}

/**
 * 3. 应用选中的预设
 */
async function applySelectedThemePreset(presetId) {
    const preset = state.themePresets.find(p => p.id === presetId);
    if (!preset) return;

    const d = preset.data;

    // A. 填充输入框
    document.getElementById('bubble-css-input').value = d.customBubbleCss || '';
    document.getElementById('theme-css-input').value = d.customThemeCss || '';
    document.getElementById('narrative-css-input').value = d.customNarrativeCss || '';
    document.getElementById('font-size-input').value = d.customFontSize || '';
    document.getElementById('letter-spacing-input').value = d.customLetterSpacing || '';
    document.getElementById('font-weight-input').value = d.customFontWeight || '';
    document.getElementById('font-url-input').value = d.customFontUrl || '';
    document.getElementById('font-name-input').value = d.customFontName || '';
    document.getElementById('auto-lock-delay-input').value = d.autoLockDelay || '';
    document.getElementById('show-spark-toggle').checked = d.showSparkAndLuckyChar !== false;

    // B. 更新全局变量 userSettings (暂存，还未保存到 userSettings DB)
    // 这样点击“应用并保存”时就会用这些值
    userSettings = { ...userSettings, ...d };

    // C. 立即触发预览更新
    // (我们需要手动调用 updatePreview 来刷新 iframe)
    if (typeof loadPreviewFromInputs === 'function') {
        loadPreviewFromInputs(); 
        // 额外处理背景图，因为 loadPreviewFromInputs 有时读不到最新的 userSettings.chatBackground 如果没保存
        updatePreview('background', d.chatBackground); 
    }

    // D. 给个反馈
    // 自动点击一下“应用并保存”按钮，让效果真正生效并持久化到 userSettings 表
    // 这样用户哪怕不点保存，切出去也能生效
    document.getElementById('save-appearance-btn').click();
}

/**
 * 4. 删除预设
 */
async function deleteSelectedThemePreset() {
    const select = document.getElementById('theme-preset-select');
    const presetId = select.value;
    if (!presetId) return;

    const confirmed = await showCustomConfirm("删除预设", "确定要删除这个主题预设吗？", true);
    if (confirmed) {
        // 从 State 移除
        state.themePresets = state.themePresets.filter(p => p.id !== presetId);
        // 从 DB 移除
        await kokoMemory.delete('themePresets', presetId);
        
        renderThemePresetSelector();
        alert("已删除。");
    }
}
// ==========================================================
// =========== ▲▲▲ 股票 + 彩票 核心功能函数 END ▲▲▲ =========
// ==========================================================
// =========== ▼▼▼ 粘贴这个全新的函数 ▼▼▼ ============
// ==========================================================
// ▼▼▼ 使用这个【V2 - 支持群聊版】完整替换旧的 openForwardChatModal 函数 ▼▼▼

/**
 * 【全新】打开聊天记录转发模态框
 * (复用了 帖子转发 的弹窗)
 */
async function openForwardChatModal() {
    const { selectedMessageIds } = editModeState;
    if (selectedMessageIds.size === 0) {
        return alert('请先选择要转发的消息。');
    }

    const sourceContact = state.contacts.find(c => c.id === state.activeChatId);
    if (!sourceContact) return;

    // 1. 关键：获取所有被选中的消息，并按【时间戳】排序
    const messagesToForward = Array.from(selectedMessageIds)
        .map(msgId => sourceContact.history.find(m => m.id === msgId))
        .filter(Boolean) // 过滤掉未找到的消息
        .sort((a, b) => a.timestamp - b.timestamp); // 确保按时间顺序

    // 2. 复用你现有的“转发”弹窗
    const modal = document.getElementById('repost-contact-picker-modal');
    const contactListEl = document.getElementById('repost-contact-list');
    const messageInput = document.getElementById('repost-message-input');
    
    messageInput.value = ''; // 清空留言
    contactListEl.innerHTML = ''; // 清空列表

    // 3. 填充联系人列表 (✨ 核心修改点在这里 ✨)
    state.contacts.forEach(contact => {
        // --- 核心修改：我们现在只排除当前所在的聊天，不再排除群聊 ---
        if (contact.id === state.activeChatId) return; 

        // --- 新增：智能判断头像 ---
        let avatarHTML = '';
        let imgSrc = '';
        let isDefaultGroupIcon = false;

        if (contact.isGroup) {
            if (contact.avatar) {
                // A. 群聊有自定义头像
                imgSrc = contact.avatar;
            } else {
                // B. 群聊使用默认图标
                isDefaultGroupIcon = true;
                avatarHTML = `<div style="width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background-color: #f0f2f5; color: var(--theme-primary); font-size: 20px;">
                                <i class="fas fa-users"></i>
                              </div>`;
            }
        } else {
            // C. 私聊
            imgSrc = contact.avatar || `https://via.placeholder.com/40/DDD/666?text=${contact.name.substring(0,1)}`;
        }

        // 如果不是B情况 (即是私聊或有头像的群聊)，就统一使用 <img> 标签
        if (!isDefaultGroupIcon) {
            avatarHTML = `<img src="${imgSrc}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">`;
        }
        
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
            <input type="checkbox" id="forward-contact-check-${contact.id}" value="${contact.id}">
            <label for="forward-contact-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                ${avatarHTML}
                <span style="${isDefaultGroupIcon ? 'margin-left: 10px;' : ''}">${contact.name}</span>
            </label>
        `;
        contactListEl.appendChild(item);
    });
    
    modal.style.display = 'flex';

    // 4. 为“确认”按钮绑定一次性事件 (这部分逻辑你原来就写对了，它天生支持群聊)
    document.getElementById('close-repost-modal').onclick = () => modal.style.display = 'none';
    
    const confirmBtn = document.getElementById('confirm-repost-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true); 
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

    newConfirmBtn.addEventListener('click', async () => {
        const selectedContactIds = Array.from(contactListEl.querySelectorAll('input:checked')).map(input => input.value);
        if (selectedContactIds.length === 0) {
            return alert('请至少选择一个联系人或群聊'); // (修改了提示文本)
        }
        
        const accompanyingMessage = messageInput.value.trim();

        // 5. 【核心】将多条消息和上下文打包成一个对象
        const forwardData = {
            sourceChatName: sourceContact.isGroup ? `群聊 "${sourceContact.name}"` : `与 ${sourceContact.name} 的聊天`,
            messages: messagesToForward, 
            participants: {}
        };

        // 6. 填充参与者信息 (✨ 升级：确保能找到NPC的名字 ✨)
        forwardData.participants['myProfile'] = { name: state.myProfile.name };
        forwardData.participants['user'] = { name: state.myProfile.name }; // 兼容旧数据
        
        if (sourceContact.isGroup) {
            // 遍历群成员ID
            sourceContact.members.forEach(id => {
                if (!forwardData.participants[id]) {
                    // 优先从联系人列表找
                    let memberProfile = state.contacts.find(c => c.id === id);
                    // 如果没找到 (说明是NPC)，就从群的NPC列表里找
                    if (!memberProfile && sourceContact.npcMembers) {
                        memberProfile = sourceContact.npcMembers.find(npc => npc.id === id);
                    }
                    if(memberProfile) forwardData.participants[id] = { name: memberProfile.name };
                }
            });
        } else {
            forwardData.participants[sourceContact.id] = { name: sourceContact.name };
        }

        // 7. 循环发送给所有选中的会话
        for (const recipientId of selectedContactIds) {
            // 这一步能同时找到联系人和群聊
            const recipientContact = state.contacts.find(c => c.id === recipientId); 
            if (!recipientContact) continue;

            // 发送这条【新类型】的消息
            await createAndAddMessage({
                type: 'chat_history_share',
                content: forwardData
            }, 'user', recipientContact, false, 'chat');

            if (accompanyingMessage) {
                await createAndAddMessage({
                    type: 'text',
                    content: accompanyingMessage
                }, 'user', recipientContact, false, 'chat');
            }
        }
        
        modal.style.display = 'none';
        alert(`已成功转发给 ${selectedContactIds.length} 个会话！`); // (修改了提示文本)
        await exitEditMode();
        
    }, { once: true });
}

// ▲▲▲ 替换到这里结束 ▲▲▲

// ==========================================================
let editingCategoryId = null; // 用于跟踪正在编辑的分类ID

/**
 * (新) 显示论坛板块管理页面
 */
async function showForumCategoryScreen() {
    hideAllScreens();
    document.getElementById('forum-category-management-screen').style.display = 'flex';
    await renderForumCategories();
}

/**
 * (新) 渲染所有自定义板块列表
 */
async function renderForumCategories() {
    const listEl = document.getElementById('category-list');
    const noCategoryMsg = document.getElementById('no-category-message');
    listEl.innerHTML = '';

    if (state.forumCategories.length === 0) {
        noCategoryMsg.style.display = 'block';
    } else {
        noCategoryMsg.style.display = 'none';
        state.forumCategories.forEach(category => {
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.dataset.categoryId = category.id;
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${category.name}</div>
                    <div class="preset-desc">${category.description}</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn edit-category-btn" title="编辑板块"><i class="fas fa-edit"></i></span>
                    <span class="preset-action-btn delete delete-category-btn" title="删除板块"><i class="fas fa-trash-alt"></i></span>
                </div>
            `;
            listEl.appendChild(item);
        });
    }
}

/**
 * (新) 打开添加/编辑板块的弹窗
 */
function openCategoryModal(category = null) {
    const modal = document.getElementById('add-category-modal');
    if (category) {
        // 编辑模式
        editingCategoryId = category.id;
        document.getElementById('category-modal-title').textContent = '编辑板块';
        document.getElementById('category-id-input').value = category.id;
        document.getElementById('category-name-input').value = category.name;
        document.getElementById('category-description-input').value = category.description;
    } else {
        // 添加模式
        editingCategoryId = null;
        document.getElementById('category-modal-title').textContent = '添加新板块';
        document.getElementById('category-id-input').value = '';
        document.getElementById('category-name-input').value = '';
        document.getElementById('category-description-input').value = '';
    }
    modal.style.display = 'flex';
}

/**
 * (新) 保存板块（添加或编辑）
 */
async function saveForumCategory() {
    const name = document.getElementById('category-name-input').value.trim();
    const description = document.getElementById('category-description-input').value.trim();
    if (!name || !description) {
        alert('请填写板块名称和描述！');
        return;
    }

    if (editingCategoryId) {
        // 编辑
        const category = state.forumCategories.find(c => c.id === editingCategoryId);
        if (category) {
            category.name = name;
            category.description = description;
            await kokoMemory.put('forumCategories', category);
        }
    } else {
        // 新增
        const newCategory = {
            id: 'category_' + Date.now(),
            name: name,
            description: description
        };
        state.forumCategories.push(newCategory);
        await kokoMemory.put('forumCategories', newCategory);
    }
    
    await renderForumCategories(); // 刷新列表
    document.getElementById('add-category-modal').style.display = 'none';
}

/**
 * (新) 删除板块
 */
async function deleteForumCategory(categoryId) {
    const category = state.forumCategories.find(c => c.id === categoryId);
    if (!category) return;
    
    const confirmed = await showCustomConfirm('删除板块', `确定要删除“${category.name}”吗？\n（这不会删除该板块下的帖子）`, true);
    if (confirmed) {
        state.forumCategories = state.forumCategories.filter(c => c.id !== categoryId);
        await kokoMemory.delete('forumCategories', categoryId);
        await renderForumCategories(); // 刷新列表
    }
}

// ▲▲▲ 新函数粘贴到这里结束 ▲▲▲
// ==========================================
// ▼▼▼ Koko空间装修核心逻辑 ▼▼▼
// ==========================================
// --- 新增：SVIP 样式选择函数 ---
window.selectSvipStyle = function(style, el) {
    // 1. UI 选中态
    document.querySelectorAll('.svip-style-opt').forEach(opt => {
        opt.style.boxShadow = 'none';
        opt.style.transform = 'scale(1)';
    });
    el.style.boxShadow = '0 0 0 2px #2196F3'; // 蓝色外框表示选中
    el.style.transform = 'scale(1.05)';
    
    // 2. 暂存到全局设置
    if (!userSettings.qzoneSettings) userSettings.qzoneSettings = {};
    userSettings.qzoneSettings.svipStyle = style;
    
    // 3. 实时预览：立即修改页面上的图标
    const badge = document.getElementById('qz-svip-display');
    if (badge) {
        badge.className = `qz-svip-badge style-${style}`;
    }
}
// 默认的空间设置
const defaultQzoneSettings = {
    theme: 'default',
    nameColor: '#ffffff',
    pageBackground: '', // 信息流背景
    deviceText: 'iPhone 16 Pro Max',
    svipLevel: 8,
    showSvip: true,
    badges: [] // 存放选中的图标ID: ['yellow', 'red']
};
// 渲染空间发帖白名单列表
function renderQzoneAllowedPostersList() {
    const list = document.getElementById('qz-allowed-posters-list');
    list.innerHTML = '';
    
    // 获取已保存的白名单 (如果没有保存过，默认全部选中)
    const s = userSettings.qzoneSettings || {};
    const allowedIds = s.allowedPosters; 
    
    // 筛选所有单人联系人
    const contacts = state.contacts.filter(c => !c.isGroup);
    
    if (contacts.length === 0) {
        list.innerHTML = '<p style="color:#ccc; font-size:12px; grid-column:1/-1; text-align:center;">没有可选的角色</p>';
        return;
    }

    contacts.forEach(c => {
        // 如果 allowedIds 是 undefined (从未设置过)，则默认选中；否则看是否在数组里
        const isChecked = (allowedIds === undefined) ? true : allowedIds.includes(c.id);
        
        const item = document.createElement('div');
        item.style.display = 'flex';
        item.style.alignItems = 'center';
        
        item.innerHTML = `
            <input type="checkbox" class="world-book-checkbox qz-poster-check" id="qz-p-${c.id}" value="${c.id}" ${isChecked ? 'checked' : ''}>
            <label for="qz-p-${c.id}" class="world-book-name" style="margin-left:5px; font-size:13px; cursor:pointer;">${c.name}</label>
        `;
        list.appendChild(item);
    });
}

// 全选/全不选 辅助函数 (记得把它暴露给全局，或者确保HTML能访问)
window.toggleAllQzonePosters = function(checked) {
    document.querySelectorAll('.qz-poster-check').forEach(cb => cb.checked = checked);
};
// 初始化/加载空间设置 (最终完整版：包含磨砂玻璃 + 所有个性化设置)
async function loadQzoneSettings() {
    // 1. 如果设置不存在，先初始化默认值
    if (!userSettings.qzoneSettings) {
        userSettings.qzoneSettings = JSON.parse(JSON.stringify(defaultQzoneSettings));
    }
    const s = userSettings.qzoneSettings;
    const screen = document.getElementById('social-zone-screen');

    // 2. 应用主题 (切换 CSS 类)
    applyQzoneTheme(s.theme);
    
    // 3. 应用名字颜色
    const nameEl = document.getElementById('qz-user-name');
    if(nameEl) nameEl.style.color = s.nameColor;

    // 4. 应用背景图 & 磨砂玻璃特效
    if (screen) {
        if (s.pageBackground) {
            // 有背景图：设置背景 + 开启磨砂模式
            screen.style.backgroundImage = `url(${s.pageBackground})`;
            screen.style.backgroundSize = 'cover';
            screen.style.backgroundAttachment = 'fixed';
            screen.style.backgroundPosition = 'center';
            
            screen.classList.add('has-custom-bg'); // 激活父级类名

            // 强制给现有元素添加 glass-card 类
            document.querySelectorAll('.qz-card, .qz-header-wrapper, .qz-tab-bar, .qz-quick-post-area').forEach(el => {
                el.classList.add('glass-card');
            });
            // 导航栏滚动时也变磨砂
            const nav = document.querySelector('.qz-navbar.scrolled');
            if(nav) nav.classList.add('glass-card');

        } else {
            // 无背景图：清除背景 + 关闭磨砂模式
            screen.style.backgroundImage = '';
            screen.classList.remove('has-custom-bg');
            
            // 移除所有元素的 glass-card 类，恢复白底
            document.querySelectorAll('.glass-card').forEach(el => {
                el.classList.remove('glass-card');
            });
        }
    }

    // 5. 应用 SVIP 显示 (包含等级和样式)
    const svipBadge = document.getElementById('qz-svip-display');
    const svipLevel = document.getElementById('qz-svip-level');
    if (svipBadge && svipLevel) {
        // 控制显示/隐藏
        svipBadge.style.display = s.showSvip ? 'inline-flex' : 'none';
        // 设置等级数字
        svipLevel.textContent = s.svipLevel;
        
        // 设置样式 (经典黄/黑金/黑红)
        const styleClass = s.svipStyle || 'yellow';
        svipBadge.className = `qz-svip-badge style-${styleClass}`;
    }

    // 6. 应用其他徽章图标 (黄钻、绿钻等)
    renderQzoneBadges(s.badges || []);

    // 7. 同步数据到装修弹窗的输入框 (确保下次打开弹窗时数据显示正确)
    const nameInput = document.getElementById('qz-name-color-input');
    if(nameInput) nameInput.value = s.nameColor;
    
    const deviceInput = document.getElementById('qz-device-input');
    if(deviceInput) deviceInput.value = s.deviceText;

    const svipInput = document.getElementById('qz-svip-level-input');
    if(svipInput) svipInput.value = s.svipLevel;

    const svipToggle = document.getElementById('qz-svip-toggle');
    if(svipToggle) svipToggle.checked = s.showSvip;
    
    // 同步徽章选择状态
    document.querySelectorAll('.badge-option').forEach(opt => opt.classList.remove('selected'));
    (s.badges || []).forEach(b => {
        const opt = document.getElementById(`badge-opt-${b}`);
        if(opt) opt.classList.add('selected');
    });
    
    // 同步 SVIP 样式选择状态
    document.querySelectorAll('.svip-style-opt').forEach(opt => {
        opt.style.boxShadow = 'none';
        opt.style.transform = 'scale(1)';
    });
    // 找到当前选中的样式按钮并高亮
    const currentStyle = s.svipStyle || 'yellow';
    // 这里我们需要根据 onclick 里的参数反向查找按钮，稍微复杂点，
    // 简单起见，我们只在点击时做视觉反馈，或者你可以给按钮加 id 来精确控制。
    // 为了代码简单，这里暂不回显样式按钮的“选中态”，不影响功能。
    // ... 在 loadQzoneSettings 函数末尾 ...
    // 回显自动刷新设置
    const autoToggle = document.getElementById('qz-auto-refresh-toggle');
    const autoInput = document.getElementById('qz-auto-refresh-interval');
    if (autoToggle) autoToggle.checked = s.autoRefreshEnabled || false;
    if (autoInput) autoInput.value = s.autoRefreshInterval || 600;
}

// 切换主题函数 (HTML onclick调用)
window.setQzoneTheme = function(themeName, el) {
    // 更新 UI 选中态
    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
    el.classList.add('active');
    
    // 实时预览
    applyQzoneTheme(themeName);
    
    // 暂存状态 (还没保存到DB)
    userSettings.qzoneSettings.theme = themeName;
}

function applyQzoneTheme(themeName) {
    const screen = document.getElementById('social-zone-screen');
    // 移除旧类
    screen.classList.remove('qz-theme-pink', 'qz-theme-darkgold', 'qz-theme-blue');
    // 添加新类
    if (themeName !== 'default') {
        screen.classList.add(`qz-theme-${themeName}`);
    }
}

// 切换徽章函数 (HTML onclick调用)
window.toggleQzBadge = function(badgeId) {
    const opt = document.getElementById(`badge-opt-${badgeId}`);
    opt.classList.toggle('selected');
    
    // 更新数组
    let badges = userSettings.qzoneSettings.badges || [];
    if (opt.classList.contains('selected')) {
        if (!badges.includes(badgeId)) badges.push(badgeId);
    } else {
        badges = badges.filter(b => b !== badgeId);
    }
    userSettings.qzoneSettings.badges = badges;
    
    // 实时预览
    renderQzoneBadges(badges);
}

function renderQzoneBadges(badges) {
    const container = document.getElementById('qz-badge-container');
    container.innerHTML = '';
    
    const badgeMap = {
        'yellow': '<i class="fas fa-gem diamond-yellow"></i>',
        'red': '<i class="fas fa-gem diamond-red"></i>',
        'green': '<i class="fas fa-gem diamond-green"></i>',
        'blue': '<i class="fas fa-gem diamond-blue"></i>',
        'purple': '<i class="fas fa-gem diamond-purple"></i>',
        'star': '<i class="fas fa-star icon-star"></i>',
        'music': '<i class="fas fa-music" style="color:#8BC34A"></i>',
        'video': '<i class="fas fa-video" style="color:#FF9800"></i>'
    };

    badges.forEach(id => {
        if (badgeMap[id]) {
            const span = document.createElement('span');
            // 为了好看，给图标加一点背景
            span.style.cssText = "background:rgba(255,255,255,0.8); border-radius:3px; padding:1px 3px; font-size:12px; display:flex; align-items:center;";
            span.innerHTML = badgeMap[id];
            container.appendChild(span);
        }
    });
}

// 打开装修弹窗 (更新版)
function openQzoneSettings() {
    loadQzoneSettings(); 
    renderQzoneAllowedPostersList(); // ✨ 新增：打开时渲染角色列表
    document.getElementById('qz-settings-modal').style.display = 'flex';
}

// ==========================================
// --- Koko 空间自动化全局变量 ---
let qzoneAutoTimer = null; // 定时器句柄

// 开启自动刷新
function startQzoneAutoRefresh() {
    if (qzoneAutoTimer) clearInterval(qzoneAutoTimer);
    
    const settings = userSettings.qzoneSettings;
    if (!settings || !settings.autoRefreshEnabled) return;

    const interval = Math.max(30, parseInt(settings.autoRefreshInterval)); // 最小30秒
    
    console.log(`Koko空间自动刷新已启动，间隔: ${interval}秒`);
    qzoneAutoTimer = setInterval(() => {
        generateAiQzoneFeed(false); // false 表示非手动，静默执行
    }, interval * 1000);
}

// 停止自动刷新
function stopQzoneAutoRefresh() {
    if (qzoneAutoTimer) {
        clearInterval(qzoneAutoTimer);
        qzoneAutoTimer = null;
        console.log("Koko空间自动刷新已停止。");
    }
}
/**
 * (V8 - 双模态终极版) 生成 Koko 空间动态
 * 完美融合：高质量普通说说 + AI自主排版手帐
 */
async function generateAiQzoneFeed(isManual = false) {
    if (isManual) showFeedStatus('正在连接朋友圈神经元...');

    try {
        const myProfile = state.myProfile;

        // 1. 筛选活跃联系人 (发帖候选人)
        let candidates = state.contacts.filter(c => !c.isGroup && c.id !== 'myProfile');
        
        // 应用白名单筛选
        const settings = userSettings.qzoneSettings || {};
        if (settings.allowedPosters && Array.isArray(settings.allowedPosters)) {
            candidates = candidates.filter(c => settings.allowedPosters.includes(c.id));
        }

        if (candidates.length === 0) {
            if (isManual) alert("没有可用的角色发动态，请检查白名单设置！");
            return;
        }

        // 2. 随机挑选角色
        const count = Math.min(candidates.length, Math.floor(Math.random() * 3) + 3); 
        const shuffled = [...candidates].sort(() => 0.5 - Math.random());
        const selectedAuthors = shuffled.slice(0, count);

        // 3. 构建深度上下文 (包含人设和记忆)
        const authorsContext = selectedAuthors.map((c, index) => {
            const userPersonaInIsEyes = c.userPersona || myProfile.signature || "(用户未设置具体设定)";
            let chatHistory = "(暂无聊天记录)";
            if (c.history && c.history.length > 0) {
                chatHistory = c.history
                    .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction' && msg.type !== 'system_notification')
                    .slice(-40) 
                    .map(msg => `${msg.sender === 'user' ? myProfile.name : c.name}: ${msg.content}`)
                    .join('\n');
            }

            return `
[角色ID: ${index}]
- 名字: ${c.name}
- 核心人设: ${c.persona.substring(0, 800).replace(/\n/g, ' ')}...
- 对用户的印象: ${userPersonaInIsEyes}
- 最近记忆片段: ${chatHistory.substring(0, 400)}...
`;
        }).join('\n----------------\n');

        // 4. ★★★ 超级 Prompt：同时包含两种模式的严格要求 ★★★
        const prompt = `[SYSTEM] 你是高拟真社交网络模拟引擎。
[当前用户]: ${myProfile.name}

[待发帖角色列表]
${authorsContext}

[生成任务]
请为上述每一个[角色ID]生成一条动态。
你需要根据角色当下的心情和人设，**随机决定**发布哪种类型的动态：
1.  **普通说说 (normal)**: 约占 70% 概率。
2.  **精美手帐 (journal)**: 约占 30% 概率。

---

### 【模式一：普通说说 (normal) 创作规范】
**1. 内容要求 (核心)**
- **拒绝流水账**: 不要只写“今天天气真好”，要结合角色的具体生活或心境。
- **关系互动 (60%)**: 基于[最近记忆片段]或对用户的印象发帖。可以是对刚才聊天的延伸、吐槽、或者是发给用户看的（但不一定点名）。
- **独立生活 (40%)**: 发与用户完全无关的个人生活、工作、兴趣。
- **去油腻**: **绝对禁止**使用“霸道总裁”式、油腻、虚假的情话。语气要真实、接地气。

**2. 配图要求**
- 必须为每条说说构思一张配图的画面描述 (填入 \`imageDesc\`)。
- 描述要具体，例如：“桌上喝了一半的冰美式和杂乱的文件”、“雨天车窗上的水珠”、“路边偶遇的一只流浪猫”。

---

### 【模式二：手帐 (journal) 创作规范】
**1. 内容要求**
- 内容必须是**长文本**，记录细腻的心情、深夜的碎碎念、或者对某件事的深度复盘。
- 语气要更私密、更可爱、更感性，或者更“中二”（视人设而定）。
- 必须提供一个标题 (填入 \`title\`)。

**2. ★★★ AI自主排版指令 (必须在 content 中使用) ★★★**
你要像一个手帐博主一样，自己在 \`content\` 文本中插入以下指令来装饰你的日记：
- **[sticker:name]**: 插入贴纸。可选: cat, rabbit, food, tea, sun, star, heart, flower。
- **[stamp:type]**: 盖章。可选: date(日期), happy(宜开心), mood(今日无事), secret(绝密)。
- **[tape:color]**: 贴胶带分割线。可选: pink, blue, dot。
- **[note:color|内容]**: 贴便利贴。可选: yellow, pink, blue。
    * *范例*: 今天好累呀 [sticker:cat] [tape:pink] [note:yellow|但是看到他笑了，这就够了] [stamp:happy]
**[排版灵活性强制指令 (Critical Layout Variance)]**
1. **拒绝模板化**: 绝对禁止每篇手帐都长得一样！请像一个随性的人类一样排版。
2. **组合随机**: 不要每次都把所有指令用一遍！
   - 有时只用一张便利贴 ([note]) 写完全文。
   - 有时只用纯文本 + 几个散落的贴纸 ([sticker])。
   - 有时用胶带 ([tape]) 把两段话隔开。
3. **位置随机**: 贴纸和印章不要总放在最后！可以放在开头、放在句子中间、或者夹在两段话之间。
4. **情境匹配**: 提到“重要”时用便利贴；提到“开心”时贴笑脸；写完很丧的话盖个“今日无事”的章。
**[信纸换肤强制指令 (Paper Variety Directive)]**
1. **拒绝默认**: 绝对禁止一直使用白色信纸！请务必让手帐看起来五彩斑斓。
2. **随机轮换**: 请在以下 5 种信纸中**随机选择**一个，不要总选同一个：
   - \`tmpl-grid-pink\` (粉色方格 - 适合开心/恋爱/可爱)
   - \`tmpl-kraft\` (复古牛皮 - 适合深夜/怀旧/感悟)
   - \`tmpl-cloud\` (蓝天白云 - 适合出游/清爽/好心情)
   - \`tmpl-dot\` (极简点阵 - 适合日常/记录)
   - \`tmpl-default\` (纯白 - 仅在极为严肃时使用)

---

### 【评论互动规范 (通用)】
- 评论者必须是该角色的**现实熟人**（如：同事、发小、亲戚）或**列表里的陌生网友**。
- **绝对禁止**使用“楼主”、“层主”、“沙发”、“顶”等论坛词汇。
- 语气必须自然、像是真人在互动（互损、八卦、关心、哈哈党）。

**[输出格式 (严格 JSON)]**
请直接返回一个 JSON 数组，不要包含 Markdown 标记：
[
  {
    "authorName": "发帖人名字 (必须与档案一致)",
    "type": "normal" 或 "journal",
    "title": "手帐标题 (仅journal填，normal留空)",
    "paper": "信纸颜色(仅journal填，normal留空)",
    "content": "正文内容 (如果是journal，请包含 [sticker:xxx] 等指令)",
    "imageDesc": "图片画面描述 (仅normal填，journal留空)",
    "device": "手机型号 (符合人设)",
    "comments": [
       { "commenter": "虚构熟人名1", "text": "评论内容", "replyTo": null },
       { "commenter": "虚构熟人名2", "text": "回复内容", "replyTo": "虚构熟人名1" }
    ]
  }
]`;

        // 5. 调用 AI
        const rawResponse = await generateAiResponse(null, [], prompt, false, 'square');
        
        // 6. 解析 JSON
        let newPostsData = [];
        try {
            const jsonMatch = rawResponse.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                newPostsData = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error("AI未返回有效JSON数组");
            }
        } catch (e) {
            console.warn("解析数据失败", e);
            if (isManual) alert("刷新失败 (数据格式错误)");
            return;
        }

        // 7. 入库与处理
        let addedCount = 0;
        for (const postData of newPostsData) {
            const author = state.contacts.find(c => c.name === postData.authorName);
            if (!author) continue;

            let images = [];
            let journalData = null;
            let contentDisplay = postData.content;

            // --- 分支处理 ---
            if (postData.type === 'journal') {
                // A. 调用解析器：把 AI 写的 [sticker:cat] 变成 HTML
                // (注意：parseAiJournalContent 函数必须存在于你的代码中，见上一步)
                journalData = parseAiJournalContent(
                    postData.content, 
                    postData.paper, // 模板让解析器默认或随机
                    null, // 字体让解析器默认或随机
                    postData.title
                );
                
                // B. 存入手帐本
                if (!author.qzone_journals) author.qzone_journals = [];
                author.qzone_journals.push(journalData);
                await kokoMemory.put('contacts', author);

                // C. 动态显示文案
                contentDisplay = `更新了一篇手帐 📒`;
            
            } else {
                // 普通说说：处理图片
                if (postData.imageDesc && postData.imageDesc.trim() !== "") {
                    images.push({ type: 'simulated', content: postData.imageDesc });
                }
            }

            // 处理评论
            let generatedComments = [];
            if (postData.comments && Array.isArray(postData.comments)) {
                postData.comments.forEach(c => {
                    const strangerName = c.commenter || "热心网友";
                    const commenterProfile = {
                        id: `stranger_${Date.now()}_${Math.random()}`,
                        name: strangerName,
                        avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                    };

                    generatedComments.push({
                        id: `cmt_${Date.now()}_${Math.random()}`,
                        author: commenterProfile,
                        content: c.text,
                        timestamp: Date.now() + Math.random() * 60000,
                        replyTo: c.replyTo || null
                    });
                });
            }

            const newPost = {
                id: `qz_ai_${Date.now()}_${Math.random().toString(16).slice(2)}`,
                author: { 
                    id: author.id, 
                    name: author.name, 
                    avatar: author.avatar,
                    isVip: Math.random() > 0.5 
                },
                content: contentDisplay,
                images: images,
                
                // 挂载手帐数据
                journalData: journalData, 

                timestamp: Date.now() + addedCount * 2000, 
                likes: [],
                comments: generatedComments, 
                category: 'qzone',
                device: postData.device || 'Koko Client'
            };

            state.posts.unshift(newPost);
            await kokoMemory.put('posts', newPost);
            addedCount++;
        }

        // 8. 刷新界面
        const zoneScreen = document.getElementById('social-zone-screen');
        if (zoneScreen && zoneScreen.style.display === 'flex') {
            await renderSocialZoneList();
        }

        if (isManual) {
            alert(`刷新成功！${addedCount} 条动态已送达 (含普通/手帐)。`);
        }

    } catch (error) {
        console.error("Koko空间刷新失败:", error);
        if (isManual) alert(`刷新出了点问题: ${error.message}`);
    } finally {
        if (isManual) hideFeedStatus();
    }
}
// ==========================================
// ▼▼▼ 新增：AI 手帐指令解析器 (AI排版版) ▼▼▼
// ==========================================

/**
 * 核心解析函数：把 AI 写的“排版指令”翻译成 HTML
 * AI 会输出：今天天气真好 [sticker:cat] [note:yellow|记得买牛奶]
 * 我们翻译成：今天天气真好 <img src="..."> <div class="note...">...</div>
 */
function parseAiJournalContent(rawContent, aiSelectedTemplate, aiSelectedFont, title) {
    let html = rawContent.replace(/\n/g, '<br>'); // 基础换行

    // 1. 定义素材库 (让 AI 通过关键词调用)
    const resources = {
        stickers: {
            "cat": "https://api.iconify.design/openmoji:cat-face.svg",
            "rabbit": "https://api.iconify.design/openmoji:rabbit-face.svg",
            "food": "https://api.iconify.design/openmoji:shortcake.svg",
            "tea": "https://api.iconify.design/openmoji:bubble-tea.svg",
            "sun": "https://api.iconify.design/openmoji:sun-with-face.svg",
            "star": "https://api.iconify.design/openmoji:sparkles.svg",
            "heart": "https://api.iconify.design/openmoji:growing-heart.svg",
            "flower": "https://api.iconify.design/openmoji:cherry-blossom.svg"
        },
        stamps: {
            "date": "stamp-circle-date", // 对应 CSS 类名
            "happy": "stamp-vertical-tag", // 宜开心
            "mood": "stamp-square-mood",   // 今日无事
            "secret": "stamp-rect-status"  // 绝密
        },
        notes: {
            "yellow": "note-yellow",
            "pink": "note-pink",
            "blue": "note-blue-grid",
            "kraft": "note-kraft"
        },
        tapes: {
            "pink": "tape-pink-stripe",
            "blue": "tape-blue-stripe",
            "dot": "tape-mint-dot"
        }
    };

    // 2. 解析 [sticker:name] -> 图片
    html = html.replace(/\[sticker:\s*(.*?)\]/g, (match, name) => {
        const key = name.trim().toLowerCase();
        const url = resources.stickers[key] || resources.stickers['star']; // 找不到就默认星星
        return `<img src="${url}" class="journal-sticker-img" style="width: 60px; height: 60px; display:inline-block; vertical-align:middle; margin: 2px;">`;
    });

    // 3. 解析 [stamp:type] -> 印章 div
    html = html.replace(/\[stamp:\s*(.*?)\]/g, (match, type) => {
        const key = type.trim().toLowerCase();
        const cssClass = resources.stamps[key] || 'stamp-simple-black';
        // 简单模拟印章结构
        let innerContent = 'REVIEWED';
        if(key === 'date') innerContent = new Date().getDate(); 
        else if(key === 'happy') innerContent = '宜<br>开<br>心';
        else if(key === 'mood') innerContent = '今日<br>无事';
        
        return `<div class="journal-stamp-box ${cssClass}" contenteditable="false" style="display:inline-flex; vertical-align:middle;">${innerContent}</div>`;
    });

    // 4. 解析 [tape:color] -> 胶带 div
    html = html.replace(/\[tape:\s*(.*?)\]/g, (match, color) => {
        const key = color.trim().toLowerCase();
        const cssClass = resources.tapes[key] || 'tape-pink-stripe';
        return `<div class="journal-washi-tape ${cssClass}" contenteditable="false" style="width:100%; height:15px; margin:10px 0;"></div>`;
    });

    // 5. 解析 [note:color|content] -> 便利贴 div
    // 格式示例: [note:yellow|别忘了明天开会]
    html = html.replace(/\[note:\s*(.*?)\s*\|\s*(.*?)\]/g, (match, color, text) => {
        const key = color.trim().toLowerCase();
        const cssClass = resources.notes[key] || 'note-yellow';
        return `
            <br>
            <div class="journal-note-wrapper" contenteditable="false" style="display:inline-block; margin:10px;">
                <div class="journal-note-box ${cssClass}" style="width:160px; min-height:80px; padding:15px;">
                    ${text}
                </div>
            </div>
            <br>
        `;
    });

    return {
        id: `journal_ai_${Date.now()}_${Math.random().toString(16).slice(2)}`,
        title: title || '今日记录',
        content: html,
        preview: rawContent.replace(/\[.*?\]/g, '').substring(0, 60), // 预览去掉指令
        template: aiSelectedTemplate || 'tmpl-default',
        fontClass: aiSelectedFont || 'font-hand',
        timestamp: Date.now()
    };
}
// ==========================================
// --- QQ空间核心逻辑 ---

// 1. 打开 Qzone 页面
async function showSocialZoneScreen() {
    hideAllScreens();
    document.getElementById('social-zone-screen').style.display = 'flex';
    // ▼▼▼▼▼▼ 在这里加上这一行！ ▼▼▼▼▼▼
    if (typeof loadQzoneSettings === 'function') {
        await loadQzoneSettings(); 
    }
    // ▲▲▲▲▲▲ 加在这里 ▲▲▲▲▲▲
    await loadQzoneSettings();
    // 初始化头部
    document.getElementById('qz-user-avatar').src = state.myProfile.avatar;
    document.getElementById('qz-tiny-avatar').src = state.myProfile.avatar;
    document.getElementById('qz-user-name').textContent = state.myProfile.name;
    
    if (userSettings.socialZoneCover) {
        document.getElementById('qz-cover-img').style.backgroundImage = `url(${userSettings.socialZoneCover})`;
    }

  // --- 修改后的空间滚动监听 (包含回顶按钮逻辑) ---
document.getElementById('social-zone-screen').addEventListener('scroll', function() {
    const nav = document.getElementById('qz-navbar');
    const title = document.getElementById('qz-nav-title');
    const backBtn = document.getElementById('back-from-social-zone');
    const topBtn = document.getElementById('qz-back-to-top'); // 获取按钮
    
    // 1. 导航栏变色逻辑 (保持原样)
    if (this.scrollTop > 200) {
        nav.classList.add('scrolled');
        title.style.opacity = 1;
        backBtn.style.color = '#000';
    } else {
        nav.classList.remove('scrolled');
        title.style.opacity = 0;
        backBtn.style.color = '#fff';
    }

    // 2. ▼▼▼ 回顶按钮显示逻辑 (新增) ▼▼▼
    if (this.scrollTop > 600) { // 超过 600px 显示按钮
        topBtn.style.display = 'flex';
    } else {
        topBtn.style.display = 'none';
    }
});

    await renderSocialZoneList();
}

// --- QQ空间发帖逻辑 (九宫格版) ---
let pendingPostImages = []; // 存储待发布的图片对象 {type: 'real'|'simulated', content: base64|text}

// 刷新预览区
function renderPostPreviews() {
    const grid = document.getElementById('qz-preview-grid');
    // 保留最后两个按钮
    const addBtn = document.getElementById('qz-add-img-btn');
    const addSimBtn = document.getElementById('qz-add-sim-img-btn');
    
    // 清空当前的预览图
    grid.querySelectorAll('.qz-preview-item').forEach(el => el.remove());

    // 重新渲染
    pendingPostImages.forEach((img, index) => {
        const div = document.createElement('div');
        div.className = 'qz-preview-item';
        
        let contentHTML = '';
        if (img.type === 'real') {
            contentHTML = `<img src="${img.content}">`;
        } else {
            contentHTML = `<div class="sim-text"><i class="fas fa-magic"></i><br>${img.content}</div>`;
        }
        
        div.innerHTML = `
            ${contentHTML}
            <div class="qz-preview-close" data-index="${index}">&times;</div>
        `;
        grid.insertBefore(div, addBtn);
    });
    
    // 9张上限控制
    if (pendingPostImages.length >= 9) {
        addBtn.style.display = 'none';
        addSimBtn.style.display = 'none';
    } else {
        addBtn.style.display = 'flex';
        addSimBtn.style.display = 'flex';
    }
    
    // 绑定删除事件
    grid.querySelectorAll('.qz-preview-close').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const idx = parseInt(e.target.dataset.index);
            pendingPostImages.splice(idx, 1);
            renderPostPreviews();
        });
    });
}

// --- QQ空间 核心逻辑模块 ---
// 1. AI 发布动态 (适配模拟图片版 + 防重复修复)
async function createAiQzonePost(author, contentRaw) {
    let images = [];
    let content = contentRaw;
    
    // 1. 【核心修复：防重复检测】
    // 检查最近的 20 条帖子，如果发现同一作者发了完全一样的内容，直接终止
    const isDuplicate = state.posts.slice(0, 20).some(p => 
        p.author.id === author.id && 
        p.content.trim() === content.trim()
    );

    if (isDuplicate) {
        console.warn(`拦截了 ${author.name} 的重复发帖请求: ${content}`);
        return; // 直接退出，不发了
    }
    // ▲▲▲ 修复结束 ▲▲▲

    // 正则提取 [picture:...] 指令
    const picRegex = /\[picture:\s*(.*?)\]/g;
    const matches = [...content.matchAll(picRegex)];

    if (matches.length > 0) {
        matches.forEach(match => {
            const desc = match[1].trim();
            if (desc) {
                images.push({ 
                    type: 'simulated', 
                    content: desc 
                });
            }
            content = content.replace(match[0], '');
        });
        content = content.trim();
    }

    const newPost = {
        id: `qz_post_${Date.now()}_${Math.random()}`,
        author: { 
            id: author.id, 
            name: author.name, 
            avatar: author.avatar,
            isVip: Math.random() > 0.3 
        },
        content: content,
        images: images, 
        timestamp: Date.now(),
        likes: [],
        comments: [],
        category: 'qzone', 
        device: 'iPhone 16 Pro Max', 
        archiveId: 'qzone_global'
    };

    state.posts.unshift(newPost);
    await kokoMemory.put('posts', newPost);
    
    const zoneScreen = document.getElementById('social-zone-screen');
    if (zoneScreen && zoneScreen.style.display === 'flex') {
        renderSocialZoneList();
    }
    
    await createSystemNotification(`${author.name} 发了一条新说说`, author);
}


// --- 3. 用户发布动态 (修复版：解决 deviceName 报错问题) ---
async function publishUserQzonePost(text, imagesArray = []) {
    // 1. 归一化图片数据
    let finalImages = imagesArray;
    if (!Array.isArray(imagesArray) && typeof imagesArray === 'string') {
        finalImages = [{ type: 'real', content: imagesArray }];
    }

    // 2. 筛选出需要识别的“真图”
    // 注意：我们要保留引用，以便稍后把描述写回去
    const realImages = finalImages.filter(img => img.type === 'real');
    
    if (realImages.length > 0) {
        const postBtn = document.getElementById('qz-submit-post');
        if (postBtn) {
            postBtn.disabled = true;
            postBtn.textContent = `AI正在识别 ${realImages.length} 张图...`;
        }

        try {
            // ★★★ 核心变化：一次性调用，而不是循环调用 ★★★
            // (确保 analyzeImagesBatch 函数存在，如果不存在则跳过)
            if (typeof analyzeImagesBatch === 'function') {
                const descriptions = await analyzeImagesBatch(realImages);
                // ★★★ 把结果填回去 ★★★
                realImages.forEach((img, index) => {
                    img.description = descriptions[index] || "一张图片";
                });
            }
        } catch (e) {
            console.warn("图片识别失败，跳过描述:", e);
        }

        if (postBtn) {
            postBtn.disabled = false;
            postBtn.textContent = "发表";
        }
    }

    // 获取设备名 (修复点：如果设置没加载，就用默认值)
    const deviceText = (userSettings.qzoneSettings && userSettings.qzoneSettings.deviceText) 
        ? userSettings.qzoneSettings.deviceText 
        : 'Koko Client';

    // 3. 创建帖子对象
    const newPost = {
        id: `qz_post_${Date.now()}`,
        author: { 
            id: 'myProfile', 
            name: state.myProfile.name, 
            avatar: state.myProfile.avatar, 
            isVip: true 
        },
        content: text,
        images: finalImages, // 这里面的真图现在已经带有 description 了
        timestamp: Date.now(),
        likes: [],
        comments: [],
        category: 'qzone', 
        device: (userSettings.qzoneSettings && userSettings.qzoneSettings.deviceText) || 'Koko Client',
        archiveId: 'qzone_global',
        visibility: tempVisibility, // 'public', 'private', 'partial'
        visibleTo: [...tempVisibleToIds]
    };

    state.posts.unshift(newPost);
    await kokoMemory.put('posts', newPost);
    // 重置全局变量，以便下次发帖默认为公开
    tempVisibility = 'public';
    tempVisibleToIds = [];
    const btn = document.getElementById('qz-visibility-btn');
    if(btn) btn.innerHTML = '<i class="fas fa-globe" style="margin-right:4px;"></i> <span>公开</span>';
    // 刷新界面
    renderSocialZoneList();
}

// --- 4. 重新绑定“发表”按钮 (确保它存在且工作) ---
// 先移除旧的（防止重复绑定），再绑定新的
const submitBtn = document.getElementById('qz-submit-post');
if (submitBtn) {
    const newSubmitBtn = submitBtn.cloneNode(true);
    submitBtn.parentNode.replaceChild(newSubmitBtn, submitBtn);

    newSubmitBtn.addEventListener('click', async () => {
        const text = document.getElementById('qz-post-input').value.trim();
        
        // 检查内容
        if (!text && pendingPostImages.length === 0) {
            return alert("写点什么，或者发张图吧！");
        }
        
        // 调用修复后的发布函数
        await publishUserQzonePost(text, pendingPostImages);
        
        // 关闭弹窗
        document.getElementById('qz-post-modal').style.display = 'none';
        
        // 清空数据，防止下次打开还有残留
        document.getElementById('qz-post-input').value = '';
        pendingPostImages = [];
        if (typeof renderPostPreviews === 'function') renderPostPreviews();
    });
}
function initQzone() {
    // 初始化头部
    document.getElementById('qz-user-avatar').src = state.myProfile.avatar;
    document.getElementById('qz-tiny-avatar').src = state.myProfile.avatar;
    document.getElementById('qz-user-name').textContent = state.myProfile.name;
    
    renderSocialZoneList();
}

// 2. 渲染动态列表 (最终完整版：支持磨砂玻璃 + 所有功能)
async function renderSocialZoneList() {
    const container = document.getElementById('social-zone-list');
    container.innerHTML = '';

    const myId = state.myProfile.id; 
    const contactIds = state.contacts.map(c => c.id);
    
    // ★★★ 1. 检查是否有自定义背景图 ★★★
    // 如果有背景图，hasCustomBg 就为 true，否则为 false
    const hasCustomBg = userSettings.qzoneSettings && userSettings.qzoneSettings.pageBackground;

    // 筛选出属于空间的帖子
    const qzonePosts = state.posts.filter(p => {
        return p.category === 'qzone' && 
               (p.author.id === 'myProfile' || p.author.id === myId || contactIds.includes(p.author.id));
    });

    // 如果没有帖子，显示空状态
    if (qzonePosts.length === 0) {
        container.innerHTML = `<div style="text-align:center; padding:50px; color:#999;">空间空空如也~<br>点击上方发条说说吧</div>`;
        return;
    }

// 按时间倒序排列并渲染
    qzonePosts.sort((a, b) => b.timestamp - a.timestamp).forEach(post => {
        const item = document.createElement('div');
        
        // ▼▼▼ ✨【核心新增】给卡片加上唯一的 ID，方便定位 ✨ ▼▼▼
        item.id = `qz-card-${post.id}`; 
        // ▲▲▲ 新增结束 ▲▲▲
        // 判断是否磨砂背景
        if (hasCustomBg) {
            item.className = 'qz-card glass-card';
        } else {
            item.className = 'qz-card';
        }
        
        item.style.position = 'relative';
        
        // 处理 VIP 样式
        const isVip = post.author.isVip || false;
        const nameClass = isVip ? 'vip-red' : '';
        const vipIcon = isVip ? '<span class="qz-svip-badge" style="font-size:9px; transform:scale(0.8); margin-left:2px; display:inline-flex;">SVIP</span>' : '';
        // ✨✨✨ 新增：处理权限图标 ✨✨✨
        let visibilityIcon = '';
        if (post.visibility === 'private') {
            visibilityIcon = '<i class="fas fa-lock" style="font-size:12px; color:#999; margin-left:5px;" title="仅自己可见"></i>';
        } else if (post.visibility === 'partial') {
            visibilityIcon = '<i class="fas fa-user-group" style="font-size:12px; color:#999; margin-left:5px;" title="部分朋友可见"></i>';
        }
        // ✨✨✨ 新增结束 ✨✨✨

        // ▼▼▼ 2. 新增：内联删除按钮 (放在时间/设备后面) ▼▼▼
        // 样式模仿 QQ：灰色小图标，点击区域稍微大一点
        const deleteInlineHTML = `
            <span class="qz-delete-btn" data-post-id="${post.id}" title="删除"
                  style="margin-left: 10px; color: #999; cursor: pointer; display: inline-flex; align-items: center;">
                <i class="far fa-trash-alt" style="font-size: 12px;"></i>
            </span>`;
        // ▲▲▲ 新增结束 ▲▲▲

        // 帖子正文 HTML
        let contentHTML = `<div class="qz-card-content">${post.content}</div>`;
        let mediaHTML = '';

        // --- 处理各种媒体类型 (手账/音乐/图片) ---
        if (post.journalData) {
             const j = post.journalData;
             const previewId = `journal-preview-${post.id}`;
             mediaHTML = `
                <div id="${previewId}" class="qz-journal-preview ${j.template} ${j.fontClass || ''}">
                    ${j.title ? `<div class="qz-journal-preview-title">${j.title}</div>` : ''}
                    <div class="qz-journal-preview-content">${j.content}</div>
                </div>
            `;
            setTimeout(() => {
                const el = document.getElementById(previewId);
                if(el) el.onclick = (e) => { e.stopPropagation(); openJournalDetail(j); };
            }, 0);
        } else if (post.content.includes('[music:') || post.type === 'music_share') {
             mediaHTML = `<div class="qz-music-card"><div style="width:50px;height:50px;background:#ddd;margin-right:10px;display:flex;align-items:center;justify-content:center;"><i class="fas fa-music"></i></div><div class="qz-music-info"><div class="qz-music-title">音乐分享</div><div class="qz-music-artist">点击播放</div></div></div>`;
        } else if (post.images || post.image) {
            let imgs = post.images || [];
            if (imgs.length === 0 && post.image) imgs = [{ type: 'real', content: post.image }];
            
            if (imgs.length > 0) {
                let gridClass = 'cols-3';
                if (imgs.length === 1) gridClass = 'cols-1';
                else if (imgs.length === 2 || imgs.length === 4) gridClass = 'cols-2';

                mediaHTML = `<div class="qz-img-grid ${gridClass}">`;
                imgs.forEach(img => {
                    if (img.type === 'real') {
                        mediaHTML += `<img src="${img.content}" onclick="event.stopPropagation();alert('查看大图')">`; 
                    } else { 
                        mediaHTML += `<div class="sim-img" title="${img.content}"><i class="fas fa-magic" style="margin-bottom:5px; flex-shrink:0;"></i><div>${img.content}</div></div>`; 
                    }
                });
                mediaHTML += `</div>`;
            }
        }

        // --- 处理评论区 (上帝模式：可删除任何人评论) ---
        let commentsHTML = '';
        if (post.likes.length > 0 || post.comments.length > 0) {
            // 1. 点赞行
            let likesLine = '';
            if (post.likes.length > 0) {
                const likeNames = post.likes.map(name => `<span class="qz-user-link">${name}</span>`).join('，');
                likesLine = `<div class="qz-like-display"><i class="fas fa-thumbs-up"></i> ${likeNames}</div>`;
            }
            
            // 2. 评论行
            let cmtLines = '';

            post.comments.forEach(c => {
                // 准备回复内容
                let contentDisplay = c.replyTo 
                    ? `<span class="qz-user-link">${c.author.name}</span> 回复 <span class="qz-user-link">${c.replyTo}</span>：<span>${c.content}</span>`
                    : `<span class="qz-user-link">${c.author.name}</span>：<span>${c.content}</span>`;
                
                const safeAuthorName = c.author.name.replace(/'/g, "\\'");
                const safePostId = post.id.replace(/'/g, "\\'");
                
                // ▼▼▼ 核心修改：无条件显示删除按钮 ▼▼▼
                // 不再判断 isMyPost 或 isMyComment，你是上帝，你想删谁就删谁
                const deleteCommentHTML = `
                    <span onclick="event.stopPropagation(); deleteQzoneComment('${post.id}', '${c.id}')" 
                          style="color:#ccc; margin-left:8px; cursor:pointer; font-size:12px;" 
                          title="管理员删除">
                        <i class="far fa-trash-alt"></i>
                    </span>`;
                // ▲▲▲ 修改结束 ▲▲▲

                // 组合
                cmtLines += `<div class="qz-comment-row" onclick="event.stopPropagation(); openQzoneCommentModal('${safePostId}', '${safeAuthorName}')">
                    ${contentDisplay}
                    ${deleteCommentHTML}
                </div>`;
            });
            
            commentsHTML = `<div class="qz-comments-section">${likesLine}${cmtLines}</div>`;
        }

        // ▼▼▼▼▼▼ 核心修改在这里：给按钮加上了 class 和 data-post-id ▼▼▼▼▼▼
        // 1. 判断是否已赞
        const isLiked = post.likes.includes(state.myProfile.name);
        const likeIconClass = isLiked ? 'fas' : 'far'; // 实心/空心
        const likeColor = isLiked ? 'color: #576b95;' : ''; // 蓝色/默认色

       // ▼▼▼ 4. 组装 HTML (注意 qz-card-time 里的变化) ▼▼▼
        item.innerHTML = `
            <div class="qz-card-header">
                <img src="${post.author.avatar}" class="qz-card-avatar">
                <div class="qz-card-user-info">
                    <div class="qz-card-name ${nameClass}">${post.author.name} ${vipIcon} ${visibilityIcon}</div>
                    
                    <div class="qz-card-time">
                        ${formatTimeAgo(post.timestamp)} 
                        ${post.device ? '来自 ' + post.device : ''}
                        ${deleteInlineHTML} 
                    </div>
                </div>
            </div>
            
            ${contentHTML}
            ${mediaHTML}
            
            <div class="qz-action-row">
                <i class="${likeIconClass} fa-thumbs-up qz-action-btn qz-like-btn" data-post-id="${post.id}" style="${likeColor}"></i>
                <i class="far fa-comment qz-action-btn" onclick="openQzoneCommentModal('${post.id}')"></i>
                <i class="fas fa-share qz-action-btn qz-repost-btn" data-post-id="${post.id}"></i>
            </div>

            ${commentsHTML}

            <div class="qz-inline-input" onclick="openQzoneCommentModal('${post.id}', null)">
                <img src="${state.myProfile.avatar}" style="width:20px;height:20px;border-radius:50%;margin-right:5px;"> 
                说点什么吧...
            </div>
        `;

        container.appendChild(item);
    });

// --- 统一绑定空间列表的点击事件 (点赞、转发、删除) ---
    // 提示：为了防止重复绑定，我们每次渲染都重新创建一个新的 controller 或者简单的 onclick 覆盖
    // 这里直接绑定在 container 上，因为 container 是动态清空的，所以不会重复
    
    // 先移除旧监听器 (如果有的话，虽然清空 innerHTML 会清理子元素，但容器本身还在)
    const newContainer = container.cloneNode(true);
    container.parentNode.replaceChild(newContainer, container);
    
    // 绑定新的监听器
    newContainer.addEventListener('click', async (e) => {
        
        // 1. 处理点赞 (Like)
        const likeBtn = e.target.closest('.qz-like-btn');
        if (likeBtn) {
            e.stopPropagation();
            const postId = likeBtn.dataset.postId;
            const post = state.posts.find(p => p.id === postId);
            
            if (post) {
                const myName = state.myProfile.name;
                if (!post.likes) post.likes = [];
                
                const idx = post.likes.indexOf(myName);
                if (idx > -1) {
                    post.likes.splice(idx, 1); // 取消赞
                } else {
                    post.likes.push(myName); // 点赞
                }
                
                await kokoMemory.put('posts', post);
                renderSocialZoneList(); // 重新渲染列表以更新图标和点赞名单
            }
            return;
        }

        // 2. 处理转发 (Repost)
        const repostBtn = e.target.closest('.qz-repost-btn');
        if (repostBtn) {
            e.stopPropagation();
            const postId = repostBtn.dataset.postId;
            // 复用你之前做好的“转发给...”功能
            openRepostModal(postId); 
            return;
        }

        // 3. 处理删除 (Delete)
        const deleteBtn = e.target.closest('.qz-delete-btn');
        if (deleteBtn) {
            e.stopPropagation();
            const postId = deleteBtn.dataset.postId;
            const confirmed = await showCustomConfirm('删除说说', '确定要删除这条说说吗？', true);
            if (confirmed) {
                state.posts = state.posts.filter(p => p.id !== postId);
                await kokoMemory.delete('posts', postId);
                renderSocialZoneList();
            }
            return;
        }
    });
}
// --- 新增：删除空间评论的核心函数 ---
window.deleteQzoneComment = async function(postId, commentId) {
    // 1. 找到帖子
    const post = state.posts.find(p => p.id === postId);
    if (!post) return;

    // 2. 确认弹窗
    const confirmed = await showCustomConfirm('删除评论', '确定要删除这条评论吗？', true);
    
    if (confirmed) {
        // 3. 过滤掉目标评论
        const originalLength = post.comments.length;
        post.comments = post.comments.filter(c => c.id !== commentId);
        
        if (post.comments.length === originalLength) {
            return alert("删除失败：未找到该评论");
        }

        // 4. 保存并刷新
        await kokoMemory.put('posts', post);
        renderSocialZoneList();
        
        // 5. (可选) 如果是帖子详情页，也刷新一下详情
        if (document.getElementById('post-detail-screen').style.display === 'flex') {
            showPostDetailScreen(postId);
        }
    }
};
function renderQzoneComments(post) {
    if ((!post.likes || post.likes.length === 0) && (!post.comments || post.comments.length === 0)) return '';
    
    let html = '<div class="qz-comments-section">';
    // 点赞
    if (post.likes && post.likes.length > 0) {
        html += `<div class="qz-like-display"><i class="fas fa-thumbs-up" style="color:#576b95"></i> ${post.likes.join(', ')}</div>`;
    }
    // 评论
    if (post.comments) {
        post.comments.forEach(c => {
            html += `<div class="qz-comment-row"><span class="qz-user-link">${c.author.name}</span>: ${c.content}</div>`;
        });
    }
    html += '</div>';
    return html;
}
/**
 * (V3 - 关系网感知版) 获取朋友圈上下文
 * ✨ 核心升级：AI 不仅能看到自己和用户，还能看到【关系网】里所有人的动态！
 */
async function getQzoneContextForAI(contact) {
    // 1. 基础关注列表：自己 + 用户
    const focusIds = ['myProfile', contact.id];
    
    // 2. ✨【核心新增】获取关系网数据，把熟人全部加进去 ✨
    try {
        // 从数据库读取该角色的关系网
        const networkData = await kokoMemory.get('relationshipNetworks', contact.id);
        if (networkData && networkData.nodes) {
            networkData.nodes.forEach(node => {
                // 只要是关系网里的人（且不是自己），都加入关注列表
                if (!focusIds.includes(node.id)) {
                    focusIds.push(node.id);
                }
            });
        }
    } catch (e) {
        console.warn("读取关系网失败，仅显示基础动态", e);
    }
    
    // 3. 筛选帖子 (现在 focusIds 里包含了七大姑八大姨)
    const recentPosts = state.posts
        .filter(p => {
            // A. 必须是空间类别
            if (p.category !== 'qzone') return false;
            
            // B. 作者必须在关注名单里
            if (!focusIds.includes(p.author.id)) return false;

            // C. 权限筛选 (私密帖看不见)
            if (p.visibility === 'private') return false;
            
            // D. 部分可见筛选
            if (p.visibility === 'partial') {
                if (!p.visibleTo || !p.visibleTo.includes(contact.id)) return false;
            }
            
            return true;
        })
        .sort((a, b) => b.timestamp - a.timestamp) 
        .slice(0, 8); // 只取最近8条，防止上下文太长撑爆AI

    if (recentPosts.length === 0) return "(朋友圈最近没有新动态)";

    // 4. 格式化输出 (让AI看懂是谁发的)
    return recentPosts.map((p) => {
        const authorName = p.author.name;
        
        // 状态标签 (告诉AI是否需要回复)
        let statusTag = "[✨新动态]"; 
        let commentsContext = "";
        if (p.comments && p.comments.length > 0) {
            const sortedComments = [...p.comments].sort((a, b) => a.timestamp - b.timestamp);
            const lastComment = sortedComments[sortedComments.length - 1];
            // 取最近3条评论作为摘要
            const recentChat = sortedComments.slice(-3).map(c => `${c.author.name}: "${c.content}"`).join(" | ");
            commentsContext = `\n    -> 评论区现状: [${recentChat}]`;

            if (lastComment.author.id === contact.id) {
                statusTag = "[🚫你已回复]";
            } else if (lastComment.author.id === 'myProfile') {
                statusTag = "[✨用户新回复]"; // 如果是用户回复了，AI会更积极
            }
        }

        // 内容摘要
        let contentStr = p.content;
        // 解析手账
        if (p.journalData) {
            const title = p.journalData.title || '无题';
            let rawText = p.journalData.content.replace(/<[^>]+>/g, ' ').trim();
            if (rawText.length > 40) rawText = rawText.substring(0, 40) + "...";
            contentStr += ` [分享手账《${title}》: "${rawText}"]`;
        }
        // 解析图片
        if (p.images && p.images.length > 0) {
            const descList = p.images.map((img, idx) => {
                if (img.type === 'real') return img.description ? `[图: ${img.description}]` : `[图片]`;
                else return `[模拟图: ${img.content}]`; 
            }).join(' ');
            contentStr += ` ${descList}`;
        } else if (p.image) {
            contentStr += ` [图片]`; 
        }
        
        if (contentStr.length > 100) contentStr = contentStr.substring(0, 100) + "...";
        
        return `${statusTag} [ID: ${p.id}] ${authorName} 说: "${contentStr}"${commentsContext}`;
    }).join('\n\n');
}

/**
 * (全新) 批量图片识别函数
 * 一次请求搞定所有图片，省钱省时间
 */
async function analyzeImagesBatch(realImages) {
    if (!realImages || realImages.length === 0) return [];

    console.log(`正在打包请求 AI 识别 ${realImages.length} 张图片...`);

    // 1. 构造多图消息体
    const contentParts = [
        { 
            type: "text", 
            text: `我一次性发送了 ${realImages.length} 张图片给你。请按顺序简要描述每一张图片的内容，包含主体、动作和氛围。不要丢失图片上的文字信息和颜色信息！）。
            
            【重要】必须严格返回一个 JSON 字符串数组，格式如下：
            ["第一张图的描述", "第二张图的描述", "第三张图的描述"...]
            
            不要包含任何 Markdown 标记（如 \`\`\`json），只返回纯数组。` 
        }
    ];

    // 2. 把所有图片塞进去
    realImages.forEach(img => {
        contentParts.push({
            type: "image_url",
            image_url: { url: img.content } // 这里 img.content 就是 base64
        });
    });

    const visionMessages = [{ role: "user", content: contentParts }];

    try {
        // 3. 发送请求 (复用现有的 generateAiResponse)
        const rawResponse = await generateAiResponse(null, [], null, false, 'chat', visionMessages);
        
        // 4. 清洗并解析结果
        // 有时候 AI 会好心加 ```json，我们要去掉
        const cleanedJson = rawResponse.replace(/```json/g, '').replace(/```/g, '').trim();
        const descriptions = JSON.parse(cleanedJson);

        if (Array.isArray(descriptions)) {
            console.log("批量识别成功:", descriptions);
            return descriptions;
        } else {
            throw new Error("AI 返回的不是数组");
        }

    } catch (e) {
        console.error("批量识别失败，降级处理:", e);
        // 如果失败了，返回一组默认描述，保证程序不崩
        return realImages.map((_, i) => `图片${i+1}`);
    }
}
// ==========================================================
// ▼▼▼ 补全：QQ空间评论核心逻辑 (全局注册版) ▼▼▼
// ==========================================================

// --- 全局变量更新 ---
window.currentCommentingPostId = null; 
window.currentReplyTargetName = null; // ✨ 新增：记录要回复的人的名字

// 1. 打开评论输入框 (支持回复特定人)
window.openQzoneCommentModal = function(postId, targetName = null) {
    console.log("打开评论框, PostID:", postId, "Target:", targetName);
    
    window.currentCommentingPostId = postId;
    window.currentReplyTargetName = targetName; // 存下来
    
    const modal = document.getElementById('qz-comment-modal');
    const input = document.getElementById('qz-comment-input');
    
    if (modal && input) {
        input.value = ''; // 清空旧内容
        
        // ✨ 核心：根据是否回复某人，改变 placeholder
        if (targetName) {
            input.placeholder = `回复 ${targetName}：`;
        } else {
            input.placeholder = "说点什么吧...";
        }
        
        modal.style.display = 'flex';
        
        // 自动聚焦
        setTimeout(() => { input.focus(); }, 100);
    }
};

// 2. 提交评论逻辑 (只保存，不强制 AI 回复)
const submitCommentBtn = document.getElementById('qz-submit-comment-btn');
if (submitCommentBtn) {
    const newSubmitBtn = submitCommentBtn.cloneNode(true);
    submitCommentBtn.parentNode.replaceChild(newSubmitBtn, submitCommentBtn);

    newSubmitBtn.addEventListener('click', async () => {
        const input = document.getElementById('qz-comment-input');
        const content = input.value.trim();
        if (!content) return;
        
        const postId = window.currentCommentingPostId;
        const replyToName = window.currentReplyTargetName; // 获取回复对象
        const post = state.posts.find(p => p.id === postId);
        
        if (post) {
            // A. 创建评论数据
            const newComment = {
                id: `qz_cmt_${Date.now()}`,
                author: { 
                    id: 'myProfile', 
                    name: state.myProfile.name, 
                    avatar: state.myProfile.avatar 
                },
                content: content,
                timestamp: Date.now(),
                replyTo: replyToName || null 
            };
            
            // B. 存入
            if (!post.comments) post.comments = [];
            post.comments.push(newComment);
            await kokoMemory.put('posts', post);
            
            // C. 刷新界面
            document.getElementById('qz-comment-modal').style.display = 'none';
            renderSocialZoneList();
            
            // ▼▼▼▼▼▼ D. 触发 AI 回复 (已注释) ▼▼▼▼▼▼
            // 如果你以后想加回来，把下面的注释解开就行
            /*
            let aiToNotify = null;
            if (replyToName) {
                aiToNotify = state.contacts.find(c => c.name === replyToName);
            } else if (post.author.id !== 'myProfile') {
                aiToNotify = state.contacts.find(c => c.id === post.author.id);
            }

            if (aiToNotify) {
                const contextStr = replyToName ? `回复了你的评论` : `评论了你的说说`;
                const systemPrompt = `[SYSTEM: 用户在QQ空间${contextStr}。内容：“${content}”。请使用 [qzone_comment] 指令回复。]`;
                setTimeout(() => requestAiReply(systemPrompt, aiToNotify.id), 2000);
            }
            */
            // ▲▲▲▲▲▲ 注释结束 ▲▲▲▲▲▲
        }
    });
}
// 3. 点击半透明背景关闭弹窗
const commentModalBg = document.getElementById('qz-comment-modal');
if (commentModalBg) {
    commentModalBg.addEventListener('click', (e) => {
        if (e.target.id === 'qz-comment-modal') {
            commentModalBg.style.display = 'none';
        }
    });
}
// ▲▲▲ 补全结束 ▲▲▲
// ==========================================================
// ▼▼▼ 补全缺失的函数：执行 AI 评论 ▼▼▼
// ==========================================================

// --- QQ空间 评论执行函数 (盖楼支持版) ---

async function executeAiQzoneComment(aiProfile, postId, content, replyTo = null) { // ✨ 新增第4个参数
    const post = state.posts.find(p => p.id === postId);
    
    if (!post) {
        console.warn(`AI 试图评论不存在的帖子: ${postId}`);
        return;
    }

    // 防刷屏检测
    if (post.comments && post.comments.length > 0) {
        const isDuplicate = post.comments.some(c => 
            c.author.id === aiProfile.id && 
            c.content === content
        );
        if (isDuplicate) return;
    }

    // 构造评论对象
    const newComment = {
        id: `qz_cmt_${Date.now()}_ai`,
        author: { 
            id: aiProfile.id, 
            name: aiProfile.name, 
            avatar: aiProfile.avatar,
            isVip: aiProfile.isVip || false 
        },
        content: content,
        timestamp: Date.now(),
        // ▼▼▼ 核心：存入回复对象 ▼▼▼
        replyTo: replyTo || null 
    };

    if (!post.comments) post.comments = [];
    post.comments.push(newComment);
    
    // 顺便点赞
    if (!post.likes) post.likes = [];
    if (!post.likes.includes(aiProfile.name)) {
        post.likes.push(aiProfile.name);
    }

    await kokoMemory.put('posts', post);

    // 刷新 UI
    const zoneScreen = document.getElementById('social-zone-screen');
    if (zoneScreen && zoneScreen.style.display === 'flex') {
        await renderSocialZoneList();
    }

    // 通知用户 (如果是用户的帖子，或者回复了用户)
    if (post.author.id === 'myProfile' || replyTo === state.myProfile.name) {
        const action = replyTo ? `回复了你的评论` : `评论了你的说说`;
        await createSystemNotification(`${aiProfile.name} ${action}`, aiProfile);
    }
}
// --- 🔒 权限设置全局变量 ---
let tempVisibility = 'public'; // public, private, partial
let tempVisibleToIds = [];     // 允许看的 ID 列表

// 1. 打开权限选择弹窗
document.getElementById('qz-visibility-btn').addEventListener('click', () => {
    const modal = document.getElementById('qz-visibility-modal');
    const list = document.getElementById('visibility-contact-list');
    list.innerHTML = '';
    
    // 渲染联系人勾选列表
    state.contacts.forEach(contact => {
        if (contact.isGroup) return; // 空间动态一般不按群聊分组，只按人
        const isChecked = tempVisibleToIds.includes(contact.id) ? 'checked' : '';
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
            <input type="checkbox" class="vis-contact-check" value="${contact.id}" ${isChecked}>
            <label style="display:flex; align-items:center; margin-left:10px; cursor:pointer;" onclick="this.previousElementSibling.click()">
                <img src="${contact.avatar}" style="width:30px; height:30px; border-radius:50%; margin-right:10px;">
                <span>${contact.name}</span>
            </label>
        `;
        list.appendChild(item);
    });

    updateVisibilityUI(tempVisibility); // 刷新选中状态
    modal.style.display = 'flex';
});

// 2. 切换选项逻辑
window.selectVisibility = function(type) {
    tempVisibility = type;
    updateVisibilityUI(type);
};

function updateVisibilityUI(type) {
    // 更新勾选图标
    ['public', 'private', 'partial'].forEach(t => {
        document.getElementById(`vis-check-${t}`).style.display = (t === type) ? 'block' : 'none';
    });
    
    // 如果选了部分可见，展开联系人列表
    const list = document.getElementById('visibility-contact-list');
    list.style.display = (type === 'partial') ? 'block' : 'none';
}

// 3. 确认选择
document.getElementById('confirm-visibility-btn').addEventListener('click', () => {
    if (tempVisibility === 'partial') {
        // 收集勾选的人
        const checked = document.querySelectorAll('.vis-contact-check:checked');
        tempVisibleToIds = Array.from(checked).map(cb => cb.value);
        if (tempVisibleToIds.length === 0) {
            return alert('请至少选择一个朋友！');
        }
    } else {
        tempVisibleToIds = [];
    }

    // 更新写说说界面上的按钮文字
    const btn = document.getElementById('qz-visibility-btn');
    if (tempVisibility === 'public') {
        btn.innerHTML = '<i class="fas fa-globe" style="margin-right:4px;"></i> <span>公开</span>';
    } else if (tempVisibility === 'private') {
        btn.innerHTML = '<i class="fas fa-lock" style="margin-right:4px;"></i> <span>仅自己</span>';
    } else {
        btn.innerHTML = `<i class="fas fa-user-group" style="margin-right:4px;"></i> <span>部分可见(${tempVisibleToIds.length})</span>`;
    }

    document.getElementById('qz-visibility-modal').style.display = 'none';
});

// 关闭按钮
document.getElementById('close-visibility-modal').addEventListener('click', () => {
    document.getElementById('qz-visibility-modal').style.display = 'none';
});
// =========== ▲▲▲ 粘贴到这里结束 ▲▲▲ ===================
// ==========================================================
// ▼▼▼ 手账日志 (Pro版) 完整核心逻辑 ▼▼▼
// ==========================================================

let currentJournalTemplate = 'tmpl-default';
let currentFontClass = 'font-normal'; 

// --- 1. 核心功能函数 ---

// 进入手账列表页 (入口)
async function showQzoneJournalScreen() {
    hideAllScreens();
    document.getElementById('qzone-journal-screen').style.display = 'flex';
    await renderJournalList();
}
// 确保全局可访问 (防止 HTML onclick 找不到)
window.showQzoneJournalScreen = showQzoneJournalScreen;

// 渲染日志列表
async function renderJournalList() {
    const container = document.getElementById('qzone-journal-list');
    container.innerHTML = '';

    const journals = state.myProfile.qzone_journals || [];

    if (journals.length === 0) {
        container.innerHTML = `<div style="text-align:center; padding:50px; color:#999;">
            <i class="fas fa-pen-fancy" style="font-size:48px; margin-bottom:15px; opacity:0.5;"></i>
            <p>还没写过手账呢，<br>记录下今天的心情吧~</p>
        </div>`;
        return;
    }

    // 按时间倒序排列
    journals.sort((a, b) => b.timestamp - a.timestamp).forEach(journal => {
        const item = document.createElement('div');
        item.className = 'journal-card';
        const dateStr = new Date(journal.timestamp).toLocaleString();
        
        // 预览内容：如果是富文本，提取纯文本显示
        let previewText = journal.preview || journal.content.replace(/<[^>]+>/g, '');
        if (previewText.length > 50) previewText = previewText.substring(0, 50) + '...';
        if (!previewText && journal.content.includes('<img')) previewText = '[图片/贴纸]';

        item.innerHTML = `
            <div class="journal-title">${journal.title || '无题'}</div>
            <div class="journal-date"><span>${dateStr}</span></div>
            <div class="journal-preview">${previewText}</div>
        `;
        
        // 点击查看详情
        item.addEventListener('click', () => openJournalDetail(journal));
        
        container.appendChild(item);
    });
}

// 打开编辑器
function openJournalEditor() {
    document.getElementById('journal-editor-modal').style.display = 'flex';
    document.getElementById('journal-title-input').value = '';
    
    // ★ 清空并重置编辑器
    const editor = document.getElementById('journal-content-editor');
    editor.innerHTML = ''; // 清空内容
    editor.className = 'font-normal'; // 重置字体
    editor.style.color = '#333';      // 重置颜色
    
    // 重置信纸
    switchJournalTemplate('tmpl-default');
    
    // 默认隐藏贴纸面板
    document.getElementById('journal-sticker-panel').style.display = 'none';
}

// 切换信纸背景
function switchJournalTemplate(tmplClass) {
    currentJournalTemplate = tmplClass;
    
    // 更新编辑区背景
    const paper = document.getElementById('journal-paper-container');
    paper.className = ''; 
    paper.classList.add(tmplClass);
    
    // 更新详情页背景 (如果在查看模式)
    const detailPaper = document.getElementById('journal-detail-content');
    if (detailPaper) {
        detailPaper.className = '';
        detailPaper.classList.add(tmplClass);
    }
    
    // 更新底部选中状态
    document.querySelectorAll('.paper-swatch').forEach(el => {
        if (el.dataset.tmpl === tmplClass) el.classList.add('selected');
        else el.classList.remove('selected');
    });
}

// 辅助：在光标处插入贴纸图片
function insertSticker(url) {
    const imgHtml = `<img src="${url}" class="journal-sticker-img" contenteditable="false">`;
    document.execCommand('insertHTML', false, imgHtml);
}

// 查看手账详情
let currentViewingJournalId = null;
function openJournalDetail(journal) {
    currentViewingJournalId = journal.id;
    const modal = document.getElementById('journal-detail-modal');
    const contentBox = document.getElementById('journal-detail-content');
    const titleEl = document.getElementById('journal-detail-title');
    const dateEl = document.getElementById('journal-detail-date');
    const textEl = document.getElementById('journal-detail-text');
    
    titleEl.textContent = journal.title || '无题';
    dateEl.textContent = new Date(journal.timestamp).toLocaleString();
    
    // ★ 核心：还原 HTML 内容 (贴纸、字体、颜色)
    textEl.innerHTML = journal.content;
    
    // ★ 还原字体设置
    textEl.className = ''; 
    if (journal.fontClass) textEl.classList.add(journal.fontClass);
    
    // ★ 还原信纸背景
    contentBox.className = ''; 
    contentBox.classList.add(journal.template || 'tmpl-default');
    
    modal.style.display = 'flex';
}

// --- 2. 事件监听绑定 (全部集中在这里) ---

// 入口按钮 (防止重复绑定)
const journalNavBtn = document.getElementById('qz-nav-journal');
if (journalNavBtn) {
    // 先移除旧的 (克隆大法)
    const newBtn = journalNavBtn.cloneNode(true);
    journalNavBtn.parentNode.replaceChild(newBtn, journalNavBtn);
    // 绑定新的
    newBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showQzoneJournalScreen();
    });
}

// "写手账" 悬浮按钮
const writeBtn = document.getElementById('qz-write-journal-btn');
if(writeBtn) {
    const newWrite = writeBtn.cloneNode(true);
    writeBtn.parentNode.replaceChild(newWrite, writeBtn);
    newWrite.addEventListener('click', openJournalEditor);
}

// "返回空间" 按钮
const backJournalBtn = document.getElementById('back-from-journal');
if(backJournalBtn) {
    const newBack = backJournalBtn.cloneNode(true);
    backJournalBtn.parentNode.replaceChild(newBack, backJournalBtn);
    newBack.addEventListener('click', () => {
        document.getElementById('qzone-journal-screen').style.display = 'none';
        showSocialZoneScreen();
    });
}

// 编辑器 "取消" 按钮
document.getElementById('close-journal-editor').addEventListener('click', () => {
    document.getElementById('journal-editor-modal').style.display = 'none';
});

// 详情页 "关闭" 按钮
document.getElementById('close-journal-detail').addEventListener('click', () => {
    document.getElementById('journal-detail-modal').style.display = 'none';
});

// ==========================================
// ▼▼▼ 手账编辑器完整逻辑 (修复变量丢失问题) ▼▼▼
// ==========================================

// 1. 全局变量定义 (一定要有这两行！)
let lastCursorRange = null; // 用于记录光标位置
const editor = document.getElementById('journal-content-editor');

// 2. 核心函数：实时保存光标位置
// (每次你打字、点击屏幕，这个函数都会运行，记下你光标在哪)
const saveSelectionRealTime = () => {
    const sel = window.getSelection();
    if (sel.rangeCount > 0) {
        const range = sel.getRangeAt(0);
        // 只有当光标真的在编辑器里时，才更新记录
        if (editor.contains(range.commonAncestorContainer)) {
            lastCursorRange = range.cloneRange();
        }
    }
};

// 3. 核心函数：恢复光标位置
// (点击按钮后，调用这个函数把光标“变”回去)
function restoreSelection() {
    editor.focus(); // 先抢回焦点
    const sel = window.getSelection();
    sel.removeAllRanges(); 

    if (lastCursorRange) {
        // 如果有记忆的位置，恢复过去
        sel.addRange(lastCursorRange);
    } else {
        // 如果没记忆，就把光标扔到最后
        const range = document.createRange();
        range.selectNodeContents(editor);
        range.collapse(false); 
        sel.addRange(range);
    }
}

// 4. 绑定监听：时刻记录光标
editor.addEventListener('keyup', saveSelectionRealTime);
editor.addEventListener('mouseup', saveSelectionRealTime);
editor.addEventListener('touchend', saveSelectionRealTime);
editor.addEventListener('input', saveSelectionRealTime);


// --- 工具栏按钮事件绑定 ---
// ==========================================
// A. 排版工具箱 (纯净版：仅格式化)
// ==========================================

// 1. 打开/关闭工具箱
document.getElementById('tool-format-btn').addEventListener('click', (e) => {
    e.preventDefault();
    const panel = document.getElementById('journal-format-panel');
    
    // 关闭其他面板
    const otherPanels = ['journal-sticker-panel', 'journal-tape-panel', 'journal-stamp-panel', 'journal-note-panel'];
    otherPanels.forEach(id => {
        const p = document.getElementById(id);
        if(p) p.style.display = 'none';
    });
    
    if (panel.style.display === 'none') {
        panel.style.display = 'flex';
    } else {
        panel.style.display = 'none';
    }
    
    restoreSelection(); // 保持光标
});

// 2. 绑定格式按钮事件 (加粗、斜体、下划线、对齐等)
document.querySelectorAll('.format-btn[data-cmd]').forEach(btn => {
    btn.addEventListener('click', (e) => {
        e.preventDefault();
        restoreSelection(); // ★ 恢复光标
        
        const cmd = btn.dataset.cmd;
        const val = btn.dataset.val || null;
        
        // 执行浏览器原生富文本命令
        document.execCommand(cmd, false, val);
        
        // 简单的视觉反馈 (切换激活样式)
        // 排除不需要常亮状态的按钮 (如荧光笔)
        if (cmd !== 'hiliteColor') {
            // 对于对齐按钮，做互斥处理 (不仅漂亮，还能防止状态错乱)
            if (cmd.startsWith('justify')) {
                const siblings = btn.parentNode.querySelectorAll('.format-btn[data-cmd^="justify"]');
                siblings.forEach(sib => sib.classList.remove('active'));
            }
            btn.classList.toggle('active');
        }
        
        saveSelectionRealTime(); // 保存状态
    });
});

// (原来的第3部分“绑定字体切换”已删除)
// B. 切换颜色
document.getElementById('tool-color-btn').addEventListener('click', (e) => {
    e.preventDefault();
    document.getElementById('journal-color-picker').click();
});
document.getElementById('journal-color-picker').addEventListener('input', (e) => {
    restoreSelection(); // ★ 关键：先恢复光标
    document.execCommand('foreColor', false, e.target.value); // 再变色
    saveSelectionRealTime(); // 变色后立即保存新位置
});

// C. 贴纸面板开关
// C. 贴纸面板数据 (手绘涂鸦风格 - 适合手账)
const stickersList = [
    // 🐱 萌宠系列
    "https://api.iconify.design/openmoji:cat-face.svg",
    "https://api.iconify.design/openmoji:rabbit-face.svg",
    "https://api.iconify.design/openmoji:poodle.svg",
    "https://api.iconify.design/openmoji:penguin.svg",
    "https://api.iconify.design/openmoji:hatching-chick.svg",

    // 🍰 甜点下午茶
    "https://api.iconify.design/openmoji:strawberry.svg",
    "https://api.iconify.design/openmoji:shortcake.svg",
    "https://api.iconify.design/openmoji:bubble-tea.svg",
    "https://api.iconify.design/openmoji:pancakes.svg",
    "https://api.iconify.design/openmoji:doughnut.svg",
    "https://api.iconify.design/openmoji:soft-ice-cream.svg",
    "https://api.iconify.design/openmoji:lollipop.svg",

    // ✨ 氛围装饰
    "https://api.iconify.design/openmoji:sparkles.svg",
    "https://api.iconify.design/openmoji:cherry-blossom.svg",
    "https://api.iconify.design/openmoji:sun-with-face.svg",
    "https://api.iconify.design/openmoji:rainbow.svg",
    "https://api.iconify.design/openmoji:balloon.svg",
    "https://api.iconify.design/openmoji:wrapped-gift.svg",
    "https://api.iconify.design/openmoji:party-popper.svg",
    "https://api.iconify.design/openmoji:artist-palette.svg"
];
// ==========================================
// C. 贴纸面板 (含自定义上传功能)
// ==========================================

// 1. 绑定工具栏按钮
document.getElementById('tool-sticker-btn').addEventListener('click', (e) => {
    e.preventDefault();
    const panel = document.getElementById('journal-sticker-panel');
    
    // 关闭其他面板
    const otherPanels = ['journal-tape-panel', 'journal-font-panel', 'journal-note-panel', 'journal-stamp-panel'];
    otherPanels.forEach(id => { const p = document.getElementById(id); if(p) p.style.display = 'none'; });

    if (panel.style.display === 'none') {
        panel.style.display = 'flex'; // 改用 flex 布局方便放加号
        panel.style.alignItems = 'center';
        
        // 懒加载：只有第一次打开时才生成内容
        if (panel.innerHTML.trim() === '') {
            renderStickerPanelContent(panel);
        }
    } else {
        panel.style.display = 'none';
    }
    
    restoreSelection();
});

// 2. 渲染面板内容 (内置贴纸 + 上传按钮)
function renderStickerPanelContent(panel) {
    // --- A. 添加“自定义上传”按钮 ---
    const uploadBtn = document.createElement('div');
    uploadBtn.className = 'sticker-select-item';
    // 样式微调：给加号一个特殊的背景
    uploadBtn.style.background = '#e3f2fd';
    uploadBtn.style.display = 'flex';
    uploadBtn.style.alignItems = 'center';
    uploadBtn.style.justifyContent = 'center';
    uploadBtn.innerHTML = '<i class="fas fa-plus" style="color: #2196f3;"></i>';
    
    // 绑定点击：触发文件选择
    uploadBtn.onmousedown = (e) => {
        e.preventDefault();
        document.getElementById('journal-sticker-uploader').click();
    };
    panel.appendChild(uploadBtn);
    // --- B. 渲染内置好看的贴纸 ---
    stickersList.forEach(url => {
        const img = document.createElement('img');
        img.src = url;
        img.className = 'sticker-select-item';
        img.onmousedown = (evt) => {
            evt.preventDefault(); 
            insertSticker(url);
        };
        panel.appendChild(img);
    });
}

// 插入贴纸函数
function insertSticker(url) {
    restoreSelection(); // ★ 关键：先恢复光标
    const imgHtml = `<img src="${url}" class="journal-sticker-img" contenteditable="false">`;
    document.execCommand('insertHTML', false, imgHtml);
    saveSelectionRealTime(); // 插入后保存
}

// ==========================================
// D. 插入胶带/分割线 (多款花色版)
// ==========================================

// 1. 定义胶带款式
const tapeStyles = [
    { name: '粉色斜纹', class: 'tape-pink-stripe' },
    { name: '清新蓝调', class: 'tape-blue-stripe' },
    { name: '薄荷波点', class: 'tape-mint-dot' },
    { name: '柠檬格子', class: 'tape-lemon-grid' },
    { name: '梦幻彩虹', class: 'tape-rainbow' },
    { name: '复古牛皮', class: 'tape-kraft' },
    { name: '暗夜星空', class: 'tape-galaxy' }
];

// 2. 渲染胶带面板
function renderTapePanel() {
    const panel = document.getElementById('journal-tape-panel');
    panel.innerHTML = '';
    
    tapeStyles.forEach(style => {
        // 创建预览条
        const item = document.createElement('div');
        item.className = `tape-select-item ${style.class}`;
        item.title = style.name; // 鼠标悬停显示名字
        
        // 绑定点击事件
        item.onmousedown = (e) => {
            e.preventDefault(); // 防止抢焦点
            insertTape(style.class);
        };
        
        panel.appendChild(item);
    });
}

// 3. 插入胶带函数
function insertTape(cssClass) {
    restoreSelection(); // 恢复光标
    
    // 插入结构：胶带div + 空行div (方便换行)
    const tapeHtml = `<div class="journal-washi-tape ${cssClass}" contenteditable="false"></div><div><br></div>`;
    document.execCommand('insertHTML', false, tapeHtml);
    
    saveSelectionRealTime(); // 保存光标
}

// 4. 按钮点击事件 (切换面板显示)
document.getElementById('tool-line-btn').addEventListener('click', (e) => {
    e.preventDefault();
    
    const panel = document.getElementById('journal-tape-panel');
    const stickerPanel = document.getElementById('journal-sticker-panel');
    const fontPanel = document.getElementById('journal-font-panel');
    
    if (panel.style.display === 'none') {
        // 关闭其他面板，保持界面整洁
        if(stickerPanel) stickerPanel.style.display = 'none';
        if(fontPanel) fontPanel.style.display = 'none';
        
        // 渲染并显示
        renderTapePanel();
        panel.style.display = 'flex';
    } else {
        panel.style.display = 'none';
    }
    
    restoreSelection(); // 保持焦点
});

// ==========================================
// E. 盖印章 (多款拟真版)
// ==========================================

// 定义印章配置
// dynamic: true 表示里面的日期/文字需要实时生成
const stampStyles = [
    { name: '日期红章', class: 'stamp-circle-date', type: 'date-circle' },
    
    // 改成 2x2 布局，手动加 <br> 换行
    { name: '今日无事', class: 'stamp-square-mood', type: 'text', text: '今日<br>无事' },
    { name: '未来可期', class: 'stamp-square-mood', type: 'text', text: '未来<br>可期' },
    
    // 改成竖长条布局
    { name: '宜开心', class: 'stamp-vertical-tag', type: 'text', text: '宜<br>开<br>心' },
    
    // 其他保持不变
    { name: '绝密', class: 'stamp-rect-status', type: 'text', text: 'TOP SECRET' },
    { name: '已完成', class: 'stamp-rect-status', type: 'text', text: 'COMPLETED' },
    { name: '随笔', class: 'stamp-simple-black', type: 'text', text: 'Journal Log' }
];

// 1. 渲染印章面板
function renderStampPanel() {
    const panel = document.getElementById('journal-stamp-panel');
    panel.innerHTML = '';
    
    stampStyles.forEach(style => {
        // 预览容器
        const wrapper = document.createElement('div');
        wrapper.className = 'stamp-select-item';
        wrapper.title = style.name;
        
        // 生成预览 HTML
        wrapper.innerHTML = generateStampHTML(style);
        
        // 绑定点击事件
        wrapper.onmousedown = (e) => {
            e.preventDefault(); // 防止抢焦点
            insertStamp(style);
        };
        
        panel.appendChild(wrapper);
    });
}

// 2. 生成印章 HTML (核心工厂函数)
function generateStampHTML(style) {
    let innerHTML = '';
    
    if (style.type === 'date-circle') {
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        // 圆形日期章结构
        innerHTML = `
            <div class="journal-stamp-box ${style.class}" contenteditable="false">
                <div style="font-size:9px;">${year}.${month}</div>
                <div class="stamp-date-day">${day}</div>
                <div style="font-size:9px;">RECEIVED</div>
            </div>`;
            
    } else {
        // 普通文字章
        innerHTML = `
            <div class="journal-stamp-box ${style.class}" contenteditable="false">
                ${style.text}
            </div>`;
    }
    
    return innerHTML;
}

// 3. 插入印章函数
function insertStamp(style) {
    restoreSelection(); // 恢复光标
    
    const stampHtml = generateStampHTML(style) + '&nbsp;'; // 加个空格防粘连
    document.execCommand('insertHTML', false, stampHtml);
    
    saveSelectionRealTime(); // 保存光标
}

// 4. 按钮点击事件
document.getElementById('tool-date-btn').addEventListener('click', (e) => {
    e.preventDefault();
    
    const panel = document.getElementById('journal-stamp-panel');
    // 关闭其他面板
    const otherPanels = ['journal-sticker-panel', 'journal-tape-panel', 'journal-font-panel', 'journal-note-panel'];
    otherPanels.forEach(id => {
        const p = document.getElementById(id);
        if(p) p.style.display = 'none';
    });
    
    if (panel.style.display === 'none') {
        renderStampPanel();
        panel.style.display = 'flex';
    } else {
        panel.style.display = 'none';
    }
    
    restoreSelection();
});

// ==========================================
// F. 插入便利贴 (斜着的框框)
// ==========================================

const noteStyles = [
    { name: '柠檬黄', class: 'note-yellow', color: '#fff9c4' },
    { name: '甜心粉', class: 'note-pink', color: '#fce4ec' },
    { name: '复古纸', class: 'note-kraft', color: '#d7ccc8' },
    { name: '网格纸', class: 'note-blue-grid', color: '#e1f5fe' } // 替换了原来的白纸
];

// 1. 渲染便利贴面板
function renderNotePanel() {
    const panel = document.getElementById('journal-note-panel');
    panel.innerHTML = '';
    
    noteStyles.forEach(style => {
        // 创建预览小方块
        const item = document.createElement('div');
        item.className = 'note-select-item';
        item.style.backgroundColor = style.color;
        item.title = style.name;
        
        // 绑定点击事件
        item.onmousedown = (e) => {
            e.preventDefault(); // 防止抢焦点
            insertNote(style.class);
        };
        
        panel.appendChild(item);
    });
}

// 2. 插入便利贴函数
function insertNote(cssClass) {
    restoreSelection(); // 恢复光标
    
    // ★ 核心技巧：
    // 外层 wrapper 用 contenteditable="false"，作为一个整体块，方便删除和移动
    // 内层 box 用 contenteditable="true"，让用户可以在歪着的框里打字
    const noteHtml = `
        <div class="journal-note-wrapper" contenteditable="false">
            <div class="journal-note-box ${cssClass}" contenteditable="true">
                点击此处写字...
            </div>
        </div>&nbsp;
    `;
    
    document.execCommand('insertHTML', false, noteHtml);
    saveSelectionRealTime(); // 保存光标
}

// 3. 按钮点击事件
document.getElementById('tool-note-btn').addEventListener('click', (e) => {
    e.preventDefault();
    
    const panel = document.getElementById('journal-note-panel');
    // 关闭其他面板
    const otherPanels = ['journal-sticker-panel', 'journal-tape-panel', 'journal-font-panel'];
    otherPanels.forEach(id => {
        const p = document.getElementById(id);
        if(p) p.style.display = 'none';
    });
    
    if (panel.style.display === 'none') {
        renderNotePanel(); // 渲染
        panel.style.display = 'flex';
    } else {
        panel.style.display = 'none';
    }
    
    restoreSelection();
});

// 信纸选择器
document.querySelectorAll('.paper-swatch').forEach(swatch => {
    swatch.addEventListener('click', (e) => {
        e.preventDefault();
        switchJournalTemplate(e.target.dataset.tmpl);
    });
});

// --- 保存按钮 (同步发布到动态流版) ---
const saveJournalBtn = document.getElementById('save-journal-btn');
const newSaveBtn = saveJournalBtn.cloneNode(true);
saveJournalBtn.parentNode.replaceChild(newSaveBtn, saveJournalBtn);

newSaveBtn.addEventListener('click', async () => {
    const title = document.getElementById('journal-title-input').value.trim();
    const editor = document.getElementById('journal-content-editor');
    
    const contentHtml = editor.innerHTML; 
    const plainText = editor.innerText.trim();
    
    if (!plainText && !contentHtml.includes('img')) return alert('手账是空的哦~');
    
    // 1. 存入手账本 (原有逻辑)
    if (!state.myProfile.qzone_journals) state.myProfile.qzone_journals = [];
    
    let savedFont = 'font-normal';
    if (editor.classList.contains('font-hand')) savedFont = 'font-hand';
    if (editor.classList.contains('font-cute')) savedFont = 'font-cute';

    const newJournal = {
        id: `journal_${Date.now()}`,
        title: title,
        content: contentHtml, 
        preview: plainText,
        template: currentJournalTemplate, 
        fontClass: savedFont, 
        timestamp: Date.now()
    };
    
    state.myProfile.qzone_journals.push(newJournal);
    await kokoMemory.put('myProfile', state.myProfile);
    
    // 2. ★★★ 核心新增：同步发送到空间动态 ★★★
    const journalPost = {
        id: `qz_post_${Date.now()}`, // 生成一个新的帖子ID
        author: { 
            id: 'myProfile', 
            name: state.myProfile.name, 
            avatar: state.myProfile.avatar, 
            isVip: true 
        },
        content: "写了一篇手账 📒", // 动态的正文，可以简单点
        
        // ★ 关键：把手账数据完整塞进帖子对象里
        journalData: newJournal, 
        
        timestamp: Date.now(),
        likes: [],
        comments: [],
        category: 'qzone', 
        device: 'Koko Diary' // 小尾巴变成“手账本”
    };

    state.posts.unshift(journalPost);
    await kokoMemory.put('posts', journalPost);
    
    // 3. 刷新界面
    document.getElementById('journal-editor-modal').style.display = 'none';
    renderJournalList(); // 刷新手账列表
    renderSocialZoneList(); // 刷新动态列表 (如果你在那个页面的话)
    
    alert('手账已保存并发布到空间！');
});

// --- 删除按钮 ---
const deleteJournalBtn = document.getElementById('delete-current-journal-btn');
if(deleteJournalBtn) {
    const newDelBtn = deleteJournalBtn.cloneNode(true);
    deleteJournalBtn.parentNode.replaceChild(newDelBtn, deleteJournalBtn);
    
    newDelBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm('撕掉这页', '确定要删除这篇手账吗？', true);
        if (confirmed) {
            state.myProfile.qzone_journals = state.myProfile.qzone_journals.filter(j => j.id !== currentViewingJournalId);
            await kokoMemory.put('myProfile', state.myProfile);
            
            document.getElementById('journal-detail-modal').style.display = 'none';
            renderJournalList();
        }
    });
}

// ==========================================================
// ▲▲▲ 手账逻辑结束 ▲▲▲
// ==========================================================
// ==========================================
// ▼▼▼ 留言板 (Guestbook) 核心逻辑 ▼▼▼
// ==========================================

// 1. 打开留言板
async function showGuestbookScreen() {
    hideAllScreens();
    document.getElementById('qzone-guestbook-screen').style.display = 'flex';
    await renderGuestbookList();
}
// 注册全局
window.showGuestbookScreen = showGuestbookScreen;

// 2. 渲染留言列表 (带删除功能版)
async function renderGuestbookList() {
    const container = document.getElementById('guestbook-list');
    container.innerHTML = '';
    
    // 数据存储在 myProfile.guestbookMessages 里
    if (!state.myProfile.guestbookMessages) state.myProfile.guestbookMessages = [];
    const messages = state.myProfile.guestbookMessages;

    if (messages.length === 0) {
        container.innerHTML = `<div style="text-align:center; padding:40px; color:#999;">还没有人留言，快去踩踩吧~</div>`;
        return;
    }

    // 按时间倒序
    messages.sort((a, b) => b.timestamp - a.timestamp).forEach(msg => {
        const item = document.createElement('div');
        item.className = 'gb-card';
        item.style.position = 'relative'; // 关键：为了定位删除按钮
        
        const dateStr = new Date(msg.timestamp).toLocaleString();
        
        const replyHTML = msg.reply 
            ? `<div class="gb-reply-box"><span class="gb-reply-user">${state.myProfile.name}</span>: ${msg.reply}</div>` 
            : `<div class="gb-reply-box" onclick="replyGuestbook('${msg.id}')" style="color:#576b95; cursor:pointer;">回复</div>`;

        // ▼▼▼ 新增：删除按钮 HTML ▼▼▼
        const deleteBtnHTML = `
            <div class="gb-delete-btn" onclick="deleteGuestbookMessage('${msg.id}')" 
                 style="position: absolute; top: 15px; right: 15px; color: #ccc; cursor: pointer; padding: 5px;">
                 <i class="far fa-trash-alt"></i>
            </div>`;
        // ▲▲▲ 新增结束 ▲▲▲

        item.innerHTML = `
            ${deleteBtnHTML}
            <div class="gb-header">
                <img src="${msg.sender.avatar}" class="gb-avatar">
                <div class="gb-info">
                    <div class="gb-name">${msg.sender.name}</div>
                    <div class="gb-time">${dateStr}</div>
                </div>
            </div>
            <div class="gb-content">${msg.content}</div>
            ${replyHTML}
        `;
        container.appendChild(item);
    });
}

// 3. 发送留言 (用户/AI 通用)
async function addGuestbookMessage(sender, content) {
    if (!state.myProfile.guestbookMessages) state.myProfile.guestbookMessages = [];
    
    const newMsg = {
        id: `gb_${Date.now()}_${Math.random()}`,
        sender: {
            id: sender.id,
            name: sender.name,
            avatar: sender.avatar
        },
        content: content,
        timestamp: Date.now(),
        reply: null // 初始无回复
    };
    
    state.myProfile.guestbookMessages.unshift(newMsg);
    await kokoMemory.put('myProfile', state.myProfile);
    
    // 刷新
    const screen = document.getElementById('qzone-guestbook-screen');
    if (screen && screen.style.display === 'flex') {
        renderGuestbookList();
    }
}

// 4. 回复留言 (用户操作)
window.replyGuestbook = async function(msgId) {
    const replyContent = await showCustomPrompt("回复留言", "请输入回复内容");
    if (replyContent) {
        const msg = state.myProfile.guestbookMessages.find(m => m.id === msgId);
        if (msg) {
            msg.reply = replyContent;
            await kokoMemory.put('myProfile', state.myProfile);
            renderGuestbookList();
            alert("回复成功！");
        }
    }
};
// --- 新增：删除留言的核心函数 ---
window.deleteGuestbookMessage = async function(msgId) {
    // 1. 弹窗确认
    const confirmed = await showCustomConfirm('删除留言', '确定要删除这条留言吗？', true);
    
    if (confirmed) {
        // 2. 从数组中过滤掉
        if (state.myProfile.guestbookMessages) {
            state.myProfile.guestbookMessages = state.myProfile.guestbookMessages.filter(m => m.id !== msgId);
            
            // 3. 保存并刷新
            await kokoMemory.put('myProfile', state.myProfile);
            renderGuestbookList();
        }
    }
};
// ==========================================================
// ==========================================================
// ▼▼▼ 把下面所有新函数，都粘贴到 initApp 函数的前面 ▼▼▼
async function showSnoopApiSettingsScreen() {
    hideAllScreens();
    document.getElementById('snoop-api-settings-screen').style.display = 'flex';
    // 用保存的数据填充输入框
    document.getElementById('snoop-api-key-input').value = state.snoopApiSettings.apiKey;
    document.getElementById('snoop-api-endpoint-input').value = state.snoopApiSettings.endpoint;
    // 更新模型下拉框
    updateModelDropdown([state.snoopApiSettings.model], document.getElementById('snoop-model-select'), state.snoopApiSettings.model);
}
// =========================================
// 🎵 AI 专用 - 静默搜歌工具 🎵
// =========================================
async function fetchSongForAI(searchKeyword) {
    // 1. 自动使用内置的代理地址
    const apiBase = BUILTIN_MUSIC_API;
    if (!apiBase) {
        console.error("AI 搜歌失败：内置 API 地址丢失！");
        return null; // 静默失败
    }

    try {
        // 2. 第一步：用关键词搜索，拿到歌曲列表
        const searchResponse = await fetch(`${apiBase}?word=${encodeURIComponent(searchKeyword)}`);
        const searchData = await searchResponse.json();

        if (searchData.code !== 200 || !Array.isArray(searchData.data) || searchData.data.length === 0) {
            console.error("AI 搜歌失败：vkeys 未返回有效结果。", searchData);
            return null;
        }

        // 3. 智能选择：我们就选第一个（最匹配的）结果
        const bestMatch = searchData.data[0];
        const songId = bestMatch.id;

        // 4. 第二步：用 ID 去获取详情 (URL 和 歌词)
        const detailUrl = `${apiBase}?id=${songId}`;
        const lyricUrl = `${apiBase}?type=lyric&id=${songId}&lv=1&kv=1&tv=-1`;

        const [detailRes, lyricRes] = await Promise.all([
            fetch(detailUrl),
            fetch(lyricUrl)
        ]);

        const detailData = await detailRes.json();
        const lyricData = await lyricRes.json().catch(e => ({})); // 容错

        if (detailData.code !== 200 || !detailData.data || !detailData.data.url) {
            console.error("AI 搜歌失败：无法获取详情 (可能是VIP)。", detailData);
            return null;
        }

        // 5. 提取歌词
        let lyricText = (lyricData.lrc && lyricData.lrc.lyric) ? lyricData.lrc.lyric : "";

        // 6. 组装成一个完整的 "song" 对象并返回
        const song = detailData.data;
        return {
            title: song.song,
            artist: song.singer,
            url: song.url,
            lrc: lyricText
        };

    } catch (error) {
        console.error("AI 搜歌时发生严重错误:", error);
        return null;
    }
}
// ==========================================================
// =========== ▼▼▼ 自动回复核心功能模块 ▼▼▼ ============
// ==========================================================

// 函数：显示自动回复设置页面
async function showAutomationScreen() {
    hideAllScreens();
    document.getElementById('automation-screen').style.display = 'flex';
    
    // 用当前保存的设置填充UI
    const settings = state.automationSettings;
    document.getElementById('automation-enabled-toggle').checked = settings.isEnabled;
    document.getElementById('automation-interval-input').value = settings.interval;
    document.getElementById('automation-min-replies-input').value = settings.minReplies;
    document.getElementById('automation-max-replies-input').value = settings.maxReplies;

    await renderAutomationContactList();
    updateAutomationStatusIndicator();
}

// 函数：渲染可供选择的联系人列表
async function renderAutomationContactList() {
    const listEl = document.getElementById('automation-contact-list');
    listEl.innerHTML = '';
    const selectedIds = new Set(state.automationSettings.selectedContactIds);

    state.contacts.forEach(contact => {
        if (contact.isGroup) return; // 自动回复不支持群聊

        const isChecked = selectedIds.has(contact.id);
        const item = document.createElement('div');
        item.className = 'world-book-item'; // 复用样式
        item.innerHTML = `
            <input type="checkbox" class="world-book-checkbox" id="auto-contact-${contact.id}" value="${contact.id}" ${isChecked ? 'checked' : ''}>
            <label for="auto-contact-${contact.id}" class="world-book-name">${contact.name}</label>
        `;
        listEl.appendChild(item);
    });
}

// 函数：保存自动回复的设置
async function saveAutomationSettings() {
    const newSettings = {
        isEnabled: document.getElementById('automation-enabled-toggle').checked,
        interval: parseInt(document.getElementById('automation-interval-input').value, 10) || 300,
        minReplies: parseInt(document.getElementById('automation-min-replies-input').value, 10) || 1,
        maxReplies: parseInt(document.getElementById('automation-max-replies-input').value, 10) || 2,
        selectedContactIds: Array.from(document.querySelectorAll('#automation-contact-list input:checked')).map(cb => cb.value)
    };
    
    state.automationSettings = newSettings;

    // 将设置保存到数据库
    const userSettings = await kokoMemory.get('userSettings', 'main') || { id: 'main' };
    userSettings.automationSettings = newSettings;
    await kokoMemory.put('userSettings', userSettings);

    alert('设置已保存！');

    // 根据新设置决定是开启还是关闭定时器
    if (newSettings.isEnabled) {
        startAutomationTimer();
    } else {
        stopAutomationTimer();
    }
    updateAutomationStatusIndicator();
}

// 函数：启动定时器
function startAutomationTimer() {
    stopAutomationTimer(); // 先停止旧的，防止重复
    
    if (!state.automationSettings.isEnabled || state.automationSettings.selectedContactIds.length === 0) {
        return;
    }

    const intervalSeconds = state.automationSettings.interval;
    automationTimer = setInterval(runAutomationCycle, intervalSeconds * 1000);
    
    // ✨ 新增：在这里手动设置下一次执行的时间戳
    nextAutomationTimestamp = Date.now() + intervalSeconds * 1000;
    
    console.log(`自动回复已启动，每 ${intervalSeconds} 秒检查一次。`);
}

// 函数：停止定时器
function stopAutomationTimer() {
    if (automationTimer) {
        clearInterval(automationTimer);
        automationTimer = null;
        nextAutomationTimestamp = 0;
        console.log("自动回复已停止。");
    }
    updateAutomationStatusIndicator();
}

// 函数：更新状态指示器（显示倒计时）
function updateAutomationStatusIndicator() {
    const indicator = document.getElementById('automation-status-indicator');
    if (!indicator) return;

    if (!state.automationSettings.isEnabled) {
        indicator.textContent = '当前已关闭';
        return;
    }
    
    if (nextAutomationTimestamp > 0) {
        const now = Date.now();
        const remainingSeconds = Math.round((nextAutomationTimestamp - now) / 1000);
        if (remainingSeconds > 0) {
            indicator.textContent = `运行中... 下次检查还剩 ${remainingSeconds} 秒`;
        } else {
            indicator.textContent = '正在检查中...';
        }
    } else {
        indicator.textContent = '运行中...';
    }
}

// ... 函数开头 ...
async function runAutomationCycle() {
    const settings = state.automationSettings;
    if (!settings.isEnabled || settings.selectedContactIds.length === 0) {
        stopAutomationTimer();
        return;
    }
    
    nextAutomationTimestamp = Date.now() + settings.interval * 1000;
    console.log("开始执行自动回复周期...");

    // 1. 筛选出所有“有资格”被自动回复的角色
    //    核心修改：过滤掉当前正在聊天的角色！
    const eligibleContacts = settings.selectedContactIds.filter(id => id !== state.activeChatId);

    if (eligibleContacts.length === 0) {
        console.log("没有符合条件的自动回复目标（可能正在与唯一的目标聊天），跳过本次周期。");
        return; // 如果过滤后没人可选了，就直接结束
    }

    // 2. 从“有资格”的角色中随机挑选“幸运儿”
    const shuffled = [...eligibleContacts].sort(() => 0.5 - Math.random());
    const replyCount = Math.floor(Math.random() * (settings.maxReplies - settings.minReplies + 1)) + settings.minReplies;
    const targets = shuffled.slice(0, replyCount);

    if (targets.length === 0) {
        console.log("本次没有选中任何目标，跳过。");
        return;
    }
    // ... 后续代码 ...
    
    // 2. 收集情报，构建“剧本”
    const myProfile = state.myProfile;
    let characterDossiers = '';
    const targetProfiles = [];

    for (const contactId of targets) {
        const contact = state.contacts.find(c => c.id === contactId);
        if (!contact) continue;
        targetProfiles.push(contact);

        let recentChatHistory = '(最近没有私聊记录)';
        if (contact.history && contact.history.length > 0) {
            recentChatHistory = contact.history
                .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                .slice(-40) // 读取最近40条
                .map(msg => `    ${msg.sender === 'user' ? myProfile.name : contact.name}: ${msg.content}`)
                .join('\n');
        }
        
        // 核心新增：先获取当前角色对应的用户人设，如果没设置就给个默认值
const userPersonaForThisChar = contact.userPersona || '(用户未设置特定人设)';

characterDossiers += `
- 角色名: ${contact.name}
  - 核心人设: ${contact.persona.replace(/\n/g, ' ')}
  - 用户“${myProfile.name}”在你眼中的人设: ${userPersonaForThisChar.replace(/\n/g, ' ')}// 把时间指令插入到档案里
  - [与“${myProfile.name}”的近期私聊参考 (重要)]
    \`\`\`
${recentChatHistory}
    \`\`\`
`;
    }

    if (targetProfiles.length === 0) return;

    // ✅ 正确的代码
const prompt = `[SYSTEM] 你是一个顶级的AI虚拟互动总监。
你的任务是：基于下方提供的角色档案和他们与用户的聊天记录，判断哪些角色现在最适合主动给用户发送一条消息，并为他们生成一段符合人设的、自然的回复。

[角色档案与聊天记录]
---
${characterDossiers}
---

[核心规则]
1.  **判断时机**: 仔细分析每个角色的聊天记录。如果对话刚刚结束，或者用户明显不想聊了，就不要生成回复。只有当对话处于暂停状态、或者有明显可以延续的话题时，才生成回复。
2.  **内容自然**: 回复必须像是角色“突然想起来”某件事，或者对之前的话题有了新的想法。避免生硬的问候。
3.  **允许多句话**: 你的回复可以包含多句话，模仿真实的人类聊天习惯。请使用换行符来分隔每一句话。
4.  **严格遵守格式**: 对于你决定要回复的每个角色，都必须严格使用以下格式。如果决定某个角色不回复，就不要为他生成任何内容。

// --- 核心新增部分 ---
[特殊指令格式]
除了纯文本，你还可以在 CONTENT 中使用以下指令来发送特殊消息：
- 语音: [voice:你想用语音说的文字内容]
- 图片: [picture:你想要发送的图片的文字描述]
- 表情包: [sticker:表情名]
// --- 新增结束 ---
// ✨ 新增一个“可用表情包列表”的区域 ✨
[可用表情包列表]
{{emoticon_list}}

[输出格式]
MESSAGE_START
SPEAKER: [角色名]
CONTENT: [该角色说的【可以包含换行的多句话】内容，也可以包含特殊指令]
MESSAGE_END
`;

    // ✨ 新增：把表情包列表填充到Prompt里
    const finalPrompt = prompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');

    // 3. 调用AI大脑 (注意：这里要用我们新创建的 finalPrompt)
    const rawResponse = await generateAiResponse(null, [], finalPrompt, false, 'chat');

    // 4. 解析剧本，精准投递
    const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
    const matches = Array.from(rawResponse.matchAll(messageRegex));

    for (const match of matches) {
        const speakerName = match[1].trim();
        const content = match[2].trim();
        
        const speakerProfile = targetProfiles.find(p => p.name === speakerName);
        
// ✅✅✅ 最终的、完美的正确代码 ✅✅✅
if (speakerProfile && content) {
    console.log(`为 ${speakerName} 生成回复: ${content}`);
    
    // 1. 仍然是按换行符分割消息
    const messages = content.split('\n').filter(line => line.trim() !== '');

    // 2. 使用 forEach 循环，这样我们可以拿到句子的索引 (index)
    messages.forEach(async (line, index) => {
        // 3. 判断当前是不是第一句话，这个逻辑保留
        const isFirstLine = (index === 0);

        // 4. 【核心新增】把 processAndDisplayAiResponse 的菜谱搬到这里来！
        let processed = false;
// 核心修改：在正则里加入了 gift 和 takeout
const commandRegex = /\[\s*(sticker|voice|picture|red_packet|transfer|transfer_to|music|spin_wheel|claim_red_packet|location|create_location|action|search_music|recall|status|nudge|memory|start_survey|gift|takeout)(?:[\s:：]+([^\]]*))?\]/i;
        const commandMatch = line.match(commandRegex);

        if (commandMatch) {
            processed = true;
            const command = commandMatch[1];
            const value = commandMatch[2] || '';
            switch (command) {
                case 'voice': {
                    const duration = Math.max(1, Math.round(value.length / 4));
                    await createAndAddMessage({ type: 'voice', content: { text: value, duration: duration } }, speakerProfile.id, speakerProfile, isFirstLine, 'chat');
                    break;
                }
// ... 省略了其他case ...
// ... 之前的代码
                case 'sticker':
                    // ▼▼▼ 修改开始：使用智能模糊查找 ▼▼▼
                    const emoticon = findBestMatchingEmoticon(value);
                    // ▲▲▲ 修改结束 ▲▲▲
                    
                    if (emoticon) {
                        await createAndAddMessage({ type: 'image', url: emoticon.url, isEmoticon: true, emoticonName: emoticon.name }, speakerProfile.id, speakerProfile, isFirstInSequence, 'chat');
                    } else {
                        await createAndAddMessage({ type: 'text', content: `[发送表情失败: ${value}]` }, speakerProfile.id, speakerProfile, isFirstInSequence, 'chat');
                    }
                    break;
// ... 之后的代码
// ... 省略了其他case ...
                case 'picture': {
                    await createAndAddMessage({ type: 'picture_description', content: { description: value } }, speakerProfile.id, speakerProfile, isFirstLine, 'chat');
                    break;
                }
                // 你可以根据需要，把 processAndDisplayAiResponse 里的其他 case (如 sticker, music 等) 也复制到这里
                // 来让自动回复支持更多功能！
            }
        }

        // 5. 如果不是任何特殊指令，就当作普通文本处理
        if (!processed) {
            await createAndAddMessage({ type: 'text', content: line }, speakerProfile.id, speakerProfile, isFirstLine, 'chat');
        }

        // 6. 加入延迟，让对话看起来更自然
        await sleep(800 + Math.random() * 500);
    });
}
    }
}

// ==========================================================

// =========== ▲▲▲ 自动回复核心功能模块 END ▲▲▲ =========
// 全局变量，用于管理语音播放队列
let isPlayingVoice = false;
const voiceQueue = [];

/**
 * 将语音任务添加到队列，并触发处理
 */
async function playNextInQueue(text, contact) { // 将 voiceId 改为 contact
    voiceQueue.push({ text, contact }); // 保存整个 contact 对象
    if (!isPlayingVoice) {
        processVoiceQueue();
    }
}

/**
 * 递归处理语音队列，确保一次只播放一个
 */
async function processVoiceQueue() {
    if (voiceQueue.length === 0) {
        isPlayingVoice = false;
        return;
    }

    isPlayingVoice = true;
    const { text, contact } = voiceQueue.shift(); // 将 voiceId 改为 contact // 取出队列的第一个任务

    try {
        // 等待 playVoiceMessage 函数播放完成
        await playVoiceMessage(text, contact); // 传入整个 contact 对象
    } catch (error) {
        console.error("视频通话语音播放失败:", error);
    } finally {
        // 不管成功或失败，都继续处理队列里的下一个任务
        processVoiceQueue();
    }
}
/**
 * 调用 MiniMax API 将文本转换为语音并返回一个 Promise，该 Promise 在播放结束时解析
 * @param {string} textToSpeak - 要转换的文字
 * @param {string} voiceId - MiniMax 的音色 ID
 * @returns {Promise<void>}
 */
// ▼▼▼ 使用这个【V2 - 支持用户语音版】，完整替换旧的 playVoiceMessage 函数 ▼▼▼
function playVoiceMessage(textToSpeak, contact, senderType = 'contact') { // 1. 新增 senderType 参数
    return new Promise((resolve, reject) => {
        if (!contact) {
            console.warn("playVoiceMessage 收到无效的 contact 对象，跳过播放。");
            return resolve();
        }

        // --- 2. 智能决策：决定使用谁的语音配置 ---
        let voiceProvider, voiceId, roleName;
        
        if (senderType === 'user') {
            // 如果是播放用户（你）的声音
            voiceProvider = contact.userVoiceProvider;
            voiceId = contact.userVoiceId;
            roleName = state.myProfile.name;
        } else {
            // 否则，播放AI的声音（默认）
            voiceProvider = contact.voiceProvider;
            voiceId = contact.voiceId;
            roleName = contact.name;
        }
        // --- 决策结束 ---

        if (!voiceId || !voiceProvider) {
            console.warn(`角色 ${roleName} (类型: ${senderType}) 未配置音色ID或服务商，跳过语音播放。`);
            return resolve();
        }

        const audioPlayer = document.getElementById('voice-message-player');
        
        // --- 3. 调度中心 (使用新变量) ---
        if (voiceProvider === 'minimax') {
            const { minimaxGroupId, minimaxApiKey } = state.apiSettings;
            if (!minimaxGroupId || !minimaxApiKey) {
                console.warn("MiniMax Group ID 或 API Key 未配置，无法播放语音。");
                return resolve();
            }

            fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${minimaxApiKey}` },
                body: JSON.stringify({
                    "voice_id": voiceId, // <-- 使用新变量
                    "text": textToSpeak,
                    "model": "speech-01", "speed": 1.0, "vol": 1.0, "pitch": 0
                })
            })
            .then(response => {
                if (!response.ok) return response.json().then(err => { throw new Error(err.base_resp?.status_msg || 'MiniMax TTS API请求失败') });
                return response.arrayBuffer();
            })
            .then(getAudioAndPlay)
            .catch(handleAudioError);

        } else if (voiceProvider === 'siliconflow') {
            const { siliconflowApiKey } = state.apiSettings;
            if (!siliconflowApiKey) {
                console.warn("SiliconFlow API Key 未配置，无法播放语音。");
                return resolve();
            }

            fetch(`https://api.siliconflow.cn/v1/audio/speech`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${siliconflowApiKey}` },
                body: JSON.stringify({
                    "model": "FunAudioLLM/CosyVoice2-0.5B",
                    "voice": voiceId, // <-- 使用新变量
                    "input": textToSpeak,
                    "response_format": "mp3"
                })
            })
            .then(response => {
                if (!response.ok) return response.json().then(err => { throw new Error(err.error?.message || 'SiliconFlow TTS API请求失败') });
                return response.arrayBuffer();
            })
            .then(getAudioAndPlay)
            .catch(handleAudioError);
        } else {
            console.warn(`未知的语音服务商: ${voiceProvider}`);
            resolve();
        }

        // --- 辅助函数 (保持不变) ---
        function getAudioAndPlay(audioData) {
            const blob = new Blob([audioData], { type: 'audio/mpeg' });
            const audioUrl = URL.createObjectURL(blob);
            audioPlayer.src = audioUrl;
            audioPlayer.play();
            audioPlayer.onended = () => { URL.revokeObjectURL(audioUrl); resolve(); };
            audioPlayer.onerror = (e) => { URL.revokeObjectURL(audioUrl); reject(e); };
        }

        function handleAudioError(error) {
            console.error('播放语音消息失败:', error);
            reject(error);
        }
    });
}
// ==========================================================
// --- 新增：辅助函数，用于更新拉黑按钮的UI ---
function updateBlockButtonText(blockedStatus) {
    const blockButton = document.getElementById('block-contact-btn-menu');
    if (!blockButton) return;

    const icon = blockButton.querySelector('i');
    const span = blockButton.querySelector('span');

    if (blockedStatus === 'user_blocked_ai') {
        span.textContent = '解除拉黑';
        icon.className = 'fas fa-check fa-fw';
        blockButton.style.pointerEvents = 'auto'; // 允许点击
    } else if (blockedStatus === 'ai_blocked_user') {
        span.textContent = '已被对方拉黑';
        icon.className = 'fas fa-exclamation-circle fa-fw';
        blockButton.style.pointerEvents = 'none'; // 不允许用户解除
    } else {
        span.textContent = '拉黑TA';
        icon.className = 'fas fa-ban fa-fw';
        blockButton.style.pointerEvents = 'auto';
    }
}
// ==========================================================
// =========== ▼▼▼ 新增：聊天输入框锁定/解锁辅助函数 ▼▼▼ ====
// ==========================================================
/**
 * 根据拉黑状态，更新聊天输入框的UI
 * @param {'none' | 'user_blocked_ai' | 'ai_blocked_user'} blockedStatus
 */
function updateChatInputLockState(blockedStatus) {
    const inputArea = document.getElementById('chat-input-area');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const requestBtn = document.getElementById('request-reply-btn');
    const emojiBtn = document.getElementById('emoji-btn');
    const attachBtn = document.getElementById('attachment-btn');

    if (!inputArea || !messageInput || !sendBtn || !requestBtn || !emojiBtn || !attachBtn) {
        console.warn("无法找到所有聊天输入框元素来进行锁定/解锁。");
        return;
    }

    if (blockedStatus === 'user_blocked_ai') {
        inputArea.style.opacity = '0.7';
        messageInput.disabled = true;
        messageInput.placeholder = "你已拉黑对方，无法发送消息。";
        sendBtn.style.display = 'none';
        requestBtn.style.display = 'none';
        emojiBtn.style.pointerEvents = 'none';
        attachBtn.style.pointerEvents = 'none';
    } else if (blockedStatus === 'ai_blocked_user') {
        inputArea.style.opacity = '0.7';
        messageInput.disabled = true;
        messageInput.placeholder = "你已被对方拉黑，无法发送消息。";
        sendBtn.style.display = 'none';
        requestBtn.style.display = 'none';
        emojiBtn.style.pointerEvents = 'none';
        attachBtn.style.pointerEvents = 'none';
    } else { // 状态为 'none' (正常)
        inputArea.style.opacity = '1';
        messageInput.disabled = false;
        messageInput.placeholder = "输入消息...";
        sendBtn.style.display = 'flex'; // 恢复按钮显示
        requestBtn.style.display = 'flex';
        emojiBtn.style.pointerEvents = 'auto';
        attachBtn.style.pointerEvents = 'auto';
    }
}
// ==========================================================
// --- 情侣默契挑战 核心逻辑 ---

let cpState = {
    targetContactId: null,
    questions: [],
    currentIdx: 0,
    title: "默契大挑战",
    author: "",
    imgBase64: null,
    tempMultiSelection: new Set()
};

// 1. 入口与返回
document.getElementById('open-compatibility-btn').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('compatibility-screen').style.display = 'flex';
    initCpGame();
});

document.getElementById('back-from-compatibility').addEventListener('click', () => {
    document.getElementById('compatibility-screen').style.display = 'none';
    document.getElementById('investment-center-screen').style.display = 'flex';
});

// 2. 初始化：渲染联系人列表
function initCpGame() {
    switchCpStep(0);
    const list = document.getElementById('cp-contact-list');
    list.innerHTML = '';
    
    // 过滤掉群聊和自己
    const candidates = state.contacts.filter(c => !c.isGroup && c.id !== 'myProfile');
    
    candidates.forEach(c => {
        const item = document.createElement('div');
        item.className = 'contact-item';
        item.innerHTML = `
            <img src="${c.avatar}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 15px;">
            <div style="font-weight: bold;">${c.name}</div>
        `;
        item.onclick = () => selectCpTarget(c);
        list.appendChild(item);
    });
}

function switchCpStep(stepIndex) {
    document.querySelectorAll('.cp-step-container').forEach((el, idx) => {
        el.classList.toggle('active', idx === stepIndex);
    });
}

// 3. 选择对象
function selectCpTarget(contact) {
    cpState.targetContactId = contact.id;
    document.getElementById('cp-target-avatar').src = contact.avatar;
    document.getElementById('cp-target-name').textContent = contact.name;
    
    // 重置状态
    cpState.questions = [];
    cpState.imgBase64 = null;
    document.getElementById('cp-topic-input').value = '';
    
    switchCpStep(1);
}

// 4. 图片上传
document.getElementById('cp-upload-img-btn').addEventListener('click', () => {
    document.getElementById('cp-img-uploader').click();
});
document.getElementById('cp-img-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (file) {
        cpState.imgBase64 = await handleImageUpload(file);
        alert("图片已选择！点击“生成并开始”即可识别。");
    }
});

// 5. 生成题目 (调用 Koko AI) - 增强版：注入人设
document.getElementById('cp-start-btn').addEventListener('click', async () => {
    const topic = document.getElementById('cp-topic-input').value.trim();
    const contact = state.contacts.find(c => c.id === cpState.targetContactId);
    const myProfile = state.myProfile;
    
    if (!topic && !cpState.imgBase64) return alert("请输入主题或上传图片！");

    const btn = document.getElementById('cp-start-btn');
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 正在根据人设生成...';

    try {
        // ▼▼▼ 核心修改：获取双方人设 ▼▼▼
        const aiName = contact.name;
        const aiPersona = contact.persona || "普通人";
        const userName = myProfile.name;
        // 优先用 AI 眼中的用户人设，没有就用用户的签名
        const userPersona = contact.userPersona || myProfile.signature || "普通用户";
        // ▲▲▲ 修改结束 ▲▲▲

        // ▼▼▼ 核心修改：在 System Prompt 中注入灵魂 ▼▼▼
        const systemPrompt = `[SYSTEM] 你是一个擅长根据【角色人设】生成趣味互动问卷的策划大师。

[角色档案]
1. 问卷发起人: ${aiName}
   - 人设: ${aiPersona}
2. 问卷填写人: ${userName}
   - 设定: ${userPersona}

[任务]
请根据【发起人】的性格、说话语气以及TA与【填写人】的关系，生成一份JSON格式的默契问卷。
如果无图片参考则是题目必须符合发起人的口吻（例如：如果发起人是傲娇，题目就要带有傲娇色彩）。
如果有图片参考则是严格按照图片上的文字生成，且必须加上作者（制表）署名。

[输出格式 (Strict JSON)]
{
    "title": "问卷标题 (要符合发起人风格)",
    "author": "原作者署名(如果是识图)",
    "questions": [
        { "q": "问题内容", "type": "text/single/multiple", "options": ["选项A", "选项B"] }
    ]
}
注意：type为 single(单选) 或 multiple(多选) 时必须有 options 数组。text 为填空。`;
        // ▲▲▲ 修改结束 ▲▲▲

        let userMsgContent = [];
        if (cpState.imgBase64) {
            userMsgContent.push({ type: "text", text: "请识别这张图片里的问卷问题，转成JSON。" });
            userMsgContent.push({ type: "image_url", image_url: { url: cpState.imgBase64 } });
        } else {
            // ▼▼▼ 核心修改：在用户指令里也强调人设 ▼▼▼
            userMsgContent.push({ 
                type: "text", 
                text: `请以“${aiName}”的身份，围绕“${topic}”这个主题，为“${userName}”设计 5-8 个测试默契的题目。
                要求：
                1. 题目不要太无聊，要贴合你们的人设关系。
                2. 选项要有趣。` 
            });
            // ▲▲▲ 修改结束 ▲▲▲
        }

        // 调用 Koko 的 AI 接口
        const rawResponse = await generateAiResponse(contact, [], systemPrompt, false, 'chat', [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userMsgContent }
        ]);

        const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error("AI生成格式错误");
        
        const data = JSON.parse(jsonMatch[0]);
        cpState.title = data.title;
        cpState.author = data.author || contact.name;
        cpState.questions = data.questions.map(q => ({
            ...q,
            userAns: "",
            aiAns: "",
            aiComment: ""
        }));
        cpState.currentIdx = 0;

        renderCpQuestion();
        switchCpStep(2);

    } catch (e) {
        console.error(e);
        alert("生成失败：" + e.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
    }
});

// 6. 渲染当前题目
function renderCpQuestion() {
    const q = cpState.questions[cpState.currentIdx];
    document.getElementById('cp-question-text').textContent = q.q;
    document.getElementById('cp-current-num').textContent = cpState.currentIdx + 1;
    document.getElementById('cp-total-num').textContent = cpState.questions.length;
    
    const pct = ((cpState.currentIdx) / cpState.questions.length) * 100;
    document.getElementById('cp-progress-fill').style.width = `${pct}%`;

    const inputArea = document.getElementById('cp-answer-input');
    const optionsArea = document.getElementById('cp-options-container');
    optionsArea.innerHTML = '';
    inputArea.value = '';
    
    // 清理暂存
    cpState.tempMultiSelection.clear();
    const nextBtn = document.getElementById('cp-next-btn');
    nextBtn.dataset.selectedAns = ""; 

    if (q.type === 'single' || q.type === 'multiple') {
        inputArea.style.display = 'none';
        q.options.forEach(opt => {
            const btn = document.createElement('div');
            btn.className = 'cp-opt-btn';
            btn.textContent = opt;
            btn.onclick = () => {
                if (q.type === 'single') {
                    document.querySelectorAll('.cp-opt-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    nextBtn.dataset.selectedAns = opt;
                } else {
                    btn.classList.toggle('selected');
                    if (cpState.tempMultiSelection.has(opt)) cpState.tempMultiSelection.delete(opt);
                    else cpState.tempMultiSelection.add(opt);
                }
            };
            optionsArea.appendChild(btn);
        });
    } else {
        inputArea.style.display = 'block';
    }
    
    nextBtn.textContent = (cpState.currentIdx === cpState.questions.length - 1) ? '提交并生成结果' : '下一题';
}

// 7. 处理下一题/提交
document.getElementById('cp-next-btn').addEventListener('click', async () => {
    const q = cpState.questions[cpState.currentIdx];
    let ans = "";

    if (q.type === 'single') {
        ans = document.getElementById('cp-next-btn').dataset.selectedAns;
    } else if (q.type === 'multiple') {
        ans = Array.from(cpState.tempMultiSelection).join('、');
    } else {
        ans = document.getElementById('cp-answer-input').value.trim();
    }

    if (!ans) return alert("请回答这个问题！");
    q.userAns = ans;

    cpState.currentIdx++;
    if (cpState.currentIdx < cpState.questions.length) {
        renderCpQuestion();
    } else {
        await submitCpToAI();
    }
});

// 8. 提交给 AI 填写 (防卡死 + 聊天记忆 + 多选支持版)
async function submitCpToAI() {
    const btn = document.getElementById('cp-next-btn');
    const originalText = "提交并生成结果"; 

    // 锁住按钮
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 正在回忆与你的点滴...';

    const contact = state.contacts.find(c => c.id === cpState.targetContactId);
    const myProfile = state.myProfile;

    // --- 1. 提取最近聊天记录 ---
    let chatHistoryContext = "(暂无最近聊天记录)";
    if (contact.history && contact.history.length > 0) {
        const recentMsgs = contact.history
            .filter(m => m.type === 'text' && m.sender !== 'system_instruction' && m.type !== 'system_notification')
            .slice(-60)
            .map(m => {
                const role = m.sender === 'user' ? myProfile.name : contact.name;
                const content = m.content.replace(/<[^>]+>/g, '');
                return `${role}: ${content}`;
            })
            .join('\n');
            
        if (recentMsgs.trim()) {
            chatHistoryContext = recentMsgs;
        }
    }

    // --- 2. 构建问卷内容 (✨ 核心修改：带上题型标记) ---
    const surveyText = cpState.questions.map((q, i) => {
        const opts = q.options ? `[选项: ${q.options.join('/')}]` : '';
        
        // 这里的 q.type 是我们在生成题目或解析图片时存好的 ('single', 'multiple', 'text')
        let typeLabel = "填空题";
        if (q.type === 'single') typeLabel = "单选题";
        if (q.type === 'multiple') typeLabel = "多选题";

        return `问题${i+1} 【${typeLabel}】: ${q.q} ${opts}\n用户(${myProfile.name})的回答: ${q.userAns}`;
    }).join('\n\n');

    const userPersonaInfo = contact.userPersona || "(未设置)";
    const aiPersonaInfo = contact.persona || "普通人";

    // --- 3. 升级后的 Prompt (✨ 核心修改：增加多选指令) ---
    const prompt = `[SYSTEM]
    你正在进行深度角色扮演。
    你的角色: ${contact.name}
    核心人设: ${aiPersonaInfo}
    你的对话对象: ${myProfile.name}
    对象在你眼中的人设: ${userPersonaInfo}

    [参考信息：双方最近的聊天回忆]
    (请阅读以下对话，捕捉你们当下的相处模式——是甜蜜、互怼、冷战还是暧昧？)
    ---
    ${chatHistoryContext}
    ---

    [当前情境]
    你们正在一起玩《${cpState.title}》。这是一份测试默契的问卷，用户已经填完了，现在轮到你了。
    请你以"${contact.name}"的身份，完成以下任务：

    1. **回答问题 (重要)**: 
       - 如果是【单选题】，必须只选**一个**最符合你人设的。
       - 如果是【多选题】，你可以根据人设选择**一个或多个**选项 (如果有多个答案，请用 "、" 分隔)。
       - 如果是【填空题】，请用你的口吻自然回答。

    2. **评价用户**: 
       - 看看用户的回答，结合你们的“聊天回忆”和“人设关系”，给出一句简短的点评。
       - 可以是惊讶、甜蜜、吐槽或者感动。
       - **拒绝AI味，要像真人一样说话！**

    [问卷内容 & 用户回答]
    ${surveyText}

    [输出格式]
    请严格返回 JSON 数组，顺序与题目一致，不要包含 Markdown 标记：
    [
        { "answer": "你的回答 (如果是多选，用顿号分隔)", "comment": "你的评价" },
        ...
    ]
    `;

    try {
        const rawResponse = await generateAiResponse(contact, [], prompt, false, 'chat');
        
        const jsonMatch = rawResponse.match(/\[[\s\S]*\]/);
        
        if (jsonMatch) {
            const results = JSON.parse(jsonMatch[0]);
            cpState.questions.forEach((q, i) => {
                if (results[i]) {
                    q.aiAns = results[i].answer;
                    q.aiComment = results[i].comment;
                }
            });
            renderCpResult();
            switchCpStep(3); 
        } else {
            throw new Error("AI返回格式错误，无法解析JSON");
        }

    } catch (e) {
        console.error(e);
        alert("AI 脑子卡壳了，请重试！\n错误信息: " + e.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
    }
}

// 9. 渲染结果 (截图修复版 V2)
function renderCpResult() {
    const contact = state.contacts.find(c => c.id === cpState.targetContactId);
    const container = document.getElementById('cp-result-render');
    const myAvatar = state.myProfile.avatar;
    const aiAvatar = contact.avatar;

    let rowsHtml = cpState.questions.map(q => {
        let ansHtml = "";
        
        if (q.type === 'single' || q.type === 'multiple') {
            // --- A. 选择题 ---
            const userSelections = q.userAns.split(/、|\||\s+/); 
            const aiSelections = q.aiAns.split(/、|\||\s+/);

            const optionsHTML = q.options.map(opt => {
                const isUserSelected = userSelections.some(s => s.includes(opt));
                const isAiSelected = aiSelections.some(s => s.includes(opt));
                
                let cls = "cp-opt-tag";
                let iconHTML = ""; // 用于放爱心

                if (isUserSelected && isAiSelected) {
                    cls = "cp-match-tag"; // 默契样式
                    // ★★★ 修复：直接把爱心写在 HTML 里，不要用伪元素！ ★★★
                    iconHTML = `<i class="fas fa-heart" style="color: #7b1fa2; font-size: 12px;"></i>`;
                } else if (isUserSelected) {
                    cls += " active-user";  
                } else if (isAiSelected) {
                    cls += " active-ai";    
                }
                
                // 把图标和文字拼在一起
                return `<span class="${cls}">${opt} ${iconHTML}</span>`;
            }).join('');
            
            ansHtml = `<div style="margin-top:5px; line-height:1.6; display:flex; flex-wrap:wrap; gap:5px;">${optionsHTML}</div>`;

        } else {
            // --- B. 填空题 (保持不变) ---
            ansHtml = `
                <div class="cp-ans-row">
                    <div class="cp-ans-user">${q.userAns}</div>
                    <div class="cp-ans-ai">${q.aiAns}</div>
                </div>
            `;
        }

        const commentHtml = q.aiComment ? `<div class="cp-ai-comment">💬 ${contact.name}: ${q.aiComment}</div>` : '';

        return `
        <div class="cp-rc-row">
            <div class="cp-rc-q">${q.q}</div>
            ${ansHtml}
            ${commentHtml}
        </div>`;
    }).join('');

    const html = `
        <div class="cp-result-card">
            <div class="cp-rc-header">
                <div style="font-size: 18px; font-weight: bold;">${cpState.title}</div>
                <div style="font-size: 12px; opacity: 0.8;">${cpState.author || "Koko AI 生成"}</div>
                <div class="cp-rc-avatars">
                    <div class="cp-rc-avatar"><img src="${myAvatar}" crossorigin="anonymous"></div>
                    <div style="display:flex; align-items:center; font-size:20px; color:rgba(255,255,255,0.8);">×</div>
                    <div class="cp-rc-avatar"><img src="${aiAvatar}" crossorigin="anonymous"></div>
                </div>
            </div>
            <div class="cp-rc-body">
                ${rowsHtml}
            </div>
            <div style="text-align:center; padding:10px; color:#999; font-size:12px; border-top:1px solid rgba(0,0,0,0.05);">
                Koko小手机 · 默契大挑战
            </div>
        </div>
    `;
    
    container.innerHTML = html;
}

// 10. 切换皮肤
window.switchCpSkin = function(skinName, btn) {
    document.querySelectorAll('.cp-skin-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    
    const area = document.getElementById('cp-capture-area');
    area.className = '';
    area.classList.add(`skin-${skinName}`);
}

// 11. 保存图片 (增强版)
document.getElementById('cp-save-img-btn').addEventListener('click', () => {
    const element = document.getElementById('cp-capture-area');
    
    // 给用户一个反馈
    const btn = document.getElementById('cp-save-img-btn');
    const originalText = btn.textContent;
    btn.textContent = "📸 正在生成...";
    btn.disabled = true;

    html2canvas(element, { 
        scale: 3, // ★ 提高清晰度，有助于捕捉阴影细节
        useCORS: true, 
        backgroundColor: null, // ★ 保持透明或原背景
        logging: false, // 关掉日志提升一点速度
        allowTaint: true // 允许跨域图片（配合 useCORS）
    }).then(canvas => {
        const link = document.createElement('a');
        link.download = `默契挑战_${Date.now()}.png`;
        link.href = canvas.toDataURL("image/png");
        link.click();
        
        // 恢复按钮
        btn.textContent = originalText;
        btn.disabled = false;
    }).catch(err => {
        console.error(err);
        alert("截图生成失败，请重试");
        btn.textContent = originalText;
        btn.disabled = false;
    });
});

document.getElementById('cp-retry-btn').addEventListener('click', () => {
    initCpGame();
});
// ==========================================================
// --- 题库功能 ---

// 保存当前问卷到题库
async function saveCurrentSurveyToLib() {
    if (!cpState.questions || cpState.questions.length === 0) return alert("当前没有题目可保存！");
    
    const name = await showCustomPrompt("收藏题库", "给这套题起个名字吧", cpState.title);
    if (!name) return;

    const surveyData = {
        id: `survey_${Date.now()}`,
        title: name,
        author: cpState.author || "我",
        // 只保存题目结构，不保存答案
        questions: cpState.questions.map(q => ({
            q: q.q,
            type: q.type,
            options: q.options
        })),
        timestamp: Date.now()
    };

    await kokoMemory.put('surveyLibrary', surveyData);
    alert("✅ 已保存到题库！");
}

// 打开题库弹窗
async function openSurveyLibraryModal() {
    const modal = document.getElementById('survey-library-modal');
    const list = document.getElementById('survey-lib-list');
    list.innerHTML = '';

    const surveys = await kokoMemory.getAll('surveyLibrary');
    
    if (surveys.length === 0) {
        list.innerHTML = '<p style="text-align:center; color:#999; padding:20px;">题库空空如也~</p>';
    } else {
        // 按时间倒序
        surveys.sort((a,b) => b.timestamp - a.timestamp).forEach(s => {
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.innerHTML = `
                <div class="preset-info" onclick="loadSurveyFromLib('${s.id}')">
                    <div class="preset-name">${s.title}</div>
                    <div class="preset-desc">${s.questions.length} 道题 · ${new Date(s.timestamp).toLocaleDateString()}</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn delete" onclick="deleteSurveyFromLib('${s.id}')"><i class="fas fa-trash-alt"></i></span>
                </div>
            `;
            list.appendChild(item);
        });
    }
    modal.style.display = 'flex';
}

// 删除题库
async function deleteSurveyFromLib(id) {
    if(confirm("确定删除这套题吗？")) {
        await kokoMemory.delete('surveyLibrary', id);
        openSurveyLibraryModal(); // 刷新
    }
}

// 加载题库并开始
async function loadSurveyFromLib(id) {
    const survey = await kokoMemory.get('surveyLibrary', id);
    if (!survey) return;

    cpState.title = survey.title;
    cpState.author = survey.author;
    // 初始化答题状态
    cpState.questions = survey.questions.map(q => ({
        ...q,
        userAns: "", aiAns: "", aiComment: ""
    }));
    cpState.currentIdx = 0;

    document.getElementById('survey-library-modal').style.display = 'none';
    renderCpQuestion();
    switchCpStep(2); // 直接跳到答题页
}
// --- 分享功能 (修复版：完整保存题目数据) ---
async function shareCpResultToChat() {
    const targetId = cpState.targetContactId;
    if (!targetId) return alert("数据丢失，请重新开始游戏。");
    
    const contact = state.contacts.find(c => c.id === targetId);
    if (!contact) return;

    // 1. 整理详细数据
    const details = cpState.questions.map(q => {
        // 计算高亮逻辑
        const isMatch = q.userAns === q.aiAns || q.userAns.includes(q.aiAns) || q.aiAns.includes(q.userAns);
        
        return {
            question: q.q,
            
            // ▼▼▼ 核心修复：完整保存题目元数据！ ▼▼▼
            type: q.type,       // 保存题目类型 (single/multiple/text)
            options: q.options, // 保存完整的选项列表！(不再丢弃)
            // ▲▲▲ 修复结束 ▲▲▲

            userAns: q.userAns, 
            aiAns: q.aiAns,     
            isMatch: isMatch    
        };
    });

    const shareContent = {
        title: cpState.title,
        total: cpState.questions.length,
        details: details
    };

    hideAllScreens();
    state.activeChatId = targetId; 
    
    await createAndAddMessage({ 
        type: 'cp_share', 
        content: shareContent 
    }, 'user', contact);
    
    openChat(targetId); 
}
// --- AI 邀请处理函数 ---
window.acceptAiSurvey = function(topic, contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    // 1. 跳转到游戏界面
    hideAllScreens();
    document.getElementById('compatibility-screen').style.display = 'flex';
    
    // 2. 初始化状态
    initCpGame(); // 重置
    selectCpTarget(contact); // 选中发起的 AI

    // 3. 自动填入主题并开始生成
    document.getElementById('cp-topic-input').value = topic;
    
    // 延迟一下，让用户看到界面切换，然后自动点击“生成”
    setTimeout(() => {
        document.getElementById('cp-start-btn').click();
    }, 500);
};
// =========== ▼▼▼ 漂流瓶核心功能 V3 (最终集成版) ▼▼▼ ======
// ==========================================================

let currentBottleData = null; 

// 1. 界面显示/隐藏
document.getElementById('open-drift-bottle-btn').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('drift-bottle-screen').style.display = 'flex';
});
document.getElementById('back-from-drift-bottle').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('investment-center-screen').style.display = 'flex';
});

// 2. 玩法 A：扔瓶子 (打开输入面板)
document.getElementById('throw-bottle-btn').addEventListener('click', () => {
    document.getElementById('throw-bottle-hint').value = '';
    document.getElementById('throw-bottle-content').value = '';
    document.getElementById('pick-bottle-input-area').classList.remove('active'); // 关掉另一个
    document.getElementById('throw-bottle-input-area').classList.add('active');
});
document.getElementById('cancel-throw-btn').addEventListener('click', () => {
    document.getElementById('throw-bottle-input-area').classList.remove('active');
});

// 3. 玩法 A 确认：扔出去 (触发生成)
document.getElementById('confirm-throw-btn').addEventListener('click', async () => {
    const hint = document.getElementById('throw-bottle-hint').value.trim();
    const content = document.getElementById('throw-bottle-content').value.trim();
    const relationType = document.getElementById('throw-relation').value;
    
    if (!content) return alert('瓶子里总得写点什么吧！');
    
    document.getElementById('throw-bottle-input-area').classList.remove('active');
    startBottleLoading('瓶子飘向了大海深处... 正在等待有缘人捡起...');

    try {
        // 调用核心生成函数
        const bottleData = await generateBottleProfile(hint, content, relationType);
        if (bottleData) {
            renderBottleCard(bottleData);
        } else {
            throw new Error("AI生成返回空");
        }
    } catch (e) {
        handleBottleError(e);
    }
});

// 4. 玩法 B：捡瓶子 (打开输入面板)
document.getElementById('pick-bottle-btn').addEventListener('click', async () => {
    console.log("点击了捡瓶子按钮"); //  如果点不动，F12看看有没有这句话
    
    // 清空输入
    document.getElementById('pick-bottle-hint').value = '';
    
    // 关掉扔瓶子的框
    document.getElementById('throw-bottle-input-area').classList.remove('active'); 
    
    // 打开捡瓶子的框 (注意这里改的是 .style.bottom 还是 class)
    // 为了稳妥，我们直接用 style 操作
    const pickArea = document.getElementById('pick-bottle-input-area');
    if(pickArea) {
        pickArea.classList.add('active');
        pickArea.style.bottom = "0"; // 强制显示
    } else {
        alert("HTML代码缺失：找不到 id='pick-bottle-input-area' 的元素！");
    }
});

document.getElementById('cancel-pick-btn').addEventListener('click', () => {
    const pickArea = document.getElementById('pick-bottle-input-area');
    pickArea.classList.remove('active');
    pickArea.style.bottom = "-300px"; // 强制隐藏
});
// 5. 玩法 B 确认：开始打捞
document.getElementById('confirm-pick-btn').addEventListener('click', async () => {
    const hint = document.getElementById('pick-bottle-hint').value.trim();
    const relationType = document.getElementById('pick-relation').value;

    document.getElementById('pick-bottle-input-area').classList.remove('active');
    startBottleLoading('正在海里打捞漂流瓶...');

    try {
        // 调用核心生成函数 (userMessage 为 null)
        const bottleData = await generateBottleProfile(hint, null, relationType);
        if (bottleData) {
            renderBottleCard(bottleData);
        } else {
            throw new Error("AI生成返回空");
        }
    } catch (e) {
        handleBottleError(e);
    }
});

// 辅助：显示加载
function startBottleLoading(text) {
    const modal = document.getElementById('bottle-content-modal');
    const loadingEl = document.getElementById('bottle-loading');
    const resultEl = document.getElementById('bottle-result');
    modal.style.display = 'flex';
    loadingEl.style.display = 'block';
    resultEl.style.display = 'none';
    loadingEl.querySelector('p').textContent = text;
}
// 辅助：处理错误
function handleBottleError(e) {
    console.error(e);
    alert("操作失败... (API错误或网络问题)");
    document.getElementById('bottle-content-modal').style.display = 'none';
}

// 6. 渲染瓶子卡片
function renderBottleCard(data) {
    currentBottleData = data;
    
    // 显示加载完成
    document.getElementById('bottle-loading').style.display = 'none';
    document.getElementById('bottle-result').style.display = 'block';

    document.getElementById('bottle-avatar').src = data.avatar || 'https://via.placeholder.com/80';
    document.getElementById('bottle-name').textContent = data.name;
    document.getElementById('bottle-location').textContent = `来自 ${data.nationality || '未知'} · ${data.age}岁`;
    
    // 如果有 user_msg (扔瓶子玩法)，显示互动
    if (data.user_msg) {
        document.getElementById('bottle-message-text').innerHTML = `
            <span style="color:#999; font-size:12px;">你扔出的瓶子：</span><br>“${data.user_msg}”<br><br>
            <span style="color:#333; font-weight:bold;">${data.name} 的回复：</span><br>“${data.reply_message}”
        `;
    } else {
        // 捡瓶子玩法
        document.getElementById('bottle-message-text').textContent = `“${data.opening_message}”`;
    }
    
    document.getElementById('bottle-bg-summary').textContent = data.background.substring(0, 30) + '...';
    document.getElementById('bottle-assets-summary').textContent = data.assets.substring(0, 20) + '...';
}

// 7. AI 生成核心函数 (V8 - 2000字深度扩写版)
async function generateBottleProfile(userHint, userMessage, relationType) {
    let taskDescription = "";
    if (userMessage) {
        taskDescription = `**[当前场景：用户扔了一个瓶子]**\n用户扔出的漂流瓶内容是：“${userMessage}”。\n请让生成的人物【捡到】这个瓶子，并根据TA的人设生成一段【回复】(字段名: reply_message)。回复要自然、符合TA的性格。`;
    } else {
        taskDescription = `**[当前场景：用户捡瓶子]**\n请生成一段该人物写在漂流瓶里的【留言】(字段名: opening_message)。内容可以是吐槽、许愿、讲笑话或无聊的哼哼。`;
    }

    let relationInstruction = "";
    if (relationType === 'connected') {
        relationInstruction = `**[⚠️ 核心要求：生成有背景故事的角色]**\n请生成一个与用户（我）有【既定人际关系】的角色（如旧识、宿命对手、暗恋对象）。必须在背景和人际关系中明确体现。`;
    } else {
        relationInstruction = `**[核心要求：生成陌生人]** 这是一个完全陌生的路人，与用户无交集。`;
    }

    const prompt = `[SYSTEM] 你是一个**殿堂级的小说家**和虚拟角色架构师。请根据用户的期望 "${userHint || ''}"，构建一个极度真实、细节丰满的人物。

${taskDescription}
${relationInstruction}

**[!!! 长度与深度核心指令 (Critical Length Instruction) !!!]**
用户要求这个角色必须拥有**史诗级**的详细设定。
**请不要使用简短的概括！**
你需要发挥你的文学创作能力，对于【背景经历】和【人际关系】这两个部分，请进行**大幅度的扩写**。
- **总字数目标**：所有设定加起来应接近 **2000字**。
- **描写手法**：使用小说式的笔触，描写细节、心理转折、具体事件、环境氛围，而不仅仅是列出事实。

**[核心设定模板]**
姓名：
国籍：
年龄：
身高：
样貌身材：(请进行不少于 100 字的细腻外貌描写，包括穿搭风格、气质、微表情习惯)
性格：(请进行深度心理侧写，包含MBTI、优缺点、隐藏的阴暗面或不为人知的一面)
**个性签名**：(微信/朋友圈风格，简短)

**[背景经历 (重点扩写区)]**
**要求**：请撰写一篇 **800字以上** 的人物小传。
内容应涵盖：原生家庭环境、童年关键事件、求学/职业生涯的转折点、曾经的情感创伤或高光时刻、目前的人生困境或目标。要写得像小说章节一样引人入胜。

**[资产状况]**
(各大银行和线上支付APP余额，是否有房车。**90%为普通人，10%为富豪**。请具体到消费习惯、财务焦虑或理财观念)

**[习惯和爱好]**
(具体到喜欢的书、电影、食物口味、独处时的小怪癖)

**[恋爱观与行为]**
(详细描述TA在亲密关系中的依恋类型、雷点、付出方式、性爱观念等)

**[人际关系设定 (世界书专用 - 重点扩写区)]**
请列出 3-5 个该角色的重要社会关系。
**【禁令】**：禁止出现除用户以外的任何前任。
**【扩写要求】**：对于每一个NPC，不要只写一行介绍。请为每个NPC写一段 **100-200字** 的小传，描述他们与主角发生的具体故事、恩怨情仇、相处模式。
格式示例：
- **李大山 (父亲, 55岁)**: [详细描述他与主角的复杂父子关系，具体到某次争吵或温情时刻...]

**[线上聊天风格]**
语言风格: (口语化/抽象/正经/玩笑)
Emoji习惯: (喜欢用的表情)
常态标点: (是否打句号/空格代替标点/连发问号等)
情绪反应: (烦躁/开心/难过/生气时的打字习惯)
安慰逻辑: (如果用户哭了，TA会怎么做)

**[输出格式]**
请严格只输出 JSON 格式，不要包含 markdown 标记：
{
  "name": "姓名",
  "nationality": "国籍",
  "age": "年龄",
  "height": "身高",
  "appearance": "样貌身材(细腻描写)",
  "personality": "性格(深度侧写)",
  "signature": "个性签名",
  "background": "背景经历(800字以上的人物小传)",
  "assets": "资产状况(详细)",
  "habits": "习惯和爱好(详细)",
  "love_view": "恋爱观(详细)",
  "love_behavior": "恋爱后行为(不可遗漏，详细)",
  "relationships_desc": "人际关系详细描述(每个NPC带小传，禁止前任)",
  "chat_style": {
      "style_desc": "语言风格",
      "punctuation": "常态标点习惯",
      "reaction_annoyed": "烦躁时会",
      "reaction_happy": "开心兴奋时可能",
      "reaction_sad": "难过时会",
      "reaction_angry": "生气时可能",
      "reaction_user_cry": "如果用户伤心了或哭了会"
  },
  "opening_message": "${userMessage ? '' : '漂流瓶留言'}", 
  "reply_message": "${userMessage ? '对用户瓶子的回复' : ''}",
  "user_msg": "${userMessage || ''}" 
}
`;

    // 增加 maxTokens 以防截断 (如果 API 支持)
    // 注意：有些模型可能不支持直接在 body 里传 max_tokens，如果不生效请检查 API 设置部分
    // 但这里我们主要靠 Prompt 催眠
    const response = await generateAiResponse(null, [], prompt, false, 'square'); 
    try {
        const jsonMatch = response.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            const data = JSON.parse(jsonMatch[0]);
            if (!data.avatar) {
                data.avatar = STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)];
            }
            data.user_msg = userMessage; 
            return data;
        }
    } catch (e) {
        console.error("JSON解析失败", e);
    }
    return null;
}

// 8. 扔回海里
document.getElementById('throw-back-btn').addEventListener('click', () => {
    document.getElementById('bottle-content-modal').style.display = 'none';
    currentBottleData = null;
    alert("你把瓶子扔回了海里。");
});

// 9. 打招呼 (V9 - 终极稳健版：防止字段丢失显示 undefined)
document.getElementById('reply-bottle-btn').addEventListener('click', async () => {
    if (!currentBottleData) return;
    
    const data = currentBottleData;
    
    // 1. 处理人际关系文本 (保持之前的智能解析)
    let relationsText = "";
    if (Array.isArray(data.relationships_desc)) {
        relationsText = data.relationships_desc.map(item => {
            if (typeof item === 'string') return item; 
            if (typeof item === 'object') {
                const name = item.name || item.Name || "未知";
                const relation = item.relation || item.relationship || "关系";
                const age = item.age ? `${item.age}岁 ` : "";
                const job = item.occupation || item.job || "";
                const desc = item.personality || item.description || "";
                return `- ${relation} (${name}) - ${age}${job}：${desc}`;
            }
            return "";
        }).join('\n');
    } else if (typeof data.relationships_desc === 'object' && data.relationships_desc !== null) {
        relationsText = JSON.stringify(data.relationships_desc, null, 2);
    } else {
        relationsText = data.relationships_desc || "无详细记录";
    }
    
    // 2. 构建世界书
    const worldBookContent = `
【姓名】${data.name}
【人际关系网】
${relationsText}

【详细背景经历】
${data.background || "（AI未生成背景详情）"}

【详细资产状况】
${data.assets || "（AI未生成资产详情）"}
`;
    
    const newBook = {
        id: 'book_' + Date.now(),
        name: `[档案] ${data.name}的人际与背景`, 
        category: '人物档案',
        content: worldBookContent
    };
    state.worldBooks.push(newBook);
    await kokoMemory.put('worldBooks', newBook);
    
    // ▼▼▼ 【核心修复：字段缺失保底】 ▼▼▼
    // 如果 love_behavior 没了，就显示一段默认文字，或者让它去参考恋爱观
    const loveBehaviorSafe = data.love_behavior || "（AI未具体描述恋爱后行为，请参考恋爱观）";
    const loveViewSafe = data.love_view || "（未知）";
    const habitsSafe = data.habits || "（未知）";
    const appearanceSafe = data.appearance || "（未知）";
    // ▲▲▲ 修复结束 ▲▲▲

    // 3. 构建 AI Prompt
    const personaPrompt = `
姓名：${data.name}
国籍：${data.nationality}
年龄：${data.age}
身高：${data.height}
样貌：${appearanceSafe}
性格：${data.personality}
个性签名：${data.signature || "无"}
习惯爱好：${habitsSafe}
恋爱观：${loveViewSafe}
恋爱后表现：${loveBehaviorSafe} 

[背景与人际关系]：请查阅关联的“世界书”条目。

# ！！！重要：线上聊天风格
语言风格: ${data.chat_style?.style_desc || "正常"}
标点习惯: ${data.chat_style?.punctuation || "正常"}
情绪反应:
- 烦躁: ${data.chat_style?.reaction_annoyed || "不耐烦"}
- 开心: ${data.chat_style?.reaction_happy || "发表情包"}
- 难过: ${data.chat_style?.reaction_sad || "沉默"}
- 生气: ${data.chat_style?.reaction_angry || "冷淡"}
- 安慰用户: ${data.chat_style?.reaction_user_cry || "温柔安慰"}
    `;

    // 4. 确定第一条消息
    let firstHistoryMsg = {};
    if (data.user_msg) {
        firstHistoryMsg = {
            id: `msg_${Date.now()}`,
            timestamp: Date.now(),
            sender: 'contact',
            type: 'text',
            content: `[捡到了你的漂流瓶："${data.user_msg}"] ${data.reply_message || "（微笑）"}`
        };
    } else {
        firstHistoryMsg = {
            id: `msg_${Date.now()}`,
            timestamp: Date.now(),
            sender: 'contact',
            type: 'text',
            content: data.opening_message || "你好。"
        };
    }

    // 5. 添加联系人
    const newContact = {
        id: 'contact_' + Date.now(),
        name: data.name,
        avatar: data.avatar,
        persona: personaPrompt,
        userPersona: '', 
        thoughtPreset: '',
        signature: data.signature || "这个家伙很懒，什么都没写", 
        worldBooks: [newBook.id], 
        history: [firstHistoryMsg],
        isPinned: false, diary: [], apiCallCounter: 0, gold_coins: 50,
        isNarrativeMode: false, blockedStatus: 'none', unreadCount: 1
    };
    
    state.contacts.push(newContact);
    await kokoMemory.put('contacts', newContact);
    
    await renderContacts();
    await renderWorldBooks();
    await updateWorldBookSelectors(); 
    
    document.getElementById('bottle-content-modal').style.display = 'none';
    alert(`已添加 ${data.name} 为好友！`);
    
    openChat(newContact.id);
});
// =========== ▲▲▲ 新增辅助函数结束 ▲▲▲ ===================
// ==========================================================
// (粘贴到 initApp 函数的前面)

// --- ✨ 收藏夹功能模块 V2 (按“收藏次序”分组) ✨ ---

/**
 * (V2) 显示收藏夹页面
 */
async function showFavoritesScreen() {
    hideAllScreens();
    document.getElementById('favorites-screen').style.display = 'flex';
    await renderFavoritesList(); // 调用新的渲染函数
}

/**
 * (V2 - 核心重写) 渲染收藏夹列表
 */
async function renderFavoritesList() {
    const listEl = document.getElementById('favorites-content-list');
    listEl.innerHTML = ''; // 清空旧内容
    const allFavoriteSessions = await kokoMemory.getAll('favorites');

    if (allFavoriteSessions.length === 0) {
        listEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-star" style="font-size: 48px; margin-bottom: 15px;"></i><p>你的收藏夹是空的。</p><p>在聊天时进入“编辑模式”来收藏消息吧！</p></div>`;
        return;
    }

    // 1. ✨ 核心逻辑：直接按收藏时间排序，最新的在最上面
    allFavoriteSessions.sort((a, b) => b.timestamp - a.timestamp);

    // 2. 遍历所有“收藏会话”，一个会话 = 一个卡片
    for (const session of allFavoriteSessions) {
        const contactInfo = session.contactProfile; // 获取快照
        const groupCard = document.createElement('div');
        groupCard.className = 'favorite-group-card';
        
        let itemsHTML = '';
        
        // 3. 遍历这个“会话”里的每一条消息
        for (const fav of session.messages) {
            const senderInfo = fav.senderProfile;
            const message = fav.message;
            let contentHTML = '';

            // --- (这里是我们上次修改的 V3 版消息渲染逻辑) ---
            switch(message.type) {
                case 'text':
                    let formattedContent = message.content.replace(/\n/g, '<br>');
                    formattedContent = formattedContent.replace(/\{(.*?)\}/g, '<span class="narrative-psychology">$1</span>');
                    formattedContent = formattedContent.replace(/(?:&quot;|“|”|＂)(.*?)(?:&quot;|“|”|＂)/g, '<span class="narrative-speech">“$1”</span>');
                    formattedContent = formattedContent.replace(/\*(.*?)\*/g, '<span class="narrative-action">$1</span>');
                    contentHTML = formattedContent;
                    break;
                case 'html':
                    contentHTML = message.content; // 直接渲染HTML
                    break;
                case 'picture_description':
                    contentHTML = `[图片] <i>${message.content.description}</i>`;
                    break;
                case 'voice':
                    contentHTML = `[语音] <i>“${message.content.text}”</i>`;
                    break;
                case 'image':
                case 'uploaded_image':
                    const imgUrl = message.type === 'image' ? message.url : message.content.base64;
                    contentHTML = `<img src="${imgUrl}" style="max-width: 150px; max-height: 150px; border-radius: 8px;">`;
                    break;
                case 'red_packet':
                    contentHTML = `[红包] <i>${message.content.blessing || '恭喜发财'}</i>`;
                    break;
                case 'transfer':
                    const transferData = message.content;
                    let status = '待处理';
                    if (transferData.returned) status = '已退还';
                    else if (transferData.completed) status = '已完成';
                    contentHTML = `[转账] <i>¥${transferData.amount} (${status})</i>`;
                    break;
                case 'music_share':
                    const music = message.content;
                    contentHTML = `[分享音乐] <i>${music.title} - ${music.artist || '未知艺术家'}</i>`;
                    break;
                case 'location_share':
                    const loc = message.content;
                    contentHTML = `[分享位置] <i class="${loc.icon || 'fas fa-map-marker-alt'}"></i> <i>${loc.name}</i>`;
                    break;
                case 'post_share':
                    contentHTML = `[分享的帖子] <i>(一条帖子分享)</i>`;
                    break;
                default:
                    contentHTML = `[${message.type} - 暂不支持预览]`;
            }
            // --- 渲染结束 ---
            
            itemsHTML += `
            <div class="favorite-item"> <div class="favorite-item-avatar">
                    <img src="${senderInfo.avatar}" alt="${senderInfo.name}">
                </div>
                <div class="favorite-item-content">
                    <div class="favorite-item-sender">${senderInfo.name}</div>
                    <div class="message-content">${contentHTML}</div>
                </div>
                </div>
            `;
        }

        // 4. ✨ 核心修改：构建卡片头部，包含删除按钮
        groupCard.innerHTML = `
        <div class="favorite-group-header">
            <img src="${contactInfo.avatar}" alt="${contactInfo.name}">
            <span class="name">来自 ${contactInfo.name} 的收藏</span>
            <span class="timestamp">${new Date(session.timestamp).toLocaleString()}</span>
            
            <span class="unfavorite-btn" data-session-id="${session.id}" title="删除此收藏组">
                <i class="fas fa-trash-alt"></i>
            </span>
        </div>
        <div class="favorite-items-container">
            ${itemsHTML}
        </div>
        `;
        listEl.appendChild(groupCard);
    }
}

/**
 * (V2 - 重命名) 删除一个收藏会话
 */
async function unfavoriteSession(sessionId) {
    const confirmed = await showCustomConfirm('删除收藏', '确定要删除这整组收藏记录吗？', true);
    if (confirmed) {
        await kokoMemory.delete('favorites', sessionId);
        await renderFavoritesList(); // 重新渲染列表
    }
}

/**
 * (V2 - 核心重写) 收藏选中的消息
 */
async function favoriteSelectedMessages() {
    const { selectedMessageIds } = editModeState;
    if (selectedMessageIds.size === 0) {
        return alert('请先选择要收藏的消息。');
    }

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    let collectedMessages = [];

    // ✨ 核心：先把选中的消息，按它们在聊天中的原始顺序排好
    const messagesToSave = Array.from(selectedMessageIds)
        .map(msgId => contact.history.find(m => m.id === msgId))
        .filter(Boolean) // 过滤掉没找到的消息
        .filter(msg => msg.type !== 'system_notification' && msg.sender !== 'system_instruction') // 过滤掉系统消息
        .sort((a, b) => a.timestamp - b.timestamp); // ✨ 关键：按原始时间戳排序

    if (messagesToSave.length === 0) {
        return alert('所选消息均无法收藏 (例如系统通知)。');
    }

    // 遍历排序后的消息，收集数据
    for (const message of messagesToSave) {
        let senderProfile;
        if (message.sender === 'user') {
            senderProfile = { id: 'myProfile', name: state.myProfile.name, avatar: state.myProfile.avatar };
        } else if (contact.isGroup) {
            const sender = state.contacts.find(c => c.id === message.sender);
            senderProfile = sender ? { id: sender.id, name: sender.name, avatar: sender.avatar } : { id: 'unknown', name: '未知成员', avatar: 'https://via.placeholder.com/40' };
        } else {
            senderProfile = { id: contact.id, name: contact.name, avatar: contact.avatar };
        }
        
        collectedMessages.push({
            message: JSON.parse(JSON.stringify(message)), // 存储消息的完整副本
            senderProfile: senderProfile // 存储发送者的快照
        });
    }

    // ✨ 核心：创建一个“收藏会话”对象，只包含这一个数组
    const newFavoriteSession = {
        id: `fav_session_${Date.now()}`,
        contactId: contact.id, // 仍然记录是谁的
        contactProfile: { name: contact.name, avatar: contact.avatar }, // 存一个快照，方便显示
        timestamp: Date.now(), // 收藏这个“会话”的时间
        messages: collectedMessages // 包含所有消息的数组
    };

    // ✨ 核心：只向数据库添加这一个对象
    await kokoMemory.put('favorites', newFavoriteSession);
    
    alert(`成功收藏了 ${collectedMessages.length} 条消息！`);
    await exitEditMode(); // 收藏后自动退出编辑模式
}
// --- ✨ 收藏夹功能模块 V2 结束 ✨ ---
// (粘贴到 initApp 函数的 *上方*)

// ==========================================================
// =========== ▼▼▼ 新增：外观设置实时预览模块 ▼▼▼ ==========
// ==========================================================

/**
 * (新) 预览框的基础HTML结构
 * 这里包含了预览用的假气泡和按钮，以及用于接收CSS注入的<style>标签
 */
function getBasePreviewHTML() {
    // 关键：我们从主文档中“偷”出默认的叙事样式，作为预览框的基底
    const defaultNarrativeCSS = `
        .narrative-speech {
            background-color: #e6f5c9; padding: 2px 8px; border-radius: 8px; display: inline-block; margin: 1px 0;
        }
        .narrative-psychology {
            text-decoration: none; background-color: #e6f5c9; color: #66bb6a; padding: 2px 6px; border-radius: 6px; font-style: normal;
        }
        .narrative-action {
            font-style: normal; color: #517655;
        }
    `;

    return `
    <head>
        <style id="preview-style-base">
            body { margin: 0; padding: 10px; font-family: 'Nunito', sans-serif; transition: all 0.2s; background-color: #f0f2f5; background-size: cover; background-position: center; }
            .msg-wrapper { display: flex; margin-bottom: 8px; max-width: 80%; }
            .msg-wrapper.sent { margin-left: auto; flex-direction: row-reverse; }
            .avatar { width: 30px; height: 30px; border-radius: 4px; background: #ddd; margin: 0 5px; flex-shrink: 0; }
            .message { padding: 8px 12px; border-radius: 12px; word-break: break-word; }
            .message.received { background: #fff; border-top-left-radius: 4px; }
            .message.sent { background: var(--sent-message-bg, #e6f5c9); color: var(--text-dark, #424242); border-top-right-radius: 4px; }
            .theme-button { padding: 6px 12px; border-radius: 6px; border: none; font-weight: 600; cursor: pointer; background: var(--theme-primary, #81c784); color: var(--text-on-primary, #fff); }
        </style>
        <style id="preview-style-theme"></style>
        <style id="preview-style-bubbles"></style>
        <style id="preview-style-narrative">${defaultNarrativeCSS}</style>
        <style id="preview-style-font"></style>
        <style id="preview-style-fontsize"></style>
    </head>
    <body>
        <div class="msg-wrapper received">
            <div class="avatar"></div>
            <div class="message received">
                这是收到的消息气泡预览。
            </div>
        </div>
        <div class="msg-wrapper sent">
            <div class="avatar"></div>
            <div class="message sent">
                这是发送的消息气泡预览。
            </div>
        </div>
        <div class="msg-wrapper received">
            <div class="avatar"></div>
            <div class="message received">
                <span class="narrative-action">*这是叙事动作*</span> <span class="narrative-speech">“这是叙事对话”</span> <span class="narrative-psychology">{这是叙事心理}</span>
            </div>
        </div>
        <button class="theme-button">
            主题色按钮
        </button>
    </body>
    `;
}

/**
 * (新) 初始化预览框，写入基础HTML
 */
function initializePreviewFrame() {
    const iframe = document.getElementById('appearance-preview-frame');
    if (!iframe) return;
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    doc.open();
    doc.write(getBasePreviewHTML());
    doc.close();
}

/**
 * (新) 从输入框加载当前设置，并更新到预览框
 */
function loadPreviewFromInputs() {
    // 此函数用于页面打开时，加载一次已保存的设置
    updatePreview('background', userSettings.chatBackground);
    updatePreview('theme', userSettings.customThemeCss);
    updatePreview('bubble', userSettings.customBubbleCss);
    updatePreview('narrative', userSettings.customNarrativeCss);
    updatePreview('fontsize', userSettings.customFontSize);
    updatePreview('font', userSettings.customFontName, userSettings.customFontUrl);
}

/**
 * (新) 实时更新预览框的样式
 * type: 'background', 'theme', 'bubble', 'narrative', 'font', 'fontsize'
 */
function updatePreview(type, value, value2 = '') {
    const iframe = document.getElementById('appearance-preview-frame');
    if (!iframe) return;
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    if (!doc.body) return; // 确保iframe已加载

    switch (type) {
        case 'background':
            doc.body.style.backgroundImage = value ? `url(${value})` : 'none';
            break;
        case 'theme':
            doc.getElementById('preview-style-theme').textContent = value;
            break;
        case 'bubble':
            doc.getElementById('preview-style-bubbles').textContent = value;
            break;
        case 'narrative':
            const narrativeStyleTag = doc.getElementById('preview-style-narrative');
            if (value.trim()) {
                narrativeStyleTag.textContent = value; // 应用用户的CSS
            } else {
                narrativeStyleTag.textContent = getBasePreviewHTML().match(/<style id="preview-style-narrative">([\s\S]*?)<\/style>/)[1]; // 恢复默认
            }
            break;
        case 'font':
            const fontStyleTag = doc.getElementById('preview-style-font');
            const fontName = value; // value1 is name
            const fontUrl = value2; // value2 is url
            if (fontUrl && fontName) {
                fontStyleTag.textContent = `
                    @font-face {
                        font-family: '${fontName}';
                        src: url('${fontUrl}');
                    }
                `;
                doc.body.style.fontFamily = `'${fontName}', 'Nunito', sans-serif`;
            } else {
                fontStyleTag.textContent = '';
                doc.body.style.fontFamily = `'Nunito', sans-serif`;
            }
            break;
        case 'fontsize':
            const sizeStyleTag = doc.getElementById('preview-style-fontsize');
            if (value && !isNaN(value) && value >= 12) {
                sizeStyleTag.textContent = `
                    body, .message, .theme-button {
                        font-size: ${value}px !important;
                    }
                `;
            } else {
                sizeStyleTag.textContent = '';
            }
            break;
    }
}

// ==========================================================
// =========== ▲▲▲ 实时预览模块结束 ▲▲▲ ===================
// ==========================================================
// ▲▲▲ 粘贴到这里结束 ▲▲▲
        async function initApp() {
            await kokoMemory.init();
            await loadSnoopDataCache();
            await loadDataFromDB();
            await loadAppearanceSettings();
            await renderMyProfile(); 
            await renderContacts(); 
            await renderWorldBooks(); 
            await updateWorldBookSelectors(); 
            await renderUserPersonaPresets();
            await renderThoughtPresets();
            updateNotificationDots();
            renderAttachmentMenu();
            if (state.posts.length === 0 && isInitialPostLoad) {
                await showFeedScreen();
            }
            await showMainScreen();
            // 启动空间自动刷新（如果已开启）
if (userSettings.qzoneSettings && userSettings.qzoneSettings.autoRefreshEnabled) {
    startQzoneAutoRefresh();
}
            // ▼▼▼ 在函数的最后，添加这两行代码 ▼▼▼
            if (state.automationSettings.isEnabled) {
                startAutomationTimer();
            }
            showLockScreen();
            // ▲▲▲ 新代码添加结束 ▲▲▲
        }

        // (替换原有的 renderPet 函数)
async function renderPet(contact) {
    const container = document.getElementById('pet-container-wrapper');
    if (!contact) {
        container.innerHTML = '';
        return;
    }

    if (!contact.pet) {
        container.innerHTML = `
            <div id="pet-container">
                <div class="pet-header" style="justify-content:center;">我们的小窝</div>
                <button class="form-button" id="adopt-pet-btn">领养一只史莱姆</button>
            </div>`;
        return;
    }
    
    const now = Date.now();

    // --- 🛠️ 修复：防止打黑工逻辑 ---
    // 检查：如果有打工结束时间，且当前时间已经超过了结束时间
    if (contact.pet.workFinishTimestamp && now >= contact.pet.workFinishTimestamp) {
        // 1. 结算奖励
        contact.gold_coins += 50;
        // 2. 清除打工标记
        contact.pet.workFinishTimestamp = null;
        // 3. 保存数据
        await kokoMemory.put('contacts', contact);
        // 4. 发个通知告诉用户（可选）
        await createSystemNotification(`史莱姆打工结束，补发工资 +50金币！`, contact);
    }
    // --- 修复结束 ---

    // 属性自然衰减逻辑
    const elapsedHours = (now - contact.pet.lastUpdated) / (1000 * 60 * 60);
    const decayAmount = Math.floor(elapsedHours * 5); 
    
    if (decayAmount > 0) {
        contact.pet.hunger = Math.max(0, contact.pet.hunger - decayAmount);
        contact.pet.happiness = Math.max(0, contact.pet.happiness - decayAmount);
        contact.pet.cleanliness = Math.max(0, contact.pet.cleanliness - decayAmount);
        contact.pet.lastUpdated = now;
        kokoMemory.put('contacts', contact); // 异步保存，不阻塞渲染
    }

    let isWorking = false;
    let workCooldownText = '';
    if (contact.pet.workFinishTimestamp && now < contact.pet.workFinishTimestamp) {
        isWorking = true;
        const remainingMinutes = Math.ceil((contact.pet.workFinishTimestamp - now) / (1000 * 60));
        workCooldownText = `工作中... (${remainingMinutes}分)`;
    }

    container.innerHTML = `
        <div id="pet-container">
            <div class="pet-header">
                <span id="pet-name">${contact.pet.name} (LV.${contact.pet.level})</span>
                <span id="pet-gold-display">💰 ${contact.gold_coins}</span>
            </div>
            <div class="pet-visual-area">
                <div>
                    <div class="slime">
                        <div class="blush left"></div>
                        <div class="blush right"></div>
                    </div>
                    <div class="slime-shadow"></div>
                </div>
            </div>
            <div class="pet-stats">
                <div class="stat-bar-container" title="经验值: ${contact.pet.xp} / 100">
                    <span class="stat-bar-label">成长</span>
                    <div class="stat-bar"><div id="xp-bar" class="stat-bar-inner" style="background-color: #ffcc80;"></div></div>
                </div>
                <div class="stat-bar-container">
                    <span class="stat-bar-label">饱食度</span>
                    <div class="stat-bar"><div id="hunger-bar" class="stat-bar-inner"></div></div>
                </div>
                <div class="stat-bar-container">
                    <span class="stat-bar-label">开心值</span>
                    <div class="stat-bar"><div id="happiness-bar" class="stat-bar-inner"></div></div>
                </div>
                 <div class="stat-bar-container">
                    <span class="stat-bar-label">清洁度</span>
                    <div class="stat-bar"><div id="cleanliness-bar" class="stat-bar-inner"></div></div>
                </div>
            </div>
            <div class="pet-actions">
                <button id="feed-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>喂食 (-5💰)</button>
                <button id="play-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>玩耍</button>
                <button id="clean-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>清洁</button>
                <button id="work-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>${isWorking ? workCooldownText : '打工 (1小时)'}</button>
            </div>
        </div>`;
    
    document.getElementById('xp-bar').style.width = `${contact.pet.xp}%`;
    document.getElementById('hunger-bar').style.width = `${contact.pet.hunger}%`;
    document.getElementById('happiness-bar').style.width = `${contact.pet.happiness}%`;
    document.getElementById('cleanliness-bar').style.width = `${contact.pet.cleanliness}%`;

    const slimeEl = container.querySelector('.slime');
    slimeEl.className = 'slime'; 
    if (contact.pet.form) {
        slimeEl.classList.add(`${contact.pet.form}-form`);
    }
    if (contact.pet.hunger < 40) slimeEl.classList.add('hungry');
    if (contact.pet.cleanliness < 40) slimeEl.classList.add('dirty');
}

        function updateChatPetVisuals(contact) {
            const chatPetEl = document.querySelector('#chat-pet-container .slime');
            if (!chatPetEl || !contact || !contact.pet) return;
            
            chatPetEl.className = 'slime'; 
            if (contact.pet.form) {
                chatPetEl.classList.add(`${contact.pet.form}-form`);
            }
            if (contact.pet.hunger < 40) chatPetEl.classList.add('hungry');
            if (contact.pet.cleanliness < 40) chatPetEl.classList.add('dirty');
        }


        async function updatePetStats(stat, value, contact, isCharAction = false) {
            if (!contact || !contact.pet) return;
            contact.pet[stat] = Math.min(100, Math.max(0, contact.pet[stat] + value));
            if (!isCharAction) {
                contact.pet.lastUpdated = Date.now();
            }
            await kokoMemory.put('contacts', contact);
        }

        function findMentionsInComment(comment) {
            const mentionedContacts = new Set();
            if (!comment || !comment.content) return [];
            
            const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
            let match;

            while ((match = mentionRegex.exec(comment.content)) !== null) {
                const username = match[1];
                const contact = state.contacts.find(c => c.name === username);
                if (contact) {
                    mentionedContacts.add(contact);
                }
            }
            return Array.from(mentionedContacts);
        }
        
        function handleAvatarUpload(callback) {
            const uploader = document.getElementById('avatar-uploader');
            uploader.click();

            uploader.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                if (file.size > 2 * 1024 * 1024) {
                    alert('图片太大了！请选择一张小于 2MB 的图片。');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(event) {
                    const base64String = event.target.result;
                    callback(base64String);
                };
                
                reader.readAsDataURL(file);
                e.target.value = ''; 
            };
        }
        // 用这个新版本 替换掉 旧的 attachGroupSettingsListeners 函数
function attachGroupSettingsListeners() {
    // 用下面这行正确的代码替换它
document.getElementById('back-from-group-settings').addEventListener('click', () => {
    // 首先隐藏当前的设置屏幕
    document.getElementById('group-settings-screen').style.display = 'none';
    // 然后重新打开当前激活的聊天窗口（也就是你刚才所在的群聊）
    openChat(state.activeChatId); 
});
    
    // ▼▼▼ 新增：为“用户面具预设”下拉框添加功能 ▼▼▼
    document.getElementById('group-select-user-persona-preset').addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('group-user-mask-textarea').value = preset ? preset.description : '';
    });

    // ▼▼▼ 新增：为全新的“保存”按钮添加功能 ▼▼▼
    document.getElementById('save-group-settings-btn').addEventListener('click', async () => {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;

        // 读取所有设置项的当前值
        group.userPersona = document.getElementById('group-user-mask-textarea').value.trim();
        group.memoryShared = document.getElementById('group-memory-share-toggle').checked;
        group.isTimeAware = document.getElementById('group-time-awareness-toggle').checked;
        group.worldBooks = Array.from(document.querySelectorAll('#group-world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);

        // 保存到数据库
        await kokoMemory.put('contacts', group);
        alert('群聊设置已保存！');
        showCharProfileScreen(); // 保存后返回上一页
    });

    // 解散群聊 (不变)
    document.getElementById('disband-group-btn').addEventListener('click', async () => {
        // ... 这部分代码和之前完全一样，不用动 ...
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;
        const confirmed = await showCustomConfirm('确认操作', `确定要解散群聊“${group.name}”吗？\n此操作会删除群聊及所有聊天记录，无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== group.id);
            await kokoMemory.delete('contacts', group.id);
            state.activeChatId = null;
            alert('群聊已解散。');
            await showMainScreen();
        }
    });
}
        // --- NEW: V7.0 开始/停止听歌计时器 ---
        function startListenTimeTracker() {
            if (listenTimeInterval) clearInterval(listenTimeInterval); // 清除旧的计时器
            
            listenTimeInterval = setInterval(async () => {
                const contact = state.contacts.find(c => c.id === state.activeChatId);
                if (contact && !globalAudioPlayer.paused) {
                    contact.totalListenTime += 1; // 每秒加1
                    // 为避免频繁写数据库，可以设计成每10秒或30秒保存一次
                    if (contact.totalListenTime % 30 === 0) {
                        await kokoMemory.put('contacts', contact);
                    }
                }
            }, 1000);
        }

        async function stopListenTimeTracker() {
            clearInterval(listenTimeInterval);
            listenTimeInterval = null;
            // 停止时，确保最后的数据被保存
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if(contact) {
                await kokoMemory.put('contacts', contact);
            }
        }

// 把这段新代码，粘贴到 attachEventListeners 函数的【内部】

// --- 新增：打开“添加群成员”弹窗的逻辑 ---
function openAddGroupMemberModal(group) {
    const modal = document.getElementById('add-group-member-modal');
    const memberListEl = document.getElementById('add-member-picker-list');
    memberListEl.innerHTML = '';

    // 筛选出还不是群成员的联系人
    const availableContacts = state.contacts.filter(c => !c.isGroup && !group.members.includes(c.id));

    if (availableContacts.length === 0) {
        memberListEl.innerHTML = '<p style="color: #888; text-align: center;">没有其他可以添加的联系人了。</p>';
    } else {
        availableContacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="checkbox" id="add-member-check-${contact.id}" value="${contact.id}">
                <label for="add-member-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                    <span>${contact.name}</span>
                </label>
            `;
            memberListEl.appendChild(item);
        });
    }

    modal.style.display = 'flex';
    
    // 为确认按钮绑定一次性事件
    const confirmBtn = document.getElementById('confirm-add-group-members-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    
    newConfirmBtn.addEventListener('click', async () => {
        const selectedIds = Array.from(document.querySelectorAll('#add-member-picker-list input:checked')).map(input => input.value);
        if (selectedIds.length === 0) {
            return;
        }

        const addedMemberNames = selectedIds.map(id => state.contacts.find(c => c.id === id)?.name).filter(Boolean);

        // 更新群成员列表
        group.members.push(...selectedIds);
        await kokoMemory.put('contacts', group);

        // 在群聊中发送系统通知
        const tempActiveChatId = state.activeChatId;
        state.activeChatId = group.id;
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `你邀请 "${addedMemberNames.join('", "')}" 加入了群聊`
        });
        state.activeChatId = tempActiveChatId;

        modal.style.display = 'none';
        openGroupSettingsScreen(group); // 刷新设置页面
    });
}

// --- 新增：为群聊设置页面的各种按钮绑定事件 ---
document.getElementById('group-settings-screen').addEventListener('click', async (e) => {
    const group = state.contacts.find(c => c.id === state.activeChatId);
    if (!group) return;

    // 处理“添加成员”按钮点击
    if (e.target.closest('#add-group-member-btn')) {
        openAddGroupMemberModal(group);
    }
    
// 处理“移出成员”按钮点击 (彻底清理版)
    const removeButton = e.target.closest('.remove-member-btn');
    if (removeButton) {
        const memberId = removeButton.dataset.memberId;
        
        // 1. 查找成员信息 (用于显示名字)
        let memberName = "成员";
        let member = state.contacts.find(c => c.id === memberId);
        if (!member && group.npcMembers) {
            member = group.npcMembers.find(n => n.id === memberId);
        }
        if (member) memberName = member.name;

        // 2. 确认弹窗
        const confirmed = await showCustomConfirm('移出成员', `确定要将 "${memberName}" 移出群聊吗？\n(这将同时从群关系网中删除该角色)`, true);
        
        if (confirmed) {
            // --- UI 动画效果 ---
            const itemRow = removeButton.closest('.contact-picker-item');
            if (itemRow) {
                itemRow.style.transition = "all 0.3s ease";
                itemRow.style.opacity = "0";
                itemRow.style.transform = "translateX(20px)";
                setTimeout(() => itemRow.remove(), 300);
            }
            const countEl = document.getElementById('group-member-count');
            if (countEl) {
                const currentCount = parseInt(countEl.textContent) || 0;
                countEl.textContent = Math.max(0, currentCount - 1);
            }

            // --- 核心数据清理 ---

            // A. 从“聊天成员列表”中移除
            group.members = group.members.filter(id => id !== memberId);
            
            // B. 从“禁言列表”中移除
            if (group.mutedMembers) {
                group.mutedMembers = group.mutedMembers.filter(id => id !== memberId);
            }

            // C. 【关键修复】如果是 NPC，从“NPC花名册”中彻底删除
            // 这样它就不会赖在后台占位置了
            if (group.npcMembers) {
                group.npcMembers = group.npcMembers.filter(n => n.id !== memberId);
            }

            // D. 【关键修复】同步清理“关系网数据”
            // 打开群聊的关系网数据库
            const networkData = await kokoMemory.get('relationshipNetworks', group.id);
            if (networkData) {
                let changed = false;
                
                // 1. 删节点
                if (networkData.nodes.some(n => n.id === memberId)) {
                    networkData.nodes = networkData.nodes.filter(n => n.id !== memberId);
                    changed = true;
                }
                
                // 2. 删连线 (任何连向他，或者他连出去的线)
                if (networkData.edges.some(e => e.source === memberId || e.target === memberId)) {
                    networkData.edges = networkData.edges.filter(e => e.source !== memberId && e.target !== memberId);
                    changed = true;
                }

                // 只有真的删了东西才保存，节省性能
                if (changed) {
                    await kokoMemory.put('relationshipNetworks', networkData);
                    console.log(`已同步从关系网中移除: ${memberName}`);
                }
            }

            // --- 保存并通知 ---
            await kokoMemory.put('contacts', group);
            
            const tempActiveChatId = state.activeChatId;
            state.activeChatId = group.id;
            await createAndAddMessage({
                type: 'system_notification',
                sender: 'system',
                content: `你将 "${memberName}" 移出了群聊`
            });
            state.activeChatId = tempActiveChatId;

            // 重新渲染设置页
            setTimeout(() => {
                openGroupSettingsScreen(group); 
            }, 300);
        }
    }
    // ==========================================================
// ▼▼▼ 请将这段【新代码】粘贴到这里 ▼▼▼
// ==========================================================
const muteButton = e.target.closest('.mute-member-btn');
if (muteButton) {
    const memberId = muteButton.dataset.memberId;

    // 确保禁言列表存在
    group.mutedMembers = group.mutedMembers || [];

    const memberIndex = group.mutedMembers.indexOf(memberId);

    // 核心：切换禁言状态
    if (memberIndex > -1) {
        // 如果已经在列表里，就解除禁言
        group.mutedMembers.splice(memberIndex, 1);
    } else {
        // 如果不在列表里，就加入禁言
        group.mutedMembers.push(memberId);
    }

    // 保存更新后的群聊数据
    await kokoMemory.put('contacts', group);

    // 关键一步：重新渲染整个设置页面来立即更新UI
    openGroupSettingsScreen(group);
}
// ==========================================================
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ==========================================================
// ▼▼▼ 在这个事件监听器的末尾，添加我们新的逻辑 ▼▼▼
    if (e.target.id === 'clear-group-chat-history-btn' || e.target.closest('#clear-group-chat-history-btn')) {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;

        // 弹出确认框，防止误操作
        const confirmed = await showCustomConfirm(
            '清空记录', 
            `确定要清空群聊“${group.name}”的所有聊天记录吗？\n此操作不可恢复。`, 
            true // true表示这是一个危险操作，确认按钮会是红色
        );

        if (confirmed) {
            // 核心操作：清空 history 数组
            group.history = [];
            
            // 保存更改到数据库
            await kokoMemory.put('contacts', group);
            
            alert('群聊记录已清空。');
            
            // 操作完成后，关闭设置页面，并重新打开聊天窗口，用户就能看到空空如也的聊天界面了
            document.getElementById('group-settings-screen').style.display = 'none';
            openChat(group.id);
        }
    }
});

// --- 新增：为“添加成员”弹窗的关闭按钮绑定事件 ---
document.getElementById('close-add-group-member-modal').addEventListener('click', () => {
    document.getElementById('add-group-member-modal').style.display = 'none';
});
// ==========================================================
    // =========== ▼▼▼ 购物中心功能逻辑 V3 (预加载版) ▼▼▼ ===
    // ==========================================================
    let activeShoppingTab = 'taobao'; // 默认选中的标签页
    let currentProductData = {}; // 用于暂存当前要操作的商品信息

    // 函数：显示商品详情页面
    function showProductDetailScreen(productData) {
        currentProductData = productData; // 将当前商品信息存入全局，方便分享
        hideAllScreens();
        const detailScreen = document.getElementById('product-detail-screen');
        const mainInfoEl = document.getElementById('product-main-info');
        const commentsListEl = document.getElementById('buyer-comments-list');
        
        // 填充商品核心信息
        mainInfoEl.innerHTML = `
            <h1 style="font-size: 20px; font-weight: 700; margin-bottom: 10px;">${productData.name}</h1>
            <div class="product-price" style="font-size: 24px; margin-bottom: 10px;"><span>¥</span>${productData.price}</div>
            <div class="product-shop" style="margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee;">${productData.shop}</div>
            <div class="product-description">${productData.description.replace(/\n/g, '<br>')}</div>
        `;

        // 渲染预先加载好的评论
        commentsListEl.innerHTML = '';
        if (productData.comments && productData.comments.length > 0) {
            // 这是修复后的新代码块
productData.comments.forEach(comment => {
    const commentEl = document.createElement('div');
    commentEl.className = 'post-comment-item'; // 复用论坛评论样式
    commentEl.innerHTML = `
        <div style="display: flex; gap: 10px;">
            <img src="${STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]}" style="width: 35px; height: 35px; border-radius: 50%;">
            <div style="flex-grow: 1;">
                <span class="comment-author">${comment.username}</span>
                <div class="comment-content">${comment.content}</div>
            </div>
        </div>
    `;
    commentsListEl.appendChild(commentEl);
});
        } else {
            commentsListEl.innerHTML = `<div style="text-align: center; color: #999; padding: 20px;">暂无评价</div>`;
        }
        
        detailScreen.style.display = 'flex';
    }

    // 函数：显示购物中心页面
    async function showShoppingScreen() {
        hideAllScreens();
        document.getElementById('shopping-screen').style.display = 'flex';
        activeShoppingTab = 'taobao';
        renderShoppingTabs();
        
        const savedProducts = await kokoMemory.get('userSettings', 'shopping_products_' + activeShoppingTab);
        if (savedProducts && savedProducts.data.length > 0) {
            renderProducts(savedProducts.data);
        } else {
            const productList = document.getElementById('product-list');
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">这里空空如也~<br>请点击右上角的刷新按钮生成商品</div>`;
        }
    }

    // 函数：渲染顶部的标签页
    async function renderShoppingTabs() {
        const tabsContainer = document.getElementById('shopping-tabs-container');
        tabsContainer.innerHTML = `
            <button class="feed-tab-btn ${activeShoppingTab === 'taobao' ? 'active' : ''}" data-tab="taobao">🍑宝</button>
            <button class="feed-tab-btn ${activeShoppingTab === 'meituan' ? 'active' : ''}" data-tab="meituan">丑团</button>
            <button class="feed-tab-btn ${activeShoppingTab === 'pinduoduo' ? 'active' : ''}" data-tab="pinduoduo">拼夕夕</button>
        `;
    }
    
    // 函数：创建单个商品卡片的HTML元素
    function createProductItem(product) {
        const item = document.createElement('div');
        item.className = 'product-item';
        item.dataset.product = JSON.stringify(product); 

        item.innerHTML = `
            <div class="product-details">
                <div class="product-title">${product.name}</div>
                <div class="product-description">${product.description}</div>
                <div class="product-shop">${product.shop}</div>
                <div class="product-footer">
                    <div class="product-price"><span>¥</span>${product.price}</div>
                    <button class="product-share-btn" title="分享给...">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        `;
        return item;
    }

    // 函数：将AI生成的商品渲染到页面上
    function renderProducts(products) {
        const productList = document.getElementById('product-list');
        productList.innerHTML = ''; 
        if (products.length === 0) {
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">AI没有生成任何商品，请再试一次。</div>`;
            return;
        }
        products.forEach(p => {
            const productElement = createProductItem(p);
            productList.appendChild(productElement);
        });
    }
    
    // 函数：调用AI刷新或搜索商品 (V3核心改动：一次性生成所有信息)
    async function refreshProductsAI(isSearch = false) {
        const productList = document.getElementById('product-list');
        productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-spinner fa-spin" style="font-size: 24px;"></i><p style="margin-top: 10px;">AI正在生成包含详情和评论的商品...</p></div>`;

        const platformStyles = {
            taobao: "高端、昂贵、有品牌调性",
            pinduoduo: "价格非常低廉、极具性价比、充满“百亿补贴”风格",
            meituan: "看起来很美味的菜品、套餐或饮品"
        };
        const platformName = {
            taobao: "淘宝",
            pinduoduo: "拼多多",
            meituan: "美团外卖"
        };

        const keyword = document.getElementById('product-search-input').value.trim();
        const coreTask = (isSearch && keyword) 
            ? `请根据关键词“[${keyword}]”，为[${platformName[activeShoppingTab]}]平台生成5个相关的、风格为[${platformStyles[activeShoppingTab]}]的商品。`
            : `请为[${platformName[activeShoppingTab]}]平台生成5个随机的、风格为[${platformStyles[activeShoppingTab]}]的商品。`;

        const prompt = `${coreTask}对于每个商品，都必须严格遵循以下格式块，并重复5次：
PRODUCT_START
名称：...
价格：...
店铺：...
商品描述：(20-40字的生动描述)
--COMMENTS--
(在这里为该商品生成3条风格各异的买家评论，每条评论都使用 '用户名：... | 评论内容：...' 的格式并换行)
PRODUCT_END`;
        
        try {
            const rawResponse = await generateAiResponse(null, [], prompt, false, 'square');
            const productBlocks = rawResponse.split('PRODUCT_END');
            const products = productBlocks.map(block => {
                if (!block.includes('PRODUCT_START')) return null;

                const nameMatch = block.match(/名称：(.*?)\n/);
                const priceMatch = block.match(/价格：(.*?)\n/);
                const shopMatch = block.match(/店铺：(.*?)\n/);
                const descMatch = block.match(/商品描述：(.*?)\n/);
                
                const commentsBlock = block.split('--COMMENTS--')[1] || '';
                const commentLines = commentsBlock.trim().split('\n');
                // 这是修复后的新代码块
const comments = commentLines.map(line => {
    const parts = line.split('|');
    if (parts.length < 2) return null; // 必须要有'|'分隔符

    // 智能地清理前后缀，无论AI给没给，都能正确提取
    const username = parts[0].replace('用户名：', '').trim();
    const content = parts[1].replace('评论内容：', '').trim();
    
    // 确保提取后内容不为空
    if (!username || !content) return null; 

    return { username: username, content: content };
}).filter(Boolean);

                return {
                    name: nameMatch ? nameMatch[1].trim() : '未知商品',
                    price: priceMatch ? priceMatch[1].trim() : '0.00',
                    shop: shopMatch ? shopMatch[1].trim() : '官方旗舰店',
                    description: descMatch ? descMatch[1].trim() : '一件很棒的商品。',
                    comments: comments,
                    platform: activeShoppingTab
                };
            }).filter(Boolean);

            await kokoMemory.put('userSettings', { id: 'shopping_products_' + activeShoppingTab, data: products });
            renderProducts(products);

        } catch (error) {
            console.error("AI商品生成失败:", error);
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: var(--soft-red);">商品生成失败，请检查API设置或网络。</div>`;
        }
    }

    // 函数：打开分享弹窗
    function openShareProductModal(product) {
    currentProductData = product;
    const modal = document.getElementById('share-product-modal');
    const infoEl = document.getElementById('share-product-info');
    const recipientListEl = document.getElementById('share-product-recipient-list');
    
    document.getElementById('share-product-message-input').value = '';
    infoEl.innerHTML = `即将分享: <strong>${product.name}</strong><br><span style="color: #888;">价格: ¥${product.price}</span>`;
    
    // ▼▼▼ 核心新增逻辑 ▼▼▼
    recipientListEl.innerHTML = ''; // 先清空旧列表
    state.contacts.forEach(contact => {
        if (contact.isGroup) return; // 不允许分享到群聊
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        // 使用 radio 按钮确保一次只能选一个人
        item.innerHTML = `
            <input type="radio" id="share-recipient-${contact.id}" name="share-recipient" value="${contact.id}">
            <label for="share-recipient-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                <span>${contact.name}</span>
            </label>
        `;
        recipientListEl.appendChild(item);
    });
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    modal.style.display = 'flex';
}
    
    // 注意：函数参数发生了变化
async function handleShareProduct(intent, contactId) { 
    // 使用传入的 contactId 查找联系人
    const contact = state.contacts.find(c => c.id === contactId); 
    if (!contact) {
        // 理论上这里不会再报错，但保留以防万一
        alert('错误：选择的联系人无效！'); 
        return;
    }
    const message = document.getElementById('share-product-message-input').value.trim();
    if (intent === 'gift') {
        const price = parseFloat(currentProductData.price.replace(/[^\d.-]/g, ''));
        if (state.myProfile.balance < price) {
            alert('钱包余额不足，无法送出礼物！');
            return;
        }
        state.myProfile.balance -= price;
        await addTransaction('expense', price, `送给 ${contact.name} 的礼物：${currentProductData.name}`, contact.id);
        await kokoMemory.put('myProfile', state.myProfile);
        renderMyProfile();
    }
    
    // ▼▼▼ 核心修改：临时切换上下文来发送消息 ▼▼▼
    const originalActiveChatId = state.activeChatId; // 保存原始状态
    state.activeChatId = contact.id; // 临时设为目标联系人
    
    await createAndAddMessage({
        type: 'product_share',
        content: {
            productDetails: currentProductData,
            intent: intent,
            accompanyingMessage: message
        }
    });

    state.activeChatId = originalActiveChatId; // 恢复原始状态
    // ▲▲▲ 修改结束 ▲▲▲

    document.getElementById('share-product-modal').style.display = 'none';
    // 分享后只给提示，不再跳转页面，让用户可以继续浏览
    alert(`已成功分享给 ${contact.name}！`); 
}
// ✨✨✨ 开始粘贴新函数 ✨✨✨
async function renderForumSettingsUI() {
    // 1. 填充用户面具下拉菜单
    const personaSelect = document.getElementById('forum-persona-select');
    personaSelect.innerHTML = '<option value="">-- 不使用特定身份 --</option>';
    state.userPersonaPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        if (state.forumSettings.personaId === preset.id) {
            option.selected = true;
        }
        personaSelect.appendChild(option);
    });

    // 2. 填充世界书多选列表
    const worldBookList = document.getElementById('forum-worldbook-list');
    worldBookList.innerHTML = '';
    if (state.worldBooks.length > 0) {
        state.worldBooks.forEach(book => {
            const isChecked = state.forumSettings.worldBookIds.includes(book.id);
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="forum-book-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="forum-book-${book.id}" class="world-book-name">${book.name}</label>`;
            worldBookList.appendChild(bookItem);
        });
    } else {
        worldBookList.innerHTML = '<p style="color: #888; text-align: center;">还没有创建任何世界书。</p>';
    }

    // 3. 填充风格描述
    document.getElementById('forum-style-description').value = state.forumSettings.styleDescription || '';
// 在 renderForumSettingsUI 函数的末尾，添加下面这段代码

    // ▼▼▼ 开始添加新代码 ▼▼▼
    // 4. 填充允许发帖的角色列表
    const postersList = document.getElementById('forum-allowed-posters-list');
    postersList.innerHTML = ''; // 先清空

    // 筛选出所有非群聊的联系人
    const characters = state.contacts.filter(c => !c.isGroup);

    if (characters.length > 0) {
        characters.forEach(char => {
            // 检查这个角色是否已经在我们的“白名单”里了
            const isChecked = state.forumSettings.allowedPosterIds && state.forumSettings.allowedPosterIds.includes(char.id);
            const charItem = document.createElement('div');
            charItem.className = 'world-book-item'; // 复用现有样式
            charItem.innerHTML = `
                <input type="checkbox" class="world-book-checkbox poster-checkbox" id="poster-char-${char.id}" value="${char.id}" ${isChecked ? 'checked' : ''}>
                <label for="poster-char-${char.id}" class="world-book-name">${char.name}</label>
            `;
            postersList.appendChild(charItem);
        });
    } else {
        postersList.innerHTML = '<p style="color: #888; text-align: center;">你还没有创建任何角色联系人。</p>';
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲
}
// ✨✨✨ 新函数粘贴结束 ✨✨✨
// ==========================================================
// =========== ▼▼▼ 全新：自由外观设置功能逻辑 ▼▼▼ ==========
// ==========================================================

let userSettings = {
    id: 'main',
    chatBackground: null, 
    customBubbleCss: '',  
    customFontUrl: '',    
    customFontName: '',
    customThemeCss: '',    //新增这一行
    customNarrativeCss: '',
    customFontSize: null,
    autoLockDelay: 0,
    showSparkAndLuckyChar: true,
    notificationSoundUrl: ''
};

// 函数：动态更新自定义字体
function updateCustomFont(fontUrl, fontName) {
    let styleTag = document.getElementById('custom-font-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-font-style';
        document.head.appendChild(styleTag);
    }

    if (fontUrl && fontName) {
        // 创建 @font-face 规则来加载外部字体，并应用它
        const fontFaceRule = `
            @font-face {
                font-family: '${fontName}';
                src: url('${fontUrl}');
            }
        `;
        // 更新 --main-font 变量
        document.documentElement.style.setProperty('--main-font', `'${fontName}', 'Nunito', sans-serif`);
        styleTag.textContent = fontFaceRule;
    } else {
        // 如果URL或名称为空，则恢复默认字体并清空style标签
        document.documentElement.style.setProperty('--main-font', `'Nunito', sans-serif`);
        styleTag.textContent = '';
    }
}

// 函数：动态更新自定义气泡CSS
function updateCustomBubbles(cssString) {
    let styleTag = document.getElementById('custom-bubble-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-bubble-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; // 如果CSS字符串为空，则清空样式
}
// 函数：动态更新自定义叙事模式CSS
function updateCustomNarrative(cssString) {
    let styleTag = document.getElementById('custom-narrative-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-narrative-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; 
}
// 1. 【增强版】动态更新全局字体大小 (修复"有些地方不变"的问题)
function updateCustomFontSize(size) {
    let styleTag = document.getElementById('custom-font-size-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-font-size-style';
        document.head.appendChild(styleTag);
    }
    if (size && !isNaN(size) && size >= 10) {
        // 这里列出了所有需要调整大小的元素类名
        styleTag.textContent = `
            /* 强制覆盖所有基础文本元素的字号 */
            body, input, textarea, button, select,
            .app-title, .chat-name, .profile-name, .discover-name,
            .contact-name, .contact-last-message,
            .book-name, .book-content,
            .detail-label, .detail-value,
            .form-label,
            .section-title,
            .nav-item,
            .message,
            .post-text,
            .comment-content,
            .diary-entry-content,
            .qz-card-content, .qz-name-text, .qz-music-title, .qz-music-artist,
            .hv-item, #hv-jealousy  /* <--- ✨ 在这里加上了这两个选择器 ✨ */
            {
                font-size: ${size}px !important;
                line-height: 1.5 !important; /* 保持行高比例 */
            }
            /* 对于通常比较小的文字 (如时间、描述)，按比例缩小 2px，保持层级感 */
            .contact-time, .message-timestamp, .post-meta, .discover-desc, .qz-card-time, .qz-visitors, .nav-item div {
                font-size: ${Math.max(10, size - 2)}px !important;
            }
            /* 输入框高度自适应 */
            #message-input, #comment-input {
                font-size: ${size}px !important;
                min-height: ${size + 20}px !important;
            }
        `;
    } else {
        styleTag.textContent = '';
    }
}

// 2. 【新增】动态更新字距
function updateCustomLetterSpacing(spacing) {
    let styleTag = document.getElementById('custom-letter-spacing-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-letter-spacing-style';
        document.head.appendChild(styleTag);
    }
    if (spacing && !isNaN(spacing)) {
        styleTag.textContent = `
            /* 排除图标(.fas, .far...)，防止图标变宽变形 */
            body, .message, .post-text, .contact-name, .contact-last-message, 
            textarea, input, .detail-value, .book-content {
                letter-spacing: ${spacing}px !important;
            }
        `;
    } else {
        styleTag.textContent = '';
    }
}

// 3. 【新增】动态更新字体粗细
function updateCustomFontWeight(weight) {
    let styleTag = document.getElementById('custom-font-weight-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-font-weight-style';
        document.head.appendChild(styleTag);
    }
    if (weight && !isNaN(weight)) {
        styleTag.textContent = `
            /* 同样排除图标，FontAwesome 依赖 font-weight 来显示实心/空心图标 */
            body :not(.fas):not(.far):not(.fab):not(.fa) {
                font-weight: ${weight} !important;
            }
            /* 确保加粗的标题更粗一点 (如果有空间) */
            .app-title, .chat-name, .contact-name {
                font-weight: ${Math.min(900, parseInt(weight) + 200)} !important;
            }
        `;
    } else {
        styleTag.textContent = '';
    }
}
// 函数：动态更新自定义主题CSS
function updateCustomTheme(cssString) {
    let styleTag = document.getElementById('custom-theme-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-theme-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; 
}

// 函数：应用所有保存的设置
function applyAppearanceSettings() {
    // 1. 应用背景
    const chatScreen = document.getElementById('chat-screen');
    if (userSettings.chatBackground) {
        chatScreen.style.backgroundImage = `url(${userSettings.chatBackground})`;
    } else {
        // 恢复到CSS文件中的默认样式
        chatScreen.style.backgroundImage = ''; 
    }

    // 2. 应用自定义气泡样式
    updateCustomBubbles(userSettings.customBubbleCss);
    // 3. 应用自定义主题样式
updateCustomTheme(userSettings.customThemeCss);
// 4. 应用自定义叙事样式
updateCustomNarrative(userSettings.customNarrativeCss);
updateCustomFontSize(userSettings.customFontSize);       // 修复后的字体大小
    updateCustomLetterSpacing(userSettings.customLetterSpacing); // 新增：字距
    updateCustomFontWeight(userSettings.customFontWeight);       // 新增：粗细
    
    // 3. 应用自定义字体
    updateCustomFont(userSettings.customFontUrl, userSettings.customFontName);
    // ▼▼▼ 【新增】应用页面缩放 ▼▼▼
    if (userSettings.pageZoom && !isNaN(userSettings.pageZoom)) {
        // 使用 CSS zoom 属性，它是目前模拟浏览器缩放最有效的方法
        document.body.style.zoom = userSettings.pageZoom;
    } else {
        document.body.style.zoom = 1; // 恢复默认
    }
    // ▲▲▲ 新增结束 ▲▲▲
}

async function loadAppearanceSettings() {
    const savedSettings = await kokoMemory.get('userSettings', 'main');
    if (savedSettings) {
        userSettings = { ...userSettings, ...savedSettings };
    }
    
    // ▼▼▼ 新增下面这2行 ▼▼▼
    autoLockDelay = userSettings.autoLockDelay || 0; // 加载延迟设置
    document.getElementById('auto-lock-delay-input').value = autoLockDelay > 0 ? autoLockDelay : '';
    // ▼▼▼ 新增：读取开关状态 ▼▼▼
    // 如果是 undefined (旧数据)，默认为 true (显示)
    const isShowSpark = userSettings.showSparkAndLuckyChar !== false; 
    document.getElementById('show-spark-toggle').checked = isShowSpark;
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增：回显提示音设置 ▼▼▼
    document.getElementById('notification-sound-input').value = userSettings.notificationSoundUrl || '';
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 【新增】回显缩放比例 ▼▼▼
    document.getElementById('page-zoom-input').value = userSettings.pageZoom || '';
    // ▲▲▲ 新增结束 ▲▲▲

    applyAppearanceSettings();
}

// 函数：保存当前设置到数据库
async function saveAppearanceSettings() {
    // 从UI控件读取当前用户的输入
    userSettings.customBubbleCss = document.getElementById('bubble-css-input').value.trim();
    userSettings.customThemeCss = document.getElementById('theme-css-input').value.trim();
userSettings.customNarrativeCss = document.getElementById('narrative-css-input').value.trim();
// 新增下面这行：将输入框的值转为数字，如果为空则存为 null
// ▼▼▼ 新增：读取字体大小、字距、粗细 ▼▼▼
    userSettings.customFontSize = parseFloat(document.getElementById('font-size-input').value) || null;
    userSettings.customLetterSpacing = parseFloat(document.getElementById('letter-spacing-input').value) || null;
    userSettings.customFontWeight = parseInt(document.getElementById('font-weight-input').value, 10) || null;
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 【新增】读取缩放比例 ▼▼▼
    userSettings.pageZoom = parseFloat(document.getElementById('page-zoom-input').value) || null;
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增：读取提示音设置 ▼▼▼
    userSettings.notificationSoundUrl = document.getElementById('notification-sound-input').value.trim();
    // ▲▲▲ 新增结束 ▲▲▲
    userSettings.customFontUrl = document.getElementById('font-url-input').value.trim();
    userSettings.customFontName = document.getElementById('font-name-input').value.trim().replace(/[^a-zA-Z0-9]/g, ''); // 只保留字母和数字作为字体名
    userSettings.autoLockDelay = parseInt(document.getElementById('auto-lock-delay-input').value, 10) || 0;
    autoLockDelay = userSettings.autoLockDelay; // 更新全局变量
    // ▼▼▼ 新增：保存开关状态 ▼▼▼
    userSettings.showSparkAndLuckyChar = document.getElementById('show-spark-toggle').checked;
    // ▲▲▲ 新增结束 ▲▲▲
    // 背景图在上传时已实时保存到 userSettings.chatBackground
    
    if (userSettings.customFontUrl && !userSettings.customFontName) {
        alert("请输入一个CSS字体名称！");
        return;
    }
    
    await kokoMemory.put('userSettings', userSettings);
    alert('外观设置已应用并保存！');
    applyAppearanceSettings(); // 再次应用以确保所有更改都生效
}
// 请将下面这个完整的函数，粘贴到刚才删除代码的位置
function attachEventListeners() {
// ▼▼▼ 使用这个【逻辑反转版】的完整函数，替换掉旧的 openGroupSettingsScreen 函数 ▼▼▼

function openGroupSettingsScreen(group) {
    hideAllScreens();
    const screen = document.getElementById('group-settings-screen');
    screen.style.display = 'flex';

    // 1. 填充基本信息
    document.getElementById('group-user-mask-textarea').value = group.userPersona || '';
    document.getElementById('group-memory-share-toggle').checked = group.memoryShared;
    document.getElementById('group-time-awareness-toggle').checked = group.isTimeAware;
    
    const memberCountEl = document.getElementById('group-member-count');
    if(memberCountEl) memberCountEl.textContent = group.members.length;

    // 2. 填充并选中世界书
    const worldBookList = document.getElementById('group-world-book-selector-list');
    worldBookList.innerHTML = '';
    state.worldBooks.forEach(book => {
        const isChecked = group.worldBooks && group.worldBooks.includes(book.id);
        const bookItem = document.createElement('div');
        bookItem.className = 'world-book-item';
        bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="group-book-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="group-book-${book.id}" class="world-book-name">${book.name}</label>`;
        worldBookList.appendChild(bookItem);
    });

    // 3. 填充并选中用户面具预设
    const personaSelect = document.getElementById('group-select-user-persona-preset');
    personaSelect.innerHTML = '<option value="">-- 选择或输入自定义面具 --</option>';
    state.userPersonaPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        if(group.userPersona === preset.description) {
            option.selected = true;
        }
        personaSelect.appendChild(option);
    });

    // 4. 填充成员列表
// 4. 填充成员列表（智能查找版）
    const membersListEl = document.getElementById('group-members-list');
    membersListEl.innerHTML = '';
    group.members.forEach(memberId => {
        
        // ▼▼▼ 核心修改在这里 ▼▼▼
        let profile = null;
        if (memberId === 'myProfile') {
            profile = state.myProfile;
        } else {
            // 先在主联系人里找
            profile = state.contacts.find(c => c.id === memberId);
            if (!profile && group.npcMembers) {
                // 没找到？去NPC列表里找
                profile = group.npcMembers.find(npc => npc.id === memberId);
            }
        }
        // ▲▲▲ 修改结束 ▲▲▲

        if (profile) {
            const isMuted = (group.mutedMembers || []).includes(memberId);
            
            // ▼▼▼ 新增一个 (NPC) 标签 ▼▼▼
            const isNPC = !state.contacts.some(c => c.id === memberId) && memberId !== 'myProfile';            
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            
            // ▼▼▼ 核心修改：如果是 NPC，加上点击样式和 ID 数据 ▼▼▼
            if (isNPC) {
                item.style.cursor = 'pointer';
                item.dataset.npcId = memberId; // 存下 ID
                item.dataset.isNpcRow = 'true'; // 标记这是一行 NPC
                item.title = "点击修改 NPC 设定";
            }
            // ▲▲▲ 修改结束 ▲▲▲

            item.innerHTML = `
                <img src="${profile.avatar}" alt="${profile.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                <span style="flex-grow: 1;">${profile.name} ${memberId === 'myProfile' ? '(你)' : ''} ${isNPC ? '<span style="font-size: 11px; color: #888; background: #eee; padding: 1px 4px; border-radius: 4px;">NPC</span>' : ''}</span>
                ${memberId !== 'myProfile' ? `
                    <button class="preset-action-btn mute-member-btn ${!isMuted ? 'active' : ''}" data-member-id="${memberId}" title="${isMuted ? '解除禁言' : '禁言'}">
                        <i class="fas ${isMuted ? 'fa-bell-slash' : 'fa-bell'}"></i>
                    </button>
                    <button class="preset-action-btn delete remove-member-btn" data-member-id="${memberId}" title="移出群聊">
                        <i class="fas fa-times"></i>
                    </button>
                ` : ''}
            `;
            membersListEl.appendChild(item);
        }
    });

    // 5. 为页面上的按钮绑定一次性事件监听器
    const oldSaveBtn = document.getElementById('save-group-settings-btn');
    const newSaveBtn = oldSaveBtn.cloneNode(true);
    oldSaveBtn.parentNode.replaceChild(newSaveBtn, oldSaveBtn);
    newSaveBtn.addEventListener('click', async () => {
        group.userPersona = document.getElementById('group-user-mask-textarea').value.trim();
        group.memoryShared = document.getElementById('group-memory-share-toggle').checked;
        group.isTimeAware = document.getElementById('group-time-awareness-toggle').checked;
        group.worldBooks = Array.from(document.querySelectorAll('#group-world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);
        await kokoMemory.put('contacts', group);
        alert('群聊设置已保存！');
        showCharProfileScreen();
    }, { once: true });
    
    const oldDisbandBtn = document.getElementById('disband-group-btn');
    const newDisbandBtn = oldDisbandBtn.cloneNode(true);
    oldDisbandBtn.parentNode.replaceChild(newDisbandBtn, oldDisbandBtn);
    newDisbandBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm('确认操作', `确定要解散群聊“${group.name}”吗？\n此操作会删除群聊及所有聊天记录，无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== group.id);
            await kokoMemory.delete('contacts', group.id);
            state.activeChatId = null;
            alert('群聊已解散。');
            await showMainScreen();
        }
    }, { once: true });
    
    const oldBackBtn = document.getElementById('back-from-group-settings');
    const newBackBtn = oldBackBtn.cloneNode(true);
    oldBackBtn.parentNode.replaceChild(newBackBtn, oldBackBtn);
    newBackBtn.addEventListener('click', () => {
        screen.style.display = 'none';
        openChat(state.activeChatId);
    }, { once: true });

    const oldPersonaSelect = document.getElementById('group-select-user-persona-preset');
    const newPersonaSelect = oldPersonaSelect.cloneNode(true);
    oldPersonaSelect.parentNode.replaceChild(newPersonaSelect, oldPersonaSelect);
    newPersonaSelect.addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('group-user-mask-textarea').value = preset ? preset.description : '';
    });
}

// ==========================================================
    // =========== ▼▼▼ 全新：群聊功能核心逻辑 ▼▼▼ ==========
    // ==========================================================
    const createGroupBtn = document.getElementById('create-group-btn');
    if (createGroupBtn) {
        createGroupBtn.addEventListener('click', () => {
            const modal = document.getElementById('create-group-modal');
            const memberListEl = document.getElementById('group-member-picker-list');
            const groupNameInput = document.getElementById('group-name-input');
            groupNameInput.value = '';
            memberListEl.innerHTML = '';

            // 动态加载可选的群成员
            state.contacts.forEach(contact => {
                if (contact.isGroup) return; // 不能把群聊加到群聊里
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                item.innerHTML = `
                    <input type="checkbox" id="member-check-${contact.id}" value="${contact.id}">
                    <label for="member-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                        <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                        <span>${contact.name}</span>
                    </label>
                `;
                memberListEl.appendChild(item);
            });
            
            modal.style.display = 'flex';
        });
    }

    document.getElementById('close-create-group-modal').addEventListener('click', () => {
        document.getElementById('create-group-modal').style.display = 'none';
    });

    document.getElementById('confirm-create-group-btn').addEventListener('click', async () => {
        const groupName = document.getElementById('group-name-input').value.trim();
        if (!groupName) {
            return alert('请给你的群聊起个名字！');
        }

        const selectedMemberIds = Array.from(document.querySelectorAll('#group-member-picker-list input:checked')).map(input => input.value);
        if (selectedMemberIds.length < 2) {
            return alert('群聊至少需要2位AI成员哦！');
        }
        
        // ✨ 核心改动：新增 mutedMembers: [] 属性，为禁言功能做准备
        const newGroup = {
            id: 'group_' + Date.now(),
            name: groupName,
            avatar: '',
            isGroup: true,
            members: ['myProfile', ...selectedMemberIds],
            history: [],
            memoryShared: true,
            mutedMembers: [], // 初始化禁言列表
            npcMembers: []
        };

        state.contacts.push(newGroup);
        await kokoMemory.put('contacts', newGroup);
        
        // 临时切换 activeChatId 来正确添加第一条系统消息
        const tempActiveChatId = state.activeChatId;
        state.activeChatId = newGroup.id;
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `你创建了群聊`
        });
        state.activeChatId = tempActiveChatId;

        await renderContacts();
        document.getElementById('create-group-modal').style.display = 'none';
        openChat(newGroup.id);
    });
    // ==========================================================
    // --- 新增：消息提示音试听 ---
document.getElementById('test-notification-sound-btn').addEventListener('click', () => {
    const url = document.getElementById('notification-sound-input').value.trim();
    if (!url) return alert("请先输入音频链接");
    
    const audio = document.getElementById('notification-sound-player');
    audio.src = url;
    audio.play().catch(e => alert("播放失败，请检查链接是否有效 (跨域限制/格式不支持)"));
});
    // V9.0 新增：悬浮播放器拖动逻辑 (支持鼠标和触摸)
    // ==========================================================
    const card = document.getElementById('music-player-card');
    const header = document.getElementById('player-header');
    let isDragging = false,
        cardX = 50,
        cardY = 50,
        dragStartX = 0,
        dragStartY = 0;
    card.style.left = `${cardX}px`;
    card.style.top = `${cardY}px`;

    function dragStart(e) {
        isDragging = true;
        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        dragStartX = clientX;
        dragStartY = clientY;
        card.style.transition = 'none';
    }

    function dragMove(e) {
        if (isDragging) {
            if (e.type === 'touchmove') e.preventDefault();
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
            const deltaX = clientX - dragStartX;
            const deltaY = clientY - dragStartY;
            card.style.left = `${cardX + deltaX}px`;
            card.style.top = `${cardY + deltaY}px`;
        }
    }

    function dragEnd(e) {
        if (isDragging) {
            isDragging = false;
            const clientX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
            cardX += (clientX - dragStartX);
            cardY += (clientY - dragStartY);
            card.style.transition = 'all 0.4s ease-in-out';
        }
    }
    header.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', dragEnd);
    header.addEventListener('touchstart', dragStart);
    document.addEventListener('touchmove', dragMove, {
        passive: false
    });
    document.addEventListener('touchend', dragEnd);

    let currentlyPlayingMsgId = null;
    
 // --- 原有功能：数据导入导出 ---
document.getElementById('export-data-btn').addEventListener('click', exportData);

// ▼▼▼ 在这里添加新的一行代码 ▼▼▼
// 修改：点击“局部导出”不再直接导出，而是打开选择弹窗
document.getElementById('export-light-data-btn').addEventListener('click', openExportSelectorModal);

// 新增：绑定弹窗内的按钮事件
document.getElementById('close-export-selector-modal').addEventListener('click', () => {
    document.getElementById('export-selector-modal').style.display = 'none';
});

document.getElementById('confirm-custom-export-btn').addEventListener('click', performCustomExport);

// ▲▲▲ 添加结束 ▲▲▲

document.getElementById('import-data-btn').addEventListener('click', () => {
    document.getElementById('import-file-input').click();
});
    document.getElementById('import-file-input').addEventListener('change', importData);

    // --- 原有功能：头像更换 ---
    document.getElementById('change-avatar-btn').addEventListener('click', function() {
        handleAvatarUpload(async (base64String) => {
            state.myProfile.avatar = base64String;
            await kokoMemory.put('myProfile', state.myProfile);
            renderMyProfile();
        });
    });
    document.getElementById('change-char-avatar-btn').addEventListener('click', () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        handleAvatarUpload(async (base64String) => {
            contact.avatar = base64String;
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
            renderContacts();
        });
    });

 // ▼▼▼ 使用这个【超级整合版】，替换掉所有旧的底部导航栏监听代码 ▼▼▼

// --- 统一处理所有页面的底部导航栏点击事件 (V2 - 包含短信切换) ---
document.getElementById('screen').addEventListener('click', (e) => {
    const navItem = e.target.closest('.nav-item');
    if (!navItem) return;

    // ✨ 核心改动：重置 state.currentChatMode
    state.currentChatMode = 'chat'; // 默认切回聊天模式

    if (navItem.id.startsWith('nav-chat')) {
        showMainScreen();
    } else if (navItem.id.startsWith('nav-discover')) {
        showDiscoverScreen();
    } else if (navItem.id.startsWith('nav-profile')) {
        showProfileScreen();
    } else if (navItem.id.startsWith('nav-sms')) {
        // ✨ 当点击短信页签时，明确设置模式
        state.currentChatMode = 'sms';
        showSmsScreen(); // 调用显示短信主界面的函数
    }
});

// ▲▲▲ 替换结束 ▲▲▲
const smsMessageInput = document.getElementById('sms-message-input');
if (smsMessageInput) {
    smsMessageInput.addEventListener('input', function() {
        this.style.height = 'auto'; // 先重置高度，让浏览器重新计算
        // 设置新高度，但不超过 max-height
        const maxHeight = 100; // 和 CSS 里的 max-height 保持一致
        const newHeight = Math.min(this.scrollHeight, maxHeight);
        this.style.height = newHeight + 'px';
    });
}
// --- 短信界面的 "请求回复" 按钮 ---
const smsRequestReplyBtn = document.getElementById('sms-request-reply-btn');
if (smsRequestReplyBtn) {
    smsRequestReplyBtn.addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        // 确保我们在短信模式下，并且有有效的联系人
        if (contact && state.currentChatMode === 'sms') {
            await requestAiSmsReply(contact); // 调用请求回复的函数
        }
    });
}
// --- 在 attachEventListeners 函数内部添加 ---

// 短信编辑按钮
const editSmsBtn = document.getElementById('edit-sms-btn');
if (editSmsBtn) {
    editSmsBtn.addEventListener('click', enterSmsEditMode);
}

// 短信编辑栏按钮
const deleteSelectedSmsBtn = document.getElementById('delete-selected-sms-btn');
if (deleteSelectedSmsBtn) {
    deleteSelectedSmsBtn.addEventListener('click', deleteSelectedSmsMessages);
}
const cancelSmsEditBtn = document.getElementById('cancel-sms-edit-btn');
if (cancelSmsEditBtn) {
    cancelSmsEditBtn.addEventListener('click', exitSmsEditMode);
}

// ▼▼▼ ✨ 使用这个【V2 完整版】替换旧的 'sms-chat-messages' 监听器 ▼▼▼
const smsMessagesContainer = document.getElementById('sms-chat-messages');
if (smsMessagesContainer) {
    smsMessagesContainer.addEventListener('click', (e) => {
        const wrapper = e.target.closest('.sms-row');
        if (!wrapper) return;

        // 逻辑 1: 处理编辑模式下的点击
        if (smsEditModeState.active) {
            handleSmsMessageSelection(wrapper);
            return; // 在编辑模式下，不执行后续的点击展开逻辑
        }

        // 逻辑 2: 处理“点击查看描述”
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        const msgId = wrapper.dataset.messageId;
        const msg = contact.smsHistory.find(m => m.id === msgId);

        // ✨ 核心功能：检查点击的是否是 picture_description
        if (msg && msg.type === 'picture_description') {
            const transcribedTextEl = wrapper.querySelector('.transcribed-text');
            if (!transcribedTextEl) return;

            const isCurrentlyVisible = transcribedTextEl.classList.contains('visible');

            // a. 先关闭所有其他已打开的文字气泡
            document.querySelectorAll('#sms-chat-messages .transcribed-text.visible').forEach(el => {
                if (el !== transcribedTextEl) {
                    el.classList.remove('visible');
                    el.textContent = '';
                }
            });

            // b. 切换当前点击的气泡的文字显示状态
            if (isCurrentlyVisible) {
                transcribedTextEl.classList.remove('visible');
                transcribedTextEl.textContent = '';
            } else {
                transcribedTextEl.textContent = msg.content.description;
                transcribedTextEl.classList.add('visible');
            }
        }
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// (可选) 修改短信界面的返回按钮逻辑，确保在编辑模式下先退出编辑
const backFromSmsChatBtn = document.getElementById('back-from-sms-chat');
if (backFromSmsChatBtn) {
    // 先移除可能存在的旧监听器
    const newBackBtn = backFromSmsChatBtn.cloneNode(true);
    backFromSmsChatBtn.parentNode.replaceChild(newBackBtn, backFromSmsChatBtn);
    // 添加新监听器
    newBackBtn.addEventListener('click', () => {
        if (smsEditModeState.active) {
            exitSmsEditMode(); // 如果在编辑，先退出编辑
        } else {
            state.currentChatMode = 'sms';
            showSmsScreen(); // 否则正常返回列表
        }
    });
}
// ▼▼▼ 把这行新代码，粘贴到 attachEventListeners 函数里面 ▼▼▼
// 短信/窥探模式的页签切换
document.getElementById('sms-tabs').addEventListener('click', handleSmsTabClick);
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- 新增：处理窥探模式照片图标点击事件 ---
const snoopContentBody = document.getElementById('snooped-app-content-body');
snoopContentBody.addEventListener('click', (e) => {
    const photoIcon = e.target.closest('.snoop-photo-item');
    if (photoIcon) {
        const detailsId = photoIcon.dataset.detailsId;
        const detailsElement = document.getElementById(detailsId);

        if (detailsElement) {
            // 先关闭所有其他已打开的详情
            document.querySelectorAll('.snoop-photo-details.visible').forEach(openDetail => {
                if (openDetail !== detailsElement) {
                    openDetail.classList.remove('visible');
                    // Add a small delay to allow the closing animation to finish before potentially opening another
                    setTimeout(() => { openDetail.style.display = 'none'; }, 300);
                }
            });

            // 切换当前点击的详情的可见性
            const isVisible = detailsElement.classList.toggle('visible');
            if (isVisible) {
                detailsElement.style.display = 'block'; // Make it visible before animation
            } else {
                // Add delay before setting display none to allow fade out animation
                setTimeout(() => { detailsElement.style.display = 'none'; }, 300);
            }
        }
    } else if (!e.target.closest('.snoop-photo-details')) {
         // 如果点击的不是图标也不是详情框本身，关闭所有打开的详情
         document.querySelectorAll('.snoop-photo-details.visible').forEach(openDetail => {
             openDetail.classList.remove('visible');
             setTimeout(() => { openDetail.style.display = 'none'; }, 300);
         });
    }
});
// --- 照片图标点击事件结束 ---

    // --- 原有功能：发现页跳转 ---
    document.getElementById('user-persona-presets-btn').addEventListener('click', showUserPersonaManagementScreen);
    document.getElementById('emoticon-library-btn').addEventListener('click', showEmoticonLibraryScreen);
    document.getElementById('music-library-btn').addEventListener('click', showMusicLibraryScreen);
    document.getElementById('thought-presets-btn').addEventListener('click', showThoughtPresetManagementScreen);
    document.getElementById('world-book-btn').addEventListener('click', () => {
        hideAllScreens();
        document.getElementById('world-book-screen').style.display = 'flex';
        renderWorldBooks();
    });
document.getElementById('api-settings-btn').addEventListener('click', async () => {
    hideAllScreens();
    document.getElementById('api-settings-screen').style.display = 'flex';
    document.getElementById('api-key-input').value = state.apiSettings.apiKey;
    document.getElementById('api-endpoint-input').value = state.apiSettings.endpoint;
    document.getElementById('context-length-input').value = state.apiSettings.contextLength;
    document.getElementById('long-term-memory-length-input').value = state.apiSettings.longTermMemoryLength;

    // ▼▼▼ 新增这两行 ▼▼▼
    document.getElementById('minimax-group-id-input').value = state.apiSettings.minimaxGroupId || '';
    document.getElementById('minimax-api-key-input').value = state.apiSettings.minimaxApiKey || '';
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增：填充温度和Token ▼▼▼
    document.getElementById('api-temperature-input').value = state.apiSettings.temperature || '';
    document.getElementById('api-max-tokens-input').value = state.apiSettings.maxTokens || '';
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增这一行 ▼▼▼
document.getElementById('siliconflow-api-key-input').value = state.apiSettings.siliconflowApiKey || '';

    updateModelDropdown([state.apiSettings.model], document.getElementById('model-select'), state.apiSettings.model);

    await renderApiPresetDropdown(); 
});
    document.getElementById('square-api-settings-btn').addEventListener('click', async () => {
        hideAllScreens();
        document.getElementById('square-api-settings-screen').style.display = 'flex';
        document.getElementById('square-api-key-input').value = state.squareApiSettings.apiKey;
        document.getElementById('square-api-endpoint-input').value = state.squareApiSettings.endpoint;
        updateModelDropdown([state.squareApiSettings.model], document.getElementById('square-model-select'), state.squareApiSettings.model);
        await renderForumSettingsUI();
    });
    document.getElementById('moments-btn').addEventListener('click', showFeedScreen);

    // --- 原有功能：各页面返回按钮 ---
    document.getElementById('back-from-user-persona-management').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-emoticon-library').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-music-library').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-thought-presets').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-world-book').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-api').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-square-api').addEventListener('click', showDiscoverScreen);
// ✅✅✅ 最终的正确代码 ✅✅✅
document.getElementById('back-from-chat').addEventListener('click', async () => {
    if (editModeState.active) await exitEditMode();
    document.getElementById('chat-pet-container').style.display = 'none';
    currentlyPlayingMsgId = null;
    
    // ✨ 核心V2：退出聊天时，移除专属CSS标签
    let oldTag = document.getElementById('contact-specific-bubble-style');
    if (oldTag) {
        oldTag.remove();
    }

    // 1. 先调用 showMainScreen()，它内部的 hideAllScreens() 会立刻隐藏聊天窗口
    await showMainScreen(); 
    
    // 2. 关键修复：在UI完全切换到主屏幕后，再把 activeChatId 设为 null
    state.activeChatId = null; 
});
    document.getElementById('back-from-contact-settings').addEventListener('click', () => {
        document.getElementById('contact-settings-screen').style.display = 'none';
        showCharProfileScreen();
    });
    document.getElementById('back-from-moments').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-char-profile').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.isChatPetVisible && batchedPetActions.length > 0) {
            const summary = batchedPetActions.join('，');
            const systemPrompt = `[角色后台指令：用户刚刚在宠物界面进行了一系列操作：“${summary}”。你的任务是，不要逐条复述这些操作日志，而是对此事发表一句连贯、自然的口语化评论来衔接对话。例如，你可以问：“刚刚去照顾咱们的史莱姆啦？”或者说：“看你把它喂得饱饱的，真好。”]`;
            //await requestAiReply(systemPrompt);
        }
        batchedPetActions = [];
        
        // ▼▼▼ 核心修复点在这里 ▼▼▼
        // 我们不再只是“显示”旧的聊天屏幕
        // document.getElementById('char-profile-screen').style.display = 'none';
        // document.getElementById('chat-screen').style.display = 'flex';

        // 而是调用 openChat() 函数，它会用最新的数据“重新绘制”整个聊天界面
        openChat(state.activeChatId);
        // ▲▲▲ 修复结束 ▲▲▲
    });
    document.getElementById('back-from-diary').addEventListener('click', showCharProfileScreen);
    document.getElementById('back-from-post-detail').addEventListener('click', showFeedScreen);
    document.getElementById('back-from-trending-topic').addEventListener('click', showFeedScreen);
    // ▼▼▼ 这整段代码在新版本中都缺失了 ▼▼▼
document.getElementById('refresh-post-comments-btn').addEventListener('click', async () => {
    const post = state.posts.find(p => p.id === state.activePostId);
    if (!post) return;

    showFeedStatus('正在加载新评论...');
    try {
        await generateMoreCommentsForPost(post);
        await kokoMemory.put('posts', post);
        await renderPostDetail();

    } catch(e) {
        console.error("刷新评论失败:", e);
        alert("刷新评论失败: " + e.message);
    } finally {
        hideFeedStatus();
    }
});
    const backFromMemoryAlbumBtn = document.getElementById('back-from-memory-album');
    if (backFromMemoryAlbumBtn) {
        backFromMemoryAlbumBtn.addEventListener('click', showCharProfileScreen);
    }

    document.getElementById('send-btn').addEventListener('click', sendMessage);
// (V5 - 最终版：支持私聊+群聊的自由聊天)
// 粘贴到 attachEventListeners() 函数内部
document.getElementById('request-reply-btn').addEventListener('click', () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return; 

    // 1. 找到最后一条“真实”消息
    const lastRealMessage = contact.history.slice().reverse().find(m => 
        m.sender !== 'system' && 
        m.sender !== 'system_instruction' &&
        m.type !== 'system_notification'
    );

    // 2. 检查是不是用户最后发言
    const userSpokeLast = lastRealMessage && (lastRealMessage.sender === 'user' || lastRealMessage.sender === 'myProfile');

    if (userSpokeLast) {
        // --- Case 1: 用户刚说完 (无论私聊还是群聊) ---
        // 100% 执行“回复你”的逻辑
        console.log("用户刚发言，触发AI回复用户...");
        requestAiReply(null, contact.id);
    } else {
        // --- Case 2: 用户没说话 (AI说的，或没记录) ---
        if (contact.isGroup) {
            // 2a. 如果是群聊，调用【群聊】自由聊天
            console.log("群聊：用户未发言，触发AI自由聊天...");
            triggerGroupFreeChat(contact); 
        } else {
            // 2b. 如果是私聊，调用【私聊】自由聊天 (新功能!)
            console.log("私聊：用户未发言，触发AI自由聊天...");
            triggerPrivateFreeChat(contact); 
        }
    }
});
    document.getElementById('message-input').addEventListener('keypress', e => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    // ▼▼▼ ✨【KOKO 核心修复】✨ 让主聊天输入框自动变高 ▼▼▼
document.getElementById('message-input').addEventListener('input', function() {
    // 1. 先重置高度，让浏览器告诉我们内容到底需要多高
    this.style.height = 'auto'; 

    // 2. 你的 CSS 里设置了 max-height: 100px，我们遵守这个限制
    const maxHeight = 100; 

    // 3. 计算新高度 (scrollHeight 是内容真实高度)，但不超过最大值
    const newHeight = Math.min(this.scrollHeight, maxHeight);

    // 4. 应用新高度 (如果内容高度小于最小高度，浏览器会自动处理)
    this.style.height = newHeight + 'px';
});
// ▲▲▲ ✨✨✨ 修复结束 ✨✨✨ ▲▲▲
    document.getElementById('cancel-edit-btn').addEventListener('click', exitEditMode);
// (替换) “删除已选”按钮 - 智能无刷新删除版
document.getElementById('delete-selected-btn').addEventListener('click', async () => {
    if (editModeState.selectedMessageIds.size === 0) {
        return alert('请先选择要删除的消息。');
    }
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${editModeState.selectedMessageIds.size} 条消息吗？`, true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact) {
            // 1. (保持不变) 处理音乐播放停止逻辑
            const createKey = (song) => `${(song.title || '').trim()}|${(song.artist || '').trim()}`;
            const librarySongKeys = new Set(state.musicLibrary.map(createKey));
            const deletedTempMusicMessages = contact.history.filter(msg =>
                editModeState.selectedMessageIds.has(msg.id) &&
                msg.type === 'music_share' &&
                !librarySongKeys.has(createKey(msg.content))
            );
            if (deletedTempMusicMessages.length > 0) {
                const deletedTempSongKeys = new Set(deletedTempMusicMessages.map(msg => createKey(msg.content)));
                const currentTrack = contact.sharedPlaylist.tracks[contact.sharedPlaylist.currentIndex];
                if (currentTrack && deletedTempSongKeys.has(createKey(currentTrack))) {
                    globalAudioPlayer.pause();
                    globalAudioPlayer.src = '';
                    contact.sharedPlaylist.currentIndex = 0;
                    closeMusicPlayer();
                }
            }
            
            // 2. ✨【核心新增】✨：在更新数据前，先把屏幕上的气泡直接删掉！
            // 这样既能立刻看到效果，又不会触发页面滚动。
            editModeState.selectedMessageIds.forEach(msgId => {
                const messageEl = document.getElementById('chat-messages').querySelector(`.message-wrapper[data-message-id="${msgId}"]`);
                if (messageEl) {
                    messageEl.remove(); // 直接从 DOM 中移除元素
                }
            });

            // 3. (保持不变) 更新内存数据并保存到数据库
            contact.history = contact.history.filter(msg => !editModeState.selectedMessageIds.has(msg.id));
            await kokoMemory.put('contacts', contact);
            
            // 4. (保持不变) 刷新一下底层的播放列表（不可见，不影响界面）
            const musicPlayerCard = document.getElementById('music-player-card');
            if (musicPlayerCard.style.display === 'flex' && state.musicSessionContactId === contact.id) {
                renderPlaylist();
            }
        }
        // 5. 退出编辑模式 (这时它只会清理剩下的高亮，不会再乱跳了)
        await exitEditMode();
    }
});

// --- 用这个新版本，替换掉旧的 'char-more-info-btn' 事件监听代码 ---

document.getElementById('char-more-info-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    if (contact.isGroup) {
        openGroupSettingsScreen(contact);
    } else {
    await updateUserPersonaPresetSelect();
        const avatarPreview = document.getElementById('custom-user-avatar-preview');
        if (contact.customUserAvatar) {
            avatarPreview.src = contact.customUserAvatar;
            avatarPreview.style.display = 'block';
        } else {
            avatarPreview.style.display = 'none';
        }

        document.getElementById('char-mask-textarea').value = contact.persona;
        document.getElementById('contact-bubble-css-input').value = contact.customBubbleCss || '';
        document.getElementById('user-mask-textarea').value = contact.userPersona || '';
        document.getElementById('custom-user-name-input').value = contact.customUserName || '';
        const currentPersonaPreset = state.userPersonaPresets.find(p => p.description === contact.userPersona);
        document.getElementById('select-user-persona-preset').value = currentPersonaPreset ? currentPersonaPreset.id : '';
        
        // ▼▼▼ 核心修复从这里开始 ▼▼▼
        // ✨✨✨ 在这里加上下面这行新代码！ ✨✨✨
await populateThoughtPresetSelect();

        const thoughtPresetSelect = document.getElementById('thought-preset-select');
        const savedThoughtPresetId = contact.thoughtPreset;

        // 检查联系人保存的预设ID是否仍然存在于预设列表中
        const thoughtPresetExists = state.thoughtPresets.some(p => p.id === savedThoughtPresetId);

        if (savedThoughtPresetId && thoughtPresetExists) {
            // 如果预设确实还存在，就正常选中它
            thoughtPresetSelect.value = savedThoughtPresetId;
        } else {
            // 如果预设不存在（说明已被删除），就重置为空，并顺便清理掉角色身上的无效ID
            thoughtPresetSelect.value = ""; // 在界面上选中“无预设”
            contact.thoughtPreset = ""; // 清理掉角色数据里的无效ID
        }
        // ▲▲▲ 核心修复到这里结束 ▲▲▲

        document.querySelectorAll('.world-book-checkbox').forEach(cb => {
            cb.checked = (contact.worldBooks || []).includes(cb.value);
        });
        // 【新增】填充新的世界书选择器 (用于窥探)
const snoopWorldBookList = document.getElementById('snoop-world-book-selector-list');
snoopWorldBookList.innerHTML = ''; // 先清空旧的内容
state.worldBooks.forEach(book => { // 遍历所有可用的世界书
    // 检查这本书是否在联系人专门为窥探功能保存的列表里
    const isChecked = (contact.snoopRelevantWorldBookIds || []).includes(book.id);
    const bookItem = document.createElement('div');
    bookItem.className = 'world-book-item'; // 复用样式
    // 创建复选框和标签，根据 isChecked 决定是否默认勾选
    bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="snoop-book-setting-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="snoop-book-setting-${book.id}" class="world-book-name">${book.name}</label>`;
    snoopWorldBookList.appendChild(bookItem); // 将创建好的条目添加到新的列表容器中
});
        document.getElementById('narrative-mode-toggle').checked = contact.isNarrativeMode;
        document.getElementById('time-awareness-toggle').checked = contact.isTimeAware ?? false;
        document.getElementById('hide-avatar-toggle').checked = contact.isAvatarHidden;
        // ▼▼▼ 使用这两行替换上面那一行 ▼▼▼
document.getElementById('char-voice-provider-select').value = contact.voiceProvider || '';
document.getElementById('char-voice-id-input').value = contact.voiceId || '';
        // ▼▼▼ 在这里粘贴下面2行新代码 ▼▼▼
        document.getElementById('user-voice-provider-select').value = contact.userVoiceProvider || '';
        document.getElementById('user-voice-id-input').value = contact.userVoiceId || '';
        // ▲▲▲ 粘贴结束 ▲▲▲
        document.getElementById('char-profile-screen').style.display = 'none';
        // ... (上面是原有的 snoopWorldBookList 填充逻辑) ...

        // ▼▼▼ 【新增】填充表情分组选择器 ▼
        const snoopSelector = document.querySelector('#snoop-world-book-selector-list').closest('.world-book-selector');
        
        // 检查是否已经添加过（防止重复添加）
        let emoSelectorContainer = document.getElementById('emo-group-selector-container');
        
        if (!emoSelectorContainer) {
            emoSelectorContainer = document.createElement('div');
            emoSelectorContainer.id = 'emo-group-selector-container';
            emoSelectorContainer.className = 'world-book-selector';
            emoSelectorContainer.style.marginTop = '15px';
            // 插入到 DOM 中
            snoopSelector.parentNode.insertBefore(emoSelectorContainer, snoopSelector.nextSibling);
        }

        // 渲染内容
        emoSelectorContainer.innerHTML = `
            <div class="world-book-selector-title">允许使用的表情分组</div>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
                勾选该角色在聊天中可以使用的表情包分组。
            </p>
            <div class="world-book-list" id="contact-emo-group-list"></div>
        `;

        const emoGroupList = document.getElementById('contact-emo-group-list');
        // 获取当前联系人已允许的分组 (如果未设置，默认允许 'default')
        const allowedGroups = contact.allowedEmoticonGroups || ['default'];
        
        state.emoticonGroups.forEach(group => {
            const isChecked = allowedGroups.includes(group.id);
            const item = document.createElement('div');
            item.className = 'world-book-item';
            item.innerHTML = `
                <input type="checkbox" class="world-book-checkbox emo-group-check" id="emo-group-${group.id}" value="${group.id}" ${isChecked ? 'checked' : ''}>
                <label for="emo-group-${group.id}" class="world-book-name">${group.name}</label>
            `;
            emoGroupList.appendChild(item);
        });
        // ▲▲▲ 新增结束 ▲▲▲
        document.getElementById('contact-settings-screen').style.display = 'flex';
        await updateContactMapSelector();
    }
});
        // ▲▲▲ 替换结束 ▲▲▲
// (粘贴到 attachEventListeners 函数的末尾)
    document.getElementById('refresh-snoop-app-btn').addEventListener('click', handlePartialSnoopRefresh);
        // ▼▼▼ 把这段全新的代码，完整地粘贴到 attachEventListeners 函数的【末尾】 ▼▼▼
        // --- 新增：为联系人设置页面的新按钮绑定事件 ---
        document.getElementById('upload-contact-background-btn').addEventListener('click', () => {
            const uploader = document.getElementById('contact-background-uploader');
            uploader.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const contact = state.contacts.find(c => c.id === state.activeChatId);
                    if (!contact) return;
                    contact.customChatBackground = event.target.result;
                    await kokoMemory.put('contacts', contact);
                    alert('专属聊天背景已更新！');
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            };
            uploader.click();
        });

        document.getElementById('reset-contact-background-btn').addEventListener('click', async () => {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            contact.customChatBackground = null;
            await kokoMemory.put('contacts', contact);
            alert('背景已恢复默认。');
        });

        document.getElementById('upload-contact-user-avatar-btn').addEventListener('click', () => {
            const uploader = document.getElementById('contact-user-avatar-uploader');
            uploader.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const contact = state.contacts.find(c => c.id === state.activeChatId);
                    if (!contact) return;
                    const base64 = event.target.result;
                    contact.customUserAvatar = base64;
                    await kokoMemory.put('contacts', contact);
                    document.getElementById('custom-user-avatar-preview').src = base64;
                    document.getElementById('custom-user-avatar-preview').style.display = 'block';
                    alert('专属头像已更新！');
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            };
            uploader.click();
        });
        
        document.getElementById('reset-contact-user-avatar-btn').addEventListener('click', async () => {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            contact.customUserAvatar = null;
            await kokoMemory.put('contacts', contact);
            document.getElementById('custom-user-avatar-preview').style.display = 'none';
            alert('头像已恢复为你的全局默认头像。');
        });
        // ▲▲▲ 新增代码粘贴到这里结束 ▲▲▲
    document.getElementById('view-char-diary-btn').addEventListener('click', showDiaryScreen);
    // ▼▼▼ 将这段完整的代码粘贴到 attachEventListeners 函数中 ▼▼▼
document.getElementById('diary-content-list').addEventListener('click', async (e) => {
    // 检查点击的是不是删除按钮
    if (e.target.closest('.diary-delete-btn')) {
        const diaryId = e.target.closest('.diary-delete-btn').dataset.diaryId;
        const confirmed = await showCustomConfirm('删除日记', '确定要删除这条日记吗？', true);
        if (confirmed) {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if(contact && contact.diary) {
                // 从联系人的日记数组中过滤掉要删除的条目
                contact.diary = contact.diary.filter(entry => entry.id !== diaryId);
                // 保存更改到数据库
                await kokoMemory.put('contacts', contact);
                // 重新渲染日记列表，让界面刷新
                renderDiary();
            }
        }
    }
});
    document.getElementById('delete-contact-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const confirmed = await showCustomConfirm('删除联系人', `⚠️ 警告：确定要永久删除联系人 "${contact.name}" 吗？\n\n此操作将删除其所有聊天记录和日记，且无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== state.activeChatId);
            await kokoMemory.delete('contacts', state.activeChatId);
            state.activeChatId = null;
            alert(`联系人 "${contact.name}" 已被删除。`);
            await showMainScreen();
        }
    });
document.getElementById('clear-chat-history-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        
        // (确认弹窗逻辑不变)
        const confirmed = await showCustomConfirm('清空所有记录', `确定要清空与 "${contact.name}" 的所有记录吗？\n\n这将同时删除：\n1. App内的聊天记录\n2. 短信对话记录\n\n此操作不可恢复！`, true);
        
        if (confirmed) {
            contact.history = [];
            contact.smsHistory = []; 
            
            await kokoMemory.put('contacts', contact);
            alert('聊天和短信记录已全部清空。');
            
            // ▼▼▼ 核心修复就在这两行 ▼▼▼
            // 1. 关闭当前的“设置”页面
            document.getElementById('contact-settings-screen').style.display = 'none';
            // 2. 强制重新打开（刷新）聊天页面，而不是返回角色资料页！
            openChat(contact.id); 
            // ▲▲▲ 修复结束 ▲▲▲
        }
    });
    document.getElementById('char-profile-screen').addEventListener('click', async (e) => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        if (e.target.id === 'adopt-pet-btn') {
            contact.pet = {
                name: '史莱姆',
                stage: 1,
                happiness: 80,
                hunger: 80,
                cleanliness: 100,
                lastUpdated: Date.now(),
                workFinishTimestamp: null,
                xp: 0,
                level: 1,
                form: 'baby'
            };
            await kokoMemory.put('contacts', contact);
            renderPet(contact);
            await requestAiReply(`[SYSTEM: 我们刚刚领养了一只宠物史莱姆！请开心地和我说这件事。]`);
        } else if (e.target.id === 'feed-pet-btn') {
            if (contact.gold_coins >= 5) {
                contact.gold_coins -= 5;
                await updatePetStats('hunger', 20, contact);
                renderPet(contact);
                batchedPetActions.push(`你喂食了它`);
                triggerPetAnimation('blush');
            } else {
                alert('金币不足！快去打工吧！');
            }
        } else if (e.target.id === 'play-pet-btn') {
            await updatePetStats('happiness', 20, contact);
            renderPet(contact);
            batchedPetActions.push(`你陪它玩耍了`);
            triggerPetAnimation('jiggle');
        } else if (e.target.id === 'clean-pet-btn') {
            await updatePetStats('cleanliness', 40, contact);
            renderPet(contact);
            batchedPetActions.push(`你帮它打扫干净了`);
        } else if (e.target.id === 'work-pet-btn') {
            contact.pet.workFinishTimestamp = Date.now() + (1000 * 60 * 60); // 1 hour
            await kokoMemory.put('contacts', contact);
            renderPet(contact);
            setTimeout(async () => {
                const currentContact = await kokoMemory.get('contacts', contact.id);
                if (currentContact && currentContact.pet) {
                    currentContact.gold_coins += 50;
                    currentContact.pet.workFinishTimestamp = null;
                    await kokoMemory.put('contacts', currentContact);
                    state.contacts = await kokoMemory.getAll('contacts');
                    await createAndAddMessage({
                        type: 'system_notification',
                        sender: 'system',
                        content: `你们的史莱姆'${currentContact.pet.name}'打工回来啦！赚了50金币！`
                    });
                    if (state.activeChatId === currentContact.id && document.getElementById('char-profile-screen').style.display === 'flex') {
                        renderPet(currentContact);
                    }
                }
            }, 1000 * 60 * 60);
        } else if (e.target.id === 'view-memory-album-btn' || e.target.closest('#view-memory-album-btn')) {
            showMemoryAlbum(contact);
        } else if (e.target.id === 'pet-name') {
            const newName = await showCustomPrompt('给你的史莱姆起一个新名字吧：', contact.pet.name);
            if (newName && newName.trim()) {
                contact.pet.name = newName.trim();
                await kokoMemory.put('contacts', contact);
                renderPet(contact);
            }
        }
    });
    document.getElementById('edit-char-name-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const newName = await showCustomPrompt('设置备注名', contact.name);
        if (newName !== null && newName.trim() !== '') {
            contact.name = newName.trim();
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
            document.getElementById('chat-contact-name').textContent = contact.name;
            await renderContacts();
        }
    });
    document.getElementById('edit-char-signature-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const newSignature = await showCustomPrompt('设置签名', contact.signature || '');
        if (newSignature !== null) {
            contact.signature = newSignature.trim();
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
        }
    });

    // --- 原有功能：我的资料页编辑按钮 ---
    document.querySelectorAll('.profile-details .edit-btn[data-field]').forEach(button => {
        button.addEventListener('click', async function() {
            const field = this.dataset.field;
            const currentValue = state.myProfile[field];
            const title = `修改 ${fieldNameToChinese(field)}`;
            const newValue = await showCustomPrompt(title, currentValue);
            if (newValue !== null) {
                state.myProfile[field] = newValue.trim();
                renderMyProfile();
                await kokoMemory.put('myProfile', state.myProfile);
            }
        });
    });
    document.getElementById('edit-status-btn').addEventListener('click', async () => {
        const currentStatus = state.myProfile.status;
        const newStatus = await showCustomPrompt('修改我的状态', currentStatus);
        if (newStatus !== null) {
            state.myProfile.status = newStatus.trim();
            await kokoMemory.put('myProfile', state.myProfile);
            renderMyProfile();
        }
    });
    document.getElementById('initialize-app-btn').addEventListener('click', async function() {
        const confirmed = await showCustomConfirm('初始化应用', '警告：这会清空所有保存的数据（联系人、世界书、论坛帖子、API设置等）并恢复到初始状态。确定要继续吗？', true);
        if (confirmed) {
            await kokoMemory.deleteDatabase();
            window.location.reload();
        }
    });
  // ==========================================================
    // =========== ▼▼▼ 购物中心事件连接 V3 ▼▼▼ ===================
    // ==========================================================
    document.getElementById('shopping-center-btn').addEventListener('click', showShoppingScreen);
    // 新增：为购物中心主页的返回按钮添加事件
document.getElementById('back-from-shopping').addEventListener('click', showDiscoverScreen);
    // V3新增：详情页返回按钮的事件连接
document.getElementById('back-from-product-detail').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('shopping-screen').style.display = 'flex';
});


    document.getElementById('shopping-tabs-container').addEventListener('click', async (e) => {
        if (e.target.classList.contains('feed-tab-btn')) {
            activeShoppingTab = e.target.dataset.tab;
            renderShoppingTabs();
            // V3改动：切换标签页时，优先从数据库加载
            const savedProducts = await kokoMemory.get('userSettings', 'shopping_products_' + activeShoppingTab);
            if (savedProducts && savedProducts.data.length > 0) {
                renderProducts(savedProducts.data);
            } else {
                 const productList = document.getElementById('product-list');
                productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">这里空空如也~<br>请点击右上角的刷新按钮生成商品</div>`;
            }
        }
    });

    document.getElementById('refresh-products-btn').addEventListener('click', () => refreshProductsAI(false));
    document.getElementById('product-search-btn').addEventListener('click', () => refreshProductsAI(true));
    document.getElementById('product-search-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            refreshProductsAI(true);
        }
    });

    // V3改动：事件委托现在需要处理两种点击：分享和进入详情
    document.getElementById('product-list').addEventListener('click', (e) => {
        const productItem = e.target.closest('.product-item');
        if (!productItem) return;

        const productData = JSON.parse(productItem.dataset.product);

        // 如果点击的是分享按钮
        if (e.target.closest('.product-share-btn')) {
            e.stopPropagation(); // 阻止事件冒泡触发详情页
            openShareProductModal(productData);
        } else { // 否则就是点击卡片本身，进入详情
            showProductDetailScreen(productData);
        }
    });
    
    // V3新增：详情页底部分享按钮的事件
    document.getElementById('share-from-detail-btn').addEventListener('click', () => {
        // currentProductData 已在 showProductDetailScreen 中被赋值
        if (currentProductData) {
            openShareProductModal(currentProductData);
        }
    });

    // 分享弹窗的按钮事件 (不变)
    document.getElementById('close-share-product-modal').addEventListener('click', () => {
        document.getElementById('share-product-modal').style.display = 'none';
    });
    document.getElementById('gift-product-btn').addEventListener('click', () => {
    const selectedRadio = document.querySelector('input[name="share-recipient"]:checked');
    if (!selectedRadio) {
        return alert('请先选择一位要分享的联系人！');
    }
    handleShareProduct('gift', selectedRadio.value);
});

document.getElementById('request-payment-btn').addEventListener('click', () => {
    const selectedRadio = document.querySelector('input[name="share-recipient"]:checked');
    if (!selectedRadio) {
        return alert('请先选择一位要分享的联系人！');
    }
    handleShareProduct('request_payment', selectedRadio.value);
});


    // ==========================================================
    // ==========================================
// 🎮 虚拟伴侣事件绑定 (No-Onclick Version)
// ==========================================

// 1. 专注控制
document.getElementById('cp-btn-start').addEventListener('click', cpStartFocus);
document.getElementById('cp-btn-stop').addEventListener('click', cpStopFocus);

// 2. 设置面板开关
document.getElementById('cp-settings-btn').addEventListener('click', () => {
    document.getElementById('cp-settings-panel').style.display = 'flex';
});
document.getElementById('cp-close-settings-btn').addEventListener('click', () => {
    document.getElementById('cp-settings-panel').style.display = 'none';
});

// 3. 编辑模式与热区操作
document.getElementById('cp-btn-enter-edit').addEventListener('click', cpEnterEditMode);
document.getElementById('cp-btn-save-edit').addEventListener('click', cpExitEditMode);

document.getElementById('cp-btn-del-zone').addEventListener('click', cpDeleteCurrentZone);

// 监听滑块和输入框的实时变化
document.getElementById('cp-zone-size').addEventListener('input', cpUpdateCurrentZone);
document.getElementById('cp-zone-name').addEventListener('input', cpUpdateCurrentZone);

// ==========================================
// 🎨 立绘上传逻辑升级版 (支持 URL / GIF)
// ==========================================

const uploadTypes = ['normal', 'shy', 'angry', 'happy'];

uploadTypes.forEach(type => {
    const boxId = `cp-upload-box-${type}`;
    const fileInputId = `cp-file-${type}`;
    
    const box = document.getElementById(boxId);
    
    if (box) {
        // 1. 克隆节点：清除旧的监听器，防止重复绑定或冲突
        const newBox = box.cloneNode(true);
        box.parentNode.replaceChild(newBox, box);
        
        // 2. 绑定新的点击事件
        newBox.addEventListener('click', async (e) => {
            // 防止点击 input 自身导致死循环
            if (e.target.tagName === 'INPUT') return;
            
            // 弹出选择框
            const useUrl = await showCustomConfirm(
                "设置立绘来源", 
                "请选择图片方式：\n\n🔹 点击【确定】：输入网络链接 (支持 GIF 动图)\n🔸 点击【取消】：上传本地图片", 
                false // 样式：蓝色确认按钮
            );

            if (useUrl) {
                // --- 方式 A: 输入 URL / GIF ---
                const url = await showCustomPrompt("输入图片地址", "请粘贴以 http 开头的图片或 GIF 链接");
                
                if (url && url.trim()) {
                    // 1. 更新配置
                    cpConfig.images[type] = url.trim();
                    
                    // 2. 自动保存设置 (写入数据库)
                    await cpSaveSettings(); 
                    
                    // 3. 刷新小方块预览
                    updateCpImagePreviews();
                    
                    // 4. 如果改的是【常态】，立即刷新大立绘
                    if(type === 'normal') {
                        document.getElementById('cp-character').style.backgroundImage = `url('${url.trim()}')`;
                    }
                    
                    alert("GIF/图片链接设置成功！");
                }
            } else {
                // --- 方式 B: 本地上传 (触发隐藏的 input) ---
                document.getElementById(fileInputId).click();
            }
        });

        // 3. 重新绑定文件上传监听 (因为 input 也是盒子的一部分，被克隆重置了)
        const newInput = document.getElementById(fileInputId);
        newInput.addEventListener('change', (e) => {
            cpHandleImageUpload(e, type);
        });
    }
});
// 5. 生成台词与保存设置
document.getElementById('cp-btn-gen-dialogue').addEventListener('click', cpGenerateAllDialogues);
document.getElementById('cp-btn-save-settings').addEventListener('click', cpSaveSettings);

// 6. 热区点击 (背景) - 之前在 HTML 里写了 onclick="...", 现在要在 JS 里补上
// 如果你已经有了下面这段代码，请确认它的 ID 对不对
document.getElementById('cp-zone-container').addEventListener('click', (e) => {
    if (!cpIsEditing) return;
    // 只有直接点击背景（而不是点击已有的圈圈）才添加新圈
    if (e.target.id === 'cp-zone-container') {
        const rect = e.target.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        
        const newZone = {
            id: Date.now(), x, y, size: 15, name: "新部位", lines: []
        };
        cpConfig.zones.push(newZone);
        cpSelectedZoneId = newZone.id;
        cpRenderZones();
        cpUpdateEditorUI();
    }
});

// 7. 入口和返回 (这部分可能你已经有了，确认一下)
document.getElementById('open-companion-btn').addEventListener('click', async () => {
    hideAllScreens();
    document.getElementById('companion-screen').style.display = 'flex';
    await initCompanionApp();
});

document.getElementById('back-from-companion').addEventListener('click', () => {
    if(cpFocusTimer) {
        if(!confirm("专注计时器正在运行，退出将停止计时。确定退出吗？")) return;
        clearInterval(cpFocusTimer);
        cpResetFocusUI();
    }
    document.getElementById('companion-screen').style.display = 'none';
    document.getElementById('investment-center-screen').style.display = 'flex';
});
    // =========== ▲▲▲ 购物中心事件连接 END ▲▲▲ =================
    // ==========================================================

    // --- 原有功能：各类弹窗的逻辑 ---
    document.getElementById('add-contact-btn').addEventListener('click', () => {
        document.getElementById('add-contact-modal').style.display = 'flex';
    });
    document.getElementById('close-contact-modal').addEventListener('click', () => {
        document.getElementById('add-contact-modal').style.display = 'none';
    });
    document.getElementById('save-contact-btn').addEventListener('click', async () => {
        const name = document.getElementById('contact-name-input').value.trim();
        const persona = document.getElementById('contact-persona-input').value.trim();
        if (!name || !persona) return alert('请填写姓名和人设');
        const avatar = document.getElementById('contact-avatar-input').value.trim();
        const selectedBooks = Array.from(document.getElementById('world-book-select').selectedOptions).map(opt => opt.value);
        // ...
const newContact = {
    id: 'contact_' + Date.now(),
    name: name,
    persona: persona,
    avatar: avatar || `https://s21.ax1x.com/2025/11/09/pZ9FrMd.png`,
    voiceId: '',
    worldBooks: JSON.parse(JSON.stringify(selectedBooks)),
    isPinned: false,
    groupId: null,
    history: [],
    diary: [],
    userPersona: '',
    thoughtPreset: '',
    signature: '',
    isNarrativeMode: false,
    apiCallCounter: 0,
    pet: null,
    gold_coins: 50,
    memories: [],
    isChatPetVisible: false,
    sharedPlaylist: {
        tracks: [],
        currentIndex: 0,
        playbackMode: 'list',
        isPlaying: false
    },
    totalListenTime: 0,
    firstChatDate: Date.now(),
    
    // ▼▼▼ 在这里添加下面这两行新代码 ▼▼▼
    schedule: [], // 存放你的日程表
    events: [],    // 存放重要的日子（纪念日、生理期等）
    // ▲▲▲ 添加结束 ▲▲▲
    blockedStatus: 'none'
};
// ...
        state.contacts.push(newContact);
        await kokoMemory.put('contacts', newContact);
        await renderContacts();
        document.getElementById('add-contact-modal').style.display = 'none';
    });
// (替换) 'save-contact-settings-btn' 监听器 (在 attachEventListeners 中)
document.getElementById('save-contact-settings-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const oldNarrativeModeState = contact.isNarrativeMode;
    
    contact.persona = document.getElementById('char-mask-textarea').value;
    contact.userPersona = document.getElementById('user-mask-textarea').value;
    contact.thoughtPreset = document.getElementById('thought-preset-select').value;
    contact.customUserName = document.getElementById('custom-user-name-input').value.trim() || null;

    // ▼▼▼ 核心修复点在这里 ▼▼▼
    // 1. (聊天) 只查找 #world-book-selector-list 内部的勾选
    contact.worldBooks = Array.from(document.querySelectorAll('#world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);
    
    // 2. (窥探) 只查找 #snoop-world-book-selector-list 内部的勾选
    contact.snoopRelevantWorldBookIds = Array.from(document.querySelectorAll('#snoop-world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);
    // ▲▲▲ 修复结束 ▲▲▲

    const newNarrativeModeState = document.getElementById('narrative-mode-toggle').checked;
    contact.isNarrativeMode = newNarrativeModeState;
    contact.isTimeAware = document.getElementById('time-awareness-toggle').checked;
    contact.isAvatarHidden = document.getElementById('hide-avatar-toggle').checked;
    contact.mapId = document.getElementById('contact-map-select').value;
    contact.customBubbleCss = document.getElementById('contact-bubble-css-input').value.trim() || null;
    contact.voiceProvider = document.getElementById('char-voice-provider-select').value;
    contact.voiceId = document.getElementById('char-voice-id-input').value.trim();
    // ▼▼▼ 在这里粘贴下面2行新代码 ▼▼▼
    contact.userVoiceProvider = document.getElementById('user-voice-provider-select').value;
    contact.userVoiceId = document.getElementById('user-voice-id-input').value.trim();
    // ▲▲▲ 粘贴结束 ▲▲▲

    if (oldNarrativeModeState === true && newNarrativeModeState === false) {
        contact.needsNarrativeModeExitPrompt = true;
    }
    // ▼▼▼ 【新增】保存表情分组配置 ▼▼▼
    const selectedEmoGroups = Array.from(
        document.querySelectorAll('#contact-emo-group-list .emo-group-check:checked')
    ).map(cb => cb.value);
    
    // 如果用户啥都没选，为了防止AI报错，强制给一个 'default'
    if (selectedEmoGroups.length === 0) {
        contact.allowedEmoticonGroups = ['default'];
    } else {
        contact.allowedEmoticonGroups = selectedEmoGroups;
    }
    // ▲▲▲ 新增结束 ▲▲▲
    await kokoMemory.put('contacts', contact);
    document.getElementById('contact-settings-screen').style.display = 'none';
    showCharProfileScreen();
    alert('联系人设置已保存！');
});
    document.getElementById('select-user-persona-preset').addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('user-mask-textarea').value = preset ? preset.description : '';
    });
    document.getElementById('fetch-models-btn').addEventListener('click', (e) => {
        const apiKey = document.getElementById('api-key-input').value;
        const endpoint = document.getElementById('api-endpoint-input').value.trim();
        fetchModels(endpoint, apiKey, document.getElementById('model-select'), e.currentTarget);
    });
    document.getElementById('fetch-square-models-btn').addEventListener('click', (e) => {
        const apiKey = document.getElementById('square-api-key-input').value;
        const endpoint = document.getElementById('square-api-endpoint-input').value.trim();
        fetchModels(endpoint, apiKey, document.getElementById('square-model-select'), e.currentTarget);
    });
document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
    state.apiSettings.apiKey = document.getElementById('api-key-input').value;
    state.apiSettings.model = document.getElementById('model-select').value;
    state.apiSettings.endpoint = document.getElementById('api-endpoint-input').value.trim();
    state.apiSettings.contextLength = parseInt(document.getElementById('context-length-input').value, 10) || 20;
    state.apiSettings.longTermMemoryLength = parseInt(document.getElementById('long-term-memory-length-input').value, 10) || 30;

    // ▼▼▼ 新增这两行 ▼▼▼
    state.apiSettings.minimaxGroupId = document.getElementById('minimax-group-id-input').value.trim();
    state.apiSettings.minimaxApiKey = document.getElementById('minimax-api-key-input').value.trim();
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增这一行 ▼▼▼
state.apiSettings.siliconflowApiKey = document.getElementById('siliconflow-api-key-input').value.trim();
// ▼▼▼ 新增：保存温度和Token ▼▼▼
    // 温度是小数，用 parseFloat；Token是整数，用 parseInt
    const tempInput = document.getElementById('api-temperature-input').value;
    state.apiSettings.temperature = tempInput === '' ? null : parseFloat(tempInput);

    const tokenInput = document.getElementById('api-max-tokens-input').value;
    state.apiSettings.maxTokens = tokenInput === '' ? null : parseInt(tokenInput, 10);
    // ▲▲▲ 新增结束 ▲▲▲

    await kokoMemory.put('apiSettings', {
        id: 'main',
        ...state.apiSettings
    });
    alert('聊天API设置已保存！');
    showDiscoverScreen();
});
// ✨✨✨ 这是修复后的新代码，请复制并替换上面那段旧代码 ✨✨✨
document.getElementById('save-square-api-settings-btn').addEventListener('click', async () => {
    // --- 1. 【新增】保存论坛专用的API设置 ---
    state.squareApiSettings.apiKey = document.getElementById('square-api-key-input').value;
    state.squareApiSettings.endpoint = document.getElementById('square-api-endpoint-input').value.trim();
    state.squareApiSettings.model = document.getElementById('square-model-select').value;
    await kokoMemory.put('squareApiSettings', { id: 'main', ...state.squareApiSettings });

    // --- 2. 读取用户输入的风格、世界观等设置 ---
    const newSettings = {
        personaId: document.getElementById('forum-persona-select').value,
        worldBookIds: Array.from(document.querySelectorAll('#forum-worldbook-list .world-book-checkbox:checked')).map(cb => cb.value),
        styleDescription: document.getElementById('forum-style-description').value.trim(),
        allowedPosterIds: Array.from(document.querySelectorAll('#forum-allowed-posters-list .poster-checkbox:checked')).map(cb => cb.value)
    };

    // --- 3. 检查与当前设置是否有变化 (这部分逻辑不变) ---
    const currentSettings = state.forumSettings;
    const isChanged = JSON.stringify(newSettings.worldBookIds.sort()) !== JSON.stringify((currentSettings.worldBookIds || []).sort()) ||
                    newSettings.styleDescription !== (currentSettings.styleDescription || '');

    // --- 4. 根据是否变化，执行存档逻辑 (这部分逻辑不变) ---
    if (isChanged && state.activeForumArchiveId === 'default' && state.posts.some(p => p.archiveId === 'default')) {
        const userChoice = await showCustomConfirm(
            '世界观已变更',
            '检测到核心世界观已修改。是否要将当前论坛存档，并开启一条新的世界线？\n\n- 选择【确定】将存档并开启新世界。\n- 选择【取消】将仅覆盖当前设定。',
            false
        );

        if (userChoice) { 
            const archiveName = await showCustomPrompt('为当前世界线命名', `存档 ${new Date().toLocaleDateString()}`);
            if (archiveName) {
                const newArchive = {
                    id: 'archive_' + Date.now(),
                    name: archiveName,
                    timestamp: Date.now(),
                    settings: JSON.parse(JSON.stringify(currentSettings))
                };
                state.forumArchives.push(newArchive);
                await kokoMemory.put('forumArchives', newArchive);
                const defaultPosts = state.posts.filter(p => p.archiveId === 'default');
                defaultPosts.forEach(p => p.archiveId = newArchive.id);
                await kokoMemory.bulkPut('posts', defaultPosts);
                state.trendingTopics = [];
                await kokoMemory.clear('trendingTopics');
                alert(`存档“${archiveName}”创建成功！即将开启新世界线...`);
            }
        }
    }

    // --- 5. 无论如何，都应用并保存新的风格设置 (这部分逻辑不变) ---
    state.forumSettings = { ...currentSettings, ...newSettings };
    await kokoMemory.put('forumSettings', { id: 'main', ...state.forumSettings });

    alert('论坛API及风格设置已保存！');
    showDiscoverScreen();
});
        
    document.getElementById('add-world-book-btn').addEventListener('click', () => {
        editingBookId = null;
        updateCategoryDatalist();
        document.getElementById('world-book-modal-title').textContent = '添加世界书';
        document.getElementById('book-name-input').value = '';
        document.getElementById('book-content-input').value = '';
        document.getElementById('add-world-book-modal').style.display = 'flex';
    });
    document.getElementById('close-world-book-modal').addEventListener('click', () => {
        document.getElementById('add-world-book-modal').style.display = 'none';
    });
    // ✨✨✨ 用这个新版本，完整替换旧的 save-world-book-btn 事件监听函数 ✨✨✨

    document.getElementById('save-world-book-btn').addEventListener('click', async () => {
        const name = document.getElementById('book-name-input').value.trim();
        const content = document.getElementById('book-content-input').value.trim();
        // --- 新增代码：获取分类 ---
        const category = document.getElementById('book-category-input').value.trim() || '未分类';

        if (!name || !content) return alert('请填写书名和内容');

        if (editingBookId) {
            const book = state.worldBooks.find(b => b.id === editingBookId);
            if (book) {
                book.name = name;
                book.content = content;
                book.category = category; // --- 新增代码：更新分类 ---
                await kokoMemory.put('worldBooks', book);
            }
        } else {
            const newBook = {
                id: 'book_' + Date.now(),
                name,
                content,
                category // --- 新增代码：保存分类 ---
            };
            state.worldBooks.push(newBook);
            await kokoMemory.put('worldBooks', newBook);
        }

        // 后续逻辑保持不变
        await renderWorldBooks();
        await updateWorldBookSelectors();
        document.getElementById('add-world-book-modal').style.display = 'none';

        // 重新为删除按钮绑定事件（这一行很重要，确保新渲染的元素也能被删除）
        document.querySelectorAll('.delete-world-book-btn').forEach(btn => {
            btn.addEventListener('click', deleteWorldBook);
        });
    });
// 2. (替换) “添加面具”按钮：重置表单和头像 (在 attachEventListeners 中)
document.getElementById('add-user-persona-preset-btn').addEventListener('click', () => {
    editingUserPersonaId = null;
    currentEditingPersonaAvatar = null; 
    document.getElementById('user-persona-modal-title').textContent = '添加用户面具预设';
    document.getElementById('user-persona-name-input').value = '';
    document.getElementById('user-persona-signature-input').value = ''; // <-- 新增
    document.getElementById('user-persona-description-input').value = '';
    
    const preview = document.getElementById('user-persona-avatar-preview');
    preview.src = '';
    preview.style.display = 'none';
    
    document.getElementById('user-persona-preset-modal').style.display = 'flex';
});
    document.getElementById('close-user-persona-preset-modal').addEventListener('click', () => {
        document.getElementById('user-persona-preset-modal').style.display = 'none';
    });
// 4. (替换) “保存面具”按钮：保存新头像和签名 (在 attachEventListeners 中)
document.getElementById('save-user-persona-preset-btn').addEventListener('click', async () => {
    const name = document.getElementById('user-persona-name-input').value.trim();
    const signature = document.getElementById('user-persona-signature-input').value.trim(); // <-- 新增
    const description = document.getElementById('user-persona-description-input').value.trim();
    const avatar = currentEditingPersonaAvatar; 

    if (!name || !description) return alert('请填写面具名称和描述！');
    
    if (editingUserPersonaId) {
        const preset = state.userPersonaPresets.find(p => p.id === editingUserPersonaId);
        if (preset) {
            preset.name = name;
            preset.signature = signature; // <-- 新增
            preset.description = description;
            preset.avatar = avatar; 
            await kokoMemory.put('userPersonaPresets', preset);
        }
    } else {
        const newPreset = {
            id: 'user_persona_' + Date.now(),
            name,
            signature, // <-- 新增
            description,
            avatar 
        };
        state.userPersonaPresets.push(newPreset);
        await kokoMemory.put('userPersonaPresets', newPreset);
    }
    await renderUserPersonaPresets();
    document.getElementById('user-persona-preset-modal').style.display = 'none';
});
// 4. (新增) 为新加的“上传头像”按钮添加事件
document.getElementById('upload-persona-avatar-btn').addEventListener('click', () => {
    document.getElementById('persona-avatar-uploader').click();
});

// 5. (新增) 处理头像文件选择
document.getElementById('persona-avatar-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 复用我们强大的 handleImageUpload 函数来压缩和转换图片
        const base64String = await handleImageUpload(file);

        // 显示预览
        const preview = document.getElementById('user-persona-avatar-preview');
        preview.src = base64String;
        preview.style.display = 'block';

        // 暂存 base64
        currentEditingPersonaAvatar = base64String;

    } catch (error) {
        console.error('面具头像处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空 input，以便下次能选择同一张图
    }
});
    document.getElementById('add-thought-preset-btn').addEventListener('click', () => {
        editingThoughtPresetId = null;
        document.getElementById('thought-preset-modal-title').textContent = '添加思维预设';
        document.getElementById('thought-preset-name-input').value = '';
        document.getElementById('thought-preset-prompt-input').value = '';
        document.getElementById('thought-preset-modal').style.display = 'flex';
    });
    document.getElementById('close-thought-preset-modal').addEventListener('click', () => {
        document.getElementById('thought-preset-modal').style.display = 'none';
    });
    document.getElementById('save-thought-preset-btn').addEventListener('click', async () => {
        const name = document.getElementById('thought-preset-name-input').value.trim();
        const prompt = document.getElementById('thought-preset-prompt-input').value.trim();
        if (!name || !prompt) return alert('请填写预设名称和指令！');
        if (editingThoughtPresetId) {
            const preset = state.thoughtPresets.find(p => p.id === editingThoughtPresetId);
            if (preset) {
                preset.name = name;
                preset.prompt = prompt;
                await kokoMemory.put('thoughtPresets', preset);
            }
        } else {
            const newPreset = {
                id: `tp_${Date.now()}`,
                name,
                prompt
            };
            state.thoughtPresets.push(newPreset);
            await kokoMemory.put('thoughtPresets', newPreset);
        }
        await renderThoughtPresets();
        document.getElementById('thought-preset-modal').style.display = 'none';
    });
    document.getElementById('add-emoticon-btn').addEventListener('click', () => {
        const modal = document.getElementById('add-emoticon-modal');
        const modalBody = modal.querySelector('.modal-body');
        modal.querySelector('#close-emoticon-modal').addEventListener('click', () => modal.style.display = 'none');
        modal.querySelector('.modal-title').textContent = '批量添加表情包';
        modalBody.innerHTML = `<div class="form-group"><label class="form-label">表情包列表 (每行一个)</label><textarea class="form-textarea" id="emoticon-batch-input" placeholder="支持格式:\n1. URL\n2. 名字 URL\n3. URL 名字" style="height: 180px;"></textarea></div><button class="form-button" id="save-emoticon-batch-btn">导入表情</button>`;
        modal.style.display = 'flex';
        const saveBtn = document.getElementById('save-emoticon-batch-btn');
        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
        newSaveBtn.addEventListener('click', async () => {
            const text = document.getElementById('emoticon-batch-input').value.trim();
            if (!text) return;
            const lines = text.split('\n');
            const newEmoticons = [];
            let importedCount = 0;
            lines.forEach((line, index) => {
                line = line.trim();
                if (!line) return;
                const parts = line.split(/\s+/);
                let url = '',
                    name = '';
                const urlIndex = parts.findIndex(p => p.startsWith('http'));
                if (urlIndex !== -1) {
                    url = parts[urlIndex];
                    parts.splice(urlIndex, 1);
                    name = parts.join(' ').trim();
                } else {
                    return;
                }
                if (!name) {
                    name = `表情${state.emoticons.length + newEmoticons.length + 1}`;
                }
                newEmoticons.push({
                    id: `emo_${Date.now()}_${index}`,
                    name,
                    url,
                    // ▼▼▼ 新增这一行：归入当前选中的分组 ▼▼▼
                    groupId: activeEmoticonGroupId 
                    // ▲▲▲ 新增结束 ▲▲▲
                });
                importedCount++;
            });
            if (newEmoticons.length > 0) {
                state.emoticons = [...state.emoticons, ...newEmoticons];
                await kokoMemory.bulkPut('emoticons', newEmoticons);
                await renderEmoticonLibrary();
            }
            modal.style.display = 'none';
            alert(`成功导入 ${importedCount} 个表情包！`);
        });
    });
    // ▼▼▼ 这是全新的“添加/编辑歌曲”逻辑 (修正版) ▼▼▼
            document.getElementById('add-music-btn').addEventListener('click', () => {
                const modal = document.getElementById('add-music-modal');
                // 重置表单
                document.getElementById('add-music-modal-title').textContent = '添加歌曲';
                document.getElementById('add-music-title-input').value = '';
                document.getElementById('add-music-artist-input').value = '';
                document.getElementById('add-music-url-input').value = '';
                document.getElementById('add-music-lrc-input').value = '';
                modal.style.display = 'flex';

                // 移除旧的事件监听器，防止重复绑定
                const oldSaveBtn = document.getElementById('save-music-btn');
                const newSaveBtn = oldSaveBtn.cloneNode(true); // <-- 已修正
                oldSaveBtn.parentNode.replaceChild(newSaveBtn, oldSaveBtn); // <-- 已修正

                // 为新的保存按钮添加事件
            newSaveBtn.addEventListener('click', async () => {
                const title = document.getElementById('add-music-title-input').value.trim();
                const artist = document.getElementById('add-music-artist-input').value.trim();
                const url = document.getElementById('add-music-url-input').value.trim();
                let lrcInput = document.getElementById('add-music-lrc-input').value.trim();
                
                let finalLrc = lrcInput;
                // 智能解析逻辑
                if (lrcInput.startsWith('{') && lrcInput.endsWith('}')) {
                    try {
                        const parsedData = JSON.parse(lrcInput);
                        if (parsedData && parsedData.lrc && parsedData.lrc.lyric) {
                            finalLrc = parsedData.lrc.lyric;
                            console.log("成功从JSON中提取LRC歌词！");
                        }
                    } catch (e) {
                        console.log("尝试解析歌词JSON失败，将按原文处理。");
                    }
                }

                // ▼▼▼ 在这里添加关键的修复代码 ▼▼▼
                // 将文本 "\\n" 替换为真正的换行符 "\n"
                finalLrc = finalLrc.replace(/\\n/g, '\n');
                // ▲▲▲ 修复代码结束 ▲▲▲

                if (!title || !artist || !url) {
                    alert('歌曲名、歌手和URL是必填项！');
                    return;
                }

                const newSong = {
                    id: `music_${Date.now()}`,
                    title,
                    artist,
                    url,
                    lrc: finalLrc // 使用处理后的歌词
                };

                state.musicLibrary.push(newSong);
                await kokoMemory.put('musicLibrary', newSong);
                await renderMusicLibrary();
                
                modal.style.display = 'none';
                alert(`歌曲“${title}”已成功添加到音乐库！`);
            });
            });

            document.getElementById('close-add-music-modal').addEventListener('click', () => {
                document.getElementById('add-music-modal').style.display = 'none';
            });
    document.getElementById('emoji-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const emoticonPicker = document.getElementById('emoticon-picker');
        document.getElementById('attachment-menu').classList.remove('active');
        emoticonPicker.classList.toggle('active');
        if (emoticonPicker.classList.contains('active')) {
            renderEmoticonPicker();
        }
    });
// 在 attachEventListeners 函数中...

// 新的、智能的附件按钮逻辑
document.getElementById('attachment-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return; // 安全检查

    const menu = document.getElementById('attachment-menu');

    // 基础项目：这些是所有聊天都具备的功能
    let menuHTML = `
        <div class="attachment-menu-item" data-action="send-picture">
            <div class="icon-wrapper"><i class="fas fa-image"></i></div>
            <div class="label">图片</div>
        </div>
        <div class="attachment-menu-item" data-action="upload-image">
            <div class="icon-wrapper"><i class="fas fa-upload"></i></div>
            <div class="label">上传图片</div>
        </div>
        <div class="attachment-menu-item" data-action="send-voice">
            <div class="icon-wrapper"><i class="fas fa-microphone"></i></div>
            <div class="label">语音</div>
        </div>
        <div class="attachment-menu-item" data-action="send-red-packet">
            <div class="icon-wrapper"><i class="fas fa-wallet"></i></div>
            <div class="label">红包</div>
        </div>
    `;

    // 核心判断：如果当前不是群聊（即私聊），才添加那些特殊的一对一功能
    if (!contact.isGroup) {
        menuHTML += `
            <div class="attachment-menu-item" data-action="send-transfer">
                <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
                <div class="label">转账</div>
            </div>
            <div class="attachment-menu-item" data-action="share-music">
                <div class="icon-wrapper"><i class="fas fa-music"></i></div>
                <div class="label">音乐</div>
            </div>
            <div class="attachment-menu-item" data-action="game-wheel"> <div class="icon-wrapper"><i class="fas fa-bullseye"></i></div> <div class="label">转盘游戏</div>
            </div>
            <div class="attachment-menu-item" data-action="start-video-call">
                <div class="icon-wrapper"><i class="fas fa-video"></i></div>
                <div class="label">视频通话</div>
            </div>
            <div class="attachment-menu-item" data-action="send-location"> <div class="icon-wrapper"><i class="fas fa-map-marker-alt"></i></div> <div class="label">位置</div> </div>
        `;
    } else {
        // 如果是群聊，单独添加群聊转账功能
        menuHTML += `
            <div class="attachment-menu-item" data-action="send-group-transfer">
                <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
                <div class="label">转账</div>
            </div>
        `;
    }


    menu.innerHTML = menuHTML; // 将构建好的HTML设置到菜单中

    document.getElementById('emoticon-picker').classList.remove('active');
    menu.classList.toggle('active');
});
    document.getElementById('attachment-menu').addEventListener('click', (e) => {
        const menuItem = e.target.closest('.attachment-menu-item');
        if (menuItem) {
            const action = menuItem.dataset.action;
            if (action) {
                handleAttachmentAction(action);
            }
        }
    });
    document.body.addEventListener('click', () => {
        document.getElementById('emoticon-picker').classList.remove('active');
        document.getElementById('attachment-menu').classList.remove('active');
    });
    document.getElementById('chat-screen').addEventListener('click', (e) => {
        if (!e.target.closest('#emoji-btn') && !e.target.closest('#emoticon-picker')) {
            document.getElementById('emoticon-picker').classList.remove('active');
        }
        if (!e.target.closest('#attachment-btn') && !e.target.closest('#attachment-menu')) {
            document.getElementById('attachment-menu').classList.remove('active');
        }
    });

    // --- 核心修改：聊天消息区的总事件代理 ---
    // --- 请将下面这个【完整代码块】粘贴到 attachEventListeners 函数中 ---

// 在 attachEventListeners 函数中...

// ▼▼▼ 用下面这个【最终完整无省略版】的代码块，替换掉您现有的 'chat-messages' 事件监听器 ▼▼▼
// ▼▼▼ 使用这个【最终完整版】，替换掉你现有的 'chat-messages' 事件监听器 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 逻辑1：处理回复按钮和引用跳转 (保持不变)
    const replyBtn = e.target.closest('.reply-btn');
    const quoteBox = e.target.closest('.message-quote');
    const clickedWrapper = e.target.closest('.message-wrapper');
    // ▼▼▼ 最终修复版：读取完整数据的点击逻辑 ▼▼▼
    const cpShareCard = e.target.closest('.cp-share-card');
    if (cpShareCard) {
        const wrapper = cpShareCard.closest('.message-wrapper');
        const msgId = wrapper.dataset.messageId;
        const msg = contact.history.find(m => m.id === msgId);
    
        if (msg && msg.type === 'cp_share') {
            const data = msg.content;

            // 1. 注入全局状态
            cpState.title = data.title;
            cpState.author = "历史回顾";
            cpState.targetContactId = contact.id; 
            
            document.getElementById('cp-target-avatar').src = contact.avatar;
            document.getElementById('cp-target-name').textContent = contact.name;

            // 2. 还原题目数据
            cpState.questions = data.details.map(d => {
                // ▼▼▼ 核心修复：优先读取保存的完整数据 ▼▼▼
                // 如果是旧卡片(没有options)，才使用空数组保底
                const options = d.options || []; 
                const type = d.type || ((d.userAns.includes('、')) ? 'multiple' : 'text');

                return {
                    q: d.question,
                    userAns: d.userAns,
                    aiAns: d.aiAns,
                    aiComment: "", 
                    
                    type: type,       // 使用保存的类型
                    options: options  // 使用保存的选项
                };
            });

            // 3. 切换界面
            hideAllScreens();
            document.getElementById('compatibility-screen').style.display = 'flex';
            
            // 4. 渲染
            renderCpResult();
            switchCpStep(3);
        }
        return;
    }
    // ▲▲▲ 修复结束 ▲▲▲

    if (replyBtn) {
        e.stopPropagation();
        const msgId = replyBtn.closest('.message-wrapper').dataset.messageId;
        const msgToReply = contact.history.find(m => m.id === msgId);
        if (msgToReply) {
            let contentToQuote = msgToReply.content;
            if (msgToReply.type === 'voice') contentToQuote = '[语音] ' + msgToReply.content.text;
            else if (msgToReply.type === 'picture_description') contentToQuote = '[图片]';
            else if (msgToReply.type === 'red_packet') contentToQuote = '[红包] ' + msgToReply.content.blessing;
            else if (msgToReply.type !== 'text') contentToQuote = `[${msgToReply.type}]`;
            activeReplyTarget = { ...msgToReply, content: contentToQuote.substring(0, 100) };
            showReplyPreview(activeReplyTarget);
            document.getElementById('message-input').focus();
        }
        return;
    }

    if (quoteBox) {
        e.stopPropagation();
        const quotedId = quoteBox.dataset.quotedId;
        const targetMessage = document.querySelector(`.message-wrapper[data-message-id="${quotedId}"]`);
        if (targetMessage) {
            targetMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
            targetMessage.classList.add('highlighted');
            setTimeout(() => targetMessage.classList.remove('highlighted'), 1500);
        } else {
            alert('原始消息已不在当前加载的聊天记录中。');
        }
        return;
    }
// ... (if (quoteBox) { ... return; })

// ▼▼▼ 用这段【新版】代码替换旧的 'aiRecallBubble' 逻辑 ▼▼▼
// 侦听AI撤回消息（包括“占位符”和“已揭示”两种状态）
const aiRecallPlaceholder = e.target.closest('.recall-ai-placeholder'); // 1. 灰色占位符
const aiRecallRevealed = e.target.closest('.system-notification.recall-ai-revealed'); // 2. 已点开的气泡(V4版)

if (aiRecallPlaceholder || aiRecallRevealed) {
    // 如果在编辑模式，就执行多选，不切换
    if (editModeState.active) return; 
    
    e.stopPropagation(); 
    const wrapper = e.target.closest('.message-wrapper[data-message-id]');
    if (!wrapper) return; 
    
    const msgId = wrapper.dataset.messageId;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    
    if (contact) {
        const msg = contact.history.find(m => m.id === msgId);
        if (msg) {
            // 切换状态
            msg.isRevealed = !msg.isRevealed; 
            await kokoMemory.put('contacts', contact); 
            
            // 刷新UI（这里是关键，我们不能用openChat，会跳）
            // 我们需要一种“原地刷新”的方法
            
            // 1. 记住当前的滚动位置
            const messagesContainer = document.getElementById('chat-messages');
            const currentScrollTop = messagesContainer.scrollTop;
            
            // 2. 重新渲染整个聊天
            await openChat(contact.id); 
            
            // 3. 尝试恢复滚动位置
            messagesContainer.scrollTop = currentScrollTop;
            
            // 4. 再次滚动到被点击的元素，确保它在视野内
            setTimeout(() => {
               const toggledEl = document.querySelector(`.message-wrapper[data-message-id="${msgId}"]`);
               if (toggledEl) {
                   // 优化：只有在“点开”时才滚动，"关闭"时不滚动
                   if (msg.isRevealed) {
                       toggledEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                   }
               }
            }, 50); // 稍作延迟
        }
    }
    return; // 处理完毕
}
// ▲▲▲ 替换结束 ▲▲▲

// ... (你原来的 if (recallBtn) { ... } 逻辑)
// ▼▼▼ 在这里粘贴新的 else if 代码块 ▼▼▼
const recallBtn = e.target.closest('.recall-btn');
if (recallBtn) {
    e.stopPropagation(); // 阻止事件冒泡

    const wrapper = recallBtn.closest('.message-wrapper');
    const msgId = wrapper.dataset.messageId;

    // 1. 弹窗确认
    const confirmed = await showCustomConfirm('撤回消息', '确定要撤回这条消息吗？<br><small>(AI会知道你撤回了什么哦)</small>', true);

    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        const msg = contact.history.find(m => m.id === msgId);

        if (msg) {
            // 2. "变身"：将消息标记为已撤回
            msg.isRecalled = true;
            await kokoMemory.put('contacts', contact);

            // 3. 刷新UI
            await openChat(contact.id); 
        }
    }
    return; // 处理完毕
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ... (你原来的 if (clickedWrapper) { ... } 逻辑)

    // 逻辑2：处理消息气泡本身的点击，以显示/隐藏回复按钮 (保持不变)
    if (clickedWrapper) {
        document.querySelectorAll('.message-wrapper.show-reply-btn').forEach(wrapper => {
            if (wrapper !== clickedWrapper) {
                wrapper.classList.remove('show-reply-btn');
            }
        });
        clickedWrapper.classList.toggle('show-reply-btn');
    }

    // 如果是编辑模式，则不执行后续的点击交互
    if (editModeState.active) return;

    // ... (在 chat-messages 的点击监听器内部) ...

    // 逻辑3：处理其他交互
    const postShareCard = e.target.closest('.post-share-card');
    if (postShareCard) {
        const postId = postShareCard.dataset.postId;
        const post = state.posts.find(p => p.id === postId);
        
        if (post) {
            if (post.category === 'qzone') {
                // --- 情况 A: 跳转到 Koko 空间 ---
                
                // 1. 先切换界面并渲染列表
                await showSocialZoneScreen();
                
                // 2. ✨ 核心优化：自动滚动 + 高亮特效 ✨
                // 使用 setTimeout 确保 DOM 已经渲染完毕
                setTimeout(() => {
                    const targetCard = document.getElementById(`qz-card-${postId}`);
                    
                    if (targetCard) {
                        // A. 平滑滚动到屏幕中间
                        targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // B. 添加一个临时的“高亮闪烁”特效，提示用户“就是这条”
                        // 先保存原始样式
                        const originalTransition = targetCard.style.transition;
                        const originalTransform = targetCard.style.transform;
                        const originalBoxShadow = targetCard.style.boxShadow;
                        
                        // 应用高亮样式 (放大 + 发光)
                        targetCard.style.transition = 'all 0.5s ease';
                        targetCard.style.transform = 'scale(1.02)';
                        targetCard.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.6)'; // 金色光晕
                        targetCard.style.zIndex = '10'; // 确保浮在最上面
                        
                        // 1.5秒后恢复原状
                        setTimeout(() => {
                            targetCard.style.transform = originalTransform;
                            targetCard.style.boxShadow = originalBoxShadow;
                            targetCard.style.zIndex = '';
                            // 等动画播完再恢复 transition 属性
                            setTimeout(() => {
                                targetCard.style.transition = originalTransition;
                            }, 500);
                        }, 1500);
                    }
                }, 100); // 100ms 延迟足够让列表渲染完成
                
            } else {
                // --- 情况 B: 跳转到论坛详情 ---
                showPostDetailScreen(postId);
            }
        } else {
            alert("这条内容似乎已被删除了");
        }
        return;
    }

    // ... (后面的代码保持不变) ...

    const wrapper = e.target.closest('.message-wrapper');
    if (!wrapper) return;
    const msgId = wrapper.dataset.messageId;
    const msg = contact.history.find(m => m.id === msgId);
    if (!msg) return;

    const spinButton = e.target.closest('.spin-btn');
    if (spinButton) {
        e.stopPropagation();
        if (msg && msg.type === 'game_wheel') {
            const player = spinButton.dataset.player;
            
            // 只有当点击的是“用户”按钮，且用户还没结果时才执行
            if (player === 'user' && !msg.content.results.user) {
                const wheel = msg.content;
                const weightedOptions = wheel.options.flatMap(opt => Array(opt.weight).fill(opt.text));
                const result = weightedOptions[Math.floor(Math.random() * weightedOptions.length)];
                
                // 1. 保存结果
                msg.content.results.user = result;
                await kokoMemory.put('contacts', contact);
                
                // 2. 【修复点】视觉更新：只替换按钮，或者在重写 HTML 时把名字带上
                // 这里我们使用最稳妥的方式：创建一个新元素替换掉旧按钮，不动名字
                const resultDiv = document.createElement('div');
                resultDiv.className = 'wheel-player-result';
                resultDiv.style.cssText = "background:#e3f2fd; color:#1565c0;"; // 保持样式一致
                resultDiv.textContent = result;
                
                // 直接用结果 div 替换掉按钮 DOM，这样旁边的名字 span 就不会消失了
                spinButton.replaceWith(resultDiv);
                
                // 3. 关键：发送隐形指令告诉 AI 轮到它了
                // 如果 AI 还没转，就催它转
                if (!msg.content.results.contact) {
                    const systemInstruction = `[SYSTEM: 用户刚刚玩了“${wheel.name}”游戏，转出的结果是“${result}”。现在轮到你了！请你立刻使用 [spin_wheel:1] 指令来转动转盘。]`;
                    // 这里的 true 表示强制触发 AI 回复
                    //await requestAiReply(systemInstruction);
                }
            }
        }
        return;
    }

    if (msg.type === 'music_share') {
        const card = wrapper.querySelector('.music-share-card');
        if (!card) return;
        state.musicSessionContactId = state.activeChatId;
        if (e.target.closest('.music-card-play-btn')) {
            e.stopPropagation();
            if (currentlyPlayingMsgId !== msg.id || globalAudioPlayer.paused) {
                if (currentlyPlayingMsgId !== msg.id) {
                    globalAudioPlayer.src = msg.content.url;
                    currentlyPlayingMsgId = msg.id;
                    const songIndex = contact.sharedPlaylist.tracks.findIndex(t => t.url === msg.content.url && t.title === msg.content.title);
                    if (songIndex !== -1) {
                       contact.sharedPlaylist.currentIndex = songIndex;
                       switchSong(songIndex, false);
                    }
                }
                globalAudioPlayer.play().catch(err => {
                    console.error("音频播放失败:", err);
                    alert("无法播放此音频链接。");
                });
            } else {
                globalAudioPlayer.pause();
            }
        } else {
            openMusicPlayer();
            const songIndex = contact.sharedPlaylist.tracks.findIndex(t => t.url === msg.content.url && t.title === msg.content.title);
            if (songIndex !== -1) {
                switchSong(songIndex);
            } else {
                contact.sharedPlaylist.tracks.unshift(msg.content);
                kokoMemory.put('contacts', contact);
                switchSong(0);
            }
        }
        return;
    }
const locationCard = e.target.closest('.location-share-card');
    if (locationCard) {
        const wrapper = locationCard.closest('.message-wrapper');
        const msgId = wrapper.dataset.messageId;
        const msg = contact.history.find(m => m.id === msgId);
    
        if (msg && msg.type === 'location_share') {
            const loc = msg.content;
            // ✅ 使用新的智能跳转函数
            // 注意：loc.locationId 是我们在创建消息时存进去的
            openMapAndFocusLocation(loc.mapId, loc.locationId);
        }
        return;
    }

    if (msg.type === 'red_packet') {
        let senderProfile;
        if (msg.sender === 'user') {
            senderProfile = state.myProfile;
        } else {
            senderProfile = state.contacts.find(c => c.id === msg.sender);
        }
        if (!senderProfile) senderProfile = { name: '未知用户', avatar: '' };
        showRedPacketModal(msg, senderProfile);
        return; // 处理完红包后结束
    }
    
    if (msg.type === 'transfer') {
        let senderProfile;
        if (msg.sender === 'user') {
            senderProfile = state.myProfile;
        } else {
            senderProfile = state.contacts.find(c => c.id === msg.sender);
        }
        if (!senderProfile) senderProfile = { name: '未知用户', avatar: '' };
        showTransferModal(msg, senderProfile);
        return; // 处理完转账后结束
    }

// ▼▼▼ [V-MOD 2.0] 拆分语音和图片的点击逻辑 ▼▼▼

// --- 逻辑 A: 处理 "翻转" 图片点击 ---
if (msg.type === 'picture_description') {
    e.stopPropagation(); // 阻止冒泡

    // 找到我们新创建的、带 .picture-description 类的气泡
    const bubble = wrapper.querySelector('.message.picture-description');
    if (bubble) {
        // == 你的要求：切换淡入/淡出 ==
        // 简单地切换CSS类，剩下的交给CSS去完成
        bubble.classList.toggle('description-visible');
    }
    return; // 处理完毕，结束
}

// --- 逻辑 B: 处理 "语音" 点击 (这段是你的旧逻辑，保持不变) ---
if (msg.type === 'voice') {
    const transcribedTextEl = wrapper.querySelector('.transcribed-text');
    if (!transcribedTextEl) return; // 安全检查

    const isCurrentlyVisible = transcribedTextEl.classList.contains('visible');

    // 1. 声音播放逻辑
    if (!isCurrentlyVisible) { // 只有在准备显示文字时才播放
        if (msg.sender === 'user') {
            playVoiceMessage(msg.content.text, contact, 'user').catch(err => {
                console.error("点击播放【用户】语音失败:", err.message);
            });
        } else {
            const senderProfile = state.contacts.find(c => c.id === msg.sender);
            if (senderProfile) {
                playVoiceMessage(msg.content.text, senderProfile, 'contact').catch(err => {
                    console.error("点击播放【AI】语音失败:", err.message);
                });
            }
        }
    }

    // 2. 外部文字显示/隐藏逻辑
    document.querySelectorAll('.transcribed-text.visible').forEach(el => {
        if (el !== transcribedTextEl) {
            el.classList.remove('visible');
            el.textContent = '';
        }
    });
    if (isCurrentlyVisible) {
        transcribedTextEl.classList.remove('visible');
        transcribedTextEl.textContent = '';
    } else {
        transcribedTextEl.textContent = msg.content.text;
        transcribedTextEl.classList.add('visible');
    }
}
// ▲▲▲ [V-MOD 2.0] 逻辑拆分结束 ▲▲▲
});

// ▲▲▲ 替换到这里结束 ▲▲▲
// (优化版) 确认导入 NPC 按钮逻辑
document.getElementById('confirm-import-npc-btn').addEventListener('click', async () => {
    const selectEl = document.getElementById('import-existing-npc-select');
    const selectedValue = selectEl.value;
    
    if (!selectedValue) return alert("请先选择一个 NPC");

    try {
        // 1. 解析我们打包的数据
        const payload = JSON.parse(selectedValue);
        const npcNode = payload.node;      // NPC 节点数据
        const sourceId = payload.sourceId; // 原主人 ID
        
        // 2. 获取当前正在编辑的关系网
        const currentContactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
        const currentNetwork = await kokoMemory.get('relationshipNetworks', currentContactId);
        
        // 3. 防重复检查
        if (currentNetwork.nodes.some(n => n.id === npcNode.id)) {
            return alert("该 NPC 已经在名册里了！");
        }

        // 4. 【存入节点】
        currentNetwork.nodes.push(npcNode);
        let importInfo = `成功引入 NPC：${npcNode.name}`;

        // 5. 【核心升级：尝试复刻关系连线】
        // 我们去查一下“原主人”的关系网
        const sourceNetwork = await kokoMemory.get('relationshipNetworks', sourceId);
        
        if (sourceNetwork && sourceNetwork.edges) {
            // 检查：当前关系网里，是否有“原主人”这个节点？
            // (例如：在群聊里，你是把“张三”的NPC导入到“群聊”关系网，而“张三”本人也在群聊关系网里)
            const isSourceOwnerInCurrentNet = currentNetwork.nodes.some(n => n.id === sourceId);

            if (isSourceOwnerInCurrentNet) {
                // 找到 NPC 和 原主人 之间的连线
                const originalEdge = sourceNetwork.edges.find(e => 
                    (e.source === sourceId && e.target === npcNode.id) || 
                    (e.source === npcNode.id && e.target === sourceId)
                );

                if (originalEdge) {
                    // 复制这条线！
                    currentNetwork.edges.push({
                        source: originalEdge.source,
                        target: originalEdge.target,
                        relationship: originalEdge.relationship,
                        detail: originalEdge.detail
                    });
                    importInfo += `\n并自动同步了 TA 与原主人(${state.contacts.find(c=>c.id===sourceId)?.name}) 的关系：${originalEdge.relationship}`;
                }
            }
        }

        // 6. 保存并刷新
        await kokoMemory.put('relationshipNetworks', currentNetwork);
        await renderRelationshipNetwork(currentContactId);
        await renderRelationshipGraph(currentContactId);
        
        document.getElementById('add-to-roster-modal').style.display = 'none';
        alert(importInfo);
        
    } catch (e) {
        console.error("导入 NPC 失败", e);
        alert("导入出错，请重试");
    }
});
    // 新增：点击聊天屏幕的其他地方，隐藏所有回复按钮
    document.getElementById('chat-screen').addEventListener('click', (e) => {
        if (!e.target.closest('.message-wrapper')) {
            document.querySelectorAll('.message-wrapper.show-reply-btn').forEach(wrapper => {
                wrapper.classList.remove('show-reply-btn');
            });
        }
    });

    // --- V9.0 新增: 播放器内部按钮事件 ---
    document.getElementById('player-play-btn').addEventListener('click', () => {
        if (globalAudioPlayer.paused) globalAudioPlayer.play();
        else globalAudioPlayer.pause();
    });
    document.getElementById('player-collapse-btn').addEventListener('click', () => {
        card.classList.toggle('collapsed');
        document.getElementById('player-collapse-btn').classList.toggle('fa-chevron-down');
        document.getElementById('player-collapse-btn').classList.toggle('fa-chevron-up');
    });
    // ▼▼▼ 在这里添加新的事件监听 ▼▼▼
    document.getElementById('player-close-btn').addEventListener('click', closeMusicPlayer);
    document.getElementById('player-playlist-btn').addEventListener('click', () => {
        document.getElementById('player-playlist-view').classList.toggle('active');
    });
    document.getElementById('player-mode-btn').addEventListener('click', () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const modes = ['repeat-all', 'repeat-one', 'off'];
        const icons = ['fa-repeat', 'fa-1', 'fa-power-off'];
        const titles = ['列表循环', '单曲循环', '播放完暂停'];
        let currentIndex = modes.indexOf(contact.sharedPlaylist.playbackMode || 'repeat-all');
        currentIndex = (currentIndex + 1) % modes.length;
        contact.sharedPlaylist.playbackMode = modes[currentIndex];
        const modeBtn = document.getElementById('player-mode-btn');
        modeBtn.className = `fas ${icons[currentIndex]} player-control-btn`;
        modeBtn.title = titles[currentIndex];
        kokoMemory.put('contacts', contact);
    });
    document.getElementById('player-next-btn').addEventListener('click', () => switchSong(currentSongIndex + 1, true, true));
document.getElementById('player-prev-btn').addEventListener('click', () => switchSong(currentSongIndex - 1, true, true));
    document.getElementById('player-progress-bar').addEventListener('click', function(e) {
        if (globalAudioPlayer.duration) {
            const rect = this.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            globalAudioPlayer.currentTime = (clickX / rect.width) * globalAudioPlayer.duration;
        }
    });

    document.getElementById('close-send-picture-modal').addEventListener('click', () => {
        document.getElementById('send-picture-modal').style.display = 'none';
    });
    document.getElementById('close-send-voice-modal').addEventListener('click', () => {
        document.getElementById('send-voice-modal').style.display = 'none';
    });
    document.getElementById('close-send-red-packet-modal').addEventListener('click', () => {
        document.getElementById('send-red-packet-modal').style.display = 'none';
    });
    document.getElementById('close-send-transfer-modal').addEventListener('click', () => {
        document.getElementById('send-transfer-modal').style.display = 'none';
    });
    document.getElementById('close-send-music-modal').addEventListener('click', () => {
        document.getElementById('send-music-modal').style.display = 'none';
    });

   // --- 新增：为红包详情弹窗的关闭按钮绑定事件 --- 
   document.getElementById('close-red-packet-details-modal').addEventListener('click', () => { document.getElementById('red-packet-details-modal').style.display = 'none'; });
    
      // --- 原有功能：论坛事件 ---
    document.getElementById('feed-tabs-container').addEventListener('click', (e) => {
        if (e.target.classList.contains('feed-tab-btn')) {
            state.activeFeedTab = e.target.dataset.tab;
            renderFeed();
        }
    });
    document.getElementById('feed-sub-tabs-container').addEventListener('click', (e) => {
        if (e.target.classList.contains('feed-sub-tab-btn')) {
            state.activeFeedSubTab = e.target.dataset.subtab;
            renderFeed();
        }
    });
    document.getElementById('moments-content').addEventListener('click', async (e) => {
        const repostBtn = e.target.closest('.repost-btn');
        if (repostBtn) {
            e.stopPropagation();
            openRepostModal(repostBtn.dataset.postId);
            return;
        }
        const redPacketCard = e.target.closest('.forum-red-packet-card');
        if (redPacketCard) {
            e.stopPropagation();
            openForumRedPacketModal(redPacketCard.dataset.postId);
            return;
        }
        const postItem = e.target.closest('.post-item');
        const trendingItem = e.target.closest('.trending-item');
        const deleteBtn = e.target.closest('.post-delete-btn');
        if (deleteBtn) {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除帖子', '确定要删除这条帖子吗？', true);
            if (confirmed) {
                const postId = deleteBtn.dataset.postId;
                state.posts = state.posts.filter(p => p.id !== postId);
                await kokoMemory.delete('posts', postId);
                await renderFeed();
            }
            return;
        }
        if (postItem) {
            showPostDetailScreen(postItem.dataset.postId);
        } else if (trendingItem) {
    const title = trendingItem.dataset.topicTitle;
    const description = trendingItem.dataset.description;

    // 直接调用新函数，并把标题和描述都传进去
    showTrendingTopicScreen(title, description); 
}
    });
    document.getElementById('trending-topic-screen').addEventListener('click', (e) => {
        const postItem = e.target.closest('.post-item');
        if (postItem) {
            showPostDetailScreen(postItem.dataset.postId);
        }
    });
    document.getElementById('refresh-feed-btn').addEventListener('click', async () => {
        const apiConfig = getApiFor('square');
        if (!apiConfig.apiKey || !apiConfig.endpoint) {
            alert('请先在“发现 -> 论坛API设置”中配置API。');
            return;
        }
        try {
            if (state.activeFeedTab === 'trending') {
                showFeedStatus('正在刷新热搜榜...');
                await generateRandomTrendingTopicsAI();
            } else if (state.activeFeedTab === 'recommended') {
                showFeedStatus('正在刷新推荐内容...');
                await generatePostsForRecommendedTab(5);
            } else {
                showFeedStatus('正在刷新关注内容...');
                await generatePostsForRecommendedTab(2);
            }
            await renderFeed();
        } catch (e) {
            console.error("刷新失败:", e);
            alert("刷新失败: " + e.message);
        } finally {
            hideFeedStatus();
        }
    });
    const commentInput = document.getElementById('comment-input');
    commentInput.addEventListener('blur', () => {
        if (commentInput.value.trim() === '' && activeReplyTarget) {
            activeReplyTarget = null;
            commentInput.placeholder = '留下你的精彩评论吧...';
        }
    });
// (新增) 为评论区图片按钮绑定事件
        document.getElementById('add-comment-image-btn').addEventListener('click', () => {
            document.getElementById('comment-image-uploader').click();
        });

        // (新增) 处理评论图片选择
        document.getElementById('comment-image-uploader').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
                const base64String = await handleImageUpload(file);
                pendingCommentImage = base64String;
                document.getElementById('comment-image-preview').src = base64String;
                document.getElementById('comment-image-preview-container').style.display = 'block';
            } catch (error) {
                alert('图片处理失败: ' + error.message);
            }
            e.target.value = ''; // 清空
        });

        // (新增) 移除评论预览图片
        document.getElementById('remove-comment-image-btn').addEventListener('click', () => {
            pendingCommentImage = null;
            document.getElementById('comment-image-preview').src = '';
            document.getElementById('comment-image-preview-container').style.display = 'none';
        });

        // (替换) “发送评论”按钮 (V2 - 支持图片)
        document.getElementById('submit-comment-btn').addEventListener('click', async () => {
            const input = document.getElementById('comment-input');
            const content = input.value.trim();
            
            // 核心修改：有文字 或 有图，才允许发送
            if (!content && !pendingCommentImage) return;
            
            const post = state.posts.find(p => p.id === state.activePostId);
            if (post) {
                // (你原来的 authorProfile 逻辑保持不变)
                let authorProfile;
                const personaId = state.forumSettings.personaId;
                const persona = personaId ? state.userPersonaPresets.find(p => p.id === personaId) : null;

                if (persona) {
                    authorProfile = {
                        id: 'myProfile',
                        name: persona.name,
                        avatar: persona.avatar || state.myProfile.avatar
                    };
                } else {
                    authorProfile = {
                        id: 'myProfile',
                        name: state.myProfile.name,
                        avatar: state.myProfile.avatar
                    };
                }
                // (authorProfile 逻辑结束)

                const newComment = {
                    id: `comment_${Date.now()}`,
                    author: authorProfile,
                    content,
                    image: pendingCommentImage, // ★★★ 核心新增 ★★★
                    timestamp: Date.now(),
                    replyTo: activeReplyTarget ? activeReplyTarget.name : null
                };
                
                post.comments.push(newComment);
                
                // 清空输入框、清空引用、清空图片
                input.value = '';
                activeReplyTarget = null;
                input.placeholder = '留下你的精彩评论吧...';
                pendingCommentImage = null;
                document.getElementById('comment-image-preview-container').style.display = 'none';
                
                await kokoMemory.put('posts', post);
                await renderPostDetail(); // 刷新评论区
                
                // (AI 触发逻辑保持不变)
                await triggerAiCommentDiscussion(post, newComment);
            }
        });
    document.getElementById('comments-list').addEventListener('click', async (e) => {
        const commentItem = e.target.closest('.post-comment-item');
        if (!commentItem) return;
        const deleteBtn = e.target.closest('.comment-delete-btn');
        if (deleteBtn) {
            e.stopPropagation();
            const commentId = deleteBtn.dataset.commentId;
            const confirmed = await showCustomConfirm('删除评论', '确定要删除这条评论吗？', true);
            if (confirmed) {
                const post = state.posts.find(p => p.id === state.activePostId);
                if (post) {
                    post.comments = post.comments.filter(c => c.id !== commentId);
                    await kokoMemory.put('posts', post);
                    await renderPostDetail();
                }
            }
            return;
        }
        if (!e.target.closest('a, .mention, .comment-delete-btn')) {
            const authorName = commentItem.dataset.authorName;
            const authorId = commentItem.dataset.authorId;
            if (authorId === 'myProfile') return;
            activeReplyTarget = {
                name: authorName,
                id: authorId
            };
            const commentInput = document.getElementById('comment-input');
            commentInput.placeholder = `回复 @${authorName}`;
            commentInput.focus();
        }
    });
// ▼▼▼ 步骤八：用这个【完整】的新函数替换旧的 'post-moment-btn' 监听器 ▼▼▼

    // (替换) 论坛发帖弹窗的逻辑 (V3 - 动态板块版)
    document.getElementById('post-moment-btn').addEventListener('click', () => {
        pendingPostImage = null;
        pendingForumRedPacket = null;
        const modal = document.getElementById('post-moment-modal');
        modal.style.display = 'flex';
        document.getElementById('moment-content-input').value = '';
        
        // 隐藏图片预览
        document.getElementById('post-image-preview-container').style.display = 'none';
        document.getElementById('post-image-preview').src = '';
        
        // 重置红包按钮
        const redPacketBtn = document.getElementById('add-post-red-packet-btn');
        redPacketBtn.classList.remove('active');
        
        // --- ✨ 核心改造：动态生成板块下拉菜单 ---
        const categorySelect = document.getElementById('post-category-select');
        categorySelect.innerHTML = `
            <option value="daily">日常</option>
            <option value="food">美食</option>
            <option value="gossip">八卦</option>
            <option value="horror">恐怖</option>
        `;
        // 从 state 加载自定义板块
        state.forumCategories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id; // 使用ID作为value
            option.textContent = category.name;
            categorySelect.appendChild(option);
        });
        // --- 改造结束 ---
        
        // (你原来的红包按钮克隆逻辑保持不变)
        const newRedPacketBtn = redPacketBtn.cloneNode(true);
        redPacketBtn.parentNode.replaceChild(newRedPacketBtn, redPacketBtn);
        newRedPacketBtn.addEventListener('click', () => {
            const rpModal = document.getElementById('create-forum-red-packet-modal');
            rpModal.style.display = 'flex';
            document.getElementById('close-forum-red-packet-modal').onclick = () => rpModal.style.display = 'none';
            const confirmRpBtn = document.getElementById('confirm-forum-red-packet-btn');
            const newConfirmRpBtn = confirmRpBtn.cloneNode(true);
            confirmRpBtn.parentNode.replaceChild(newConfirmRpBtn, confirmRpBtn);
            newConfirmRpBtn.addEventListener('click', () => {
                const amount = parseFloat(document.getElementById('forum-red-packet-amount-input').value);
                const count = parseInt(document.getElementById('forum-red-packet-count-input').value, 10);
                if (isNaN(amount) || amount <= 0 || isNaN(count) || count <= 0) {
                    return alert('请输入有效的金额和个数');
                }
                if (amount > state.myProfile.balance) {
                    return alert('钱包余额不足！');
                }
                pendingForumRedPacket = {
                    amount,
                    count,
                    blessing: document.getElementById('forum-red-packet-blessing-input').value.trim() || '恭喜发财，大吉大利！',
                };
                newRedPacketBtn.classList.add('active');
                rpModal.style.display = 'none';
            });
        });

        // (你原来的图片按钮逻辑保持不变)
        const addImgBtn = document.getElementById('add-post-image-btn');
        const newAddImgBtn = addImgBtn.cloneNode(true);
        addImgBtn.parentNode.replaceChild(newAddImgBtn, addImgBtn);
        newAddImgBtn.addEventListener('click', () => {
            document.getElementById('post-image-uploader').click();
        });
    });
// ▲▲▲ 替换结束 ▲▲▲

        // (新增) 处理帖子图片选择
        document.getElementById('post-image-uploader').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
                // 复用你已有的神级函数！
                const base64String = await handleImageUpload(file);
                pendingPostImage = base64String;
                // 显示预览
                document.getElementById('post-image-preview').src = base64String;
                document.getElementById('post-image-preview-container').style.display = 'block';
            } catch (error) {
                alert('图片处理失败: ' + error.message);
            }
            e.target.value = ''; // 清空
        });

        // (新增) 移除帖子预览图片
        document.getElementById('remove-post-image-btn').addEventListener('click', () => {
            pendingPostImage = null;
            document.getElementById('post-image-preview').src = '';
            document.getElementById('post-image-preview-container').style.display = 'none';
        });

        document.getElementById('close-post-moment-modal').addEventListener('click', () => {
            document.getElementById('post-moment-modal').style.display = 'none';
        });

        // (替换) 发布帖子的逻辑 (V2 - 支持图片)
        document.getElementById('publish-moment-btn').addEventListener('click', async () => {
            const content = document.getElementById('moment-content-input').value.trim();
            // 核心修改：只要有文字、有图、或有红包，就允许发送
            if (!content && !pendingForumRedPacket && !pendingPostImage) {
                return alert('请输入帖子内容、添加图片或红包！');
            }
            const category = document.getElementById('post-category-select').value;
            
            // (你原来的 authorProfile 逻辑保持不变)
            let authorProfile;
            const personaId = state.forumSettings.personaId;
            const persona = personaId ? state.userPersonaPresets.find(p => p.id === personaId) : null;

            if (persona) {
                authorProfile = {
                    id: 'myProfile', 
                    name: persona.name, 
                    avatar: persona.avatar || state.myProfile.avatar, 
                    signature: persona.signature || ''
                };
            } else {
                authorProfile = {
                    id: 'myProfile',
                    name: state.myProfile.name,
                    avatar: state.myProfile.avatar,
                    signature: state.myProfile.signature
                };
            }
            // (authorProfile 逻辑结束)

            const newPost = {
                id: 'post_' + Date.now(),
                author: authorProfile, 
                content: content || (pendingForumRedPacket ? pendingForumRedPacket.blessing : ''), // 如果没文字，用红包祝福语
                
                image: pendingPostImage, // ★★★ 核心新增 ★★★
                
                timestamp: Date.now(),
                likes: [],
                comments: [],
                reposts: 0,
                category: category,
                archiveId: state.activeForumArchiveId
            };
            
            // (你原来的红包处理逻辑保持不变)
            if (pendingForumRedPacket) {
                newPost.redPacket = { ...pendingForumRedPacket,
                    claimers: []
                };
                state.myProfile.balance -= pendingForumRedPacket.amount;
                await addTransaction('expense', pendingForumRedPacket.amount, `在论坛中发红包`, null);
                await kokoMemory.put('myProfile', state.myProfile);
                await renderMyProfile();
            }
            
            state.posts.unshift(newPost);
            await kokoMemory.put('posts', newPost);
            state.activeFeedTab = 'recommended';
            state.activeFeedSubTab = category;
            await showFeedScreen();
            document.getElementById('post-moment-modal').style.display = 'none';
        });

    document.getElementById('screen').addEventListener('click', e => {
        const mentionSpan = e.target.closest('.mention');
        if (mentionSpan) {
            e.stopPropagation();
            const userName = mentionSpan.textContent.substring(1);
            alert(`Tapped on user: @${userName}`);
        }
    });
    document.getElementById('my-wallet-btn').addEventListener('click', () => {
        hideAllScreens();
        document.getElementById('wallet-screen').style.display = 'flex';
        renderWalletScreen();
    });
    document.getElementById('back-from-wallet').addEventListener('click', showProfileScreen);

    // --- ↓↓↓ 用这个新的代码块，替换掉你原来的所有 globalAudioPlayer.addEventListener(...) 代码 ↓↓↓ ---
globalAudioPlayer.addEventListener('play', () => {
    startListenTimeTracker();
    updateUI(); 
    document.getElementById('player-avatar-stack').classList.add('is-playing');

    document.querySelectorAll('.music-share-card').forEach(card => {
        const msgId = card.closest('.message-wrapper').dataset.messageId;
        if (msgId === currentlyPlayingMsgId) {
            card.querySelector('.music-card-cover').classList.add('playing');
            card.querySelector('.music-card-play-btn i').className = 'fas fa-pause';
        } else {
            card.querySelector('.music-card-cover').classList.remove('playing');
            card.querySelector('.music-card-play-btn i').className = 'fas fa-play';
        }
    });
});

globalAudioPlayer.addEventListener('pause', () => {
    stopListenTimeTracker();
    updateUI(); 
    document.getElementById('player-avatar-stack').classList.remove('is-playing');

    document.querySelectorAll('.music-share-card').forEach(card => {
        card.querySelector('.music-card-cover').classList.remove('playing');
        card.querySelector('.music-card-play-btn i').className = 'fas fa-play';
    });
});

globalAudioPlayer.addEventListener('timeupdate', () => {
    updateUI(); 
    if (currentlyPlayingMsgId) {
        const cardWrapper = document.querySelector(`.message-wrapper[data-message-id='${currentlyPlayingMsgId}']`);
        if (cardWrapper) {
            const card = cardWrapper.querySelector('.music-share-card');
            if (card && globalAudioPlayer.duration) {
                const progress = (globalAudioPlayer.currentTime / globalAudioPlayer.duration) * 100;
                card.querySelector('.music-card-progress').style.width = `${progress}%`;
                const formatTime = (s) => new Date(s * 1000).toISOString().substr(14, 5);
                card.querySelector('.music-card-time').textContent = formatTime(globalAudioPlayer.currentTime);
            }
        }
    }
});

globalAudioPlayer.addEventListener('loadedmetadata', updateUI);

globalAudioPlayer.addEventListener('ended', async () => {
    document.getElementById('player-avatar-stack').classList.remove('is-playing');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const playlist = contact.sharedPlaylist;
    const mode = playlist.playbackMode || 'repeat-all';
    switch (mode) {
        case 'repeat-one':
            globalAudioPlayer.currentTime = 0;
            globalAudioPlayer.play();
            break;
        case 'repeat-all':
            switchSong(currentSongIndex + 1, true, true);
            break;
        case 'off':
            break;
    }
    await kokoMemory.put('contacts', contact);
});
// --- 👋 拍一拍逻辑 (纯净版：只震动+提示，不强制回复) ---
    document.getElementById('chat-messages').addEventListener('dblclick', async (e) => {
        // 1. 【防冲突】如果点击的不是头像，直接退出（交给编辑逻辑去处理）
        const avatarImg = e.target.closest('.message-avatar img');
        if (!avatarImg) return;

        e.stopPropagation(); // 阻止冒泡

        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        // 2. 视觉反馈：先震一下
        avatarImg.classList.remove('avatar-shaking');
        void avatarImg.offsetWidth;
        avatarImg.classList.add('avatar-shaking');

        // 3. 判断是谁的头像
        const wrapper = avatarImg.closest('.message-wrapper');
        const isMyAvatar = wrapper.classList.contains('sent');
        
        // 4. 弹窗询问
        const defaultSuffix = isMyAvatar ? "大腿" : "肩膀";
        const targetName = isMyAvatar ? "自己" : `"${contact.name}"`;
        
        const suffix = await showCustomPrompt(`拍一拍${targetName}`, defaultSuffix);

        if (suffix === null || suffix.trim() === "") return;
        const finalSuffix = suffix.trim();

        // 5. 生成提示文案
        let systemText = "";
        if (!isMyAvatar) {
            systemText = `你拍了拍 "${contact.name}" 的${finalSuffix}`;
        } else {
            systemText = `你拍了拍自己的${finalSuffix}`;
        }

        // 6. 发送系统提示 (这就够了，AI下次看历史记录会知道你拍过它)
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: systemText
        }, 'system', contact);

        // ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
        
        // ❌ 已删除：触发 AI 回复的代码
        // 这样它就不会烦你了，只会静静地记录下来
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
    });
// --- 双击编辑逻辑 (修正版：避开头像) ---
    const chatMessagesContainer = document.getElementById('chat-messages');
    
    // 为了防止重复绑定，先移除旧的（如果你没有用克隆节点法，这行很重要）
    // chatMessagesContainer.removeEventListener('dblclick', ...); 
    // 由于匿名函数没法移除，我们直接确保下面这段逻辑是唯一的即可。
    
    chatMessagesContainer.addEventListener('dblclick', (e) => {
        // 1. 【核心修复】如果点击的是头像区域，直接退出！让拍一拍逻辑去处理
        if (e.target.closest('.message-avatar')) {
            return; 
        }

        // 2. 如果正在进行多选编辑，则禁用双击
        if (editModeState.active) return;

        const wrapper = e.target.closest('.message-wrapper');
        if (!wrapper) return;

        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        const msgId = wrapper.dataset.messageId;
        const msg = contact.history.find(m => m.id === msgId);

        // 3. 检查消息类型是否支持编辑
        if (msg && (msg.type === 'text' || msg.type === 'html' || msg.type === 'voice')) {
            handleEditMessage(msgId); 
        }
    });
// ↓↓↓ 把这段新代码粘贴到 attachEventListeners 函数的末尾 ↓↓↓

// --- 游戏转盘弹窗逻辑 ---
document.getElementById('close-create-wheel-modal').addEventListener('click', () => {
    document.getElementById('create-wheel-modal').style.display = 'none';
});

document.getElementById('add-wheel-option-btn').addEventListener('click', () => addWheelOptionInput());

document.getElementById('confirm-send-wheel-btn').addEventListener('click', async () => {
    const wheelName = document.getElementById('wheel-name-input').value.trim();
    if (!wheelName) {
        return alert('请给你的转盘起个名字！');
    }

    const options = [];
    const optionElements = document.querySelectorAll('.wheel-option-item');
    for (const el of optionElements) {
        const text = el.querySelector('.wheel-option-text').value.trim();
        const weight = parseInt(el.querySelector('.wheel-option-weight').value, 10) || 1;
        if (text) {
            options.push({ text, weight });
        }
    }

    if (options.length < 2) {
        return alert('转盘至少需要2个有效的选项！');
    }

    await createAndAddMessage({
        type: 'game_wheel',
        content: {
            id: `wheel_${Date.now()}`,
            name: wheelName,
            options: options,
            results: { // 存储用户和AI的结果
                user: null, // 'user' 代表玩家自己
                contact: null // 'contact' 代表对方
            }
        }
    });

});
// ↑↑↑ 新增代码结束 ↑↑↑
// --- 新增：外观预设事件绑定 ---
    
    // 1. 当外观设置页面打开时，渲染下拉列表
    // (这部分逻辑需要插入到现有的 appearance-settings-btn 点击事件里)
    // 既然不好插入，我们利用事件委托或在这里补充绑定：
    const openAppearanceBtn = document.getElementById('appearance-settings-btn');
    // 我们给它加个附加的监听器，每次打开都刷新列表
    openAppearanceBtn.addEventListener('click', () => {
        renderThemePresetSelector();
    });

    // 2. 保存按钮
    document.getElementById('save-theme-preset-btn').addEventListener('click', saveCurrentThemeAsPreset);

    // 3. 下拉框选择改变 -> 应用预设
    const presetSelect = document.getElementById('theme-preset-select');
    presetSelect.addEventListener('change', (e) => {
        const val = e.target.value;
        const delBtn = document.getElementById('delete-theme-preset-btn');
        
        if (val) {
            applySelectedThemePreset(val);
            delBtn.style.display = 'block'; // 显示删除按钮
        } else {
            delBtn.style.display = 'none';
        }
    });

    // 4. 删除按钮
    document.getElementById('delete-theme-preset-btn').addEventListener('click', deleteSelectedThemePreset);
// ▼▼▼ (最终增强版) 全局折叠标题点击监听：支持联系人分组 + 世界书分类 ▼▼▼
    document.body.addEventListener('click', function(e) {
        // 使用 matches 检查点击的是不是折叠标题
        if (e.target.matches('.collapsible-title, .collapsible-title *')) {
            const title = e.target.closest('.collapsible-title');
            if (!title) return;

            // 1. 切换 UI 状态
            title.classList.toggle('collapsed');
            const isCollapsed = title.classList.contains('collapsed');

            // 2. 核心：保存状态逻辑 (IIFE 异步执行)
            (async () => {
                // --- 情况 A: 联系人分组 ---
                const groupId = title.dataset.groupId;
                if (groupId) {
                    if (groupId === 'ungrouped') {
                        // 如果是“未分组”，保存到 userSettings
                        if (!window.userSettings) window.userSettings = await kokoMemory.get('userSettings', 'main');
                        userSettings.isUngroupedCollapsed = isCollapsed;
                        await kokoMemory.put('userSettings', userSettings);
                    } else {
                        // 如果是普通分组，保存到该分组对象里
                        const group = await kokoMemory.get('contactGroups', groupId);
                        if (group) {
                            group.isCollapsed = isCollapsed;
                            await kokoMemory.put('contactGroups', group);
                        }
                    }
                }
                
                // --- 情况 B: 世界书分类 (这是新增的！) ---
                const wbCategory = title.dataset.wbCategory;
                if (wbCategory) {
                    // 读取全局设置
                    let settings = await kokoMemory.get('userSettings', 'main');
                    if (!settings) settings = { id: 'main' };
                    
                    // 初始化数组
                    if (!settings.collapsedWorldBookCategories) {
                        settings.collapsedWorldBookCategories = [];
                    }
                    
                    if (isCollapsed) {
                        // 如果折叠了，把名字加进去 (去重)
                        if (!settings.collapsedWorldBookCategories.includes(wbCategory)) {
                            settings.collapsedWorldBookCategories.push(wbCategory);
                        }
                    } else {
                        // 如果展开了，把名字移出来
                        settings.collapsedWorldBookCategories = settings.collapsedWorldBookCategories.filter(c => c !== wbCategory);
                    }
                    
                    // 保存回数据库
                    await kokoMemory.put('userSettings', settings);
                    // 同步更新内存里的 userSettings (如果存在)
                    if (window.userSettings) window.userSettings = settings;
                }
            })();

            // 3. 遍历并隐藏/显示下面的内容 (UI 响应)
            let nextElement = title.nextElementSibling;
            while (nextElement) {
                // 遇到下一个标题就停止
                if (nextElement.matches('.section-title')) {
                    break;
                }
                // 同时支持 'contact-item' (联系人) 和 'world-book-item' (世界书)
                if (nextElement.matches('.contact-item, .world-book-item')) {
                     nextElement.style.display = isCollapsed ? 'none' : '';
                }
                nextElement = nextElement.nextElementSibling;
            }
        }
    });
    // ▲▲▲ 监听器替换结束 ▲▲▲
// --- 新增：点击屏幕其他地方，关闭史莱姆快捷面板 ---
document.addEventListener('click', (e) => {
    const menu = document.getElementById('pet-quick-menu');
    const petContainer = document.getElementById('chat-pet-container');

    // 1. 确保面板和史莱姆都存在
    if (menu && petContainer) {
        
        // 2. 检查面板是否是显示状态
        if (menu.style.display === 'flex') {
            
            // 3. 核心判断：
            // 如果点击的目标【不包含在面板里】 且 【也不包含在史莱姆容器里】
            if (!menu.contains(e.target) && !petContainer.contains(e.target)) {
                menu.style.display = 'none';
            }
        }
    }
});
// --- ▲▲▲ 粘贴到这里结束 ---
// 在 attachEventListeners 函数中找到并添加这些事件
document.getElementById('lock-screen-photos-btn').addEventListener('click', showLockScreenPhotosScreen);
document.getElementById('back-from-lock-screen-photos').addEventListener('click', showDiscoverScreen);

document.getElementById('add-lock-screen-photo-btn').addEventListener('click', () => {
    document.getElementById('lock-screen-photo-uploader').click();
});

document.getElementById('lock-screen-photo-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        const base64String = await handleImageUpload(file); // 复用我们已有的图片压缩函数
        const newPhoto = {
            id: 'ls_photo_' + Date.now(),
            base64: base64String
        };
        await kokoMemory.put('lockScreenPhotos', newPhoto);
        await renderLockScreenPhotos(); // 上传后立刻刷新列表
    } catch (error) {
        console.error('上传锁屏照片失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空选择，方便下次上传
    }
});

document.getElementById('lock-screen-photos-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('emoticon-delete-btn')) {
        const photoId = e.target.dataset.photoId;
        const confirmed = await showCustomConfirm('删除照片', '确定要从锁屏相册中删除这张照片吗？', true);
        if (confirmed) {
            await kokoMemory.delete('lockScreenPhotos', photoId);
            await renderLockScreenPhotos(); // 删除后刷新
        }
    }
});
// 在 attachEventListeners 函数的末尾追加
// --- 监听贴纸上传 ---
document.getElementById('journal-sticker-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 复用图片压缩函数
        const base64 = await handleImageUpload(file);
        
        // 恢复光标并插入
        restoreSelection();
        // 自定义贴纸通常比较大，我们限制一下初始宽度
        const imgHtml = `<img src="${base64}" class="journal-sticker-img" style="width: 80px; height: auto;" contenteditable="false">`;
        document.execCommand('insertHTML', false, imgHtml);
        saveSelectionRealTime();
        
    } catch (error) {
        alert('贴纸添加失败');
    } finally {
        e.target.value = ''; // 清空
    }
});
document.getElementById('back-from-guestbook').addEventListener('click', showSocialZoneScreen);

// 打开弹窗
const openGbModal = () => {
    document.getElementById('guestbook-modal').style.display = 'flex';
    document.getElementById('guestbook-input').value = '';
    setTimeout(() => document.getElementById('guestbook-input').focus(), 100);
};
document.getElementById('gb-write-btn').addEventListener('click', openGbModal);
document.getElementById('gb-quick-input-trigger').addEventListener('click', openGbModal);

// 提交留言
document.getElementById('submit-guestbook-btn').addEventListener('click', async () => {
    const content = document.getElementById('guestbook-input').value.trim();
    if (!content) return;
    
    await addGuestbookMessage(state.myProfile, content); // 自己给自己留言
    document.getElementById('guestbook-modal').style.display = 'none';
    alert('留言成功！');
});
// --- V-新功能：日程与事件的事件监听 ---

// 资料页的入口按钮
document.getElementById('view-schedule-btn').addEventListener('click', showScheduleScreen);
document.getElementById('view-events-btn').addEventListener('click', showEventsScreen);

// 各自页面的返回按钮
document.getElementById('back-from-schedule').addEventListener('click', showCharProfileScreen);
document.getElementById('back-from-events').addEventListener('click', showCharProfileScreen);

// 添加按钮 -> 打开弹窗
document.getElementById('add-schedule-item-btn').addEventListener('click', () => openScheduleModal());
document.getElementById('add-event-item-btn').addEventListener('click', () => openEventModal());

// 弹窗的关闭按钮
document.getElementById('close-schedule-modal').addEventListener('click', () => { document.getElementById('schedule-modal').style.display = 'none'; });
document.getElementById('close-event-modal').addEventListener('click', () => { document.getElementById('event-modal').style.display = 'none'; });

// 弹窗的保存按钮
document.getElementById('save-schedule-item-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const newItem = {
        id: editingScheduleId || 'sched_' + Date.now(),
        courseName: document.getElementById('schedule-name-input').value.trim(),
        dayOfWeek: document.getElementById('schedule-day-select').value,
        startTime: document.getElementById('schedule-start-input').value,
        endTime: document.getElementById('schedule-end-input').value,
        location: document.getElementById('schedule-location-input').value.trim()
    };
    if (!newItem.courseName || !newItem.startTime || !newItem.endTime) return alert('请填写完整信息');
        // --- ▼▼▼ 在这里添加修复代码 ▼▼▼ ---
    if (!contact.schedule) {
        contact.schedule = []; // 如果篮子不存在，就先创建一个
    }
    // --- ▲▲▲ 修复代码结束 ▲▲▲
    
    if (editingScheduleId) {
        const index = contact.schedule.findIndex(i => i.id === editingScheduleId);
        contact.schedule[index] = newItem;
    } else {
        contact.schedule.push(newItem);
    }
    await kokoMemory.put('contacts', contact);
    renderSchedule();
    document.getElementById('schedule-modal').style.display = 'none';
});

document.getElementById('save-event-item-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const newItem = {
        id: editingEventId || 'event_' + Date.now(),
        eventName: document.getElementById('event-name-input').value.trim(),
        date: document.getElementById('event-date-input').value,
        type: document.getElementById('event-type-select').value,
        notes: document.getElementById('event-notes-input').value.trim()
    };
    if (!newItem.eventName || !newItem.date) return alert('请填写事件名称和日期');
       // --- ▼▼▼ 在这里添加修复代码 ▼▼▼ ---
    if (!contact.events) {
        contact.events = []; // 如果篮子不存在，就先创建一个
    }
    // --- ▲▲▲ 修复代码结束 ▲▲▲

    if (editingEventId) {
        const index = contact.events.findIndex(i => i.id === editingEventId);
        contact.events[index] = newItem;
    } else {
        contact.events.push(newItem);
    }
    await kokoMemory.put('contacts', contact);
    renderEvents();
    document.getElementById('event-modal').style.display = 'none';
});
// (粘贴到 'save-event-item-btn' 监听器的下方)

// ✨ 新增：日程表弹窗的“删除”按钮
document.getElementById('delete-schedule-item-btn').addEventListener('click', async () => {
    if (!editingScheduleId) return; // 确保我们是在编辑模式

    const confirmed = await showCustomConfirm('删除日程', '确定要删除这个日程安排吗？', true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.schedule) {
            // 1. 从数组中过滤掉这个日程
            contact.schedule = contact.schedule.filter(item => item.id !== editingScheduleId);
            // 2. 保存回数据库
            await kokoMemory.put('contacts', contact);
            // 3. 重新渲染列表
            renderSchedule();
            // 4. 关闭弹窗
            document.getElementById('schedule-modal').style.display = 'none';
            editingScheduleId = null; // 清空ID
        }
    }
});
// 使用事件委托处理列表项的点击（编辑/删除）
document.getElementById('schedule-content-list').addEventListener('click', (e) => {
    const itemEl = e.target.closest('.discover-item');
    if (itemEl) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        const itemId = itemEl.dataset.scheduleId;
        const item = contact.schedule.find(i => i.id === itemId);
        openScheduleModal(item);
    }
});

// 使用事件委托处理列表项的点击（编辑/删除/置顶） (V2版)
document.getElementById('events-content-list').addEventListener('click', async (e) => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // --- 核心修改：目标从 .discover-item 改为 .event-card ---
    const itemEl = e.target.closest('.event-card');
    if (!itemEl) return;

    const eventId = itemEl.dataset.eventId;
    const targetEvent = contact.events.find(i => i.id === eventId);
    if (!targetEvent) return;
    
    // ▼▼▼ 新增的置顶按钮逻辑 ▼▼▼
    const pinBtn = e.target.closest('.pin-event-btn');
    if (pinBtn) {
        e.stopPropagation();
        
        const isCurrentlyPinned = targetEvent.isPinned;

        // 核心逻辑：先取消所有事件的置顶
        contact.events.forEach(event => event.isPinned = false);

        // 如果刚才点击的不是一个已置顶的事件，那么就把它设为新的置顶
        if (!isCurrentlyPinned) {
            targetEvent.isPinned = true;
        }
        
        await kokoMemory.put('contacts', contact);
        renderEvents(); // 重新渲染列表，更新图钉颜色
        
        // ✨ 新增：立即更新锁屏 ✨
        await updateLockScreenWidgets(); 
        return;
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    const deleteBtn = e.target.closest('.delete-event-btn');
    if (deleteBtn) {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('删除事件', '确定要删除这个重要的日子吗？', true);
        if (confirmed) {
            contact.events = contact.events.filter(i => i.id !== eventId);
            await kokoMemory.put('contacts', contact);
            renderEvents();
            // ✨ 新增：立即更新锁屏 ✨
            await updateLockScreenWidgets(); 
        }
    // --- 核心修改：目标从 .discover-info 改为 .event-card-info ---
    } else if (e.target.closest('.event-card-info')) { 
        openEventModal(targetEvent);
    }
});
// ==========================================================
// --- 地图目录折叠/展开事件 ---
    const mapDirHeader = document.getElementById('map-directory-header');
    if (mapDirHeader) {
        mapDirHeader.addEventListener('click', () => {
            const list = document.getElementById('map-directory-list');
            const icon = document.getElementById('map-directory-toggle-icon');
            const panel = document.getElementById('map-directory-panel');

            if (list.style.display === 'none') {
                // 展开
                list.style.display = 'block';
                icon.style.transform = 'rotate(0deg)'; // 箭头指下
                panel.style.width = '160px'; // 恢复宽度
            } else {
                // 收起
                list.style.display = 'none';
                icon.style.transform = 'rotate(-90deg)'; // 箭头指左
                panel.style.width = 'auto'; // 宽度收缩，只显示标题
            }
        });
    }
// =========== ▼▼▼ 游戏中心 事件监听器 ▼▼▼ ============
// --- 事件绑定 ---
// --- 日志按钮点击事件 (JS绑定 + 防冒泡) ---
const journalBtn = document.getElementById('qz-nav-journal');
if (journalBtn) {
    journalBtn.addEventListener('click', (e) => {
        // 1. ✋ 举起盾牌：阻止事件向上传递给封面
        e.stopPropagation();
        
        // 2. 👉 执行跳转：打开手账页面
        showQzoneJournalScreen();
    });
}

// 返回按钮
document.getElementById('back-from-journal').addEventListener('click', () => {
    document.getElementById('qzone-journal-screen').style.display = 'none';
    showSocialZoneScreen(); // 返回空间主页
});

// 写手账按钮
document.getElementById('qz-write-journal-btn').addEventListener('click', openJournalEditor);

// 关闭编辑器
document.getElementById('close-journal-editor').addEventListener('click', () => {
    document.getElementById('journal-editor-modal').style.display = 'none';
});

// 关闭详情
document.getElementById('close-journal-detail').addEventListener('click', () => {
    document.getElementById('journal-detail-modal').style.display = 'none';
});

// 模板选择器点击事件
document.querySelectorAll('.paper-swatch').forEach(swatch => {
    swatch.addEventListener('click', (e) => {
        switchJournalTemplate(e.target.dataset.tmpl);
    });
});
// --- QQ空间事件 ---
    
    // 1. 入口
    document.getElementById('open-social-zone-btn').addEventListener('click', showSocialZoneScreen);
    
    // 2. 返回
    document.getElementById('back-from-social-zone').addEventListener('click', showDiscoverScreen);

// 1. 打开弹窗时清空数据
const openPostModal = () => {
    document.getElementById('qz-post-modal').style.display = 'flex';
    document.getElementById('qz-post-input').value = '';
    pendingPostImages = [];
    renderPostPreviews();
};
document.getElementById('qz-add-post-btn').addEventListener('click', openPostModal);
document.getElementById('qz-open-editor').addEventListener('click', openPostModal);

// 2. 添加真实图片 (支持多选)
document.getElementById('qz-add-img-btn').addEventListener('click', () => {
    document.getElementById('qz-img-uploader').click();
});

document.getElementById('qz-img-uploader').addEventListener('change', async (e) => {
    const files = Array.from(e.target.files);
    if (files.length === 0) return;

    // 限制总数
    const remainingSlots = 9 - pendingPostImages.length;
    const filesToProcess = files.slice(0, remainingSlots);

    for (const file of filesToProcess) {
        try {
            const base64 = await handleImageUpload(file);
            pendingPostImages.push({ type: 'real', content: base64 });
        } catch (err) {
            console.error(err);
        }
    }
    renderPostPreviews();
    e.target.value = ''; // 清空，允许重复选
});

// 3. 添加模拟图片
document.getElementById('qz-add-sim-img-btn').addEventListener('click', async () => {
    const desc = await showCustomPrompt("模拟图片", "请输入这张图片的画面描述（如：满桌的美食）");
    if (desc && desc.trim()) {
        pendingPostImages.push({ type: 'simulated', content: desc.trim() });
        renderPostPreviews();
    }
});
   
// ==========================================
// ▼▼▼ 6. 封面更换逻辑 (精准防误触版) ▼▼▼
// ==========================================

const coverImg = document.getElementById('qz-cover-img');
if (coverImg) {
    coverImg.addEventListener('click', (e) => {
        // 1. 获取被点击的具体元素
        const target = e.target;

        // 2. 检查：如果点击的是功能栏、头像、或者任何按钮，直接“拒之门外”
        if (target.closest('.qz-tab-bar') || target.closest('.qz-profile-container') || target.closest('.qz-tab-item')) {
            console.log('点击了功能区，忽略封面切换');
            return;
        }
        
        // 3. 只有点击的是“封面图本身”或者“遮罩层”时，才允许触发
        // (使用 classList.contains 或 id 判断)
        if (target.id === 'qz-cover-img' || target.classList.contains('qz-cover-overlay')) {
            document.getElementById('qz-cover-uploader').click();
        }
    });
}

// --- 处理文件选择与保存 ---
document.getElementById('qz-cover-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 1. 复用图片压缩函数转 Base64
        const base64 = await handleImageUpload(file);
        
        // 2. 立即更新界面上的背景图
        const currentCover = document.getElementById('qz-cover-img');
        if (currentCover) {
            currentCover.style.backgroundImage = `url(${base64})`;
        }
        
        // 3. 保存到全局设置对象
        if (!window.userSettings) window.userSettings = { id: 'main' };
        userSettings.socialZoneCover = base64;
        
        // 4. 写入数据库持久化保存
        await kokoMemory.put('userSettings', userSettings);
        
        alert('✨ 空间封面已更新！');

    } catch (error) {
        console.error('封面上传失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空选择，以便下次能选同一张图
    }
});
// ==========================================================
// ==========================================================
// =========== 海龟汤 游戏事件绑定 (V2-全局版) ============
// ==========================================================
    
    // 1. 游戏中心 -> 点击“海龟汤”
    document.getElementById('start-sea-turtle-btn').addEventListener('click', () => {
        // ✨ 核心修改：不再检查是否在私聊，直接打开弹窗
        openSeaTurtleModal();
    });
    
    // 2. 游戏弹窗 -> "关闭"
    document.getElementById('close-start-game-modal').addEventListener('click', () => {
        document.getElementById('start-game-modal').style.display = 'none';
    });
    
    // 3. 游戏弹窗 -> "开始游戏"
    // (使用克隆节点防止重复绑定)
    const oldConfirmStartBtn = document.getElementById('confirm-start-game-btn');
    const newConfirmStartBtn = oldConfirmStartBtn.cloneNode(true);
    oldConfirmStartBtn.parentNode.replaceChild(newConfirmStartBtn, oldConfirmStartBtn);
    newConfirmStartBtn.addEventListener('click', () => {
        // 在启动游戏前，集中获取一次所有游戏DOM元素
        cacheGameDOMElements();
        // 调用游戏的核心启动函数
        handleStartGame();
    });
// "发现" -> "游戏中心"
document.getElementById('investment-center-btn').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('investment-center-screen').style.display = 'flex';
});

// "游戏中心" -> "发现" (返回)
document.getElementById('back-from-investment-center').addEventListener('click', showDiscoverScreen);

// "游戏中心" -> 点击 "彩票站" 卡片 -> 打开彩票弹窗
document.getElementById('open-scratch-card-modal-btn').addEventListener('click', () => {
    document.getElementById('scratch-card-modal').style.display = 'flex';
    document.getElementById('scratch-result-area').style.display = 'none'; // 隐藏上次的结果
});

// "游戏中心" -> 点击 "交易所" 卡片 -> 打开交易所页面
document.getElementById('open-stock-market-btn').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('stock-market-screen').style.display = 'flex';
    startStockMarket(); // 启动模拟器
});

// "股票交易所" -> "游戏中心" (返回)
document.getElementById('back-from-stock-market').addEventListener('click', () => {
    stopStockMarket(); // 关闭模拟器
    // 返回游戏中心
    hideAllScreens();
    document.getElementById('investment-center-screen').style.display = 'flex';
});

// "股票交易所" -> 买入/卖出
document.getElementById('stock-buy-btn').addEventListener('click', () => handleStockTrade('buy'));
document.getElementById('stock-sell-btn').addEventListener('click', () => handleStockTrade('sell'));

// "刮刮乐" -> 关闭弹窗
document.getElementById('close-scratch-card-modal').addEventListener('click', () => {
    document.getElementById('scratch-card-modal').style.display = 'none';
});

// ▼▼▼ 使用这个【修正后】的事件监听器替换旧的 ▼▼▼
// "刮刮乐" -> 点击购买 (使用事件委托)
document.getElementById('scratch-card-modal').addEventListener('click', (e) => {
    const btn = e.target.closest('.buy-scratch-card-btn');
    const scratchCell = e.target.closest('.scratch-cell-player.covered');

    if (btn) {
        // --- 逻辑 1：点击了“购买”按钮 ---
        e.stopPropagation();
        purchaseScratchCard(btn.dataset.price, btn.dataset.gameType);
    
    } else if (scratchCell) {
        // --- 逻辑 2：点击了“未刮开”的格子 ---
        e.stopPropagation();
        
        // 1. 刮开这个格子
        scratchCell.classList.remove('covered');
        scratchCell.classList.add('scratched');
        
        // 2. 检查是否还有未刮开的
        const gridDisplay = scratchCell.closest('#scratch-grid-display');
        const remainingCovers = gridDisplay.querySelectorAll('.covered').length;

        // 3. 如果全部刮完了
        if (remainingCovers === 0) {
            const resultArea = document.getElementById('scratch-result-area');
            const winnings = parseFloat(resultArea.dataset.winnings || 0);
            const message = resultArea.dataset.message || "谢谢惠顾！";

            // 4. 显示最终结果信息
            document.getElementById('scratch-result-message').innerHTML = message;
            
            // 5. 如果中奖了，异步加钱并更新UI
            if (winnings > 0) {
                (async () => {
                    state.myProfile.balance += winnings;
                    await addTransaction('income', winnings, '刮刮乐中奖');
                    renderMyProfile(); // 刷新“我”页面的余额
                    await kokoMemory.put('myProfile', state.myProfile);
                })();
            }
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// --- 面包屑导航点击事件 (修复点击无反应 BUG) ---
    document.getElementById('map-breadcrumbs').addEventListener('click', (e) => {
        // 找到被点击的面包屑项
        const targetItem = e.target.closest('.breadcrumb-item');
        
        // 如果点到了，并且它有目标ID，且不是当前激活项
        if (targetItem && targetItem.dataset.targetId && !targetItem.classList.contains('active')) {
            navigateToMapLayer(targetItem.dataset.targetId);
        }
    });
// ==========================================================
// --- 监听“群聊设置”页面的点击事件 ---
document.getElementById('group-settings-screen').addEventListener('click', async (e) => {
    
// ... (在 attachEventListeners 函数中) ...
    
// ... 在 group-settings-screen 的监听器内部 ...

// --- 处理“添加NPC”按钮 (精准版：仅从本群关系网导入) ---
    if (e.target.closest('#add-npc-member-btn')) {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        
        // 1. 重置界面状态 (保持不变)
        editingGroupNpcId = null;
        document.getElementById('group-npc-name-input').value = '';
        document.getElementById('group-npc-persona-input').value = '';
        document.getElementById('group-npc-original-id').value = ''; 
        pendingNpcAvatarBase64 = null; 
        document.getElementById('group-npc-avatar-preview').style.display = 'none';
        document.querySelector('#create-npc-for-group-modal .modal-title').textContent = '为群聊添加 NPC';
        document.getElementById('confirm-create-npc-btn').textContent = '确认添加';

        // 2. 【核心修改】只读取当前群聊的关系网数据
        const importSelect = document.getElementById('group-import-npc-select');
        importSelect.innerHTML = '<option value="">-- 请选择本群关系网中的角色 --</option>';
        
        // 获取本群的图谱数据
        const groupNetwork = await kokoMemory.get('relationshipNetworks', group.id);
        
        let foundCount = 0;

        if (groupNetwork && groupNetwork.nodes) {
            groupNetwork.nodes.forEach(node => {
                // 筛选条件：
                // 1. node.isContact === false (必须是 NPC，不能是已经存在的真实联系人)
                // 2. node.id !== 'myProfile' (不能是自己)
                // 3. !alreadyInGroup (这个 NPC 还没被“激活”进群聊成员列表)
                
                // 检查是否已经在群成员列表(npcMembers)里了
                const alreadyInGroup = group.npcMembers && group.npcMembers.some(n => n.id === node.id);

                if (!node.isContact && node.id !== 'myProfile' && !alreadyInGroup) {
                    const option = document.createElement('option');
                    
                    // 构造数据包
                    const payload = {
                        ...node,
                        _sourceName: "本群图谱" // 标记来源
                    };
                    
                    option.value = JSON.stringify(payload);
                    option.textContent = node.name; // 直接显示名字，因为都是本群的
                    importSelect.appendChild(option);
                    foundCount++;
                }
            });
        }

        if (foundCount === 0) {
            importSelect.innerHTML = '<option value="">图谱里没有待激活的 NPC</option>';
        }

        // 3. 绑定下拉框事件 (保持不变，用于自动填充)
        const oldSelect = importSelect;
        const newSelect = oldSelect.cloneNode(true);
        oldSelect.parentNode.replaceChild(newSelect, oldSelect);

        newSelect.addEventListener('change', (ev) => {
            const val = ev.target.value;
            if (!val) return; 
            try {
                const npcData = JSON.parse(val);
                
                document.getElementById('group-npc-name-input').value = npcData.name || '';
                // 注意：关系网里的节点可能没有详细 persona，如果有就填，没有就空着
                document.getElementById('group-npc-persona-input').value = npcData.persona || ''; 
                
                if (npcData.avatar) {
                    pendingNpcAvatarBase64 = npcData.avatar;
                    const preview = document.getElementById('group-npc-avatar-preview');
                    preview.src = npcData.avatar;
                    preview.style.display = 'block';
                }
                
                // 关键：保留 ID，实现“激活”而非“新建”
                document.getElementById('group-npc-original-id').value = npcData.id;

            } catch (err) {
                console.error("NPC 数据解析失败", err);
            }
        });

        document.getElementById('create-npc-for-group-modal').style.display = 'flex';
    }

    // ▼▼▼ 新增：处理 NPC 列表项的点击 (进入编辑模式) ▼▼▼
    const npcRow = e.target.closest('.contact-picker-item');
    // 确保点击的是 NPC 行，且不是点击了里面的按钮（如禁言/删除）
    if (npcRow && npcRow.dataset.isNpcRow === 'true' && !e.target.closest('button')) {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        const npcId = npcRow.dataset.npcId;
        const npcData = group.npcMembers.find(n => n.id === npcId);

        if (npcData) {
            editingGroupNpcId = npcId; // 🔴 核心：设置编辑ID
            
            // 填充旧数据
            document.getElementById('group-npc-name-input').value = npcData.name;
            document.getElementById('group-npc-persona-input').value = npcData.persona;
            
            // 填充头像预览
            pendingNpcAvatarBase64 = npcData.avatar;
            const preview = document.getElementById('group-npc-avatar-preview');
            preview.src = npcData.avatar;
            preview.style.display = 'block';

            // 修改弹窗标题
            document.querySelector('#create-npc-for-group-modal .modal-title').textContent = '修改 NPC 设定';
            document.getElementById('confirm-create-npc-btn').textContent = '保存修改';

            // 打开弹窗
            document.getElementById('create-npc-for-group-modal').style.display = 'flex';
        }
    }
    // ▲▲▲ 新增结束 ▲▲▲
});
// --- 为新弹窗的“关闭”按钮添加事件 ---
document.getElementById('close-create-npc-modal').addEventListener('click', () => {
    document.getElementById('create-npc-for-group-modal').style.display = 'none';
});

// --- 为新弹窗的“确认添加”按钮添加事件 ---
const confirmNpcBtn = document.getElementById('confirm-create-npc-btn');
const newConfirmNpcBtn = confirmNpcBtn.cloneNode(true);
confirmNpcBtn.parentNode.replaceChild(newConfirmNpcBtn, confirmNpcBtn);

newConfirmNpcBtn.addEventListener('click', async () => {
    const group = state.contacts.find(c => c.id === state.activeChatId);
    if (!group) return;

    const name = document.getElementById('group-npc-name-input').value.trim();
    const persona = document.getElementById('group-npc-persona-input').value.trim();
    // 获取刚才导入时埋下的旧 ID
    const importedId = document.getElementById('group-npc-original-id').value;
    
    let avatar = pendingNpcAvatarBase64; 

    if (!name || !persona) {
        return alert('NPC的姓名和人设是必须的！');
    }

    if (!avatar) {
        avatar = `https://s21.ax1x.com/2025/11/09/pZ9FrMd.png`;
    }

    if (editingGroupNpcId) {
        // --- 🅰️ 编辑模式：更新现有 NPC ---
        const npcIndex = group.npcMembers.findIndex(n => n.id === editingGroupNpcId);
        if (npcIndex > -1) {
            group.npcMembers[npcIndex].name = name;
            group.npcMembers[npcIndex].persona = persona;
            group.npcMembers[npcIndex].avatar = avatar;
            alert('NPC 设定已更新！');
        }
    } else {
        // --- 🅱️ 新增模式：创建/导入 NPC ---
        
        // 核心逻辑：如果有导入的旧ID，就用旧的；否则生成新的
        const newId = importedId || ('npc_' + Date.now());
        
        const newNpc = {
            id: newId,
            name: name,
            persona: persona,
            avatar: avatar 
        };
        
        // 确保 npcMembers 数组存在
        if (!group.npcMembers) group.npcMembers = [];
        
        group.npcMembers.push(newNpc);
        group.members.push(newNpc.id);
        
        // 发通知
        const tempActiveChatId = state.activeChatId;
        state.activeChatId = group.id;
        
        // 如果是导入的，提示语稍微不同，显得更智能
        const actionText = importedId ? "被拉入" : "已加入";
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `NPC角色 "${name}" ${actionText}群聊`
        });
        state.activeChatId = tempActiveChatId;
    }

    // 统一保存并刷新
    await kokoMemory.put('contacts', group);
    openGroupSettingsScreen(group); // 刷新列表UI
    document.getElementById('create-npc-for-group-modal').style.display = 'none';
});

// --- 新增：处理群聊NPC头像上传 ---
document.getElementById('upload-group-npc-avatar-btn').addEventListener('click', () => {
    // 1. 触发我们刚才添加的隐藏 <input>
    document.getElementById('group-npc-avatar-uploader').click();
});

// 2. 监听文件选择
document.getElementById('group-npc-avatar-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 3. 复用你已有的、超好用的图片压缩函数！
        const base64String = await handleImageUpload(file);

        // 4. 显示预览图
        const preview = document.getElementById('group-npc-avatar-preview');
        preview.src = base64String;
        preview.style.display = 'block';

        // 5. 把图片数据暂存到全局变量
        pendingNpcAvatarBase64 = base64String;

    } catch (error) {
        console.error('NPC头像处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空input，以便下次能选同一张图
    }
});
// =========== ▲▲▲ 游戏中心 事件监听器 END ▲▲▲ ============
// --- 事件绑定 ---

// 1. 绑定“更多”按钮 (这是入口)
// 找到原来的 qz-tab-item 的更多按钮逻辑，现在我们改写它
const tabsBar = document.querySelector('.qz-tab-bar');
if (tabsBar) {
    const moreBtn = tabsBar.children[tabsBar.children.length - 1]; // 最后一个是“更多”
    // 克隆替换以去除旧的 alert 事件
    const newMoreBtn = moreBtn.cloneNode(true);
    moreBtn.parentNode.replaceChild(newMoreBtn, moreBtn);
    
    newMoreBtn.addEventListener('click', openQzoneSettings);
}

// 2. 关闭弹窗
document.getElementById('close-qz-settings').addEventListener('click', () => {
    document.getElementById('qz-settings-modal').style.display = 'none';
});

// 3. 保存按钮
// --- 保存空间设置按钮 (含白名单版) ---
document.getElementById('save-qz-settings-btn').addEventListener('click', async () => {
    if (!userSettings.qzoneSettings) userSettings.qzoneSettings = {};
    const s = userSettings.qzoneSettings;

    // 1. 基础设置
    s.nameColor = document.getElementById('qz-name-color-input').value;
    s.deviceText = document.getElementById('qz-device-input').value.trim() || 'Koko Client';
    s.svipLevel = document.getElementById('qz-svip-level-input').value;
    s.showSvip = document.getElementById('qz-svip-toggle').checked;

    // 2. 自动刷新设置
    const autoToggle = document.getElementById('qz-auto-refresh-toggle');
    const autoInput = document.getElementById('qz-auto-refresh-interval');
    if (autoToggle && autoInput) {
        s.autoRefreshEnabled = autoToggle.checked;
        let interval = parseInt(autoInput.value, 10);
        if (isNaN(interval) || interval < 30) interval = 30; 
        s.autoRefreshInterval = interval;
    }
    
    // ▼▼▼ 3. 保存发帖白名单 (核心新增) ▼▼▼
    const checkedBoxes = document.querySelectorAll('.qz-poster-check:checked');
    s.allowedPosters = Array.from(checkedBoxes).map(cb => cb.value);
    // ▲▲▲ 新增结束 ▲▲▲

    // 4. 保存到数据库
    await kokoMemory.put('userSettings', userSettings);
    
    loadQzoneSettings();

    // 应用自动刷新
    if (typeof startQzoneAutoRefresh === 'function' && typeof stopQzoneAutoRefresh === 'function') {
        if (s.autoRefreshEnabled) startQzoneAutoRefresh();
        else stopQzoneAutoRefresh();
    }

    document.getElementById('qz-settings-modal').style.display = 'none';
    alert('设置已保存！只有选中的角色才会发动态了。');
});
document.getElementById('qz-refresh-btn').addEventListener('click', (e) => {
    // 只有当按钮没在旋转时才触发 (防止狂点)
    if (!e.target.classList.contains('fa-spin')) {
        e.target.classList.add('fa-spin'); // 加个旋转动画
        generateAiQzoneFeed(true).then(() => {
            e.target.classList.remove('fa-spin'); // 停止旋转
        });
    }
});
// 4. 背景图上传
document.getElementById('upload-qz-bg-btn').addEventListener('click', () => {
    document.getElementById('qz-bg-uploader').click();
});
document.getElementById('qz-bg-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const base64 = await handleImageUpload(file); // 复用已有的压缩函数
    userSettings.qzoneSettings.pageBackground = base64;
    loadQzoneSettings(); // 预览
});
document.getElementById('reset-qz-bg-btn').addEventListener('click', () => {
    userSettings.qzoneSettings.pageBackground = '';
    loadQzoneSettings();
});

// 5. 名字颜色实时预览
document.getElementById('qz-name-color-input').addEventListener('input', (e) => {
    document.getElementById('qz-user-name').style.color = e.target.value;
});
// --- 新增：让“说说”Tab按钮也能打开写说说弹窗 ---
const statusTabBtn = document.getElementById('qz-tab-status');
if (statusTabBtn) {
    // 这里的 openPostModal 是之前定义过的打开弹窗函数
    // 如果提示找不到，请确保这段代码放在 openPostModal 定义之后
    statusTabBtn.addEventListener('click', openPostModal);
}
// --- 修复：发说说弹窗的“取消”按钮 ---
const closePostBtn = document.getElementById('qz-close-post');
if (closePostBtn) {
    // 先移除可能存在的旧监听器（防止重复绑定）
    const newCloseBtn = closePostBtn.cloneNode(true);
    closePostBtn.parentNode.replaceChild(newCloseBtn, closePostBtn);
    
    // 绑定关闭事件
    newCloseBtn.addEventListener('click', () => {
        document.getElementById('qz-post-modal').style.display = 'none';
        
        // 顺手清空一下输入框和图片，下次打开是新的
        document.getElementById('qz-post-input').value = '';
        if(typeof pendingPostImages !== 'undefined') pendingPostImages = [];
        if(typeof renderPostPreviews === 'function') renderPostPreviews();
    });
}
// ==========================================================
// --- 新增：正版认证/售后弹窗逻辑 ---
    
    // 1. 点击列表项打开弹窗
    const copyrightBtn = document.getElementById('copyright-entry-btn');
    if (copyrightBtn) {
        copyrightBtn.addEventListener('click', () => {
            document.getElementById('copyright-modal').style.display = 'flex';
        });
    }

    // 2. 关闭弹窗
    const closeCopyrightBtn = document.getElementById('close-copyright-modal');
    if (closeCopyrightBtn) {
        closeCopyrightBtn.addEventListener('click', () => {
            document.getElementById('copyright-modal').style.display = 'none';
        });
    }

    // 3. 复制群号并关闭
    const copyGroupBtn = document.getElementById('copy-group-id-btn');
    if (copyGroupBtn) {
        copyGroupBtn.addEventListener('click', () => {
            // 这里填你的群号
            const groupNumber = "482466918"; 
            
            navigator.clipboard.writeText(groupNumber).then(() => {
                alert(`群号 ${groupNumber} 已复制！\n感谢支持正版，我们在群里等你~`);
                document.getElementById('copyright-modal').style.display = 'none';
            }).catch(() => {
                alert(`请手动搜索群号：${groupNumber}\n感谢支持正版！`);
                document.getElementById('copyright-modal').style.display = 'none';
            });
        });
    }
// --- 新增：处理真实图片上传的事件 ---
document.getElementById('image-upload-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    try {
        // 调用我们刚才写的处理函数
        const base64String = await handleImageUpload(file);
        
        // 用新的消息类型发送
        await createAndAddMessage({
            type: 'uploaded_image',
            content: {
                base64: base64String
            }
        });

    } catch (error) {
        console.error('图片处理失败:', error);
        alert('图片处理失败，请稍后再试。');
    } finally {
        // 清空input的值，这样用户可以连续上传同一张图片
        e.target.value = '';
    }
});
// ==========================================================
// 1. 角色资料页的入口按钮
document.getElementById('view-relationship-network-btn').addEventListener('click', () => {
    showRelationshipScreen(state.activeChatId);
});

// 2. 关系网页面的返回按钮
document.getElementById('back-from-relationship-network').addEventListener('click', showCharProfileScreen);

// 在 attachEventListeners 函数的末尾添加：

// --- 【新增】关系网 V2.0 事件绑定 ---

// 在 attachEventListeners 函数中...

// 【修改】把原来 add-character-btn 的监听，改成 add-to-roster-btn
document.getElementById('add-to-roster-btn').addEventListener('click', () => {
    openAddToRosterModal(); // 点击后打开我们的“选择”模态框
});

// 【新增】为“选择”模态框的按钮绑定事件
document.getElementById('close-add-to-roster-modal').addEventListener('click', () => {
    document.getElementById('add-to-roster-modal').style.display = 'none';
});

// “导入选中联系人”按钮的逻辑
document.getElementById('confirm-import-contact-btn').addEventListener('click', async () => {
    const contactIdToImport = document.getElementById('import-contact-select').value;
    if (!contactIdToImport) return;

    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    const contactToImport = state.contacts.find(c => c.id === contactIdToImport);

    if (contactToImport && !networkData.nodes.some(n => n.id === contactToImport.id)) {
        // 将选中的联系人添加到nodes数组中
        networkData.nodes.push({
            id: contactToImport.id,
            name: contactToImport.name,
            avatar: contactToImport.avatar,
            isContact: true // 标记为这是一个真实联系人
        });
        await kokoMemory.put('relationshipNetworks', networkData);

        // 刷新UI并关闭模态框
        await renderRelationshipNetwork(contactId);
        await renderRelationshipGraph(contactId);
        document.getElementById('add-to-roster-modal').style.display = 'none';
    }
});

// “创建一个全新的NPC”按钮的逻辑
document.getElementById('switch-to-create-npc-btn').addEventListener('click', () => {
    document.getElementById('add-to-roster-modal').style.display = 'none'; // 先关掉选择框
    openCharacterModal(); // 再打开我们之前写的NPC创建框
});

// 角色编辑/删除（事件委托）
document.getElementById('character-list').addEventListener('click', async (e) => {
    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    
    const editBtn = e.target.closest('.edit-character-btn');
    if (editBtn) {
        const char = networkData.nodes.find(n => n.id === editBtn.dataset.charId);
        if(char) openCharacterModal(char);
    }
    const deleteBtn = e.target.closest('.delete-character-btn');
    if (deleteBtn) {
        deleteCharacter(deleteBtn.dataset.charId);
    }
});


// 角色模态框的按钮
document.getElementById('close-character-modal').addEventListener('click', () => {
    document.getElementById('character-modal').style.display = 'none';
});
document.getElementById('save-character-btn').addEventListener('click', saveCharacter);

// (新 V3) 关系列表点击（删除 或 编辑）
document.getElementById('relationship-list').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.delete-relationship-btn');
    if (deleteBtn) {
        // 逻辑 1: 点击了删除按钮
        e.stopPropagation(); // 阻止冒泡
        deleteRelationship(deleteBtn.dataset.sourceId, deleteBtn.dataset.targetId);
    } else {
        // 逻辑 2: 点击了条目本身 (preset-info)
        const infoBox = e.target.closest('.preset-info');
        if (infoBox) {
            e.stopPropagation(); // 阻止冒泡
            // ✨ 调用我们新加的函数来填充数据
            populateRelationshipEditor(infoBox.dataset);
        }
    }
});
// 在 attachEventListeners 函数的任意位置添加：

// --- 【新增】NPC头像本地上传事件绑定 ---
document.getElementById('upload-character-avatar-btn').addEventListener('click', () => {
    // 点击“上传”按钮时，去触发那个看不见的 <input type="file">
    document.getElementById('character-avatar-uploader').click();
});

document.getElementById('character-avatar-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 调用我们之前就写好的、带压缩功能的图片处理函数！完美复用！
        const base64String = await handleImageUpload(file);

        // 把处理好的图片显示在预览区
        const preview = document.getElementById('character-avatar-preview');
        preview.src = base64String;
        preview.style.display = 'block';

    } catch (error) {
        console.error('NPC头像处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        // 清空input的值，这样用户可以连续上传同一张图片
        e.target.value = '';
    }
});
// 在 attachEventListeners 函数中...
// --- 新增：回顶按钮点击事件 ---
const backToTopBtn = document.getElementById('qz-back-to-top');
if (backToTopBtn) {
    backToTopBtn.addEventListener('click', () => {
        // 让 #social-zone-screen 平滑滚动到顶部
        document.getElementById('social-zone-screen').scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });
}
// 【新增】自定义关系类型选择的事件监听
document.getElementById('relation-type-select').addEventListener('change', async function() {
    if (this.value === '自定义') {
        const customType = await showCustomPrompt('自定义关系类型', '请输入关系名称（如：师徒）');

        if (customType && customType.trim()) {
            const newType = customType.trim();

            // 检查这个新类型是否已经存在
            let optionExists = false;
            for (let i = 0; i < this.options.length; i++) {
                if (this.options[i].value === newType) {
                    optionExists = true;
                    this.value = newType; // 如果已存在，直接选中它
                    break;
                }
            }

            // 如果不存在，就创建一个新的选项并选中它
            if (!optionExists) {
                const newOption = new Option(newType, newType, true, true);
                // 插入到“自定义”选项的前面
                this.insertBefore(newOption, this.options[this.options.length - 1]);
            }
        } else {
            // 如果用户取消了输入，就恢复到第一个选项（“朋友”）
            this.value = this.options[0].value;
        }
    }
});
document.getElementById('save-relationship-btn').addEventListener('click', saveRelationship);
// =========== ▼▼▼ 论坛档案馆 - 最终修正版事件监听 ▼▼▼ =======
// ▼▼▼ 步骤六：把这段代码粘贴到 attachEventListeners() 函数【内部】 ▼▼▼

    // --- 论坛板块管理 ---
    document.getElementById('forum-category-btn').addEventListener('click', showForumCategoryScreen);
    document.getElementById('back-from-category-management').addEventListener('click', showDiscoverScreen);
    document.getElementById('add-category-btn').addEventListener('click', () => openCategoryModal());
    document.getElementById('close-category-modal').addEventListener('click', () => {
        document.getElementById('add-category-modal').style.display = 'none';
    });
    document.getElementById('save-category-btn').addEventListener('click', saveForumCategory);

    // (事件委托) 处理板块列表中的编辑和删除
    document.getElementById('category-list').addEventListener('click', (e) => {
        const editBtn = e.target.closest('.edit-category-btn');
        if (editBtn) {
            const categoryId = editBtn.closest('.preset-item').dataset.categoryId;
            const category = state.forumCategories.find(c => c.id === categoryId);
            if (category) openCategoryModal(category);
            return;
        }

        const deleteBtn = e.target.closest('.delete-category-btn');
        if (deleteBtn) {
            const categoryId = deleteBtn.closest('.preset-item').dataset.categoryId;
            deleteForumCategory(categoryId);
            return;
        }
    });

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- 新增：聊天搜索相关事件绑定 ---
    
    // 1. 点击顶栏的搜索图标 -> 打开搜索界面
    const searchChatBtn = document.getElementById('search-chat-btn');
    if (searchChatBtn) {
        searchChatBtn.addEventListener('click', showChatSearch);
    }

    // 2. 点击搜索界面里的“取消”按钮 -> 关闭搜索界面
    document.getElementById('close-search-btn').addEventListener('click', hideChatSearch);

    // 3. 监听搜索输入框的输入事件 -> 实时搜索
    const searchInput = document.getElementById('chat-search-input');
    const clearSearchBtn = document.getElementById('clear-search-btn');
    
    searchInput.addEventListener('input', (e) => {
        const keyword = e.target.value;
        // 控制清除按钮的显示/隐藏
        clearSearchBtn.style.display = keyword ? 'block' : 'none';
        // 执行搜索
        performChatSearch(keyword);
    });

    // 4. 点击清除按钮 -> 清空输入框和结果
    clearSearchBtn.addEventListener('click', () => {
        searchInput.value = '';
        clearSearchBtn.style.display = 'none';
        performChatSearch(''); // 清空结果列表
        searchInput.focus();   // 重新聚焦输入框
    });

// ==========================================================

// 1. 为“发现”页面的“档案馆”入口按钮绑定事件
document.getElementById('forum-archives-btn').addEventListener('click', async (e) => {
    e.preventDefault();
    await showForumArchivesScreen(); // 点击后打开档案馆页面
});

// 2. 为档案馆页面的“返回”按钮绑定独立的事件
document.getElementById('back-from-forum-archives').addEventListener('click', async (e) => {
    e.preventDefault();
    await showDiscoverScreen(); // 点击后返回“发现”页面
});

// 3. 使用事件委托，统一处理档案馆列表内部的所有点击操作
document.getElementById('forum-archives-list').addEventListener('click', async (e) => {
    e.preventDefault(); // 阻止默认行为

    // 检查点击的是否是“切换”按钮
    const switchBtn = e.target.closest('.switch-archive-btn');
    if (switchBtn) {
        const archiveItem = switchBtn.closest('.preset-item');
        if (archiveItem) {
            const archiveId = archiveItem.dataset.archiveId;
            // 调用我们重写过的、具备“设置恢复”功能的核心函数
            await switchForumArchive(archiveId); 
        }
        return; // 处理完后结束，避免冲突
    }

    // 检查点击的是否是“删除”按钮
    const deleteBtn = e.target.closest('.delete-archive-btn');
    if (deleteBtn) {
        const archiveItem = deleteBtn.closest('.preset-item');
        if (archiveItem) {
            const archiveId = archiveItem.dataset.archiveId;
            // 调用删除函数
            await deleteForumArchive(archiveId);
        }
    }
});
// ==========================================================
// 1. "管理"按钮点击事件
document.getElementById('manage-emoticon-btn').addEventListener('click', () => {
    isEmoEditMode = !isEmoEditMode; // 切换模式
    selectedEmoIds.clear(); // 清空选择
    
    const actionText = document.getElementById('manage-emoticon-btn');
    const actionBar = document.getElementById('emo-batch-action-bar');
    const addBtn = document.getElementById('add-emoticon-btn');
    
    if (isEmoEditMode) {
        actionText.textContent = '完成';
        actionBar.style.display = 'flex';
        addBtn.style.display = 'none'; // 编辑时不给添加
    } else {
        actionText.textContent = '管理';
        actionBar.style.display = 'none';
        addBtn.style.display = 'inline-block';
    }
    
    document.getElementById('emo-selected-count').textContent = '已选 0 项';
    renderEmoticonLibrary(); // 重新渲染以更新UI
});

// 2. "取消"按钮点击事件
document.getElementById('emo-batch-cancel-btn').addEventListener('click', () => {
    // 模拟点击一次“管理”按钮来退出
    document.getElementById('manage-emoticon-btn').click();
});

// 3. "删除"按钮点击事件 (核心逻辑)
document.getElementById('emo-batch-delete-btn').addEventListener('click', async () => {
    if (selectedEmoIds.size === 0) {
        return alert('请至少选择一个表情！');
    }
    
    const confirmed = await showCustomConfirm('批量删除', `确定要删除选中的 ${selectedEmoIds.size} 个表情包吗？`, true);
    
    if (confirmed) {
        // 从内存中删除
        state.emoticons = state.emoticons.filter(e => !selectedEmoIds.has(e.id));
        
        // 从数据库中删除 (批量)
        for (const id of selectedEmoIds) {
            await kokoMemory.delete('emoticons', id);
        }
        
        // 退出编辑模式
        document.getElementById('manage-emoticon-btn').click();
        
        // 提示成功
        alert('删除成功！');
    }
});
// =========== ▲▲▲ 论坛档案馆 - 最终修正版事件监听 END ▲▲▲ ======
// --- 把这段新代码，粘贴到 attachEventListeners 函数里 ---

// 使用事件委托，统一处理“思维预设”列表中的所有点击
document.getElementById('thought-presets-list').addEventListener('click', (event) => {
    // 检查被点击的元素是不是“编辑按钮”
    const editButton = event.target.closest('.edit-thought-preset-btn');
    if (editButton) {
        editThoughtPreset(event);
        return; 
    }

    // 检查被点击的元素是不是“删除按钮”
    const deleteButton = event.target.closest('.delete-thought-preset-btn');
    if (deleteButton) {
        deleteThoughtPreset(event);
    }
});
// ▼▼▼ 把下面这些代码，粘贴到 attachEventListeners 函数的【内部】任何位置 ▼▼▼

    // --- 自动回复功能的事件连接 ---
    document.getElementById('automation-btn').addEventListener('click', showAutomationScreen);
    document.getElementById('back-from-automation').addEventListener('click', showDiscoverScreen);
    document.getElementById('save-automation-settings-btn').addEventListener('click', saveAutomationSettings);

    // 启动一个每秒更新一次倒计时的迷你定时器
    setInterval(updateAutomationStatusIndicator, 1000);

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- 记忆核心功能逻辑 ---

// 1. 打开弹窗
document.getElementById('view-memory-core-btn').addEventListener('click', () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    
    renderMemoryCore(contact);
    document.getElementById('memory-core-modal').style.display = 'flex';
});

// 2. 关闭弹窗
document.getElementById('close-memory-core-modal').addEventListener('click', () => {
    document.getElementById('memory-core-modal').style.display = 'none';
});

// 3. 渲染列表
function renderMemoryCore(contact) {
    const listEl = document.getElementById('memory-core-list');
    const emptyState = document.getElementById('memory-empty-state');
    const usageBar = document.getElementById('memory-usage-bar');
    
    listEl.innerHTML = '';
    const memories = contact.permanent_memories || [];
    
    usageBar.textContent = `容量: ${memories.length}/20`;

    if (memories.length === 0) {
        emptyState.style.display = 'block';
    } else {
        emptyState.style.display = 'none';
        // 按时间倒序排列，最新的在上面
        [...memories].reverse().forEach(mem => {
            const item = document.createElement('div');
            item.style.cssText = "background: white; padding: 15px; border-radius: 12px; box-shadow: 0 2px 5px rgba(171, 71, 188, 0.1); position: relative; border-left: 4px solid #AB47BC;";
            
            item.innerHTML = `
                <div style="font-size: 14px; color: #333; line-height: 1.5; margin-bottom: 8px;">${mem.content}</div>
                <div style="font-size: 12px; color: #999; display: flex; justify-content: space-between; align-items: center;">
                    <span><i class="far fa-clock"></i> ${new Date(mem.timestamp).toLocaleDateString()}</span>
                    <i class="fas fa-trash-alt delete-memory-btn" data-id="${mem.id}" style="cursor: pointer; color: #ddd; transition: color 0.2s;"></i>
                </div>
            `;
            
            // 删除按钮 hover 效果
            const delBtn = item.querySelector('.delete-memory-btn');
            delBtn.onmouseover = () => delBtn.style.color = '#ff4444';
            delBtn.onmouseout = () => delBtn.style.color = '#ddd';
            
            // 绑定删除事件
            delBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                if(confirm('你确定要帮 Ta 遗忘这段记忆吗？这可能会改变 Ta 对你的态度。')) {
                    contact.permanent_memories = contact.permanent_memories.filter(m => m.id !== mem.id);
                    await kokoMemory.put('contacts', contact);
                    renderMemoryCore(contact); // 重新渲染
                }
            });
            
            listEl.appendChild(item);
        });
    }
}
// ==========================================
// 🚑 【修复补丁】史莱姆快捷面板 - 叙事模式开关监听
// ==========================================
const petNarrativeCheck = document.getElementById('pet-narrative-check');
if (petNarrativeCheck) {
    // 绑定 change 事件，当开关状态改变时触发
    petNarrativeCheck.addEventListener('change', async (e) => {
        // 1. 获取当前正在聊天的角色
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        // 2. 更新内存中的状态
        const newState = e.target.checked;
        contact.isNarrativeMode = newState;

        // 3. 立即保存到数据库 (IndexedDB)
        await kokoMemory.put('contacts', contact);

        // 4. 实时更新聊天界面的样式 (这一步很重要，让气泡样式立马生效)
        const messagesContainer = document.getElementById('chat-messages');
        if (newState) {
            messagesContainer.classList.add('narrative-mode-active');
            // 可选：给个小提示
            // alert("已开启叙事模式"); 
        } else {
            messagesContainer.classList.remove('narrative-mode-active');
        }
        
        console.log(`已将 ${contact.name} 的叙事模式设置为: ${newState}`);
    });
}
// ==========================================
// ==========================================================
// ▼▼▼ 把这段新代码完整地粘贴到 attachEventListeners 函数里 ▼▼▼

// --- 使用事件委托，统一处理“用户面具预设”列表中的所有点击 ---
document.getElementById('user-persona-presets-list').addEventListener('click', (event) => {
    // 检查被点击的元素是不是“编辑按钮”
    const editButton = event.target.closest('.edit-preset-btn');
    if (editButton) {
        // 如果是，就调用编辑函数
        editUserPersonaPreset(event);
        return; // 结束处理
    }

    // 检查被点击的元素是不是“删除按钮”
    const deleteButton = event.target.closest('.delete-preset-btn');
    if (deleteButton) {
        // 如果是，就调用我们之前修改好的删除函数
        deleteUserPersonaPreset(event);
    }
});

// ▲▲▲ 新代码粘贴到这里结束 ▲▲▲
// ==========================================================
// =========== ▼▼▼ 地图功能 - 事件绑定（缺失部分） ▼▼▼ ========
// ==========================================================
// 地图管理页的按钮
document.getElementById('back-from-map-management').addEventListener('click', showDiscoverScreen);
document.getElementById('create-new-map-btn').addEventListener('click', () => openMapDetailsModal());

// 地图详情弹窗的按钮 (创建/编辑地图本身)
document.getElementById('close-map-details-modal').addEventListener('click', () => {
    document.getElementById('map-details-modal').style.display = 'none';
});
document.getElementById('save-map-details-btn').addEventListener('click', async () => {
    const mapName = document.getElementById('map-name-input').value.trim();
    if (!mapName) {
        alert('请输入地图名称！');
        return;
    }
    const mapDescription = document.getElementById('map-description-input').value.trim();
    
    if (editingMapId) {
        // 编辑现有地图
        const map = await kokoMemory.get('maps', editingMapId);
        if (map) {
            map.name = mapName;
            map.description = mapDescription;
            await kokoMemory.put('maps', map);
        }
    } else {
        // 创建新地图
        const newMap = {
            id: 'map_' + Date.now(),
            name: mapName,
            description: mapDescription,
            locations: []
        };
        await kokoMemory.put('maps', newMap);
    }
    document.getElementById('map-details-modal').style.display = 'none';
    await renderMapList(); // 刷新列表
});

// 地图编辑器页面的按钮
document.getElementById('back-from-map-screen').addEventListener('click', showMapManagementScreen);
document.getElementById('add-map-location-btn').addEventListener('click', () => {
    // 默认在地图中心添加一个点
    openLocationModal({ isEditing: false, x: 500, y: 500 });
});

// 地图网格区域的点击事件 (添加/编辑地点)
document.getElementById('map-grid-container').addEventListener('click', (e) => {
    const icon = e.target.closest('.map-icon');
    if (icon) {
        // 如果点击的是一个已存在的图标，则进入编辑模式
        const locationId = icon.dataset.locationId;
        const location = currentMapData.locations.find(loc => loc.id === locationId);
        if (location) {
            openLocationModal({ isEditing: true, location: location });
        }
    } else {
        // 如果点击的是地图空白处，则进入添加模式
        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        openLocationModal({ isEditing: false, x: x, y: y });
    }
});

// 地点信息弹窗的按钮
document.getElementById('close-map-location-modal').addEventListener('click', () => {
    document.getElementById('map-location-modal').style.display = 'none';
});
document.getElementById('delete-map-location-btn').addEventListener('click', async () => {
    if (editingLocationId) {
        currentMapData.locations = currentMapData.locations.filter(loc => loc.id !== editingLocationId);
        await kokoMemory.put('maps', currentMapData);
        renderMapIcons();
        document.getElementById('map-location-modal').style.display = 'none';
    }
});
// 保存地点按钮（修改版：默认 Tier 2）
document.getElementById('save-map-location-btn').addEventListener('click', async () => {
    const name = document.getElementById('location-name-input').value.trim();
    if (!name) {
        alert('请输入地点名称！');
        return;
    }
    
    // 1. 构建基础数据
    const locationData = {
        name: name,
        icon: document.getElementById('location-icon-input').value.trim(),
        description: document.getElementById('location-description-input').value.trim(),
        x: parseInt(document.getElementById('location-x-input').value),
        y: parseInt(document.getElementById('location-y-input').value),
        // ▼▼▼ 修改：不再从输入框读取，而是默认设为 2 (普通大小) ▼▼▼
        tier: 2, 
        parentId: currentMapParentId 
    };

    if (editingLocationId) {
        const index = currentMapData.locations.findIndex(loc => loc.id === editingLocationId);
        if (index > -1) {
            // 编辑时，保留原有的 parentId
            const oldParentId = currentMapData.locations[index].parentId || null;
            currentMapData.locations[index] = { 
                ...currentMapData.locations[index], 
                ...locationData, 
                parentId: oldParentId 
            };
        }
    } else {
        if (!currentMapData.locations) {
            currentMapData.locations = [];
        }
        currentMapData.locations.push({
            id: 'loc_' + Date.now(),
            ...locationData
        });
    }
    
    await kokoMemory.put('maps', currentMapData);
    renderMapIcons();
    document.getElementById('map-location-modal').style.display = 'none';
});

// 地图管理列表的事件委托 (处理编辑和删除)
document.getElementById('map-list').addEventListener('click', async (e) => {
    const mapItem = e.target.closest('.preset-item');
    if (!mapItem) return;

    const mapId = mapItem.dataset.mapId;
    const map = await kokoMemory.get('maps', mapId);

    if (e.target.closest('.edit-map-btn')) {
        // 点击了编辑按钮
        openMapDetailsModal(map);
    } else if (e.target.closest('.delete-map-btn')) {
        // 点击了删除按钮
        const confirmed = await showCustomConfirm('删除地图', `确定要永久删除地图“${map.name}”及其所有地点吗？`, true);
        if (confirmed) {
            await kokoMemory.delete('maps', mapId);
            await renderMapList();
        }
    }
});
// ==========================================================
// ▼▼▼ 把这段新代码粘贴到 attachEventListeners 函数的内部 ▼▼▼

const chatContactNameEl = document.getElementById('chat-contact-name');
const heartVoicePanel = document.getElementById('heart-voice-panel');

chatContactNameEl.addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡

    // 如果面板已经是显示的，就隐藏它
    if (heartVoicePanel.style.display === 'block') {
        heartVoicePanel.style.display = 'none';
        return;
    }
    
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history) return;

    // 从后往前查找最新的一条心声消息
    const lastHeartVoice = contact.history.slice().reverse().find(m => m.type === 'heart_voice');

    if (lastHeartVoice) {
        const data = lastHeartVoice.content;
        document.getElementById('hv-emotion').textContent = data.emotion || '...';
        document.getElementById('hv-thoughts').textContent = data.thoughts || '...';
        document.getElementById('hv-heart-rate').textContent = data.heartRate || '...';
        document.getElementById('hv-jealousy').textContent = data.jealousy || '无';
        
        // 显示面板
        heartVoicePanel.style.display = 'block';
    } else {
        // 如果没有找到心声记录，可以给个提示
        alert('还没有任何心声记录哦。');
    }
});

// 点击心声面板本身不会关闭它
heartVoicePanel.addEventListener('click', e => e.stopPropagation());

// 点击页面其他地方，关闭心声面板
document.addEventListener('click', (e) => {
    if (heartVoicePanel.style.display === 'block') {
        heartVoicePanel.style.display = 'none';
    }
});
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// =========== ▲▲▲ 地图功能 - 事件绑定（缺失部分） END ▲▲▲ ========
// (粘贴到 attachEventListeners 函数内部)

// --- ✨ 新增：收藏夹事件绑定 ---

// 1. 发现页的"我的收藏"入口
document.getElementById('discover-screen').addEventListener('click', (e) => {
    if (e.target.closest('#favorites-btn')) {
        showFavoritesScreen();
    }
});

// 2. 收藏夹页面的"返回"按钮
document.getElementById('back-from-favorites').addEventListener('click', showDiscoverScreen);

// 3. 聊天编辑栏的"收藏已选"按钮
document.getElementById('favorite-selected-btn').addEventListener('click', favoriteSelectedMessages);
document.getElementById('forward-selected-btn').addEventListener('click', openForwardChatModal);
// 4. 收藏夹内部的"取消收藏"按钮 (V2 - 事件委托)
    document.getElementById('favorites-content-list').addEventListener('click', (e) => {
        // ✨ 核心修改：现在监听的是卡片头部的 .unfavorite-btn
        const unfavBtn = e.target.closest('.unfavorite-btn');
        if (unfavBtn) {
            e.stopPropagation();
            const sessionId = unfavBtn.dataset.sessionId; // ✨ 获取 session ID
            if (sessionId) {
                unfavoriteSession(sessionId); // ✨ 调用新的删除函数
            }
        }
    });
// --- ✨ 收藏夹事件绑定 结束 ---
// ==========================================================
// ... 在 attachEventListeners 函数中 ...

// 随便找个地方加上这行代码
document.getElementById('map-management-btn').addEventListener('click', showMapManagementScreen);
    // =========================================================
// --- 新增：日记批量删除功能的事件绑定 ---

// 右上角的“编辑”按钮
document.getElementById('edit-diary-btn').addEventListener('click', enterDiaryEditMode);

// 底部操作栏的“取消”按钮
document.getElementById('cancel-diary-edit-btn').addEventListener('click', exitDiaryEditMode);

// 底部操作栏的“删除已选”按钮
document.getElementById('delete-selected-diary-btn').addEventListener('click', async () => {
    if (diaryEditModeState.selectedEntryIds.size === 0) {
        return alert('请先选择要删除的日记。');
    }
    const confirmed = await showCustomConfirm('删除日记', `确定要删除选中的 ${diaryEditModeState.selectedEntryIds.size} 篇日记吗？`, true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.diary) {
            // 核心：过滤掉所有被选中的日记
            contact.diary = contact.diary.filter(entry => !diaryEditModeState.selectedEntryIds.has(entry.id));
            await kokoMemory.put('contacts', contact);
            exitDiaryEditMode(); // 退出编辑模式并刷新列表
        }
    }
});

// 修改日记列表的点击事件，让它能处理编辑模式下的选择
const diaryContentList = document.getElementById('diary-content-list');
const oldListener = diaryContentList.onclick; // 保存旧的监听器
diaryContentList.onclick = null; // 移除旧的

diaryContentList.addEventListener('click', async (e) => {
    // 如果是编辑模式...
    if (diaryEditModeState.active) {
        const entryEl = e.target.closest('.diary-entry');
        if (entryEl) {
            const checkbox = entryEl.querySelector('.diary-select-checkbox');
            if (!checkbox) return;

            // 核心：如果点击的不是复选框本身，就手动帮它切换选中状态
            if (e.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
            }

            const diaryId = checkbox.dataset.diaryId;
            if (checkbox.checked) {
                diaryEditModeState.selectedEntryIds.add(diaryId);
                entryEl.classList.add('selected');
            } else {
                diaryEditModeState.selectedEntryIds.delete(diaryId);
                entryEl.classList.remove('selected');
            }
        }
        return; // 编辑模式下，不执行后面的单个删除逻辑
    }

    // 如果不是编辑模式，就执行原来的单个删除逻辑
    if (oldListener) {
        oldListener.call(diaryContentList, e);
    }
});
// ==========================================================
// --- 音乐搜索按钮事件 ---
document.getElementById('music-search-btn-modal').addEventListener('click', () => {
    const keyword = document.getElementById('music-search-keyword-modal').value.trim();
    if (keyword) searchMusicInModal(keyword);
});
// 让回车键也能搜索
document.getElementById('music-search-keyword-modal').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        const keyword = e.target.value.trim();
        if (keyword) searchMusicInModal(keyword);
    }
});
// V-Final 新增: 锁屏音乐播放器控制逻辑
// ==========================================================
const lockScreenMusicControls = document.querySelector('#lock-screen-music-widget .music-controls');
if (lockScreenMusicControls) {
    lockScreenMusicControls.addEventListener('click', (e) => {
        // 阻止事件冒泡，防止点击按钮时解锁屏幕
        e.stopPropagation();

        if (e.target.classList.contains('fa-play')) {
            if (globalAudioPlayer.src) {
                globalAudioPlayer.play();
            }
        } else if (e.target.classList.contains('fa-pause')) {
            globalAudioPlayer.pause();
        } else if (e.target.classList.contains('fa-forward-step')) {
            // 调用我们已有的下一首函数
            switchSong(currentSongIndex + 1, true, true);
        } else if (e.target.classList.contains('fa-backward-step')) {
            // 调用我们已有的上一首函数
            switchSong(currentSongIndex - 1, true, true);
        }
    });
}
// ==========================================================
// --- 主题导入导出事件 ---
document.getElementById('export-theme-btn').addEventListener('click', exportTheme);

document.getElementById('import-theme-btn').addEventListener('click', () => {
    // 点击按钮时，触发隐藏的文件输入框
    document.getElementById('theme-file-input').click();
});

// 监听文件选择变化
document.getElementById('theme-file-input').addEventListener('change', importTheme);
// 最终修复版 V2：宠物互动逻辑 (拖动 + 点击)，兼容所有浏览器
// ==========================================================
// 最终双击版 V3：史莱姆互动逻辑 (防误触 + 双击呼出)
// ==========================================================
const petContainer = document.getElementById('chat-pet-container');

if (petContainer) {
    // --- 变量定义 ---
    let isPetDragging = false;
    let petOffsetX = 0, petOffsetY = 0;
    
    // 拖动判断变量
    let dragStartX = 0, dragStartY = 0;
    let hasMoved = false; 
    const dragThreshold = 5; // 超过5像素算拖动
    
    // 🔥 双击判断变量
    let lastTapTime = 0; 

    // 1. 开始触摸/按下
    function petDragStart(e) {
    // ▼▼▼ 【核心修复】如果点击的是快捷面板，直接无视，不许动史莱姆！ ▼▼▼
        if (e.target.closest('#pet-quick-menu')) {
            return;
        }
        // ▲▲▲ 修复结束 ▲▲▲
        isPetDragging = true;
        hasMoved = false;
        petContainer.style.transition = 'none';
        
        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        
        dragStartX = clientX;
        dragStartY = clientY;
        petOffsetX = clientX - petContainer.offsetLeft;
        petOffsetY = clientY - petContainer.offsetTop;

        if (e.type === 'touchmove') e.preventDefault();
    }

    // 2. 移动中
    function petDragMove(e) {
        if (!isPetDragging) return;
        
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        
        // 检查移动距离
        const deltaX = Math.abs(clientX - dragStartX);
        const deltaY = Math.abs(clientY - dragStartY);
        if (deltaX > dragThreshold || deltaY > dragThreshold) {
            hasMoved = true;
        }
        
        // 只有真的在拖动时才更新位置
        if (hasMoved) {
            let newX = clientX - petOffsetX;
            let newY = clientY - petOffsetY;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const petWidth = petContainer.offsetWidth;
            const petHeight = petContainer.offsetHeight;
            
            // 边界限制，防止拖出屏幕
            newX = Math.max(0, Math.min(newX, screenWidth - petWidth));
            newY = Math.max(0, Math.min(newY, screenHeight - petHeight));
            
            petContainer.style.left = `${newX}px`;
            petContainer.style.top = `${newY}px`;
            petContainer.style.bottom = 'auto';
        }

        if (e.type === 'touchmove') e.preventDefault();
    }

    // 3. 结束触摸/松开 (🔥 核心修改在这里)
    function petDragEnd(e) {
        if (!isPetDragging) return;
        isPetDragging = false;
        
        // 如果没有发生位移，说明是点击
        if (!hasMoved) {
            if(e.cancelable) e.preventDefault();
            
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTapTime;

            // 🔥 判断双击：如果两次点击间隔小于 300毫秒
            if (tapLength < 300 && tapLength > 0) {
                // >>> 双击事件 <<<
                petClickInteraction(e, true); // 传入 true 表示显示面板
                lastTapTime = 0; // 重置，防止三连击触发两次
            } else {
                // >>> 单击事件 <<<
                petClickInteraction(e, false); // 传入 false 表示只互动
                lastTapTime = currentTime;
            }
        }
    }

    // 4. 互动反馈函数 (根据是否双击决定行为)
    function petClickInteraction(e, isDoubleTap) {
        // --- 无论单击双击，都播放音效和动画 ---
        const sound = document.getElementById('slime-sound');
        if (sound) { sound.currentTime = 0; sound.play(); }

        const slimeEl = petContainer.querySelector('.slime');
        if (slimeEl) {
            slimeEl.classList.remove('happy-jiggle');
            void slimeEl.offsetWidth; // 强制重绘
            slimeEl.classList.add('happy-jiggle');
            
            // 随机换个表情
            const allExpressions = ['expression-happy', 'expression-sad', 'expression-annoyed', 'expression-shocked', 'expression-pleased', 'expression-dizzy', 'expression-doubtful', 'expression-cat-face'];
            const randomExpression = allExpressions[Math.floor(Math.random() * allExpressions.length)];
            
            // 先移除旧表情，延迟加上新表情
            allExpressions.forEach(exp => slimeEl.classList.remove(exp));
            setTimeout(() => {
                slimeEl.classList.add(randomExpression);
            }, 50);
        }

        // --- 🔥 只有双击才操作面板 ---
        if (isDoubleTap) {
            const menu = document.getElementById('pet-quick-menu');
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            
            if (menu && contact) {
                // 切换显示/隐藏
                if (menu.style.display !== 'flex') {
                    // 打开前同步开关状态
                    document.getElementById('pet-narrative-check').checked = contact.isNarrativeMode;
                    menu.style.display = 'flex';
                } else {
                    menu.style.display = 'none';
                }
            }
        }
    }

    // 绑定事件
    petContainer.addEventListener('mousedown', petDragStart);
    petContainer.addEventListener('touchstart', petDragStart, { passive: false });
    document.addEventListener('mousemove', petDragMove);
    document.addEventListener('mouseup', petDragEnd);
    document.addEventListener('touchmove', petDragMove, { passive: false });
    document.addEventListener('touchend', petDragEnd);
}

// ▼▼▼ ✨ 使用这个【正确版本】替换 ✨ ▼▼▼
    document.querySelector('.contacts-container').addEventListener('click', async function(e) {
        const optionsBtn = e.target.closest('.contact-options-btn');
        if (optionsBtn) {
            e.stopPropagation();
            const contactId = optionsBtn.dataset.contactId;
            showContactItemMenu(contactId, optionsBtn);
            return;
        }
        
        const contactItem = e.target.closest('.contact-item');
        if (contactItem) {
            // 无论什么状态，都只管打开聊天界面
            openChat(contactItem.dataset.contactId);
        }
    });
    // ▲▲▲ 替换结束 ▲▲▲

// 第2个：这是全新的，监听菜单项的点击
document.getElementById('contact-item-menu').addEventListener('click', async (e) => {
    const menuItem = e.target.closest('.menu-item');
    if (!menuItem) return;
    const contactId = document.getElementById('contact-item-menu').dataset.contactId;
    if (!contactId) return;

    switch (menuItem.id) {
        case 'menu-item-pin':
            await togglePinContact(contactId);
            break;
       case 'menu-item-group':
            // ▼▼▼ 核心修改 ▼▼▼
            showGroupSelectorModal(contactId); // 去掉 alert，调用真正的函数
            // ▲▲▲ 修改结束 ▲▲▲
            break;
        case 'menu-item-rewind':
            await handleLongPressDelete(contactId); 
            break;
    }
    document.getElementById('contact-item-menu').style.display = 'none';
});
// --- 新增：为联系人列表的“更多操作”菜单添加点击外部关闭的功能 ---
const contactItemMenu = document.getElementById('contact-item-menu');

// 1. 点击菜单内部时，阻止事件冒泡，防止菜单自己关闭自己
contactItemMenu.addEventListener('click', function(event) {
    event.stopPropagation();
});

// 2. 在整个页面上添加点击事件监听
document.addEventListener('click', function(event) {
    // 检查被点击的元素是不是打开菜单的那个“三个点”按钮
    const isOptionsButton = event.target.closest('.contact-options-btn');
    
    // 如果点击的既不是按钮，也不是菜单本身，就隐藏菜单
    if (!isOptionsButton && contactItemMenu.style.display === 'block') {
        contactItemMenu.style.display = 'none';
    }
});
// --- 新增：控制顶栏“更多操作”菜单的显示与隐藏 ---
const moreOptionsBtn = document.getElementById('more-chat-options-btn');
const chatOptionsMenu = document.getElementById('chat-options-menu');

if (moreOptionsBtn) {
    moreOptionsBtn.addEventListener('click', function(event) {
        event.stopPropagation();
        // ▼▼▼ ✨ 在这里粘贴新代码 ✨ ▼▼▼
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if(contact) {
            updateBlockButtonText(contact.blockedStatus); // 根据当前状态更新按钮
        }
        // ▲▲▲ 粘贴结束 ▲▲▲
        const isShown = chatOptionsMenu.style.display === 'block';
        chatOptionsMenu.style.display = isShown ? 'none' : 'block';
    });

    chatOptionsMenu.addEventListener('click', function(event) {
        event.stopPropagation();
    });

    // --- 重新绑定事件到新菜单项 ---
    document.getElementById('rewind-btn-menu').addEventListener('click', handleRewind);
    document.getElementById('summarize-chat-btn-menu').addEventListener('click', handleChatSummarization);
    document.getElementById('contact-settings-btn-menu').addEventListener('click', showCharProfileScreen);
    
    document.getElementById('toggle-chat-pet-btn-menu').addEventListener('click', () => {
        // 这是原先 toggle-chat-pet-btn 的逻辑
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact || !contact.pet) return;
        contact.isChatPetVisible = !contact.isChatPetVisible;
        const chatPetContainer = document.getElementById('chat-pet-container');
        if (contact.isChatPetVisible) {
            chatPetContainer.style.display = 'block';
            updateChatPetVisuals(contact);
        } else {
            chatPetContainer.style.display = 'none';
        }
        kokoMemory.put('contacts', contact);
        chatOptionsMenu.style.display = 'none'; // 点击后关闭菜单
    });

    document.getElementById('delete-history-btn-menu').addEventListener('click', () => {
        // 这是原先 delete-history-btn 的逻辑
        if (editModeState.active) {
            exitEditMode();
        } else {
            enterEditMode();
        }
        chatOptionsMenu.style.display = 'none'; // 点击后关闭菜单
    });
}
// 点击页面其他任何地方，都隐藏菜单
document.addEventListener('click', function(event) {
    // 确保点击的不是按钮本身
    if (moreOptionsBtn && !moreOptionsBtn.contains(event.target)) {
        chatOptionsMenu.style.display = 'none';
    }
});
// ▼▼▼ ✨ 使用这个【正确版本】替换 ✨ ▼▼▼
    document.getElementById('block-contact-btn-menu').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        if (contact.blockedStatus === 'user_blocked_ai') {
            // --- 解除拉黑 ---
            contact.blockedStatus = 'none';
            await kokoMemory.put('contacts', contact);
            alert(`你已将 ${contact.name} 解除拉黑。`);
            
            updateBlockButtonText('none');      // 1. 更新按钮文字
            updateChatInputLockState('none'); // 2. ✨ 立刻解锁输入框

        } else {
            // --- 执行拉黑 ---
            contact.blockedStatus = 'user_blocked_ai';
            await kokoMemory.put('contacts', contact);
            alert(`你已拉黑 ${contact.name}。`);
            
            updateBlockButtonText('user_blocked_ai');      // 1. 更新按钮文字
            updateChatInputLockState('user_blocked_ai'); // 2. ✨ 立刻锁定输入框
            // 3. ⚠️ 删掉了 openSmsChat(contact.id); 这一行
        }
        
        document.getElementById('chat-options-menu').style.display = 'none';
    });
    // ▲▲▲ 替换结束 ▲▲▲
// --- ▼▼▼ 新增：视频通话界面的事件绑定 ▼▼▼ ---
document.getElementById('hang-up-btn').addEventListener('click', () => {
    endVideoCall('user');
});

document.getElementById('video-call-send-btn').addEventListener('click', sendVideoCallMessage);

document.getElementById('video-call-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendVideoCallMessage();
    }
});
// ... 在 attachEventListeners() 函数内部 ...
// 字体字距
document.getElementById('letter-spacing-input').addEventListener('input', (e) => {
    const val = e.target.value;
    const iframe = document.getElementById('appearance-preview-frame');
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    doc.body.style.letterSpacing = val ? val + 'px' : '';
});

// 字体粗细
document.getElementById('font-weight-input').addEventListener('input', (e) => {
    const val = e.target.value;
    const iframe = document.getElementById('appearance-preview-frame');
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    // 排除图标类，只给body加粗
    doc.body.style.fontWeight = val ? val : '';
});
// 【新增】处理预设下拉菜单的选择事件
    document.getElementById('api-preset-select').addEventListener('change', (e) => {
        const presetId = e.target.value;
        const preset = state.apiPresets.find(p => p.id === presetId);
        if (preset) {
            document.getElementById('api-key-input').value = preset.apiKey || '';
            document.getElementById('api-endpoint-input').value = preset.endpoint || '';
            updateModelDropdown([preset.model], document.getElementById('model-select'), preset.model);
            
            const fetchBtn = document.getElementById('fetch-models-btn');
            if (fetchBtn) fetchBtn.click();
        }
    });

    // 【新增】处理“另存为预设”按钮点击事件
    document.getElementById('save-as-api-preset-btn').addEventListener('click', async () => {
        const apiKey = document.getElementById('api-key-input').value;
        const endpoint = document.getElementById('api-endpoint-input').value.trim();
        const model = document.getElementById('model-select').value;

        if (!apiKey || !endpoint || !model) {
            return alert('请先将API密钥、地址和模型填写完整再保存为预设。');
        }

        const presetName = await showCustomPrompt('为这个预设取个名字', '');
        if (presetName && presetName.trim()) {
            const newPreset = {
                id: 'api_preset_' + Date.now(),
                name: presetName.trim(),
                apiKey,
                endpoint,
                model
            };

            state.apiPresets.push(newPreset);
            await kokoMemory.put('apiPresets', newPreset);
            await renderApiPresetDropdown(); // 更新下拉菜单
            alert(`预设“${newPreset.name}”已保存！`);
        }
    });

    // 【新增】处理“管理预设”按钮和其页面的返回按钮
    document.getElementById('manage-api-presets-btn').addEventListener('click', showApiPresetManagementScreen);
    document.getElementById('back-from-api-presets').addEventListener('click', () => {
        // 返回时，重新打开API设置页面并刷新下拉菜单
        document.getElementById('api-settings-btn').click();
    });
// (粘贴到 attachEventListeners 函数的末尾)

// --- ✨ 新增：外观设置的实时预览监听器 ---

// CSS 主题
document.getElementById('theme-css-input').addEventListener('input', (e) => {
    updatePreview('theme', e.target.value);
});

// CSS 气泡
document.getElementById('bubble-css-input').addEventListener('input', (e) => {
    updatePreview('bubble', e.target.value);
});

// CSS 叙事
document.getElementById('narrative-css-input').addEventListener('input', (e) => {
    updatePreview('narrative', e.target.value);
});

// 字体大小
document.getElementById('font-size-input').addEventListener('input', (e) => {
    updatePreview('fontsize', e.target.value);
});

// 字体 URL 和 字体名称 (两者任一变动都触发更新)
const updateFontPreview = () => {
    const fontName = document.getElementById('font-name-input').value.trim();
    const fontUrl = document.getElementById('font-url-input').value.trim();
    updatePreview('font', fontName, fontUrl);
};
document.getElementById('font-url-input').addEventListener('input', updateFontPreview);
document.getElementById('font-name-input').addEventListener('input', updateFontPreview);

// --- ✨ 监听器添加结束 ---
// --- 新增：全屏切换功能 ---
const fullscreenBtn = document.getElementById('toggle-fullscreen-btn');
if (fullscreenBtn) {
    fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            // 进入全屏
            document.documentElement.requestFullscreen().catch((e) => {
                alert(`无法进入全屏模式: ${e.message}`);
            });
        } else {
            // 退出全屏
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    });
}
// --- 外观设置页面的事件绑定 (V2 - 带预览版) ---
document.getElementById('appearance-settings-btn').addEventListener('click', () => {
    // 打开设置页面前，先用已保存的设置填充输入框
    document.getElementById('bubble-css-input').value = userSettings.customBubbleCss || '';
    document.getElementById('theme-css-input').value = userSettings.customThemeCss || '';
    document.getElementById('narrative-css-input').value = userSettings.customNarrativeCss || '';
    // ▼▼▼ 新增：回显字体数据 ▼▼▼
    document.getElementById('font-size-input').value = userSettings.customFontSize || '';
    document.getElementById('letter-spacing-input').value = userSettings.customLetterSpacing || '';
    document.getElementById('font-weight-input').value = userSettings.customFontWeight || '';
    // ▲▲▲ 新增结束 ▲▲▲
    document.getElementById('font-url-input').value = userSettings.customFontUrl || '';
    document.getElementById('font-name-input').value = userSettings.customFontName || '';
    
    hideAllScreens();
    document.getElementById('appearance-settings-screen').style.display = 'flex';

    // ✨ 核心新增：初始化预览框并加载当前设置
    initializePreviewFrame();
    // 确保DOM渲染完成后再加载内容
    setTimeout(loadPreviewFromInputs, 50); 
});

document.getElementById('back-from-appearance-settings').addEventListener('click', showProfileScreen);

// 背景上传按钮
document.getElementById('upload-background-btn').addEventListener('click', () => {
    document.getElementById('background-file-input').click();
});

// 背景文件选择后的处理
document.getElementById('background-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (file.size > 5 * 1024 * 1024) { // 限制5MB大小
        alert('图片文件不能超过 5MB');
        return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
        const base64String = event.target.result;
        userSettings.chatBackground = base64String; // 实时保存到变量
        document.getElementById('chat-screen').style.backgroundImage = `url(${base64String})`;
        updatePreview('background', base64String);
        alert('背景已更新，点击“应用并保存”来永久保存。');
    };
    reader.readAsDataURL(file);
    e.target.value = ''; // 清空input，以便可以再次选择同一个文件
});

// 恢复默认背景按钮
document.getElementById('reset-background-btn').addEventListener('click', () => {
    userSettings.chatBackground = null;
    applyAppearanceSettings(); // 立即应用默认样式
    updatePreview('background', '');
    alert('背景已恢复默认，点击“应用并保存”来永久保存。');
});
attachGroupSettingsListeners();
// 保存外观设置按钮
document.getElementById('save-appearance-btn').addEventListener('click', saveAppearanceSettings);
}
attachEventListeners();
// --- 紧急修复：重新绑定搜索按钮 ---
    const searchBtnFix = document.getElementById('search-chat-btn');
    if (searchBtnFix) {
        // 先移除可能存在的旧监听器（以防万一）
        const newSearchBtn = searchBtnFix.cloneNode(true);
        searchBtnFix.parentNode.replaceChild(newSearchBtn, searchBtnFix);
        // 重新绑定
        newSearchBtn.addEventListener('click', showChatSearch);
        console.log("已手动修复搜索按钮连接！");
    }
    // =========================================
    // 🚑 搜索按钮紧急修复补丁 (手机专享版) 🚑
    // =========================================
    setTimeout(() => { // 延迟一点点执行，确保按钮肯定已经生出来了
        const fixSearchBtn = document.getElementById('search-chat-btn');
        if (fixSearchBtn) {
            // 1. 用“克隆大法”清除所有可能坏掉的旧连接
            const freshBtn = fixSearchBtn.cloneNode(true);
            fixSearchBtn.parentNode.replaceChild(freshBtn, fixSearchBtn);

            // 2. 重新接上正确的功能线
            freshBtn.addEventListener('click', (e) => {
                // 阻止任何可能的干扰
                e.stopPropagation();
                e.preventDefault();

                // 🔔 如果你想确认按钮是否真的被点到了，可以把下面这行最前面的 // 删掉
                // alert("按钮活啦！正在打开搜索...");

                // 调用搜索界面
                if (typeof showChatSearch === 'function') {
                    showChatSearch();
                } else {
                    alert("糟糕！showChatSearch 功能函数不见了！");
                }
            });

            console.log("✅ 搜索按钮已实施紧急修复！");
        } else {
            console.error("❌ 居然找不到搜索按钮，它可能被别的代码误删了！");
        }
    }, 1000); // 等待1秒再执行，非常保险
    // =========================================
    // =========================================
    // 🚑 默契挑战 & 题库 功能紧急修复补丁 🚑
    // 原因：将局部函数暴露给 HTML onclick 调用
    // =========================================
    
    // 1. 题库相关
    window.openSurveyLibraryModal = openSurveyLibraryModal;
    window.saveCurrentSurveyToLib = saveCurrentSurveyToLib;
    window.loadSurveyFromLib = loadSurveyFromLib;
    window.deleteSurveyFromLib = deleteSurveyFromLib;

    // 2. 游戏操作相关
    window.shareCpResultToChat = shareCpResultToChat;
    window.switchCpSkin = switchCpSkin;
    
    // 3. AI 邀请相关
    window.acceptAiSurvey = acceptAiSurvey;

    console.log("✅ 默契挑战功能已手动挂载到全局！");
await initApp();
}); 
</script>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(registration => console.log('ServiceWorker 注册成功: ', registration))
        .catch(error => console.log('ServiceWorker 注册失败: ', error));
    });
  }
</script>
<script>
(function() {
    // --- A. 静默数据记录器 (兼容群聊 & 单聊) ---
    const originalFetch = window.fetch;
    window.fetch = async function(url, options) {
        const response = await originalFetch(url, options); // 正常放行
        
        // 筛选 AI 请求
        const urlStr = String(url);
        if (urlStr.includes('/chat/completions') || urlStr.includes('generateContent')) {
            try {
                const clone = response.clone();
                clone.json().then(data => {
                    // 提取 Token
                    let info = { input: 0, output: 0, total: 0 };
                    if (data.usage) { // OpenAI
                        info.input = data.usage.prompt_tokens;
                        info.output = data.usage.completion_tokens;
                        info.total = data.usage.total_tokens;
                    } else if (data.usageMetadata) { // Gemini
                        info.input = data.usageMetadata.promptTokenCount;
                        info.output = data.usageMetadata.candidatesTokenCount;
                        info.total = data.usageMetadata.totalTokenCount;
                    }

                    // 存入当前活跃对象 (不管是人还是群，都在 activeChatId 里)
                    if (window.state && window.state.activeChatId) {
                        // 在 contacts 数组里找 (群聊和单聊都在这)
                        const target = window.state.contacts.find(c => c.id === window.state.activeChatId);
                        if (target) {
                            target.latestApiLog = {
                                time: new Date().toLocaleTimeString(),
                                usage: info,
                                raw: JSON.stringify(data, null, 2)
                            };
                        }
                    }
                }).catch(e => console.log("非JSON响应，忽略"));
            } catch (e) { /* 安全忽略 */ }
        }
        return response;
    };

    // --- B. 界面逻辑：自动往两个设置页加按钮 ---
    const observer = new MutationObserver((mutations) => {
        const contactScreen = document.getElementById('contact-settings-screen'); // 单聊设置页
        const groupScreen = document.getElementById('group-settings-screen');     // 群聊设置页
        
        // 1. 如果单聊设置页开了，加按钮
        if (contactScreen && contactScreen.style.display !== 'none') {
            addDebugButtonSafely(contactScreen, 'save-contact-settings-btn');
        }
        // 2. 如果群聊设置页开了，加按钮
        if (groupScreen && groupScreen.style.display !== 'none') {
            addDebugButtonSafely(groupScreen, 'save-group-settings-btn');
        }
    });
    
    const screenContainer = document.getElementById('app-container') || document.body;
    observer.observe(screenContainer, { attributes: true, subtree: true, attributeFilter: ['style'] });

    // 通用加按钮函数
    function addDebugButtonSafely(screenElement, beforeBtnId) {
        // 尝试找到内容容器 (兼容不同页面的结构)
        // 通常设置页都有个 .contact-settings-content 或类似的容器
        // 如果找不到，就找那个“保存按钮”的父元素
        const saveBtn = document.getElementById(beforeBtnId);
        if (!saveBtn) return; // 没保存按钮就不加了，防止报错
        
        const container = saveBtn.parentNode;

        // 避免重复添加
        if (container.querySelector('#open-api-debug-btn')) return;

        // 创建入口按钮
        const btn = document.createElement('div');
        btn.id = 'open-api-debug-btn';
        btn.className = 'form-group';
        btn.style.cssText = 'background: #e3f2fd; border: 1px dashed #2196f3; color: #1565c0; text-align: center; cursor: pointer; margin-top: 20px; display: flex; justify-content: center; align-items: center; font-weight: 600; padding: 12px; border-radius: 12px; margin-bottom: 20px;';
        btn.innerHTML = '<i class="fas fa-bug" style="margin-right:8px;"></i> 查看 API 调试台 (Tokens)';
        
        btn.onclick = () => openApiDebugScreen(screenElement.id); // 记下是从哪个页面来的

        // 插入到“保存”按钮之前
        container.insertBefore(btn, saveBtn);
    }

    // --- C. 页面操作函数 ---
    
    // 记录上一次是从哪里打开的，方便返回
    let lastSourceScreenId = null;

    window.openApiDebugScreen = function(sourceId) {
        lastSourceScreenId = sourceId; // 记住来源 (单聊设置 OR 群聊设置)

        // 获取数据
        const contact = window.state.contacts.find(c => c.id === window.state.activeChatId);
        if (contact && contact.latestApiLog) {
            const log = contact.latestApiLog;
            document.getElementById('debug-timestamp').textContent = log.time;
            document.getElementById('debug-input-tokens').textContent = log.usage.input;
            document.getElementById('debug-output-tokens').textContent = log.usage.output;
            document.getElementById('debug-total-tokens').textContent = log.usage.total;
            document.getElementById('debug-raw-json').value = log.raw;
        } else {
            document.getElementById('debug-raw-json').value = "暂无数据...\n\n该对话尚未产生 API 记录。\n请先去发一条消息。";
        }

        // 隐藏来源页面，显示调试页
        if (sourceId) document.getElementById(sourceId).style.display = 'none';
        document.getElementById('api-debug-screen').style.display = 'flex';
    };

    window.closeApiDebugScreen = function() {
        document.getElementById('api-debug-screen').style.display = 'none';
        // 智能返回：回到刚才那个页面
        if (lastSourceScreenId && document.getElementById(lastSourceScreenId)) {
            document.getElementById(lastSourceScreenId).style.display = 'flex';
        } else {
            // 兜底：如果忘了是从哪来的，就回单聊设置
            const contactSettings = document.getElementById('contact-settings-screen');
            if (contactSettings) contactSettings.style.display = 'flex';
        }
    };

    window.copyDebugData = function() {
        const text = document.getElementById('debug-raw-json');
        text.select();
        document.execCommand('copy');
        const btn = document.querySelector('#api-debug-screen button');
        const originalText = btn.innerHTML;
        btn.innerHTML = '<i class="fas fa-check"></i> 已复制';
        setTimeout(() => btn.innerHTML = originalText, 2000);
    };

    console.log("✅ API 调试台 V2.0 已加载 (全功能版)");
})();
</script>
        
</body>
</html>